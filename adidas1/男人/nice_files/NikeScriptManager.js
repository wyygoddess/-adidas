/*
 * setup vars for script manager
 */
 
var nike = nike || {};


var nike = nike || {};nike.exp = nike.exp || {};nike.exp.dynamic = nike.exp.dynamic || {};nike.exp.dynamic.AppConfig = nike.exp.dynamic.AppConfig || {};!function(){function copyAllProperties(dest, src){var key;for(key in src){if(src.hasOwnProperty(key)){dest[key] = src[key];}}return dest;}nike.exp.dynamic.AppConfig.copyAllProperties = copyAllProperties;var dynamicAppConfig = {"SCRIPT_MANAGER_FORMAT":"","LANGUAGE":"zh","APP_ID":"Nike01","COUNTRIES":{"":{"countryCode":"","displayName":"","mappedCountryList":[],"supportedLanguageList":["_"]},"DE":{"countryCode":"DE","displayName":"Deutschland","mappedCountryList":[],"supportedLanguageList":["de_de"]},"PR":{"countryCode":"PR","displayName":"Puerto Rico","mappedCountryList":[],"supportedLanguageList":["es_la"]},"HK":{"countryCode":"HK","displayName":"Hong Kong","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"TW":{"countryCode":"TW","displayName":"台灣","mappedCountryList":[],"supportedLanguageList":["zh_tw"]},"PT":{"countryCode":"PT","displayName":"Portugal","mappedCountryList":[],"supportedLanguageList":["pt_pt","en_gb"]},"DK":{"countryCode":"DK","displayName":"Danmark","mappedCountryList":[],"supportedLanguageList":["da_dk","en_gb"]},"LU":{"countryCode":"LU","displayName":"Luxembourg","mappedCountryList":[],"supportedLanguageList":["fr_fr","de_de","en_gb"]},"HR":{"countryCode":"HR","displayName":"Croatia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"HU":{"countryCode":"HU","displayName":"Magyarország","mappedCountryList":[],"supportedLanguageList":["hu_hu","en_gb"]},"MA":{"countryCode":"MA","displayName":"Maroc","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"ID":{"countryCode":"ID","displayName":"Indonesia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"IE":{"countryCode":"IE","displayName":"Ireland","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"US":{"countryCode":"US","displayName":"United States","mappedCountryList":[],"supportedLanguageList":["en_us"]},"EG":{"countryCode":"EG","displayName":"Egypt","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"IL":{"countryCode":"IL","displayName":"Israel","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"AE":{"countryCode":"AE","displayName":"United Arab Emirates","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"UY":{"countryCode":"UY","displayName":"Uruguay","mappedCountryList":[],"supportedLanguageList":["es_ar"]},"IN":{"countryCode":"IN","displayName":"India","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"ZA":{"countryCode":"ZA","displayName":"South Africa","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"IT":{"countryCode":"IT","displayName":"Italia","mappedCountryList":[],"supportedLanguageList":["it_it"]},"MX":{"countryCode":"MX","displayName":"México","mappedCountryList":[],"supportedLanguageList":["es_la"]},"MY":{"countryCode":"MY","displayName":"Malaysia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"ES":{"countryCode":"ES","displayName":"España","mappedCountryList":[],"supportedLanguageList":["es_es","ca_es"]},"AR":{"countryCode":"AR","displayName":"Argentina","mappedCountryList":[],"supportedLanguageList":["es_ar"]},"AT":{"countryCode":"AT","displayName":"Österreich","mappedCountryList":[],"supportedLanguageList":["de_de","en_gb"]},"AU":{"countryCode":"AU","displayName":"Australia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"VN":{"countryCode":"VN","displayName":"Vietnam","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"RO":{"countryCode":"RO","displayName":"Romania","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"NL":{"countryCode":"NL","displayName":"Nederland","mappedCountryList":[],"supportedLanguageList":["nl_nl","en_gb"]},"NO":{"countryCode":"NO","displayName":"Norge","mappedCountryList":[],"supportedLanguageList":["no_no","en_gb"]},"BE":{"countryCode":"BE","displayName":"Belgium","mappedCountryList":[],"supportedLanguageList":["nl_nl","fr_fr","en_gb","de_de"]},"FI":{"countryCode":"FI","displayName":"Finland","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"RU":{"countryCode":"RU","displayName":"Россия","mappedCountryList":[],"supportedLanguageList":["ru_ru"]},"BG":{"countryCode":"BG","displayName":"Bulgaria","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"JP":{"countryCode":"JP","displayName":"日本","mappedCountryList":[],"supportedLanguageList":["ja_jp"]},"FR":{"countryCode":"FR","displayName":"France","mappedCountryList":[],"supportedLanguageList":["fr_fr"]},"NZ":{"countryCode":"NZ","displayName":"New Zealand","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"SA":{"countryCode":"SA","displayName":"Saudi Arabia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"BR":{"countryCode":"BR","displayName":"Brasil","mappedCountryList":[],"supportedLanguageList":["pt_br"]},"SE":{"countryCode":"SE","displayName":"Sverige","mappedCountryList":[],"supportedLanguageList":["sv_se","en_gb"]},"SG":{"countryCode":"SG","displayName":"Singapore","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"SI":{"countryCode":"SI","displayName":"Slovenia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"SK":{"countryCode":"SK","displayName":"Slovakia","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"GB":{"countryCode":"GB","displayName":"United Kingdom","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"CA":{"countryCode":"CA","displayName":"Canada","mappedCountryList":[],"supportedLanguageList":["en_gb","fr_fr"]},"CH":{"countryCode":"CH","displayName":"Switzerland","mappedCountryList":[],"supportedLanguageList":["de_de","fr_fr","it_it","en_gb"]},"KR":{"countryCode":"KR","displayName":"대한민국","mappedCountryList":[],"supportedLanguageList":["ko_kr"]},"CL":{"countryCode":"CL","displayName":"Chile","mappedCountryList":[],"supportedLanguageList":["es_la"]},"CN":{"countryCode":"CN","displayName":"中国大陆","mappedCountryList":[],"supportedLanguageList":["zh_cn"]},"GR":{"countryCode":"GR","displayName":"ΕΛΛΑΔΑ","mappedCountryList":[],"supportedLanguageList":["el_gr"]},"XF":{"countryCode":"XF","displayName":"Rest of Africa","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"TH":{"countryCode":"TH","displayName":"ประเทศไทย","mappedCountryList":[],"supportedLanguageList":["th_th"]},"XL":{"countryCode":"XL","displayName":"América Latina","mappedCountryList":[],"supportedLanguageList":["es_la"]},"XM":{"countryCode":"XM","displayName":"Rest of Middle East","mappedCountryList":["BH","IQ","IR","JO","KW","LB","OM","QA","SY","YE"],"supportedLanguageList":["en_gb"]},"CZ":{"countryCode":"CZ","displayName":"Česká Republika","mappedCountryList":[],"supportedLanguageList":["cs_cz","en_gb"]},"PH":{"countryCode":"PH","displayName":"Philippines","mappedCountryList":[],"supportedLanguageList":["en_gb"]},"PL":{"countryCode":"PL","displayName":"Polska","mappedCountryList":[],"supportedLanguageList":["pl_pl"]},"TR":{"countryCode":"TR","displayName":"TÜRKİYE","mappedCountryList":[],"supportedLanguageList":["tr_tr"]}},"DEFAULT_APP_NAME":"nikestore","LANGUAGES":{"el_gr":{"dialect":"gr","displayName":"Ελληνικά","abbrev":"el_gr","lang":"el"},"it_it":{"dialect":"it","displayName":"ITALIANO","abbrev":"it_it","lang":"it"},"ru_ru":{"dialect":"ru","displayName":"Русский","abbrev":"ru_ru","lang":"ru"},"pl_pl":{"dialect":"pl","displayName":"Polski","abbrev":"pl_pl","lang":"pl"},"tr_tr":{"dialect":"tr","displayName":"Türkçe","abbrev":"tr_tr","lang":"tr"},"pt_br":{"dialect":"br","displayName":"Português","abbrev":"pt_br","lang":"pt"},"th_th":{"dialect":"th","displayName":"ไทย","abbrev":"th_th","lang":"th"},"fr_fr":{"dialect":"fr","displayName":"FRANÇAIS","abbrev":"fr_fr","lang":"fr"},"ja_jp":{"dialect":"jp","displayName":"Japanese","abbrev":"ja_jp","lang":"ja"},"cs_cz":{"dialect":"cz","displayName":"ČEŠTINA","abbrev":"cs_cz","lang":"cs"},"ca_es":{"dialect":"es","displayName":"Català","abbrev":"ca_es","lang":"ca"},"de_de":{"dialect":"de","displayName":"DEUTSCH","abbrev":"de_de","lang":"de"},"hu_hu":{"dialect":"hu","displayName":"MAGYAR","abbrev":"hu_hu","lang":"hu"},"zh_tw":{"dialect":"tw","displayName":"中文","abbrev":"zh_tw","lang":"zh"},"es_es":{"dialect":"es","displayName":"ESPAÑOL","abbrev":"es_es","lang":"es"},"nl_nl":{"dialect":"nl","displayName":"Nederlands","abbrev":"nl_nl","lang":"nl"},"es_la":{"dialect":"la","displayName":"ESPAÑOL","abbrev":"es_la","lang":"es"},"sv_se":{"dialect":"se","displayName":"SVENSKA","abbrev":"sv_se","lang":"sv"},"es_ar":{"dialect":"ar","displayName":"ESPAÑOL","abbrev":"es_ar","lang":"es"},"da_dk":{"dialect":"dk","displayName":"DANSK","abbrev":"da_dk","lang":"da"},"en_gb":{"dialect":"gb","displayName":"ENGLISH","abbrev":"en_gb","lang":"en"},"ko_kr":{"dialect":"kr","displayName":"한국어","abbrev":"ko_kr","lang":"ko"},"en_us":{"dialect":"us","displayName":"ENGLISH","abbrev":"en_us","lang":"en"},"zh_cn":{"dialect":"cn","displayName":"中文","abbrev":"zh_cn","lang":"zh"},"no_no":{"dialect":"no","displayName":"NORSK","abbrev":"no_no","lang":"no"},"pt_pt":{"dialect":"pt","displayName":"Português","abbrev":"pt_pt","lang":"pt"}},"IS_COOKIE_SETTINGS_ENABLED":false,"IS_EU":false,"REGION":"CN","SECURE_ROOT_URL":"https://secure-store.nike.com/","IS_COMMERCE_OFF_NOTIFICATION_ENABLED":false,"LOCALE":"zh_CN","COUNTRY":"CN","ROOT_URL":"http://store.nike.com/","IS_GLOBAL_STORE":false,"SERVICE_URLS":{"customizationDataService":"http://nikeid.nike.com/id/services/pdpData/","genericEmailerService":"https://secure-store.nike.com/ap/services/genericEmailerService","nikeIdProductText":"http://nikeid.nike.com/v2/products/pathName/text_lang.xml","nikeIdSaveBuildProxyService":"http://store.nike.com/html-services/templateData/id/persist","gearUpProductGuideService":"http://www.nike.com/rf-productguide/productguide.json","storeLocatorService":"http://www.nike.com/store-locator/","apigeeAuthService":"https://idn.nike.com/authbycookie","bazaarVoiceApi":"http://nike.ugc.bazaarvoice.com/3150","baseModulesURL":"http://modules.nike.com/","geoService":"http://store.nike.com/us/services/geoService","baseCmsContentURL":"http://content.nike.com/","needleChatService":"//expert.nike.com/chat.js?ver=1","catalogService":"https://secure-store.nike.com/ap/services/catalogService.xml","appConnectionGatewayURL":"https://appconnectionsgateway.svs.nike.com/appconnectionsgateway/v1/","profileService":"https://secure-store.nike.com/ap/services/profileService","paymentOptionsHostname":"https://payment.nike.com","nikeIdScene7Vignette":"http://render.nikeid.com/ir/render/nikeidrender","nikeIdSpriteSheetService":"http://nikeid.nike.com/sheet/{pathName}/{layout}","captchaService":"http://store.nike.com/ap/services/captchaService?action=createCaptcha","createStudioLockerService":"http://nikeid.nike.com/services/create_studio_locker_item","giftCertificateService":"https://secure-store.nike.com/ap/services/GiftCertificateService","jsonCartService":"https://secure-store.nike.com/ap/services/jcartService","flashIdBuilderSwf":"http://nikeid.nike.com/flashbuilder/modules/standaloneIDBuilder.swf","typeAheadSearchService":"http://search.nike.com/os/cn/zh_CN/ta","baseBrandURL":"http://www.nike.com/","orderModifyService":"https://secure-store.nike.com/ap/services/orderModifyService","idPdpDataService":"http://store.nike.com/html-services/templateData/idData","isProfane":"http://origin-nikeid.nike.com/services/is_profane","digitalPidAddToCartServiceProxy":"http://store.nike.com/cn/zh_cn/html-services/cart/digital-pid","nikeIdGetBuildService":"http://nikeid.nike.com/services/get_build.xml","commerceDomain":"http://niketown.nike.com/","returnService":"https://secure-store.nike.com/ap/services/returnService","gridwallDataService":"http://store.nike.com/html-services/gridwallData","oneStoreMobileCartURL":"https://secure-store.nike.com/cn/checkout/mobile/index.jsp?l=cart","nikeIdIcPrice":"http://nikeid.nike.com/id/services/ic/price/cn/{pathName}.json","baseNikeIdS7ImageURL":"http://ugc.nikeid.com/is/image/nike/","legalAgreementServiceURL":"https://agreementservice.svs.nike.com/rest/agreement/","baseImageURL":"http://images.nike.com/is/image/DotCom/","idEditSpriteSheetService":"http://idedit.nike.com/v2/products/{pathName}/sheet/review/{layout}","miniPdpDataService":"http://store.nike.com/html-services/templateData/miniPdpData","baseMobileURL":"http://m.nike.com/","digitalPidAddToCartService":"https://secure-store.nike.com/us/services/cart/digital-pid","swooshFamilyService":"https://secure-store.nike.com/ap/services/swooshFamilyService","baseNikePlusURL":"http://nikeplus.nike.com/plus","globalWishlistService":"https://secure-store.nike.com/ap/services/globalWishlistService","oneStoreCartURL":"https://secure-store.nike.com/cn/checkout/html/index.jsp?l=cart","nikeIdSaveBuildService":"http://nikeid.nike.com/id/services/v4/build","outfitterService":"http://store.nike.com/outfitter/","mobilePhoneNumberVerificationService":"https://idn.nike.com/idn/phone","notifyMeService":"https://secure-store.nike.com/ap/services/notifyMeService","nikeIDImageRedirect":"http://nikeid.nike.com/services/imgredirect","nikeIdProductDefault":"http://nikeid.nike.com/v2/products/pathName/configuration/default.xml","persistConfigurationService":"http://nikeid.nike.com/v2/services/persist_configuration","swooshVerification":"https://secure-store.nike.com/ap/services/swooshVerification","oneStoreCheckoutURL":"https://secure-store.nike.com/cn/checkout/html/index.jsp?l=checkout","pdpDataService":"http://store.nike.com/html-services/templateData/pdpData","nikeIdAddToCartService":"https://secure-store.nike.com/ap/services/nikeIdAddToCart","secureBaseImageURL":"https://secure-images.nike.com/is/image/DotCom/","outfitPdpDataService":"http://store.nike.com/html-services/templateData/outfitData","passcodeService":"https://secure-store.nike.com/ap/services/passcodeService","shippingMethods":"https://secure-store.nike.com/ap/services/shippingMethods","prebuildService":"http://nikeid.nike.com/v2/channel/channelName/prebuilds/prebuildId.xml","accountSettingsPersonalInfoService":"https://idn.nike.com/user/accountsettings","baseStoreURL":"http://store.nike.com/","dpidCapacityCheckService":"http://store.nike.com/nikestore/html/services/dpid/capacity?productId=","nikeIdDomain":"http://nikeid.nike.com/","oneStoreHost":"http://store.nike.com/","profileBaseService":"https://www.nike.com/profile/","eShopWorldReturnService":"https://secure-global-returns.nike.com/Nike/Returns","pdfService":"https://secure-store.nike.com/us/services/pdfService","secureBaseNikeIdS7ImageURL":"https://secure-ugc.nikeid.com/is/image/nike/","nikeIdEditDesignService":"http://store.nike.com/us/services/correctBuilderFromLockerService","nikeIdSizeCharts":"http://nikeid.nike.com/","nikeIdProductMessageService":"http://nikeid.nike.com/v2/services/get_product_messages","nikeIdProductMessage":"http://nikeid.nike.com/v2/messages_lang.xml","baseSecureNikePlusURL":"https://nikeplus.nike.com/plus","nikeIdGetBuildForCartService":"http://nikeid.nike.com/services/get_build_for_cart","consumerChoicesService":"http://store.nike.com/consumerChoices/services/design/","SMSDataService":"https://idn.nike.com/plus/v3/notifications/sms"},"FEATURE_LIST":{"SOCIAL_TWITTER":false,"SOCIAL_QZONE":false,"GLOBAL_NAV_JUMPMAN":true,"PRICING_PDP":true,"PROFILE_MOBILE_NUM":false,"RATINGS_REVIEWS_LIKES":true,"SOCIAL_SINAWEIBO":true,"PRODUCT_MESSAGING":true,"SWOOSH":true,"PROFILE_WORKOUTS":true,"GOLF_CHAT":false,"SOCIAL_FACEBOOK":false,"PROFILE_ORDER_SMS":false,"PRINT_RETURN_LABEL":true,"PRICING_WISHLIST":true,"RUNNING_CHAT":false,"PRICING_RECS":true,"SOCIAL_TENCENTWEIBO":true,"SOCIAL_PINTEREST":false,"BUYING_TOOLS_PDP":true,"PAYMENT_OPTIONS":false,"GLOBAL_NAV_FEEDBACK":false,"EMAIL_RETURN_LABEL":true,"BUYING_TOOLS_WISHLIST":true,"ORDER_EINVOICE":true,"PRICING_GRIDWALL":true,"GLOBAL_NAV_CART":true,"PRODUCT_DISPLAY":true,"COUNTRY_OF_ORIGIN":true,"GLOBAL_NAV_HURLEY":false,"NEEDLE_CHAT":false,"TAX_DISCLAIMER":false,"USER_LOGIN":true,"PROFILE_ADDRESSES":true,"PRODUCT_PURCHASE":true,"ORDER_STATUS_PAY_NOW":true,"SOCIAL_GOOGLEPLUS":false,"GLOBAL_NAV_CONVERSE":true,"PARTNER_DISCONNECT":true,"RATINGS_REVIEWS":true,"MIXED_CART":true,"PICKUP_RETURN_LABEL":true,"PRINT_GIFT_CARD":false,"PROFILE_LEADERBOARD":true,"PRODUCT_MESSAGING_COLLAPSE":true,"MAIL_RETURN_LABEL":false,"RECYCLING_MESSAGE":false},"REGIONS":{"EU":{"displayName":"Europe","abbrev":"EU","countryList":["DE","BE","FI","PT","BG","DK","LU","GR","IT","FR","HU","ES","SE","AT","SI","CZ","SK","GB","IE","PL","RO","NL"]},"EMEA":{"displayName":"Europe, Middle East, and Africa","abbrev":"EMEA","countryList":["DE","NO","BE","FI","PT","CH","DK","LU","GR","IT","FR","HU","ES","SE","AT","SI","CZ","GB","IE","PL","NL","TR"]},"XA":{"displayName":"XA","abbrev":"XA","countryList":["TW","SG","TH","IN","VN","ID","MY"]},"GS":{"displayName":"Global Store","abbrev":"GS","countryList":["NO","PR","HK","RU","TW","BG","HR","NZ","SA","BR","MA","SG","SK","ID","CA","EG","IL","AE","UY","CH","IN","ZA","CL","MX","MY","XF","AR","AU","TH","XL","XM","PH","VN","RO","TR"]},"US":{"displayName":"United States","abbrev":"US","countryList":["US"]},"AP":{"displayName":"Asia Pacific","abbrev":"AP","countryList":["JP","CN"]}},"ENV_CONFIG":{"certonaHost":"www.res-x.com","omnitureIsProd":"true","certonaPdpRootUrl":"http://store.nike.com/","renderDataQA":"false"}};copyAllProperties(nike.exp.dynamic.AppConfig, dynamicAppConfig);}();if(nike && nike.addAppConfig){nike.addAppConfig();}

var nike = nike || {};nike.exp = nike.exp || {};nike.exp.dynamic = nike.exp.dynamic || {};nike.exp.dynamic.LocalValues = nike.exp.dynamic.LocalValues || {};!function(){function copyAllProperties(dest, src){var key;for(key in src){if(src.hasOwnProperty(key)){dest[key] = src[key];}}return dest;}nike.exp.dynamic.copyAllProperties = copyAllProperties;var localValueConfig = {"pw.nikeid.bannerbottom.customizejersey":"可选球员","crossSell.certona.nikeidText":"个性定制","crossSell.certona.title.nosearch2_rr":"通过 NIKEiD 专属定制","outfitpdp.outofstock.errortitle":"错误：商品不存在","crossSell.certona.title.nfljerseykidspdp_rr":"获得最终链接","widget-settings-avatar-save":"保存\n","browserDeprecator.CTA.label":"立刻升级","outfitpdp.outofstock.message":"抱歉，已有其他客户将此商品添加至购物车。如果几分钟后尚未付款，您仍有机会选购这些商品。（代码：010N-0000000]","crossSell.certona.title.nfl_pdp_suffix":"链接","gridwall.singularPlayerAvailable":"播放器","crossSell.certona.title.cart_rr":"您可能还喜欢","browserDeprecator.CTA.link.ie":"http://windows.microsoft.com/zh-cn/internet-explorer/download-ie","profile.validation.restrictedchar.message":"包含禁用字符，请重新选择。","crossSell.certona.title.inactivepdp1_rr":"购买所有 NIKEiD 定制款","widget-settings-avatar-loading":"正在加载...","gearUp.thisGoesWith":"这一切都与","crossSell.certona.nikeidUrlText":"购买所有 NIKEiD 定制款","gridwall.nfl.allteams":"所有NFL球队可用","crossSell.certona.title.error4042_rr":"女子热卖商品","crossSell.certona.title.nosearch1_rr":"购买所有 NIKEiD 定制款","widget-settings-avatar-upload-photo":"上传图片\n","gearUp.secondOptionSuffix":"ND","gearUp.firstOptionSuffix":"st","gridwall.colorplural":"色","gridwall.colorsingular":"色","compatibility.view.ie":"您正在ie浏览器兼容性视图模式下浏览此网站。关闭此项功能后，Nike官方网站将运行得更为流畅。<a href=\"http://windows.microsoft.com/zh-cn/internet-explorer/use-compatibility-view#ie=ie-8\">了解如何关闭此项功能。</a> ","browserDeprecator.messageText":"我们不再支持您所使用的浏览器版本。    为获得最佳体验，请升级至此浏览器的最新版本。","notification.ok":"确定","crossSell.certona.title.inactivepdp2_rr":"通过 NIKEiD 专属定制","widget-settings-avatar-title":"编辑头像","crossSell.certona.title.error4043_rr":"儿童热卖商品","crossSell.certona.title.product_rr":"您可能还喜欢","browserDeprecator.help.label":"浏览器帮助","crossSell.certona.title.purchase_rr":"(purchase_rr) REPLACE THIS VALUE IN HtmlLocalValueBundle.properties!","widget-settings-avatar-delete-photo":"删除\n","GlobalNav.cartGlyph.aria":"购物车 {1}","browserDeprecator.help.link":"http://help-zh-cn.nike.com/app/answers/detail/article/site-requirements","languageSelector.select.language":"选择您的语言","gridwall.playersAvailable":"可选球员","widget-settings-avatar-restrictions":"请确保图片尺寸小于2MB，且格式为jpeg、jpg、bpm或img形式\n","GlobalNav.profileGlyph.aria":"{1}：访问你的档案和账户设置","geolocator.brand.header":"选择您的位置","crossSell.certona.title.nflbuilderpdp_rr":"获得最终链接","gearUp.options":"选项","pdp.error.cartHeader":"注意！","widget-settings-avatar-be-valid-err":"上传图片失败。请确保您选择的图片尺寸小于2MB，且格式为jpeg、jpg、bpm或img形式。\n","crossSell.certona.title.nfljerseypdp_rr":"获得最终链接","register.confirmation.titleName":"欢迎加入，{1}。","geolocator.brand.see.all.countries":"查看所有国家/地区","crossSell.certona.nikeidUrl":"http://www.nike.com/zh/zh_cn/c/nikeid","crossSell.certona.title.nikeidpdp_rr":"您可能还喜欢","browserDeprecator.header":"升级您的浏览器","widget-settings-avatar-cancel":"取消\n","geolocator.brandmessage1":"Nike.com社区的国家或地区是否要访问?","pdp.crosssell.nikeid":"定制","gearUp.thirdOptionSuffix":"RD","crossSell.certona.title.error4041_rr":"男子热卖商品","gearUp.buyNow":"立即购买","buyingtools.widths.title":"可选择不同掌宽"};copyAllProperties(nike.exp.dynamic.LocalValues, localValueConfig);}();
try{
var nike = nike || {};
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
 * Build: `lodash underscore exports="commonjs,global,node" plus="assign,at,bindKey,cloneDeep,createCallback,curry,forIn,forOwn,forInRight,forOwnRight,forEachRight,findIndex,findKey,findLast,findLastIndex,findLastKey,isPlainObject,merge,parseInt,partialRight,pull,remove,transform" --output ./tesla-resources/core/src/main/resources/assets/scripts/lib/lodash.js`
 */
;(function(){function n(n){var t,r=[];if(!n||!Ct[typeof n])return r;for(t in n)Lt.call(n,t)&&r.push(t);return r}function t(n,t,r){r=(r||0)-1;for(var e=n?n.length:0;++r<e;)if(n[r]===t)return r;return-1}function r(n,t){for(var r=n.m,e=t.m,u=-1,o=r.length;++u<o;){var i=r[u],a=e[u];if(i!==a){if(i>a||typeof i=="undefined")return 1;if(i<a||typeof a=="undefined")return-1}}return n.n-t.n}function e(n){return"\\"+At[n]}function u(n){n.length=0,at.length<pt&&at.push(n)}function o(n,t,r){t||(t=0),typeof r=="undefined"&&(r=n?n.length:0);
var e=-1;r=r-t||0;for(var u=Array(0>r?0:r);++e<r;)u[e]=n[t+e];return u}function i(n){return n instanceof i?n:new a(n)}function a(n,t){this.__chain__=!!t,this.__wrapped__=n}function f(n){function t(){if(e){var n=o(e);Wt.apply(n,arguments)}if(this instanceof t){var i=c(r.prototype),n=r.apply(i,n||arguments);return B(n)?n:i}return r.apply(u,n||arguments)}var r=n[0],e=n[2],u=n[4];return t}function l(n,t,r,e,i){if(r){var a=r(n);if(typeof a!="undefined")return a}if(!B(n))return n;var f=$t.call(n);if(!kt[f])return n;
var c=tr[f];switch(f){case bt:case dt:return new c(+n);case _t:case xt:return new c(n);case jt:return a=c(n.source,st.exec(n)),a.lastIndex=n.lastIndex,a}if(f=er(n),t){var p=!e;e||(e=at.pop()||[]),i||(i=at.pop()||[]);for(var s=e.length;s--;)if(e[s]==n)return i[s];a=f?c(n.length):{}}else a=f?o(n):sr({},n);return f&&(Lt.call(n,"index")&&(a.index=n.index),Lt.call(n,"input")&&(a.input=n.input)),t?(e.push(n),i.push(a),(f?z:hr)(n,function(n,u){a[u]=l(n,t,r,e,i)}),p&&(u(e),u(i)),a):a}function c(n){return B(n)?Jt(n):{}
}function p(n,t,r){if(typeof n!="function")return et;if(typeof t=="undefined"||!("prototype"in n))return n;switch(r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,o){return n.call(t,r,e,u,o)}}return tt(n,t)}function s(n){function t(){var n=l?a:this;if(u){var y=o(u);Wt.apply(y,arguments)}return(i||g)&&(y||(y=o(arguments)),i&&Wt.apply(y,i),g&&y.length<f)?(e|=16,s([r,h?e:-4&e,y,null,a,f])):(y||(y=arguments),p&&(r=n[v]),this instanceof t?(n=c(r.prototype),y=r.apply(n,y),B(y)?y:n):r.apply(n,y))
}var r=n[0],e=n[1],u=n[2],i=n[3],a=n[4],f=n[5],l=1&e,p=2&e,g=4&e,h=8&e,v=r;return t}function g(n,t){for(var r=-1,e=j(),u=n?n.length:0,o=[];++r<u;){var i=n[r];0>e(t,i)&&o.push(i)}return o}function h(n,t,r,e){e=(e||0)-1;for(var u=n?n.length:0,o=[];++e<u;){var i=n[e];if(i&&typeof i=="object"&&typeof i.length=="number"&&(er(i)||C(i))){t||(i=h(i,t,r));var a=-1,f=i.length,l=o.length;for(o.length+=f;++a<f;)o[l++]=i[a]}else r||o.push(i)}return o}function v(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&Ct[typeof n]||t&&Ct[typeof t]))return false;
if(null==n||null==t)return n===t;var u=$t.call(n),o=$t.call(t);if(u!=o)return false;switch(u){case bt:case dt:return+n==+t;case _t:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case jt:case xt:return n==t+""}if(o=u==mt,!o){var a=n instanceof i,f=t instanceof i;if(a||f)return v(a?n.__wrapped__:n,f?t.__wrapped__:t,r,e);if(u!=wt)return false;if(u=n.constructor,a=t.constructor,u!=a&&!(S(u)&&u instanceof u&&S(a)&&a instanceof a)&&"constructor"in n&&"constructor"in t)return false}for(r||(r=[]),e||(e=[]),u=r.length;u--;)if(r[u]==n)return e[u]==t;
var l=true,c=0;if(r.push(n),e.push(t),o){if(c=t.length,l=c==n.length)for(;c--&&(l=v(n[c],t[c],r,e)););}else gr(t,function(t,u,o){return Lt.call(o,u)?(c++,l=Lt.call(n,u)&&v(n[u],t,r,e)):void 0}),l&&gr(n,function(n,t,r){return Lt.call(r,t)?l=-1<--c:void 0});return r.pop(),e.pop(),l}function y(n,t,r,e,u){(er(t)?z:hr)(t,function(t,o){var i,a,f=t,l=n[o];if(t&&((a=er(t))||vr(t))){for(f=e.length;f--;)if(i=e[f]==t){l=u[f];break}if(!i){var c;r&&(f=r(l,t),c=typeof f!="undefined")&&(l=f),c||(l=a?er(l)?l:[]:vr(l)?l:{}),e.push(t),u.push(l),c||y(l,t,r,e,u)
}}else r&&(f=r(l,t),typeof f=="undefined"&&(f=t)),typeof f!="undefined"&&(l=f);n[o]=l})}function m(n,t,r){for(var e=-1,u=j(),o=n?n.length:0,i=[],a=r?[]:i;++e<o;){var f=n[e],l=r?r(f,e,n):f;(t?!e||a[a.length-1]!==l:0>u(a,l))&&(r&&a.push(l),i.push(f))}return i}function b(n){return function(t,r,e){var u={};r=i.createCallback(r,e,3),e=-1;var o=t?t.length:0;if(typeof o=="number")for(;++e<o;){var a=t[e];n(u,a,r(a,e,t),t)}else hr(t,function(t,e,o){n(u,t,r(t,e,o),o)});return u}}function d(n,t,r,e,u,o){var i=16&t,a=32&t;
if(!(2&t||S(n)))throw new TypeError;return i&&!r.length&&(t&=-17,r=false),a&&!e.length&&(t&=-33,e=false),(1==t||17===t?f:s)([n,t,r,e,u,o])}function _(){Et.b=Et.c=Et.g=Et.i="",Et.e="t",Et.j=true;for(var n,t=0;n=arguments[t];t++)for(var r in n)Et[r]=n[r];t=Et.a,Et.d=/^[^,]+/.exec(t)[0],n=Function,t="return function("+t+"){",r=Et;var e="var n,t="+r.d+",E="+r.e+";if(!t)return E;"+r.i+";";r.b&&(e+="var u=t.length;n=-1;if("+r.b+"){while(++n<u){"+r.g+";}}else{");var u=[];return r.j&&r.f?e+="var C=-1,D=B[typeof t]&&v(t),u=D?D.length:0;while(++C<u){n=D[C];":(e+="for(n in t){",r.j&&u.push("m.call(t, n)")),u.length&&(e+="if("+u.join("&&")+"){"),e+=r.g+";",u.length&&(e+="}"),e+="}",r.b&&(e+="}"),e+=r.c+";return E",n("d,m,o,p,q,s,v,A,B,I,J,L",t+e+"}")(p,Lt,lt,C,er,F,Et.f,Dt,Ct,xt,Ft,$t)
}function w(n){return fr[n]}function j(){var n=(n=i.indexOf)===X?t:n;return n}function x(n){return typeof n=="function"&&qt.test(n)}function k(n){var t,r;return n&&$t.call(n)==wt&&(t=n.constructor,!S(t)||t instanceof t)?(gr(n,function(n,t){r=t}),typeof r=="undefined"||Lt.call(n,r)):false}function E(n){return lr[n]}function C(n){return n&&typeof n=="object"&&typeof n.length=="number"&&$t.call(n)==yt||false}function A(n){if(!n)return n;for(var t=1,r=arguments.length;t<r;t++){var e=arguments[t];if(e)for(var u in e)"undefined"==typeof n[u]&&(n[u]=e[u])
}return n}function T(n,t,r){var e=ur(n),u=e.length;for(t=p(t,r,3);u--&&(r=e[u],false!==t(n[r],r,n)););return n}function O(n){var t=[];return gr(n,function(n,r){S(n)&&t.push(r)}),t.sort()}function R(n){for(var t=-1,r=ur(n),e=r.length,u={};++t<e;){var o=r[t];u[n[o]]=o}return u}function I(n){if(!n)return true;if(er(n)||F(n))return!n.length;for(var t in n)if(Lt.call(n,t))return false;return true}function S(n){return typeof n=="function"}function B(n){return!(!n||!Ct[typeof n])}function D(n){return typeof n=="number"||n&&typeof n=="object"&&$t.call(n)==_t||false
}function F(n){return typeof n=="string"||n&&typeof n=="object"&&$t.call(n)==xt||false}function N(n){for(var t=-1,r=ur(n),e=r.length,u=Array(e);++t<e;)u[t]=n[r[t]];return u}function $(n,t){var r=j(),e=n?n.length:0,u=false;return e&&typeof e=="number"?u=-1<r(n,t):hr(n,function(n){return!(u=n===t)}),u}function q(n,t,r){var e=true;t=i.createCallback(t,r,3),r=-1;var u=n?n.length:0;if(typeof u=="number")for(;++r<u&&(e=!!t(n[r],r,n)););else hr(n,function(n,r,u){return e=!!t(n,r,u)});return e}function K(n,t,r){var e=[];
t=i.createCallback(t,r,3),r=-1;var u=n?n.length:0;if(typeof u=="number")for(;++r<u;){var o=n[r];t(o,r,n)&&e.push(o)}else hr(n,function(n,r,u){t(n,r,u)&&e.push(n)});return e}function M(n,t,r){t=i.createCallback(t,r,3),r=-1;var e=n?n.length:0;if(typeof e!="number"){var u;return hr(n,function(n,r,e){return t(n,r,e)?(u=n,false):void 0}),u}for(;++r<e;){var o=n[r];if(t(o,r,n))return o}}function z(n,t,r){var e=-1,u=n?n.length:0;if(t=t&&typeof r=="undefined"?t:p(t,r,3),typeof u=="number")for(;++e<u&&false!==t(n[e],e,n););else hr(n,t)
}function L(n,t,r){var e=n?n.length:0;if(t=t&&typeof r=="undefined"?t:p(t,r,3),typeof e=="number")for(;e--&&false!==t(n[e],e,n););else{var u=ur(n),e=u.length;hr(n,function(n,r,o){return r=u?u[--e]:--e,t(o[r],r,o)})}return n}function W(n,t,r){var e=-1,u=n?n.length:0;if(t=i.createCallback(t,r,3),typeof u=="number")for(var o=Array(u);++e<u;)o[e]=t(n[e],e,n);else o=[],hr(n,function(n,r,u){o[++e]=t(n,r,u)});return o}function P(n,t,r){var e=-1/0,u=e;typeof t!="function"&&r&&r[t]===n&&(t=null);var o=-1,a=n?n.length:0;
if(null==t&&typeof a=="number")for(;++o<a;)r=n[o],r>u&&(u=r);else t=i.createCallback(t,r,3),z(n,function(n,r,o){r=t(n,r,o),r>e&&(e=r,u=n)});return u}function H(n,t,r,e){if(!n)return r;var u=3>arguments.length;t=i.createCallback(t,e,4);var o=-1,a=n.length;if(typeof a=="number")for(u&&(r=n[++o]);++o<a;)r=t(r,n[o],o,n);else hr(n,function(n,e,o){r=u?(u=false,n):t(r,n,e,o)});return r}function J(n,t,r,e){var u=3>arguments.length;return t=i.createCallback(t,e,4),L(n,function(n,e,o){r=u?(u=false,n):t(r,n,e,o)}),r
}function U(n){var t=-1,r=n?n.length:0,e=Array(typeof r=="number"?r:0);return z(n,function(n){var r;r=++t,r=0+Mt(nr()*(r-0+1)),e[t]=e[r],e[r]=n}),e}function V(n,t,r){var e;t=i.createCallback(t,r,3),r=-1;var u=n?n.length:0;if(typeof u=="number")for(;++r<u&&!(e=t(n[r],r,n)););else hr(n,function(n,r,u){return!(e=t(n,r,u))});return!!e}function G(n,t,r){return r&&I(t)?it:(r?M:K)(n,t)}function Q(n,t,r){var e=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var a=-1;for(t=i.createCallback(t,r,3);++a<u&&t(n[a],a,n);)e++
}else if(e=t,null==e||r)return n?n[0]:it;return o(n,0,Yt(Xt(0,e),u))}function X(n,r,e){if(typeof e=="number"){var u=n?n.length:0;e=0>e?Xt(0,u+e):e||0}else if(e)return e=Z(n,r),n[e]===r?e:-1;return t(n,r,e)}function Y(n,t,r){if(typeof t!="number"&&null!=t){var e=0,u=-1,a=n?n.length:0;for(t=i.createCallback(t,r,3);++u<a&&t(n[u],u,n);)e++}else e=null==t||r?1:Xt(0,t);return o(n,e)}function Z(n,t,r,e){var u=0,o=n?n.length:u;for(r=r?i.createCallback(r,e,1):et,t=r(t);u<o;)e=u+o>>>1,r(n[e])<t?u=e+1:o=e;return u
}function nt(n,t,r,e){return typeof t!="boolean"&&null!=t&&(e=r,r=typeof t!="function"&&e&&e[t]===n?null:t,t=false),null!=r&&(r=i.createCallback(r,e,3)),m(n,t,r)}function tt(n,t){return 2<arguments.length?d(n,17,o(arguments,2),null,t):d(n,1,null,null,t)}function rt(n,t,r){function e(){c&&clearTimeout(c),i=c=p=it,(h||g!==t)&&(s=_r(),a=n.apply(l,o),c||i||(o=l=null))}function u(){var r=t-(_r()-f);0<r?c=setTimeout(u,r):(i&&clearTimeout(i),r=p,i=c=p=it,r&&(s=_r(),a=n.apply(l,o),c||i||(o=l=null)))}var o,i,a,f,l,c,p,s=0,g=false,h=true;
if(!S(n))throw new TypeError;if(t=Xt(0,t)||0,true===r)var v=true,h=false;else B(r)&&(v=r.leading,g="maxWait"in r&&(Xt(t,r.maxWait)||0),h="trailing"in r?r.trailing:h);return function(){if(o=arguments,f=_r(),l=this,p=h&&(c||!v),false===g)var r=v&&!c;else{i||v||(s=f);var y=g-(f-s),m=0>=y;m?(i&&(i=clearTimeout(i)),s=f,a=n.apply(l,o)):i||(i=setTimeout(e,y))}return m&&c?c=clearTimeout(c):c||t===g||(c=setTimeout(u,t)),r&&(m=true,a=n.apply(l,o)),!m||c||i||(o=l=null),a}}function et(n){return n}function ut(n){z(O(n),function(t){var r=i[t]=n[t];
i.prototype[t]=function(){var n=[this.__wrapped__];return Wt.apply(n,arguments),n=r.apply(i,n),this.__chain__?new a(n,true):n}})}function ot(n){return function(t){return t[n]}}var it,at=[],ft=0,lt={},ct=+new Date+"",pt=40,st=/\w*$/,gt=RegExp(" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"),ht=/($^)/,vt=/['\n\r\t\u2028\u2029\\]/g,yt="[object Arguments]",mt="[object Array]",bt="[object Boolean]",dt="[object Date]",_t="[object Number]",wt="[object Object]",jt="[object RegExp]",xt="[object String]",kt={"[object Function]":false};
kt[yt]=kt[mt]=kt[bt]=kt[dt]=kt[_t]=kt[wt]=kt[jt]=kt[xt]=true;var Et={a:"",b:null,c:"",d:"",e:"",v:null,g:"",h:null,support:null,i:"",j:false},Ct={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},At={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},Tt=Ct[typeof window]&&window||this,Ot=Ct[typeof exports]&&exports&&!exports.nodeType&&exports,Rt=Ct[typeof module]&&module&&!module.nodeType&&module,It=Rt&&Rt.exports===Ot&&Ot,St=Ct[typeof global]&&global;!St||St.global!==St&&St.window!==St||(Tt=St);
var Bt=[],Dt=Object.prototype,Ft=String.prototype,Nt=Tt._,$t=Dt.toString,qt=RegExp("^"+($t+"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),Kt=Math.ceil,Mt=Math.floor,zt=x(zt=Object.getPrototypeOf)&&zt,Lt=Dt.hasOwnProperty,Wt=Bt.push,Pt=Dt.propertyIsEnumerable,Ht=Bt.splice,Jt=x(Jt=Object.create)&&Jt,Ut=x(Ut=Array.isArray)&&Ut,Vt=Tt.isFinite,Gt=Tt.isNaN,Qt=x(Qt=Object.keys)&&Qt,Xt=Math.max,Yt=Math.min,Zt=Tt.parseInt,nr=Math.random,tr={};tr[mt]=Array,tr[bt]=Boolean,tr[dt]=Date,tr["[object Function]"]=Function,tr[wt]=Object,tr[_t]=Number,tr[jt]=RegExp,tr[xt]=String,a.prototype=i.prototype;
var rr={};!function(){var n={0:1,length:1};rr.spliceObjects=(Bt.splice.call(n,0,1),!n[0])}(1),i.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,variable:""},Jt||(c=function(){function n(){}return function(t){if(B(t)){n.prototype=t;var r=new n;n.prototype=null}return r||Tt.Object()}}()),C(arguments)||(C=function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&Lt.call(n,"callee")&&!Pt.call(n,"callee")||false});var er=Ut||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&$t.call(n)==mt||false
},ur=Qt?function(n){return B(n)?Qt(n):[]}:n,or={a:"g,e,K",i:"e=e&&typeof K=='undefined'?e:d(e,K,3)",b:false,v:ur,g:"if(e(t[n],n,g)===false)return E"},ir={a:"z,H,l",i:"var a=arguments,b=0,c=typeof l=='number'?2:a.length;while(++b<c){t=a[b];if(t&&B[typeof t]){",v:ur,g:"if(typeof E[n]=='undefined')E[n]=t[n]",c:"}}"},ar={i:"if(!B[typeof t])return E;"+or.i,b:false},fr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"},lr=R(fr),cr=RegExp("("+ur(lr).join("|")+")","g"),pr=RegExp("["+ur(fr).join("")+"]","g"),sr=_(ir,{i:ir.i.replace(";",";if(c>3&&typeof a[c-2]=='function'){var e=d(a[--c-1],a[c--],2)}else if(c>2&&typeof a[c-1]=='function'){e=a[--c]}"),g:"E[n]=e?e(E[n],t[n]):t[n]"}),gr=_(or,ar,{j:false}),hr=_(or,ar);
S(/x/)&&(S=function(n){return typeof n=="function"&&"[object Function]"==$t.call(n)});var vr=zt?function(n){if(!n||$t.call(n)!=wt)return false;var t=n.valueOf,r=x(t)&&(r=zt(t))&&zt(r);return r?n==r||zt(n)==r:k(n)}:k,yr=b(function(n,t,r){Lt.call(n,r)?n[r]++:n[r]=1}),mr=b(function(n,t,r){(Lt.call(n,r)?n[r]:n[r]=[]).push(t)}),br=b(function(n,t,r){n[r]=t}),dr=W,_r=x(_r=Date.now)&&_r||function(){return(new Date).getTime()},wr=8==Zt(" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000")?Zt:function(n,t){return Zt(F(n)?n.replace(gt,""):n,t||0)
};i.after=function(n,t){if(!S(t))throw new TypeError;return function(){return 1>--n?t.apply(this,arguments):void 0}},i.assign=sr,i.at=function(n){for(var t=arguments,r=-1,e=h(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:e.length,u=Array(t);++r<t;)u[r]=n[e[r]];return u},i.bind=tt,i.bindAll=function(n){for(var t=1<arguments.length?h(arguments,true,false,1):O(n),r=-1,e=t.length;++r<e;){var u=t[r];n[u]=d(n[u],1,null,null,n)}return n},i.bindKey=function(n,t){return 2<arguments.length?d(t,19,o(arguments,2),null,n):d(t,3,null,null,n)
},i.chain=function(n){return n=new a(n),n.__chain__=true,n},i.compact=function(n){for(var t=-1,r=n?n.length:0,e=[];++t<r;){var u=n[t];u&&e.push(u)}return e},i.compose=function(){for(var n=arguments,t=n.length;t--;)if(!S(n[t]))throw new TypeError;return function(){for(var t=arguments,r=n.length;r--;)t=[n[r].apply(this,t)];return t[0]}},i.countBy=yr,i.createCallback=function(n,t,r){var e=typeof n;if(null==n||"function"==e)return p(n,t,r);if("object"!=e)return ot(n);var u=ur(n);return function(t){for(var r=u.length,e=false;r--&&(e=t[u[r]]===n[u[r]]););return e
}},i.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,d(n,4,null,null,null,t)},i.debounce=rt,i.defaults=A,i.defer=function(n){if(!S(n))throw new TypeError;var t=o(arguments,1);return setTimeout(function(){n.apply(it,t)},1)},i.delay=function(n,t){if(!S(n))throw new TypeError;var r=o(arguments,2);return setTimeout(function(){n.apply(it,r)},t)},i.difference=function(n){return g(n,h(arguments,true,true,1))},i.filter=K,i.flatten=function(n,t){return h(n,t)},i.forEach=z,i.forEachRight=L,i.forIn=gr,i.forInRight=function(n,t,r){var e=[];
gr(n,function(n,t){e.push(t,n)});var u=e.length;for(t=p(t,r,3);u--&&false!==t(e[u--],e[u],n););return n},i.forOwn=hr,i.forOwnRight=T,i.functions=O,i.groupBy=mr,i.indexBy=br,i.initial=function(n,t,r){var e=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var a=u;for(t=i.createCallback(t,r,3);a--&&t(n[a],a,n);)e++}else e=null==t||r?1:t||e;return o(n,0,Yt(Xt(0,u-e),u))},i.intersection=function(){for(var n=[],t=-1,r=arguments.length;++t<r;){var e=arguments[t];(er(e)||C(e))&&n.push(e)}var u=n[0],o=-1,i=j(),a=u?u.length:0,f=[];
n:for(;++o<a;)if(e=u[o],0>i(f,e)){for(t=r;--t;)if(0>i(n[t],e))continue n;f.push(e)}return f},i.invert=R,i.invoke=function(n,t){var r=o(arguments,2),e=-1,u=typeof t=="function",i=n?n.length:0,a=Array(typeof i=="number"?i:0);return z(n,function(n){a[++e]=(u?t:n[t]).apply(n,r)}),a},i.keys=ur,i.map=W,i.max=P,i.memoize=function(n,t){var r={};return function(){var e=t?t.apply(this,arguments):ct+arguments[0];return Lt.call(r,e)?r[e]:r[e]=n.apply(this,arguments)}},i.merge=function(n){var t=arguments,r=2;
if(!B(n))return n;if("number"!=typeof t[2]&&(r=t.length),3<r&&"function"==typeof t[r-2])var e=p(t[--r-1],t[r--],2);else 2<r&&"function"==typeof t[r-1]&&(e=t[--r]);for(var t=o(arguments,1,r),i=-1,a=at.pop()||[],f=at.pop()||[];++i<r;)y(n,t[i],e,a,f);return u(a),u(f),n},i.min=function(n,t,r){var e=1/0,u=e;typeof t!="function"&&r&&r[t]===n&&(t=null);var o=-1,a=n?n.length:0;if(null==t&&typeof a=="number")for(;++o<a;)r=n[o],r<u&&(u=r);else t=i.createCallback(t,r,3),z(n,function(n,r,o){r=t(n,r,o),r<e&&(e=r,u=n)
});return u},i.omit=function(n){var t=[];gr(n,function(n,r){t.push(r)});for(var t=g(t,h(arguments,true,false,1)),r=-1,e=t.length,u={};++r<e;){var o=t[r];u[o]=n[o]}return u},i.once=function(n){var t,r;if(!S(n))throw new TypeError;return function(){return t?r:(t=true,r=n.apply(this,arguments),n=null,r)}},i.pairs=function(n){for(var t=-1,r=ur(n),e=r.length,u=Array(e);++t<e;){var o=r[t];u[t]=[o,n[o]]}return u},i.partial=function(n){return d(n,16,o(arguments,1))},i.partialRight=function(n){return d(n,32,null,o(arguments,1))
},i.pick=function(n){for(var t=-1,r=h(arguments,true,false,1),e=r.length,u={};++t<e;){var o=r[t];o in n&&(u[o]=n[o])}return u},i.pluck=dr,i.pull=function(n){for(var t=arguments,r=0,e=t.length,u=n?n.length:0;++r<e;)for(var o=-1,i=t[r];++o<u;)n[o]===i&&(Ht.call(n,o--,1),u--);return n},i.range=function(n,t,r){n=+n||0,r=+r||1,null==t&&(t=n,n=0);var e=-1;t=Xt(0,Kt((t-n)/r));for(var u=Array(t);++e<t;)u[e]=n,n+=r;return u},i.reject=function(n,t,r){return t=i.createCallback(t,r,3),K(n,function(n,r,e){return!t(n,r,e)
})},i.remove=function(n,t,r){var e=-1,u=n?n.length:0,o=[];for(t=i.createCallback(t,r,3);++e<u;)r=n[e],t(r,e,n)&&(o.push(r),Ht.call(n,e--,1),u--);return o},i.rest=Y,i.shuffle=U,i.sortBy=function(n,t,e){var u=-1,o=n?n.length:0,a=Array(typeof o=="number"?o:0);for(t=i.createCallback(t,e,3),z(n,function(n,r,e){a[++u]={m:[t(n,r,e)],n:u,o:n}}),o=a.length,a.sort(r);o--;)a[o]=a[o].o;return a},i.tap=function(n,t){return t(n),n},i.throttle=function(n,t,r){var e=true,u=true;if(!S(n))throw new TypeError;return false===r?e=false:B(r)&&(e="leading"in r?r.leading:e,u="trailing"in r?r.trailing:u),r={},r.leading=e,r.maxWait=t,r.trailing=u,rt(n,t,r)
},i.times=function(n,t,r){n=-1<(n=+n)?n:0;var e=-1,u=Array(n);for(t=p(t,r,1);++e<n;)u[e]=t(e);return u},i.toArray=function(n){return er(n)?o(n):n&&typeof n.length=="number"?W(n):N(n)},i.transform=function(n,t,r,e){var u=er(n);if(null==r)if(u)r=[];else{var o=n&&n.constructor;r=c(o&&o.prototype)}return t&&(t=i.createCallback(t,e,4),(u?z:hr)(n,function(n,e,u){return t(r,n,e,u)})),r},i.union=function(){return m(h(arguments,true,true))},i.uniq=nt,i.values=N,i.where=G,i.without=function(n){return g(n,o(arguments,1))
},i.wrap=function(n,t){return d(t,16,[n])},i.zip=function(){for(var n=-1,t=P(dr(arguments,"length")),r=Array(0>t?0:t);++n<t;)r[n]=dr(arguments,n);return r},i.collect=W,i.drop=Y,i.each=z,i.eachRight=L,i.extend=sr,i.methods=O,i.object=function(n,t){var r=-1,e=n?n.length:0,u={};for(t||!e||er(n[0])||(t=[]);++r<e;){var o=n[r];t?u[o]=t[r]:o&&(u[o[0]]=o[1])}return u},i.select=K,i.tail=Y,i.unique=nt,i.clone=function(n,t,r,e){return typeof t!="boolean"&&null!=t&&(e=r,r=t,t=false),l(n,t,typeof r=="function"&&p(r,e,1))
},i.cloneDeep=function(n,t,r){return l(n,true,typeof t=="function"&&p(t,r,1))},i.contains=$,i.escape=function(n){return null==n?"":(n+"").replace(pr,w)},i.every=q,i.find=M,i.findIndex=function(n,t,r){var e=-1,u=n?n.length:0;for(t=i.createCallback(t,r,3);++e<u;)if(t(n[e],e,n))return e;return-1},i.findKey=function(n,t,r){var e;return t=i.createCallback(t,r,3),hr(n,function(n,r,u){return t(n,r,u)?(e=r,false):void 0}),e},i.findLast=function(n,t,r){var e;return t=i.createCallback(t,r,3),L(n,function(n,r,u){return t(n,r,u)?(e=n,false):void 0
}),e},i.findLastIndex=function(n,t,r){var e=n?n.length:0;for(t=i.createCallback(t,r,3);e--;)if(t(n[e],e,n))return e;return-1},i.findLastKey=function(n,t,r){var e;return t=i.createCallback(t,r,3),T(n,function(n,r,u){return t(n,r,u)?(e=r,false):void 0}),e},i.has=function(n,t){return n?Lt.call(n,t):false},i.identity=et,i.indexOf=X,i.isArguments=C,i.isArray=er,i.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&$t.call(n)==bt||false},i.isDate=function(n){return n&&typeof n=="object"&&$t.call(n)==dt||false
},i.isElement=function(n){return n&&1===n.nodeType||false},i.isEmpty=I,i.isEqual=function(n,t){return v(n,t)},i.isFinite=function(n){return Vt(n)&&!Gt(parseFloat(n))},i.isFunction=S,i.isNaN=function(n){return D(n)&&n!=+n},i.isNull=function(n){return null===n},i.isNumber=D,i.isObject=B,i.isPlainObject=vr,i.isRegExp=function(n){return n&&Ct[typeof n]&&$t.call(n)==jt||false},i.isString=F,i.isUndefined=function(n){return typeof n=="undefined"},i.lastIndexOf=function(n,t,r){var e=n?n.length:0;for(typeof r=="number"&&(e=(0>r?Xt(0,e+r):Yt(r,e-1))+1);e--;)if(n[e]===t)return e;
return-1},i.mixin=ut,i.noConflict=function(){return Tt._=Nt,this},i.parseInt=wr,i.random=function(n,t){return null==n&&null==t&&(t=1),n=+n||0,null==t?(t=n,n=0):t=+t||0,n+Mt(nr()*(t-n+1))},i.reduce=H,i.reduceRight=J,i.result=function(n,t){if(n){var r=n[t];return S(r)?n[t]():r}},i.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:ur(n).length},i.some=V,i.sortedIndex=Z,i.template=function(n,t,r){var u=i,o=u.templateSettings;n=(n||"")+"",r=A({},r,o);var a=0,f="__p+='",o=r.variable;n.replace(RegExp((r.escape||ht).source+"|"+(r.interpolate||ht).source+"|"+(r.evaluate||ht).source+"|$","g"),function(t,r,u,o,i){return f+=n.slice(a,i).replace(vt,e),r&&(f+="'+_.escape("+r+")+'"),o&&(f+="';"+o+";\n__p+='"),u&&(f+="'+((__t=("+u+"))==null?'':__t)+'"),a=i+t.length,t
}),f+="';",o||(o="obj",f="with("+o+"||{}){"+f+"}"),f="function("+o+"){var __t,__p='',__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}"+f+"return __p}";try{var l=Function("_","return "+f)(u)}catch(c){throw c.source=f,c}return t?l(t):(l.source=f,l)},i.unescape=function(n){return null==n?"":(n+"").replace(cr,E)},i.uniqueId=function(n){var t=++ft+"";return n?n+t:t},i.all=q,i.any=V,i.detect=M,i.findWhere=function(n,t){return G(n,t,true)},i.foldl=H,i.foldr=J,i.include=$,i.inject=H,i.first=Q,i.last=function(n,t,r){var e=0,u=n?n.length:0;
if(typeof t!="number"&&null!=t){var a=u;for(t=i.createCallback(t,r,3);a--&&t(n[a],a,n);)e++}else if(e=t,null==e||r)return n?n[u-1]:it;return o(n,Xt(0,u-e))},i.sample=function(n,t,r){return n&&typeof n.length!="number"&&(n=N(n)),null==t||r?n?n[0+Mt(nr()*(n.length-1-0+1))]:it:(n=U(n),n.length=Yt(Xt(0,t),n.length),n)},i.take=Q,i.head=Q,ut(i),i.VERSION="2.4.1",i.prototype.chain=function(){return this.__chain__=true,this},i.prototype.value=function(){return this.__wrapped__},z("pop push reverse shift sort splice unshift".split(" "),function(n){var t=Bt[n];
i.prototype[n]=function(){var n=this.__wrapped__;return t.apply(n,arguments),rr.spliceObjects||0!==n.length||delete n[0],this}}),z(["concat","join","slice"],function(n){var t=Bt[n];i.prototype[n]=function(){var n=t.apply(this.__wrapped__,arguments);return this.__chain__&&(n=new a(n),n.__chain__=true),n}}),Ot&&Rt?It?(Rt.exports=i)._=i:Ot._=i:Tt._=i}).call(this);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing lib.lodash. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/*
    http://www.JSON.org/json2.js
    2010-03-20

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (!this.JSON) {
    this.JSON = {};
}

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing JSON. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * Add 'contains' function to Array object prototype.
 */
Array.prototype.contains = Array.prototype.contains || function (element) {
	for (var i = 0, L = this.length; i < L; i++) {
		if (this[i] == element) {
			return true;
		}
	}
	return false;
};

Array.prototype.map = Array.prototype.map || function (element) {
	var output = [];
	for (var i = 0, L = this.length; i < L; i++) {
		output[i] = element(this[i]);
	}
	return output;
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing Array. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/*! Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    var initializing = false, fnTest = /xyz/.test(function() {
        xyz;
    }) ? /\b_super\b/ : /.*/;


    // The base Class implementation (does nothing)
    this.Class = function() {
    };

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extensible
        Class.extend = arguments.callee;

        return Class;
    };
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing Class. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 NikeScriptManager provides functionality to load all Nike API and gadget scripts dynamically.
 The manager can request all required scripts in a single request and
 load them into the page.

 **/

/**
 * @TODO: move this somewhere better!
 * Add extensions
 */


/*
 * Adding trim support for IE.  This was breaking tracking conditionals.
 * We are putting this here because we are releasing this to prod in 2 days....for holiday.
 */
if(typeof String.prototype.trim !== 'function') {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  }
}

/**
 * Root nike object
 *
 */

var nike = nike || {};

/**
 * Resolved from <b>model.scriptInfo.rootUrl</b>
 *
 * @name nike.ROOT_DOMAIN
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.secureRootUrl</b>
 *
 * @name nike.SECURE_ROOT_DOMAIN
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.appName</b>
 *
 * @name nike.DEFAULT_APP_NAME
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.country</b>
 *
 * @name nike.COUNTRY
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.langLocale</b>
 *
 * @name nike.LOCALE
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.region</b>
 *
 * @name nike.REGION
 * @type String
 */

/**
 * Resolves from <b>model.scriptInfo.language</b>
 * @name nike.LANGUAGE
 * @type String
 */

/**
 * Resolved from <b>model.scriptInfo.rootDomain</b>
 *
 * @name nike.ROOT_DOMAIN
 * @type String
 */

/**
 * Resolved from <b>buildJsMap(model.scriptInfo.rootUrls)</b>
 *
 * @name nike.ROOT_URL
 * @type Object
 */

/**
 * Resolved from <b>buildJsMap(model.scriptInfo.secureRootUrls)</b>
 *
 * @name nike.SECURE_ROOT_URL
 * @type String
 */

/**
 * Resolved from <b>buildServiceUrlMap(model.scriptInfo.supportedServices)</b>
 *
 * @name nike.SERVICE_URLS
 * @type Object
 */

/**
 * Resolved from <b>buildJsMap(model.scriptInfo.envConfigMap)</b>
 *
 * @name nike.ENV_CONFIG
 * @type Object
 */

/**
 * This is the format requested with the script manager. It can be
 * different from nike.format which is used for requesting script
 * dependencies once the script manager has loaded
 *
 * Resolved from <b>model.scriptInfo.scriptManagerFormat</b>
 *
 * @name nike.SCRIPT_MANAGER_FORMAT
 * @type String
 */

/**
 * Populate variables and fields which are required for the remainder of the initialization of the nike object.
 */
nike = _.extend({}, nike,
/** @lends nike */
{
  /**
   * A function which does nothing. Reference this instance rather than creating new versions that do the same thing.
   */
  emptyFn : function() {
  },

  /**
   * Creates a function that will record all uses of itself.  Every call will store an array of it's arguments
   * into the function.history property.   You can also change which function is actually called by
   * changing the funciton.func property to another function.
   *
   * @returns {Function} Will contain the properties 'history' and 'func' and acts as a recorded pass through
   */
  createHistoryFunc : function (func) {
    var history = [];
    var historyFunc = function () {
      var args = Array.prototype.slice.call(arguments);
      history.push(args);
      try {
        historyFunc.func.apply(this, args);
      }catch (e){
      }
    };
    historyFunc.history = history;
    historyFunc.func = func;
    return historyFunc;
  },
  /**
   * Define our global object within 'nike' (usually window)
   */
  global : this
});


/**
 * Returns the last two portions of a domain name for use with cookies
 *
 * e.g. 'store.nike.com' => 'nike.com', 'localhost' => 'localhost',
 * 'mozilla.org' => 'mozilla.org', 'ecn6-store.nike.com' => 'nike.com'
 *
 * @param {String} hostName Typically this would be window.location.hostname.  Use nike.ROOT_DOMAIN for resolved value.
 * @return {String}
 */
nike.getRootDomain = function (hostName) {
    var hostNameParts = hostName.split(".");
    var rootDomain = hostName;

    if(hostNameParts.length > 1){
        var rootDomainParts = hostNameParts.slice(hostNameParts.length - 2);
        rootDomain = rootDomainParts ? rootDomainParts.join(".") : rootDomain;
    }

    return rootDomain;
};

/**
 * If nike already exists in this window's namespace, copy this version into it, without overwriting any values.
 */
nike = _.extend({}, nike,
/** @lends nike */
{
  /**
   * Map of file names to actual namespaces for libraries we're loading
   * @type {Object}
   */
  LIB_NAMESPACE_MAP : {
    "lib.lodash" : "_",
    "jQuery" : "$"
  },
  /**
   * Used to set cookies to the root domain to span across multiple sub domains.
   *
   * @type String
   */
  ROOT_DOMAIN : (function(){
    var rootDomain = "";
    if(nike.global !== undefined &&
       nike.global.location !== undefined &&
       nike.global.location.hostname !== undefined){
      rootDomain = nike.getRootDomain(nike.global.location.hostname);
    }
    return rootDomain;
  })(),


/**
       * nike.ROOT_URL is written out dynamically by the
       * script resolver.  If the page is loaded from a secure url
       * all requests need to go through https.
       */
  SSL_ONLY : (function(){
    var isSSL = true;
    if(nike.global !== undefined &&
       nike.global.location !== undefined &&
       nike.global.location.protocol !== undefined){
        isSSL = nike.global.location.protocol != "http:";
    }
    return isSSL;
  })(),

  /**
   * Name of the data() property on a gadget element storing the
   * instance of the gadget class
   */
  GADGET_INSTANCE : 'gadgetInstance',

  PAGE_INSTANCE: 'pageInstance',

  COMPONENT_INSTANCE: 'componentInstance',

  /**
   * Flag to indicate if a gadget is loaded or not - this should be stored in an elements data()
   */
  IS_LOADED_KEY : 'isLoaded',


  /* Declare variables so that we can pay attention to code analysis tools that report undeclared variables */

  /**
   * ROOT_URL is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  ROOT_URL : undefined,
  /**
   * SECURE_ROOT_URL is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  SECURE_ROOT_URL : undefined,
  /**
   * SERVICE_URLS is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  SERVICE_URLS : undefined,
  /**
   * DEFAULT_APP_NAME - this is deprecated - it will be ignored.  Once all references are removed, it will be removed here
   */
  DEFAULT_APP_NAME : undefined, //  "${model.scriptInfo.appName!}";

  /**
   * SCRIPT_MANAGER_FORMAT is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  SCRIPT_MANAGER_FORMAT : undefined,

  /* Define some event keys: */
  EVENT_GADGET_LOADED : 'gadgetLoadedEvent',

  EVENT_LOAD_GADGET : 'loadGadgetEvent',

  EVENT_REQUESTED_SCRIPTS_LOADED : 'requestedScriptsLoadedEvent',

  EVENT_REQUESTED_STYLES_LOADED : 'requestedStylesLoadedEvent',

  EVENT_EXTERNAL_RESOURCES_LOADED : 'externalResourcesLoadedEvent',

  EVENT_LOAD_GADGET_FAIL : 'loadGadgetFailEvent',

  /**
   * COUNTRY is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  COUNTRY : undefined, //  "${model.scriptInfo.country!}";

  /**
   * LOCALE is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  LOCALE : undefined, //  "${model.scriptInfo.langLocale!}";

  /**
   * REGION is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  REGION : undefined, //  "${model.scriptInfo.region!}";

  /**
   * IS_GLOBAL_STORE is defined and populated by DynamicJSConfigBuilder - nike.exp.AppConfig
   */
  IS_GLOBAL_STORE : undefined,

  DATA_QA : "data-qa",

  /**
   * build-time logging stubs.
   * See 'logging.js' for implemented methods.
   */
  log  : nike.emptyFn,
  eventLog  : nike.emptyFn,
  debug : nike.emptyFn,
  info : nike.emptyFn,
  warn : nike.emptyFn,
  error : nike.emptyFn,
  trace : nike.emptyFn,

  /**
   * Get the root url for an app.
   *
   * @return Fully qualified URL of the app server. HTTPS if nike.SSL_ONLY is true.
   */
  getRootUrl : function() {
    if (nike.SSL_ONLY) {
      return nike.SECURE_ROOT_URL;
    }
    return nike.ROOT_URL;
  },

  /**
   * Get the root url for an app with the country
   * and locale added to the path
   */
  getLocalizedRootUrl : function(){
    var ret = nike.getRootUrl() +
      nike.COUNTRY.toLowerCase() + '/' +
      nike.LOCALE.toLowerCase() + '/';
    return ret;
  },

  /**
   * Get the base store url for an app with the country
   * and locale added to the path
   */
  getBaseStoreUrl : function(){
    var ret = nike.getServiceUrl('baseStoreURL') +
              nike.COUNTRY.toLowerCase() + '/' +
              nike.LOCALE.toLowerCase() + '/';
    return ret;
  },

  /**
   * Get the secured root url for an app with the country
   * and locale added to the path
   */
  getSecureLocalizedRootUrl : function(){
    var ret = nike.getSecureRootUrl() +
              nike.COUNTRY.toLowerCase() + '/' +
              nike.LOCALE.toLowerCase() + '/';
    return ret;
  },

  /**
   * @return the secure URL to the app server
   */
  getSecureRootUrl : function() {
    return nike.SECURE_ROOT_URL;
  },

  /**
   * Resolve a service URL for a particular app, using service
   * names defined in the tesla yellowpage configuration XML.
   *
   * @param service Service identifier in yellowpage XML.
   *
   * @return Fully qualified URL of the service with required path
   *         and protocol or root app name if no service is provided.
   */
  getServiceUrl : function(service) {
    if (service == undefined) {
      return nike.getRootUrl();
    }
    return nike.SERVICE_URLS[service];
  },

  /**
   * Creates the 'namespace' by making sure all
   * sub-object are created
   *
   * @param {String} name - String representing the namespace
   * @param {Function} [callback] - A function that will return the namespace's Class.
   * @return {Object} The namespace in question
   */
  namespace: function(name, callback){
    var parts = name.split('.');
    var namespace = nike.global;
    var part;
    for (var i = 0, L = parts.length; i < L; i++) {
      var sourceObject = {};
      if (i === L-1 && arguments.length > 1) {
        if(_(arguments[1]).isFunction()){
          sourceObject = arguments[1].call();
        } else {
          sourceObject = arguments[1];
        }
      }
      part = parts[i];
      namespace[part] = namespace[part] || sourceObject;
      namespace = namespace[part];
    }

    return namespace;
  },

  /**
   * Determine if a given namespace is a defined
   * object
   *
   * @param {String} name String representing the namespace
   * @param {Object} [rootObject] Check if objects in name param are defined on this object.  If not specified, it will check the global namespace.
   * @param {Boolean} [returnObject] If this is true, the object will be returned (including undefined if it's not found).  If false or not specified,
   *        it will return a boolean value indicating if an object was found.
   * @return {Boolean|Object|Undefined}
   */
  objectDefined  : function(name, rootObject, returnObject) {
    var parts = name.split('.');
    var namespace = rootObject ? rootObject : nike.global;
    for (var i = 0; i < parts.length; i++) {
      if (!namespace[parts[i]]) {
        return returnObject ? namespace[parts[i]] : false;
      }
      namespace = namespace[parts[i]];
    }

    return returnObject ? namespace : true;
  },

  /**
   * Added at the beginning of included scripts and
   * defines dependencies of the script.  This is mostly for
   * server side parsing, but will check for the dependency
   * on the client when executed.
   *
   * @param name Fully qualified name of object
   * @param [cssOnly=false] if this is true, don't check for the JS object because there isn't one for this asset.
   */
  requireDependency  : function(name, cssOnly) {
    // If dependency is in the lib map, it's saved in the global scope and needs to be
    // returned from there.
    if (nike.LIB_NAMESPACE_MAP[name]){
      return nike.global[nike.LIB_NAMESPACE_MAP[name]];
    } else if (!cssOnly && !nike.objectDefined(name)) {
      nike.error('Dependency not defined: ' + name);
    }
    return nike.objectDefined(name, null, true);
  },

  requireAdditionalLocalValues : function() {
    //This doesn't do anything other than prevent js error for when it's called.  This is parsed on the backend to determine if any additional local values are required for this script
  },

  /**
   * Attach the app config fields to the root nike object.  This is for backwards compatibility with old scripts that don't know about nike.exp.dynamic.AppConfig.
   */
  addAppConfig : function(){
    if(nike.objectDefined('nike.exp.dynamic.AppConfig')){
      _.extend(nike, nike.exp.dynamic.AppConfig);
    }
  },

  /**
   * There's some code that needs to be able to set cookies before we have jQuery loaded.
   * Use CookieUtil for more verbose cookie handling.
   * @param {String} cookieName - The cookie name
   * @param {String} value - The value of the cookie
   * @param {String|boolean} [domain] - A String domain value, or if `true` will just use the root domain.
   */
  createCookie : function(cookieName, value, domain){
    var domainVal = '';

    if( domain ){
      domainVal = ( typeof domain === 'boolean' )
        ? location.host.match(/\w+\.com$/)
        : domain;
      domainVal = ' domain='+ domainVal +';';
    }

    document.cookie = cookieName+"="+value+";"+domainVal+" path=/";
  },

  /**
   * There's some code that needs to be able to read cookies before we have jQuery loaded.
   * Use CookieUtil for more verbose cookie handling.
   * @param {String} cookieName - The cookie name
   * @returns {Null|String}
   */
  readCookie : function(cookieName){
    var nameEQ = cookieName + "=";
    var cookies = document.cookie.split(';');

    for( var i=0; i<cookies.length; i++ ){
      var cookie = cookies[i];
      while( cookie.charAt(0) == ' ' ) cookie = cookie.substring(1, cookie.length);
      if( cookie.indexOf(nameEQ) == 0 ) return cookie.substring(nameEQ.length, cookie.length);
    }

    return null;
  }
});


//This is for backwards compatibility - we should eventually just call fields from AppConfig directly rather than calling app config stuff off nike (ie nike.COUNTRY)
nike.addAppConfig();

/**
 * Make sure external dependencies are required
 */
nike.requireDependency('lib.lodash');
nike.requireDependency('JSON');
nike.requireDependency('Array');
nike.requireDependency('Class');


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * Extend the nike "object" with new logging functions; this will overwrite existing logging functions, which should be
 * emptyFn stubs at this point.
 */
(function(){
  if (window.nike && window.top.console) {
    var teslaConsoleCookie = nike.readCookie('tesla_console');

    if(
      teslaConsoleCookie != null
      && teslaConsoleCookie != ''
      && typeof console.log === 'function'
    ){
      nike.exp.logging = {
        maxLength: 50,
        outputCount: 0,
        logs: [],
        firstLoadOccurred: false,
        prettify: false,
        jQueryLoadCheckMax: 3,
        jQueryLoadCheck: 0,
        UPDATE_DOM_LOGS: 'updateDOMLogs',
        COOKIE_NAME: 'tesla_console_logging',
        defaults: {
          log: true,
          eventLog: false,
          info: false,
          debug: false,
          error: true,
          warn: false,
          outputToDom: true,
          outputToDevTools: false
        }
      };
      nike.exp.logging.settings = JSON.parse( nike.readCookie(nike.exp.logging.COOKIE_NAME) );

      // use defaults on initial load if the cookie isn't set
      if( !nike.exp.logging.settings ){
        nike.exp.logging.settings = _.merge( nike.exp.logging.defaults, nike.exp.logging.settings );
        nike.createCookie( nike.exp.logging.COOKIE_NAME, JSON.stringify(nike.exp.logging.settings), true );
      }

      function checkEnabled(key){
        return nike.exp.logging.settings[key];
      }

      function typeCheck(key){
        return ( console[key] ) ? key : 'log';
      }

      function customParser(key, value){
        // This will occur if the load order of JQ comes after logging.js
        // which can happen on older tesla1 pages
        if( typeof jQuery != "undefined" ){
          // this prevents DOM recursion errors
          if( (value instanceof jQuery) ){
            return '[ jQuery ]';
          }

          return value;
        }else{
          if( nike.exp.logging.jQueryLoadCheck != nike.exp.logging.jQueryLoadCheckMax ){
            setTimeout(function(){
              nike.exp.logging.jQueryLoadCheck++;
              customParser(key, value);
            }, 1000);
          }
        }
      }

      function storeLogs(args, label){
        var logColor;

        nike.exp.logging.outputCount++;

        // prettify Object if one is present
        for(var i=0; i<args.length; i++){
          if( typeof args[i] == 'object' ){
            args[i] = JSON.stringify(args[i], customParser, 2);
          }
        }

        switch( label ){
          case 'Log' : logColor = 'is-log-log'; break;
          case 'Event' : logColor = 'is-event-log'; break;
          case 'Debug' : logColor = 'is-debug-log'; break;
          case 'Info' : logColor = 'is-info-log'; break;
          case 'Warn' : logColor = 'is-warn-log'; break;
          case 'Error' : logColor = 'is-error-log'; break;
        }

        args = Array.prototype.slice.call(args);
        args.unshift('<b class="'+ logColor +'">[ '+ label +' ]</b>');

        nike.exp.logging.logs.push( args.join(' ') +"<br>" );

        // limit the output to a specific number of logs
        if( nike.exp.logging.outputCount > nike.exp.logging.maxLength ){
          nike.exp.logging.logs = nike.exp.logging.logs.splice(-nike.exp.logging.maxLength);
        }

        if( nike.exp.logging.firstLoadOccurred ){
          // not using nike.dispatch because it'd cause a recursive loop
          $(nike.global).trigger(nike.exp.logging.UPDATE_DOM_LOGS);
        }
      }

      function log(){
        if( checkEnabled('log') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            console.log.apply(console, arguments);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Log');
          }
        }
      }

      function eventLog(){
        if( checkEnabled('eventLog') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            var args = Array.prototype.slice.call(arguments);
            args.unshift('[ EVENT ] -');

            console.log.apply(console, args);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Event');
          }
        }
      }

      function debug(){
        if( checkEnabled('debug') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            console[ typeCheck('debug') ].apply(console, arguments);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Debug');
          }
        }
      }

      function info(){
        if( checkEnabled('info') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            console[ typeCheck('info') ].apply(console, arguments);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Info');
          }
        }
      }

      function warn(){
        if( checkEnabled('warn') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            console[ typeCheck('warn') ].apply(console, arguments);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Warn');
          }
        }
      }

      function error(){
        if( checkEnabled('error') ){
          if( nike.exp.logging.settings.outputToDevTools ){
            console[ typeCheck('error') ].apply(console, arguments);
          }
          if( nike.exp.logging.settings.outputToDom ){
            storeLogs(arguments, 'Error');
          }
        }
      }

      _.merge(nike, {
        log : log,
        eventLog : eventLog,
        debug : debug,
        info : info,
        warn : warn,
        error : error
      });
    } else {
      // if logging isn't possible, swallow them so errors aren't thrown
      _.merge(nike, {
        log : nike.emptyFn,
        eventLog : nike.emptyFn,
        debug : nike.emptyFn,
        info : nike.emptyFn,
        warn : nike.emptyFn,
        error : nike.emptyFn
      });
    }
  }
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing logging. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
        navigator = window.navigator,
        location = window.location;
    var jQuery = (function() {

// Define a local copy of jQuery
        var jQuery = function( selector, context ) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init( selector, context, rootjQuery );
        },

            // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,

            // Map over the $ in case of overwrite
            _$ = window.$,

            // A central reference to the root jQuery(document)
            rootjQuery,

            // A simple way to check for HTML strings or ID strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

            // Check if a string has a non-whitespace character in it
            rnotwhite = /\S/,

            // Used for trimming whitespace
            trimLeft = /^\s+/,
            trimRight = /\s+$/,

            // Match a standalone tag
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

            // JSON RegExp
            rvalidchars = /^[\],:{}\s]*$/,
            rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

            // Useragent RegExp
            rwebkit = /(webkit)[ \/]([\w.]+)/,
            ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            rmsie = /(msie) ([\w.]+)/,
            rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

            // Matches dashed string for camelizing
            rdashAlpha = /-([a-z]|[0-9])/ig,
            rmsPrefix = /^-ms-/,

            // Used by jQuery.camelCase as callback to replace()
            fcamelCase = function( all, letter ) {
                return ( letter + "" ).toUpperCase();
            },

            // Keep a UserAgent string for use with jQuery.browser
            userAgent = navigator.userAgent,

            // For matching the engine and version of the browser
            browserMatch,

            // The deferred used on DOM ready
            readyList,

            // The ready event handler
            DOMContentLoaded,

            // Save a reference to some core methods
            toString = Object.prototype.toString,
            hasOwn = Object.prototype.hasOwnProperty,
            push = Array.prototype.push,
            slice = Array.prototype.slice,
            trim = String.prototype.trim,
            indexOf = Array.prototype.indexOf,

            // [[Class]] -> type pairs
            class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: function( selector, context, rootjQuery ) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if ( !selector ) {
                    return this;
                }

                // Handle $(DOMElement)
                if ( selector.nodeType ) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if ( selector === "body" && !context && document.body ) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = selector;
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if ( typeof selector === "string" ) {
                    // Are we dealing with HTML string or an ID?
                    if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [ null, selector, null ];

                    } else {
                        match = quickExpr.exec( selector );
                    }

                    // Verify a match, and that no context was specified for #id
                    if ( match && (match[1] || !context) ) {

                        // HANDLE: $(html) -> $(array)
                        if ( match[1] ) {
                            context = context instanceof jQuery ? context[0] : context;
                            doc = ( context ? context.ownerDocument || context : document );

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec( selector );

                            if ( ret ) {
                                if ( jQuery.isPlainObject( context ) ) {
                                    selector = [ document.createElement( ret[1] ) ];
                                    jQuery.fn.attr.call( selector, context, true );

                                } else {
                                    selector = [ doc.createElement( ret[1] ) ];
                                }

                            } else {
                                ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
                                selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
                            }

                            return jQuery.merge( this, selector );

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById( match[2] );

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if ( elem && elem.parentNode ) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if ( elem.id !== match[2] ) {
                                    return rootjQuery.find( selector );
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if ( !context || context.jquery ) {
                        return ( context || rootjQuery ).find( selector );

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor( context ).find( selector );
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if ( jQuery.isFunction( selector ) ) {
                    return rootjQuery.ready( selector );
                }

                if ( selector.selector !== undefined ) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray( selector, this );
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.7.2",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function() {
                return this.length;
            },

            toArray: function() {
                return slice.call( this, 0 );
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function( num ) {
                return num == null ?

                    // Return a 'clean' array
                    this.toArray() :

                    // Return just the object
                    ( num < 0 ? this[ this.length + num ] : this[ num ] );
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function( elems, name, selector ) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if ( jQuery.isArray( elems ) ) {
                    push.apply( ret, elems );

                } else {
                    jQuery.merge( ret, elems );
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if ( name === "find" ) {
                    ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
                } else if ( name ) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function( callback, args ) {
                return jQuery.each( this, callback, args );
            },

            ready: function( fn ) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.add( fn );

                return this;
            },

            eq: function( i ) {
                i = +i;
                return i === -1 ?
                    this.slice( i ) :
                    this.slice( i, i + 1 );
            },

            first: function() {
                return this.eq( 0 );
            },

            last: function() {
                return this.eq( -1 );
            },

            slice: function() {
                return this.pushStack( slice.apply( this, arguments ),
                    "slice", slice.call(arguments).join(",") );
            },

            map: function( callback ) {
                return this.pushStack( jQuery.map(this, function( elem, i ) {
                    return callback.call( elem, i, elem );
                }));
            },

            end: function() {
                return this.prevObject || this.constructor(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

// Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

            // Handle a deep copy situation
            if ( typeof target === "boolean" ) {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if ( length === i ) {
                target = this;
                --i;
            }

            for ( ; i < length; i++ ) {
                // Only deal with non-null/undefined values
                if ( (options = arguments[ i ]) != null ) {
                    // Extend the base object
                    for ( name in options ) {
                        src = target[ name ];
                        copy = options[ name ];

                        // Prevent never-ending loop
                        if ( target === copy ) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                            if ( copyIsArray ) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[ name ] = jQuery.extend( deep, clone, copy );

                            // Don't bring in undefined values
                        } else if ( copy !== undefined ) {
                            target[ name ] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function( deep ) {
                if ( window.$ === jQuery ) {
                    window.$ = _$;
                }

                if ( deep && window.jQuery === jQuery ) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: function( hold ) {
                if ( hold ) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready( true );
                }
            },

            // Handle when the DOM is ready
            ready: function( wait ) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if ( !document.body ) {
                        return setTimeout( jQuery.ready, 1 );
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if ( wait !== true && --jQuery.readyWait > 0 ) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.fireWith( document, [ jQuery ] );

                    // Trigger any bound ready events
                    if ( jQuery.fn.trigger ) {
                        jQuery( document ).trigger( "ready" ).off( "ready" );
                    }
                }
            },

            bindReady: function() {
                if ( readyList ) {
                    return;
                }

                readyList = jQuery.Callbacks( "once memory" );

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if ( document.readyState === "complete" ) {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout( jQuery.ready, 1 );
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if ( document.addEventListener ) {
                    // Use the handy event callback
                    document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

                    // A fallback to window.onload, that will always work
                    window.addEventListener( "load", jQuery.ready, false );

                    // If IE event model is used
                } else if ( document.attachEvent ) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent( "onreadystatechange", DOMContentLoaded );

                    // A fallback to window.onload, that will always work
                    window.attachEvent( "onload", jQuery.ready );

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch(e) {}

                    if ( document.documentElement.doScroll && toplevel ) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function( obj ) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function( obj ) {
                return jQuery.type(obj) === "array";
            },

            isWindow: function( obj ) {
                return obj != null && obj == obj.window;
            },

            isNumeric: function( obj ) {
                return !isNaN( parseFloat(obj) ) && isFinite( obj );
            },

            type: function( obj ) {
                return obj == null ?
                    String( obj ) :
                    class2type[ toString.call(obj) ] || "object";
            },

            isPlainObject: function( obj ) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                    return false;
                }

                try {
                    // Not own constructor property must be Object
                    if ( obj.constructor &&
                        !hasOwn.call(obj, "constructor") &&
                        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                        return false;
                    }
                } catch ( e ) {
                    // IE8,9 Will throw exceptions on certain host objects #9897
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for ( key in obj ) {}

                return key === undefined || hasOwn.call( obj, key );
            },

            isEmptyObject: function( obj ) {
                for ( var name in obj ) {
                    return false;
                }
                return true;
            },

            error: function( msg ) {
                throw new Error( msg );
            },

            parseJSON: function( data ) {
                if ( typeof data !== "string" || !data ) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim( data );

                // Attempt to parse using the native JSON parser first
                if ( window.JSON && window.JSON.parse ) {
                    return window.JSON.parse( data );
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if ( rvalidchars.test( data.replace( rvalidescape, "@" )
                    .replace( rvalidtokens, "]" )
                    .replace( rvalidbraces, "")) ) {

                    return ( new Function( "return " + data ) )();

                }
                jQuery.error( "Invalid JSON: " + data );
            },

            // Cross-browser xml parsing
            parseXML: function( data ) {
                if ( typeof data !== "string" || !data ) {
                    return null;
                }
                var xml, tmp;
                try {
                    if ( window.DOMParser ) { // Standard
                        tmp = new DOMParser();
                        xml = tmp.parseFromString( data , "text/xml" );
                    } else { // IE
                        xml = new ActiveXObject( "Microsoft.XMLDOM" );
                        xml.async = "false";
                        xml.loadXML( data );
                    }
                } catch( e ) {
                    xml = undefined;
                }
                if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                    jQuery.error( "Invalid XML: " + data );
                }
                return xml;
            },

            noop: function() {},

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: function( data ) {
                if ( data && rnotwhite.test( data ) ) {
                    // We use execScript on Internet Explorer
                    // We use an anonymous function so that context is window
                    // rather than jQuery in Firefox
                    ( window.execScript || function( data ) {
                        window[ "eval" ].call( window, data );
                    } )( data );
                }
            },

            // Convert dashed to camelCase; used by the css and data modules
            // Microsoft forgot to hump their vendor prefix (#9572)
            camelCase: function( string ) {
                return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
            },

            nodeName: function( elem, name ) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function( object, callback, args ) {
                var name, i = 0,
                    length = object.length,
                    isObj = length === undefined || jQuery.isFunction( object );

                if ( args ) {
                    if ( isObj ) {
                        for ( name in object ) {
                            if ( callback.apply( object[ name ], args ) === false ) {
                                break;
                            }
                        }
                    } else {
                        for ( ; i < length; ) {
                            if ( callback.apply( object[ i++ ], args ) === false ) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if ( isObj ) {
                        for ( name in object ) {
                            if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
                                break;
                            }
                        }
                    } else {
                        for ( ; i < length; ) {
                            if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
                                break;
                            }
                        }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
                function( text ) {
                    return text == null ?
                        "" :
                        trim.call( text );
                } :

                // Otherwise use our own trimming functionality
                function( text ) {
                    return text == null ?
                        "" :
                        text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
                },

            // results is for internal usage only
            makeArray: function( array, results ) {
                var ret = results || [];

                if ( array != null ) {
                    // The window, strings (and functions) also have 'length'
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type( array );

                    if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
                        push.call( ret, array );
                    } else {
                        jQuery.merge( ret, array );
                    }
                }

                return ret;
            },

            inArray: function( elem, array, i ) {
                var len;

                if ( array ) {
                    if ( indexOf ) {
                        return indexOf.call( array, elem, i );
                    }

                    len = array.length;
                    i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                    for ( ; i < len; i++ ) {
                        // Skip accessing in sparse arrays
                        if ( i in array && array[ i ] === elem ) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            merge: function( first, second ) {
                var i = first.length,
                    j = 0;

                if ( typeof second.length === "number" ) {
                    for ( var l = second.length; j < l; j++ ) {
                        first[ i++ ] = second[ j ];
                    }

                } else {
                    while ( second[j] !== undefined ) {
                        first[ i++ ] = second[ j++ ];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function( elems, callback, inv ) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for ( var i = 0, length = elems.length; i < length; i++ ) {
                    retVal = !!callback( elems[ i ], i );
                    if ( inv !== retVal ) {
                        ret.push( elems[ i ] );
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function( elems, callback, arg ) {
                var value, key, ret = [],
                    i = 0,
                    length = elems.length,
                    // jquery objects are treated as arrays
                    isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

                // Go through the array, translating each of the items to their
                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback( elems[ i ], i, arg );

                        if ( value != null ) {
                            ret[ ret.length ] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for ( key in elems ) {
                        value = callback( elems[ key ], key, arg );

                        if ( value != null ) {
                            ret[ ret.length ] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return ret.concat.apply( [], ret );
            },

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function( fn, context ) {
                if ( typeof context === "string" ) {
                    var tmp = fn[ context ];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if ( !jQuery.isFunction( fn ) ) {
                    return undefined;
                }

                // Simulated bind
                var args = slice.call( arguments, 2 ),
                    proxy = function() {
                        return fn.apply( context, args.concat( slice.call( arguments ) ) );
                    };

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
                var exec,
                    bulk = key == null,
                    i = 0,
                    length = elems.length;

                // Sets many values
                if ( key && typeof key === "object" ) {
                    for ( i in key ) {
                        jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
                    }
                    chainable = 1;

                    // Sets one value
                } else if ( value !== undefined ) {
                    // Optionally, function values get executed if exec is true
                    exec = pass === undefined && jQuery.isFunction( value );

                    if ( bulk ) {
                        // Bulk operations only iterate when executing function values
                        if ( exec ) {
                            exec = fn;
                            fn = function( elem, key, value ) {
                                return exec.call( jQuery( elem ), value );
                            };

                            // Otherwise they run against the entire set
                        } else {
                            fn.call( elems, value );
                            fn = null;
                        }
                    }

                    if ( fn ) {
                        for (; i < length; i++ ) {
                            fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
                        }
                    }

                    chainable = 1;
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                        fn.call( elems ) :
                        length ? fn( elems[0], key ) : emptyGet;
            },

            now: function() {
                return ( new Date() ).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function( ua ) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec( ua ) ||
                    ropera.exec( ua ) ||
                    rmsie.exec( ua ) ||
                    ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
                    [];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            sub: function() {
                function jQuerySub( selector, context ) {
                    return new jQuerySub.fn.init( selector, context );
                }
                jQuery.extend( true, jQuerySub, this );
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init( selector, context ) {
                    if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
                        context = jQuerySub( context );
                    }

                    return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
            },

            browser: {}
        });

// Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch( userAgent );
        if ( browserMatch.browser ) {
            jQuery.browser[ browserMatch.browser ] = true;
            jQuery.browser.version = browserMatch.version;
        }

// Deprecated, use jQuery.browser.webkit instead
        if ( jQuery.browser.webkit ) {
            jQuery.browser.safari = true;
        }

// IE doesn't match non-breaking spaces with \s
        if ( rnotwhite.test( "\xA0" ) ) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

// All jQuery objects should point back to these
        rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
        if ( document.addEventListener ) {
            DOMContentLoaded = function() {
                document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
                jQuery.ready();
            };

        } else if ( document.attachEvent ) {
            DOMContentLoaded = function() {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if ( document.readyState === "complete" ) {
                    document.detachEvent( "onreadystatechange", DOMContentLoaded );
                    jQuery.ready();
                }
            };
        }

// The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if ( jQuery.isReady ) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch(e) {
                setTimeout( doScrollCheck, 1 );
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        return jQuery;

    })();


// String to Object flags format cache
    var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
    function createFlags( flags ) {
        var object = flagsCache[ flags ] = {},
            i, length;
        flags = flags.split( /\s+/ );
        for ( i = 0, length = flags.length; i < length; i++ ) {
            object[ flags[i] ] = true;
        }
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	flags:	an optional list of space-separated flags that will change how
     *			the callback list behaves
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible flags:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( flags ) {

        // Convert flags from String-formatted to Object-formatted
        // (we check in cache first)
        flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

        var // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = [],
            // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // Flag to know if list is currently firing
            firing,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // Add one or several callbacks to the list
            add = function( args ) {
                var i,
                    length,
                    elem,
                    type,
                    actual;
                for ( i = 0, length = args.length; i < length; i++ ) {
                    elem = args[ i ];
                    type = jQuery.type( elem );
                    if ( type === "array" ) {
                        // Inspect recursively
                        add( elem );
                    } else if ( type === "function" ) {
                        // Add if not in unique mode and callback is not in
                        if ( !flags.unique || !self.has( elem ) ) {
                            list.push( elem );
                        }
                    }
                }
            },
            // Fire callbacks
            fire = function( context, args ) {
                args = args || [];
                memory = !flags.memory || [ context, args ];
                fired = true;
                firing = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                    if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
                        memory = true; // Mark as halted
                        break;
                    }
                }
                firing = false;
                if ( list ) {
                    if ( !flags.once ) {
                        if ( stack && stack.length ) {
                            memory = stack.shift();
                            self.fireWith( memory[ 0 ], memory[ 1 ] );
                        }
                    } else if ( memory === true ) {
                        self.disable();
                    } else {
                        list = [];
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {
                        var length = list.length;
                        add( arguments );
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if ( firing ) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away, unless previous
                            // firing was halted (stopOnFalse)
                        } else if ( memory && memory !== true ) {
                            firingStart = length;
                            fire( memory[ 0 ], memory[ 1 ] );
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if ( list ) {
                        var args = arguments,
                            argIndex = 0,
                            argLength = args.length;
                        for ( ; argIndex < argLength ; argIndex++ ) {
                            for ( var i = 0; i < list.length; i++ ) {
                                if ( args[ argIndex ] === list[ i ] ) {
                                    // Handle firingIndex and firingLength
                                    if ( firing ) {
                                        if ( i <= firingLength ) {
                                            firingLength--;
                                            if ( i <= firingIndex ) {
                                                firingIndex--;
                                            }
                                        }
                                    }
                                    // Remove the element
                                    list.splice( i--, 1 );
                                    // If we have some unicity property then
                                    // we only need to do this once
                                    if ( flags.unique ) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    return this;
                },
                // Control if a given callback is in the list
                has: function( fn ) {
                    if ( list ) {
                        var i = 0,
                            length = list.length;
                        for ( ; i < length; i++ ) {
                            if ( fn === list[ i ] ) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if ( !memory || memory === true ) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( stack ) {
                        if ( firing ) {
                            if ( !flags.once ) {
                                stack.push( [ context, args ] );
                            }
                        } else if ( !( flags.once && memory ) ) {
                            fire( context, args );
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };




    var // Static reference to slice
        sliceDeferred = [].slice;

    jQuery.extend({

        Deferred: function( func ) {
            var doneList = jQuery.Callbacks( "once memory" ),
                failList = jQuery.Callbacks( "once memory" ),
                progressList = jQuery.Callbacks( "memory" ),
                state = "pending",
                lists = {
                    resolve: doneList,
                    reject: failList,
                    notify: progressList
                },
                promise = {
                    done: doneList.add,
                    fail: failList.add,
                    progress: progressList.add,

                    state: function() {
                        return state;
                    },

                    // Deprecated
                    isResolved: doneList.fired,
                    isRejected: failList.fired,

                    then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
                        deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
                        return this;
                    },
                    always: function() {
                        deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
                        return this;
                    },
                    pipe: function( fnDone, fnFail, fnProgress ) {
                        return jQuery.Deferred(function( newDefer ) {
                            jQuery.each( {
                                done: [ fnDone, "resolve" ],
                                fail: [ fnFail, "reject" ],
                                progress: [ fnProgress, "notify" ]
                            }, function( handler, data ) {
                                var fn = data[ 0 ],
                                    action = data[ 1 ],
                                    returned;
                                if ( jQuery.isFunction( fn ) ) {
                                    deferred[ handler ](function() {
                                        returned = fn.apply( this, arguments );
                                        if ( returned && jQuery.isFunction( returned.promise ) ) {
                                            returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
                                        } else {
                                            newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                                        }
                                    });
                                } else {
                                    deferred[ handler ]( newDefer[ action ] );
                                }
                            });
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        if ( obj == null ) {
                            obj = promise;
                        } else {
                            for ( var key in promise ) {
                                obj[ key ] = promise[ key ];
                            }
                        }
                        return obj;
                    }
                },
                deferred = promise.promise({}),
                key;

            for ( key in lists ) {
                deferred[ key ] = lists[ key ].fire;
                deferred[ key + "With" ] = lists[ key ].fireWith;
            }

            // Handle state
            deferred.done( function() {
                state = "resolved";
            }, failList.disable, progressList.lock ).fail( function() {
                    state = "rejected";
                }, doneList.disable, progressList.lock );

            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function( firstParam ) {
            var args = sliceDeferred.call( arguments, 0 ),
                i = 0,
                length = args.length,
                pValues = new Array( length ),
                count = length,
                pCount = length,
                deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
                    firstParam :
                    jQuery.Deferred(),
                promise = deferred.promise();
            function resolveFunc( i ) {
                return function( value ) {
                    args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                    if ( !( --count ) ) {
                        deferred.resolveWith( deferred, args );
                    }
                };
            }
            function progressFunc( i ) {
                return function( value ) {
                    pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                    deferred.notifyWith( promise, pValues );
                };
            }
            if ( length > 1 ) {
                for ( ; i < length; i++ ) {
                    if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
                        args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
                    } else {
                        --count;
                    }
                }
                if ( !count ) {
                    deferred.resolveWith( deferred, args );
                }
            } else if ( deferred !== firstParam ) {
                deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
            }
            return promise;
        }
    });




    jQuery.support = (function() {

        var support,
            all,
            a,
            select,
            opt,
            input,
            fragment,
            tds,
            events,
            eventName,
            i,
            isSupported,
            div = document.createElement( "div" ),
            documentElement = document.documentElement;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        all = div.getElementsByTagName( "*" );
        a = div.getElementsByTagName( "a" )[ 0 ];

        // Can't get basic test support
        if ( !all || !all.length || !a ) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement( "select" );
        opt = select.appendChild( document.createElement("option") );
        input = div.getElementsByTagName( "input" )[ 0 ];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: ( div.firstChild.nodeType === 3 ),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test( a.getAttribute("style") ),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: ( a.getAttribute("href") === "/a" ),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55/.test( a.style.opacity ),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: ( input.value === "on" ),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Tests for enctype support on a form(#6743)
            enctype: !!document.createElement("form").enctype,

            // Makes sure cloning an html5 element does not cause problems
            // Where outerHTML is undefined, this still works
            html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true,
            pixelMargin: true
        };

        // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
        jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode( true ).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }

        if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
            div.attachEvent( "onclick", function() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode( true ).fireEvent( "onclick" );
        }

        // Check if a radio maintains its value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");

        // #11217 - WebKit loses check when the name is after the checked attribute
        input.setAttribute( "name", "t" );

        div.appendChild( input );
        fragment = document.createDocumentFragment();
        fragment.appendChild( div.lastChild );

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        fragment.removeChild( input );
        fragment.appendChild( div );

        // Technique from Juriy Zaytsev
        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if ( div.attachEvent ) {
            for ( i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = ( eventName in div );
                if ( !isSupported ) {
                    div.setAttribute( eventName, "return;" );
                    isSupported = ( typeof div[ eventName ] === "function" );
                }
                support[ i + "Bubbles" ] = isSupported;
            }
        }

        fragment.removeChild( div );

        // Null elements to avoid leaks in IE
        fragment = select = opt = div = input = null;

        // Run tests that need a body at doc ready
        jQuery(function() {
            var container, outer, inner, table, td, offsetSupport,
                marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
                paddingMarginBorderVisibility, paddingMarginBorder,
                body = document.getElementsByTagName("body")[0];

            if ( !body ) {
                // Return for frameset docs that don't have a body
                return;
            }

            conMarginTop = 1;
            paddingMarginBorder = "padding:0;margin:0;border:";
            positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
            paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
            style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
            html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
                "<table " + style + "' cellpadding='0' cellspacing='0'>" +
                "<tr><td></td></tr></table>";

            container = document.createElement("div");
            container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
            body.insertBefore( container, body.firstChild );

            // Construct the test element
            div = document.createElement("div");
            container.appendChild( div );

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName( "td" );
            isSupported = ( tds[ 0 ].offsetHeight === 0 );

            tds[ 0 ].style.display = "";
            tds[ 1 ].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE <= 8 fail this test)
            support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. For more
            // info see bug #3333
            // Fails in WebKit before Feb 2011 nightlies
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            if ( window.getComputedStyle ) {
                div.innerHTML = "";
                marginDiv = document.createElement( "div" );
                marginDiv.style.width = "0";
                marginDiv.style.marginRight = "0";
                div.style.width = "2px";
                div.appendChild( marginDiv );
                support.reliableMarginRight =
                    ( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
            }

            if ( typeof div.style.zoom !== "undefined" ) {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.innerHTML = "";
                div.style.width = div.style.padding = "1px";
                div.style.border = 0;
                div.style.overflow = "hidden";
                div.style.display = "inline";
                div.style.zoom = 1;
                support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div style='width:5px;'></div>";
                support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
            }

            div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
            div.innerHTML = html;

            outer = div.firstChild;
            inner = outer.firstChild;
            td = outer.nextSibling.firstChild.firstChild;

            offsetSupport = {
                doesNotAddBorder: ( inner.offsetTop !== 5 ),
                doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
            };

            inner.style.position = "fixed";
            inner.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
            inner.style.position = inner.style.top = "";

            outer.style.overflow = "hidden";
            outer.style.position = "relative";

            offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
            offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

            if ( window.getComputedStyle ) {
                div.style.marginTop = "1%";
                support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
            }

            if ( typeof container.style.zoom !== "undefined" ) {
                container.style.zoom = 1;
            }

            body.removeChild( container );
            marginDiv = div = container = null;

            jQuery.extend( support, offsetSupport );
        });

        return support;
    })();




    var rbrace = /^(?:\{.*\}|\[.*\])$/,
        rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function( elem ) {
            elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
            return !!elem && !isEmptyDataObject( elem );
        },

        data: function( elem, name, data, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var privateCache, thisCache, ret,
                internalKey = jQuery.expando,
                getByName = typeof name === "string",

                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,

                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,

                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
                isEvents = name === "events";

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
                return;
            }

            if ( !id ) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if ( isNode ) {
                    elem[ internalKey ] = id = ++jQuery.uuid;
                } else {
                    id = internalKey;
                }
            }

            if ( !cache[ id ] ) {
                cache[ id ] = {};

                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if ( !isNode ) {
                    cache[ id ].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if ( typeof name === "object" || typeof name === "function" ) {
                if ( pvt ) {
                    cache[ id ] = jQuery.extend( cache[ id ], name );
                } else {
                    cache[ id ].data = jQuery.extend( cache[ id ].data, name );
                }
            }

            privateCache = thisCache = cache[ id ];

            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            if ( !pvt ) {
                if ( !thisCache.data ) {
                    thisCache.data = {};
                }

                thisCache = thisCache.data;
            }

            if ( data !== undefined ) {
                thisCache[ jQuery.camelCase( name ) ] = data;
            }

            // Users should not attempt to inspect the internal events object using jQuery.data,
            // it is undocumented and subject to change. But does anyone listen? No.
            if ( isEvents && !thisCache[ name ] ) {
                return privateCache.events;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if ( getByName ) {

                // First Try to find as-is property data
                ret = thisCache[ name ];

                // Test for null|undefined property data
                if ( ret == null ) {

                    // Try to find the camelCased property
                    ret = thisCache[ jQuery.camelCase( name ) ];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function( elem, name, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var thisCache, i, l,

                // Reference to internal data cache key
                internalKey = jQuery.expando,

                isNode = elem.nodeType,

                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,

                // See jQuery.data for more information
                id = isNode ? elem[ internalKey ] : internalKey;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if ( !cache[ id ] ) {
                return;
            }

            if ( name ) {

                thisCache = pvt ? cache[ id ] : cache[ id ].data;

                if ( thisCache ) {

                    // Support array or space separated string names for data keys
                    if ( !jQuery.isArray( name ) ) {

                        // try the string as a key before any manipulation
                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {

                            // split the camel cased version by spaces unless a key with the spaces exists
                            name = jQuery.camelCase( name );
                            if ( name in thisCache ) {
                                name = [ name ];
                            } else {
                                name = name.split( " " );
                            }
                        }
                    }

                    for ( i = 0, l = name.length; i < l; i++ ) {
                        delete thisCache[ name[i] ];
                    }

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if ( !pvt ) {
                delete cache[ id ].data;

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if ( !isEmptyDataObject(cache[ id ]) ) {
                    return;
                }
            }

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            // Ensure that `cache` is not a window object #10080
            if ( jQuery.support.deleteExpando || !cache.setInterval ) {
                delete cache[ id ];
            } else {
                cache[ id ] = null;
            }

            // We destroyed the cache and need to eliminate the expando on the node to avoid
            // false lookups in the cache for entries that no longer exist
            if ( isNode ) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if ( jQuery.support.deleteExpando ) {
                    delete elem[ internalKey ];
                } else if ( elem.removeAttribute ) {
                    elem.removeAttribute( internalKey );
                } else {
                    elem[ internalKey ] = null;
                }
            }
        },

        // For internal use only.
        _data: function( elem, name, data ) {
            return jQuery.data( elem, name, data, true );
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function( elem ) {
            if ( elem.nodeName ) {
                var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

                if ( match ) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function( key, value ) {
            var parts, part, attr, name, l,
                elem = this[0],
                i = 0,
                data = null;

            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = jQuery.data( elem );

                    if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                        attr = elem.attributes;
                        for ( l = attr.length; i < l; i++ ) {
                            name = attr[i].name;

                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = jQuery.camelCase( name.substring(5) );

                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                        jQuery._data( elem, "parsedAttrs", true );
                    }
                }

                return data;
            }

            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each(function() {
                    jQuery.data( this, key );
                });
            }

            parts = key.split( ".", 2 );
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";

            return jQuery.access( this, function( value ) {

                if ( value === undefined ) {
                    data = this.triggerHandler( "getData" + part, [ parts[0] ] );

                    // Try to fetch any internally stored data first
                    if ( data === undefined && elem ) {
                        data = jQuery.data( elem, key );
                        data = dataAttr( elem, key, data );
                    }

                    return data === undefined && parts[1] ?
                        this.data( parts[0] ) :
                        data;
                }

                parts[1] = value;
                this.each(function() {
                    var self = jQuery( this );

                    self.triggerHandler( "setData" + part, parts );
                    jQuery.data( this, key, value );
                    self.triggerHandler( "changeData" + part, parts );
                });
            }, null, value, arguments.length > 1, null, false );
        },

        removeData: function( key ) {
            return this.each(function() {
                jQuery.removeData( this, key );
            });
        }
    });

    function dataAttr( elem, key, data ) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {

            var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                            data === "null" ? null :
                                jQuery.isNumeric( data ) ? +data :
                                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                        data;
                } catch( e ) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data( elem, key, data );

            } else {
                data = undefined;
            }
        }

        return data;
    }

// checks a cache object for emptiness
    function isEmptyDataObject( obj ) {
        for ( var name in obj ) {

            // if the public data object is empty, the private is still empty
            if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
                continue;
            }
            if ( name !== "toJSON" ) {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer( elem, type, src ) {
        var deferDataKey = type + "defer",
            queueDataKey = type + "queue",
            markDataKey = type + "mark",
            defer = jQuery._data( elem, deferDataKey );
        if ( defer &&
            ( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
            ( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout( function() {
                if ( !jQuery._data( elem, queueDataKey ) &&
                    !jQuery._data( elem, markDataKey ) ) {
                    jQuery.removeData( elem, deferDataKey, true );
                    defer.fire();
                }
            }, 0 );
        }
    }

    jQuery.extend({

        _mark: function( elem, type ) {
            if ( elem ) {
                type = ( type || "fx" ) + "mark";
                jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
            }
        },

        _unmark: function( force, elem, type ) {
            if ( force !== true ) {
                type = elem;
                elem = force;
                force = false;
            }
            if ( elem ) {
                type = type || "fx";
                var key = type + "mark",
                    count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
                if ( count ) {
                    jQuery._data( elem, key, count );
                } else {
                    jQuery.removeData( elem, key, true );
                    handleQueueMarkDefer( elem, type, "mark" );
                }
            }
        },

        queue: function( elem, type, data ) {
            var q;
            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                q = jQuery._data( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !q || jQuery.isArray(data) ) {
                        q = jQuery._data( elem, type, jQuery.makeArray(data) );
                    } else {
                        q.push( data );
                    }
                }
                return q || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                fn = queue.shift(),
                hooks = {};

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
            }

            if ( fn ) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }

                jQuery._data( elem, type + ".run", hooks );
                fn.call( elem, function() {
                    jQuery.dequeue( elem, type );
                }, hooks );
            }

            if ( !queue.length ) {
                jQuery.removeData( elem, type + "queue " + type + ".run", true );
                handleQueueMarkDefer( elem, type, "queue" );
            }
        }
    });

    jQuery.fn.extend({
        queue: function( type, data ) {
            var setter = 2;

            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }

            if ( arguments.length < setter ) {
                return jQuery.queue( this[0], type );
            }

            return data === undefined ?
                this :
                this.each(function() {
                    var queue = jQuery.queue( this, type, data );

                    if ( type === "fx" && queue[0] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                });
        },
        dequeue: function( type ) {
            return this.each(function() {
                jQuery.dequeue( this, type );
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function( time, type ) {
            time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
            type = type || "fx";

            return this.queue( type, function( next, hooks ) {
                var timeout = setTimeout( next, time );
                hooks.stop = function() {
                    clearTimeout( timeout );
                };
            });
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, object ) {
            if ( typeof type !== "string" ) {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
                elements = this,
                i = elements.length,
                count = 1,
                deferDataKey = type + "defer",
                queueDataKey = type + "queue",
                markDataKey = type + "mark",
                tmp;
            function resolve() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            }
            while( i-- ) {
                if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
                    ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
                        jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
                        jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
                    count++;
                    tmp.add( resolve );
                }
            }
            resolve();
            return defer.promise( object );
        }
    });




    var rclass = /[\n\t\r]/g,
        rspace = /\s+/,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        getSetAttribute = jQuery.support.getSetAttribute,
        nodeHook, boolHook, fixSpecified;

    jQuery.fn.extend({
        attr: function( name, value ) {
            return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
            return this.each(function() {
                jQuery.removeAttr( this, name );
            });
        },

        prop: function( name, value ) {
            return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
            name = jQuery.propFix[ name ] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[ name ] = undefined;
                    delete this[ name ];
                } catch( e ) {}
            });
        },

        addClass: function( value ) {
            var classNames, i, l, elem,
                setClass, c, cl;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).addClass( value.call(this, j, this.className) );
                });
            }

            if ( value && typeof value === "string" ) {
                classNames = value.split( rspace );

                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];

                    if ( elem.nodeType === 1 ) {
                        if ( !elem.className && classNames.length === 1 ) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
                                    setClass += classNames[ c ] + " ";
                                }
                            }
                            elem.className = jQuery.trim( setClass );
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classNames, i, l, elem, className, c, cl;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).removeClass( value.call(this, j, this.className) );
                });
            }

            if ( (value && typeof value === "string") || value === undefined ) {
                classNames = ( value || "" ).split( rspace );

                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];

                    if ( elem.nodeType === 1 && elem.className ) {
                        if ( value ) {
                            className = (" " + elem.className + " ").replace( rclass, " " );
                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                className = className.replace(" " + classNames[ c ] + " ", " ");
                            }
                            elem.className = jQuery.trim( className );

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value,
                isBool = typeof stateVal === "boolean";

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
            }

            return this.each(function() {
                if ( type === "string" ) {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery( this ),
                        state = stateVal,
                        classNames = value.split( rspace );

                    while ( (className = classNames[ i++ ]) ) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass( className );
                        self[ state ? "addClass" : "removeClass" ]( className );
                    }

                } else if ( type === "undefined" || type === "boolean" ) {
                    if ( this.className ) {
                        // store className if set
                        jQuery._data( this, "__className__", this.className );
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                }
            });
        },

        hasClass: function( selector ) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for ( ; i < l; i++ ) {
                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
                    return true;
                }
            }

            return false;
        },

        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[0];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction( value );

            return this.each(function( i ) {
                var self = jQuery(this), val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( isFunction ) {
                    val = value.call( this, i, self.val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";
                } else if ( typeof val === "number" ) {
                    val += "";
                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map(val, function ( value ) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function( elem ) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function( elem ) {
                    var value, i, max, option,
                        index = elem.selectedIndex,
                        values = [],
                        options = elem.options,
                        one = elem.type === "select-one";

                    // Nothing was selected
                    if ( index < 0 ) {
                        return null;
                    }

                    // Loop through all the selected options
                    i = one ? index : 0;
                    max = one ? index + 1 : options.length;
                    for ( ; i < max; i++ ) {
                        option = options[ i ];

                        // Don't return options that are disabled or in a disabled optgroup
                        if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                            (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if ( one && !values.length && options.length ) {
                        return jQuery( options[ index ] ).val();
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var values = jQuery.makeArray( value );

                    jQuery(elem).find("option").each(function() {
                        this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
                    });

                    if ( !values.length ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attr: function( elem, name, value, pass ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            if ( pass && name in jQuery.attrFn ) {
                return jQuery( elem )[ name ]( value );
            }

            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === "undefined" ) {
                return jQuery.prop( elem, name, value );
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( notxml ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
            }

            if ( value !== undefined ) {

                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return;

                } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    elem.setAttribute( name, "" + value );
                    return value;
                }

            } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
                return ret;

            } else {

                ret = elem.getAttribute( name );

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function( elem, value ) {
            var propName, attrNames, name, l, isBool,
                i = 0;

            if ( value && elem.nodeType === 1 ) {
                attrNames = value.toLowerCase().split( rspace );
                l = attrNames.length;

                for ( ; i < l; i++ ) {
                    name = attrNames[ i ];

                    if ( name ) {
                        propName = jQuery.propFix[ name ] || name;
                        isBool = rboolean.test( name );

                        // See #9699 for explanation of this approach (setting first, then removal)
                        // Do not do this for boolean attributes (see #10870)
                        if ( !isBool ) {
                            jQuery.attr( elem, name, "" );
                        }
                        elem.removeAttribute( getSetAttribute ? name : propName );

                        // Set corresponding property to false for boolean attributes
                        if ( isBool && propName in elem ) {
                            elem[ propName ] = false;
                        }
                    }
                }
            }
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
                        jQuery.error( "type property can't be changed" );
                    } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function( elem, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.get( elem, name );
                    }
                    return name in elem ?
                        elem.value :
                        null;
                },
                set: function( elem, value, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.set( elem, value, name );
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function( elem, name, value ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    return ( elem[ name ] = value );
                }

            } else {
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                    return ret;

                } else {
                    return elem[ name ];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");

                    return attributeNode && attributeNode.specified ?
                        parseInt( attributeNode.value, 10 ) :
                        rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            undefined;
                }
            }
        }
    });

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
    jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
    boolHook = {
        get: function( elem, name ) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode,
                property = jQuery.prop( elem, name );
            return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
                name.toLowerCase() :
                undefined;
        },
        set: function( elem, value, name ) {
            var propName;
            if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[ name ] || name;
                if ( propName in elem ) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[ propName ] = true;
                }

                elem.setAttribute( name, name.toLowerCase() );
            }
            return name;
        }
    };

// IE6/7 do not support getting/setting some attributes with get/setAttribute
    if ( !getSetAttribute ) {

        fixSpecified = {
            name: true,
            id: true,
            coords: true
        };

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function( elem, name ) {
                var ret;
                ret = elem.getAttributeNode( name );
                return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
                    ret.nodeValue :
                    undefined;
            },
            set: function( elem, value, name ) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode( name );
                if ( !ret ) {
                    ret = document.createAttribute( name );
                    elem.setAttributeNode( ret );
                }
                return ( ret.nodeValue = value + "" );
            }
        };

        // Apply the nodeHook to tabindex
        jQuery.attrHooks.tabindex.set = nodeHook.set;

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each([ "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                set: function( elem, value ) {
                    if ( value === "" ) {
                        elem.setAttribute( name, "auto" );
                        return value;
                    }
                }
            });
        });

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function( elem, value, name ) {
                if ( value === "" ) {
                    value = "false";
                }
                nodeHook.set( elem, value, name );
            }
        };
    }


// Some attributes require a special call on IE
    if ( !jQuery.support.hrefNormalized ) {
        jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                get: function( elem ) {
                    var ret = elem.getAttribute( name, 2 );
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if ( !jQuery.support.style ) {
        jQuery.attrHooks.style = {
            get: function( elem ) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function( elem, value ) {
                return ( elem.style.cssText = "" + value );
            }
        };
    }

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
    if ( !jQuery.support.optSelected ) {
        jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
            get: function( elem ) {
                var parent = elem.parentNode;

                if ( parent ) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }

// IE6/7 call enctype encoding
    if ( !jQuery.support.enctype ) {
        jQuery.propFix.enctype = "encoding";
    }

// Radios and checkboxes getter/setter
    if ( !jQuery.support.checkOn ) {
        jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[ this ] = {
                get: function( elem ) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                }
            }
        });
    });




    var rformElems = /^(?:textarea|input|select)$/i,
        rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
        rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
        quickParse = function( selector ) {
            var quick = rquickIs.exec( selector );
            if ( quick ) {
                //   0  1    2   3
                // [ _, tag, id, class ]
                quick[1] = ( quick[1] || "" ).toLowerCase();
                quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
            }
            return quick;
        },
        quickIs = function( elem, m ) {
            var attrs = elem.attributes || {};
            return (
                (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
                    (!m[2] || (attrs.id || {}).value === m[2]) &&
                    (!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
                );
        },
        hoverHack = function( events ) {
            return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
        };

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

        add: function( elem, types, handler, data, selector ) {

            var elemData, eventHandle, events,
                t, tns, type, namespaces, handleObj,
                handleObjIn, quick, handlers, special;

            // Don't attach events to noData or text/comment nodes (allow plain objects tho)
            if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            events = elemData.events;
            if ( !events ) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if ( !eventHandle ) {
                elemData.handle = eventHandle = function( e ) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                        jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                        undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = jQuery.trim( hoverHack(types) ).split( " " );
            for ( t = 0; t < types.length; t++ ) {

                tns = rtypenamespace.exec( types[t] ) || [];
                type = tns[1];
                namespaces = ( tns[2] || "" ).split( "." ).sort();

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    quick: selector && quickParse( selector ),
                    namespace: namespaces.join(".")
                }, handleObjIn );

                // Init the event handler queue if we're the first
                handlers = events[ type ];
                if ( !handlers ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                        // Bind the global event handler to the element
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle, false );

                        } else if ( elem.attachEvent ) {
                            elem.attachEvent( "on" + type, eventHandle );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {

            var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
                t, tns, type, origType, namespaces, origCount,
                j, events, special, handle, eventType, handleObj;

            if ( !elemData || !(events = elemData.events) ) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
            for ( t = 0; t < types.length; t++ ) {
                tns = rtypenamespace.exec( types[t] ) || [];
                type = origType = tns[1];
                namespaces = tns[2];

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector? special.delegateType : special.bindType ) || type;
                eventType = events[ type ] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

                // Remove matching events
                for ( j = 0; j < eventType.length; j++ ) {
                    handleObj = eventType[ j ];

                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
                        ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                        eventType.splice( j--, 1 );

                        if ( handleObj.selector ) {
                            eventType.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( eventType.length === 0 && origCount !== eventType.length ) {
                    if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    delete events[ type ];
                }
            }

            // Remove the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                handle = elemData.handle;
                if ( handle ) {
                    handle.elem = null;
                }

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData( elem, [ "events", "handle" ], true );
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function( event, data, elem, onlyHandlers ) {
            // Don't do events on text and comment nodes
            if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
                return;
            }

            // Event object or event type
            var type = event.type || event,
                namespaces = [],
                cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }

            if ( type.indexOf( "!" ) >= 0 ) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if ( type.indexOf( "." ) >= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
                // jQuery.Event object
                event[ jQuery.expando ] ? event :
                    // Object literal
                    new jQuery.Event( type, event ) :
                // Just the event type (string)
                new jQuery.Event( type );

            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join( "." );
            event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
            ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

            // Handle a global trigger
            if ( !elem ) {

                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for ( i in cache ) {
                    if ( cache[ i ].events && cache[ i ].events[ type ] ) {
                        jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
                    }
                }
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray( data ) : [];
            data.unshift( event );

            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            eventPath = [[ elem, special.bindType || type ]];
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
                old = null;
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push([ cur, bubbleType ]);
                    old = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( old && old === elem.ownerDocument ) {
                    eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
                }
            }

            // Fire handlers on the event path
            for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

                cur = eventPath[i][0];
                event.type = eventPath[i][1];

                handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ ontype ];
                if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
                    event.preventDefault();
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
                    !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    // IE<9 dies on focus/blur to hidden element (#1486)
                    if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        old = elem[ ontype ];

                        if ( old ) {
                            elem[ ontype ] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[ type ]();
                        jQuery.event.triggered = undefined;

                        if ( old ) {
                            elem[ ontype ] = old;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function( event ) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event || window.event );

            var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
                delegateCount = handlers.delegateCount,
                args = [].slice.call( arguments, 0 ),
                run_all = !event.exclusive && !event.namespace,
                special = jQuery.event.special[ event.type ] || {},
                handlerQueue = [],
                i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }

            // Determine handlers that should run if there are delegated events
            // Avoid non-left-click bubbling in Firefox (#3861)
            if ( delegateCount && !(event.button && event.type === "click") ) {

                // Pregenerate a single jQuery object for reuse with .is()
                jqcur = jQuery(this);
                jqcur.context = this.ownerDocument || this;

                for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

                    // Don't process events on disabled elements (#6911, #8165)
                    if ( cur.disabled !== true ) {
                        selMatch = {};
                        matches = [];
                        jqcur[0] = cur;
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];
                            sel = handleObj.selector;

                            if ( selMatch[ sel ] === undefined ) {
                                selMatch[ sel ] = (
                                    handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
                                    );
                            }
                            if ( selMatch[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push({ elem: cur, matches: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if ( handlers.length > delegateCount ) {
                handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
            }

            // Run delegates first; they may want to stop propagation beneath us
            for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
                matched = handlerQueue[ i ];
                event.currentTarget = matched.elem;

                for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
                    handleObj = matched.matches[ j ];

                    // Triggered event must either 1) be non-exclusive and have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                        if ( ret !== undefined ) {
                            event.result = ret;
                            if ( ret === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }

            return event.result;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function( event, original ) {

                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function( event, original ) {
                var eventDoc, doc, body,
                    button = original.button,
                    fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }

                // Add relatedTarget, if necessary
                if ( !event.relatedTarget && fromElement ) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }

                return event;
            }
        },

        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop,
                originalEvent = event,
                fixHook = jQuery.event.fixHooks[ event.type ] || {},
                copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

            event = jQuery.Event( originalEvent );

            for ( i = copy.length; i; ) {
                prop = copy[ --i ];
                event[ prop ] = originalEvent[ prop ];
            }

            // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
            if ( !event.target ) {
                event.target = originalEvent.srcElement || document;
            }

            // Target should not be a text node (#504, Safari)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }

            // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
            if ( event.metaKey === undefined ) {
                event.metaKey = event.ctrlKey;
            }

            return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
        },

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady
            },

            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },

            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },

            beforeunload: {
                setup: function( data, namespaces, eventHandle ) {
                    // We only want to do this special case on windows
                    if ( jQuery.isWindow( this ) ) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function( namespaces, eventHandle ) {
                    if ( this.onbeforeunload === eventHandle ) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },

        simulate: function( type, elem, event, bubble ) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                { type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if ( bubble ) {
                jQuery.event.trigger( e, null, elem );
            } else {
                jQuery.event.dispatch.call( elem, e );
            }
            if ( e.isDefaultPrevented() ) {
                event.preventDefault();
            }
        }
    };

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;

    jQuery.removeEvent = document.removeEventListener ?
        function( elem, type, handle ) {
            if ( elem.removeEventListener ) {
                elem.removeEventListener( type, handle, false );
            }
        } :
        function( elem, type, handle ) {
            if ( elem.detachEvent ) {
                elem.detachEvent( "on" + type, handle );
            }
        };

    jQuery.Event = function( src, props ) {
        // Allow instantiation without the 'new' keyword
        if ( !(this instanceof jQuery.Event) ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
                src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if ( !e ) {
                return;
            }

            // if preventDefault exists run it on the original event
            if ( e.preventDefault ) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if ( !e ) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if ( e.stopPropagation ) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

// Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,

            handle: function( event ) {
                var target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj,
                    selector = handleObj.selector,
                    ret;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    });

// IE submit delegation
    if ( !jQuery.support.submitBubbles ) {

        jQuery.event.special.submit = {
            setup: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
                        form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                    if ( form && !form._submit_attached ) {
                        jQuery.event.add( form, "submit._submit", function( event ) {
                            event._submit_bubble = true;
                        });
                        form._submit_attached = true;
                    }
                });
                // return undefined since we don't need an event listener
            },

            postDispatch: function( event ) {
                // If form was submitted by the user, bubble the event up the tree
                if ( event._submit_bubble ) {
                    delete event._submit_bubble;
                    if ( this.parentNode && !event.isTrigger ) {
                        jQuery.event.simulate( "submit", this.parentNode, event, true );
                    }
                }
            },

            teardown: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove( this, "._submit" );
            }
        };
    }

// IE change delegation and checkbox/radio fix
    if ( !jQuery.support.changeBubbles ) {

        jQuery.event.special.change = {

            setup: function() {

                if ( rformElems.test( this.nodeName ) ) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if ( this.type === "checkbox" || this.type === "radio" ) {
                        jQuery.event.add( this, "propertychange._change", function( event ) {
                            if ( event.originalEvent.propertyName === "checked" ) {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add( this, "click._change", function( event ) {
                            if ( this._just_changed && !event.isTrigger ) {
                                this._just_changed = false;
                                jQuery.event.simulate( "change", this, event, true );
                            }
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add( this, "beforeactivate._change", function( e ) {
                    var elem = e.target;

                    if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
                        jQuery.event.add( elem, "change._change", function( event ) {
                            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                jQuery.event.simulate( "change", this.parentNode, event, true );
                            }
                        });
                        elem._change_attached = true;
                    }
                });
            },

            handle: function( event ) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                    return event.handleObj.handler.apply( this, arguments );
                }
            },

            teardown: function() {
                jQuery.event.remove( this, "._change" );

                return rformElems.test( this.nodeName );
            }
        };
    }

// Create "bubbling" focus and blur events
    if ( !jQuery.support.focusinBubbles ) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0,
                handler = function( event ) {
                    jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                };

            jQuery.event.special[ fix ] = {
                setup: function() {
                    if ( attaches++ === 0 ) {
                        document.addEventListener( orig, handler, true );
                    }
                },
                teardown: function() {
                    if ( --attaches === 0 ) {
                        document.removeEventListener( orig, handler, true );
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
            var origFn, type;

            // Types can be a map of types/handlers
            if ( typeof types === "object" ) {
                // ( types-Object, selector, data )
                if ( typeof selector !== "string" ) { // && selector != null
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for ( type in types ) {
                    this.on( type, selector, data, types[ type ], one );
                }
                return this;
            }

            if ( data == null && fn == null ) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if ( fn == null ) {
                if ( typeof selector === "string" ) {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if ( fn === false ) {
                fn = returnFalse;
            } else if ( !fn ) {
                return this;
            }

            if ( one === 1 ) {
                origFn = fn;
                fn = function( event ) {
                    // Can use an empty set, since event contains the info
                    jQuery().off( event );
                    return origFn.apply( this, arguments );
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
            }
            return this.each( function() {
                jQuery.event.add( this, types, fn, data, selector );
            });
        },
        one: function( types, selector, data, fn ) {
            return this.on( types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            if ( types && types.preventDefault && types.handleObj ) {
                // ( event )  dispatched jQuery.Event
                var handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {
                // ( types-object [, selector] )
                for ( var type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove( this, types, fn, selector );
            });
        },

        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },

        live: function( types, data, fn ) {
            jQuery( this.context ).on( types, this.selector, data, fn );
            return this;
        },
        die: function( types, fn ) {
            jQuery( this.context ).off( types, this.selector || "**", fn );
            return this;
        },

        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
        },

        trigger: function( type, data ) {
            return this.each(function() {
                jQuery.event.trigger( type, data, this );
            });
        },
        triggerHandler: function( type, data ) {
            if ( this[0] ) {
                return jQuery.event.trigger( type, data, this[0], true );
            }
        },

        toggle: function( fn ) {
            // Save reference to arguments for access in closure
            var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function( event ) {
                    // Figure out which function to execute
                    var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
                    jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

                    // Make sure that clicks stop
                    event.preventDefault();

                    // and execute the function
                    return args[ lastToggle ].apply( this, arguments ) || false;
                };

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while ( i < args.length ) {
                args[ i++ ].guid = guid;
            }

            return this.click( toggler );
        },

        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    });

    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            if ( fn == null ) {
                fn = data;
                data = null;
            }

            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };

        if ( jQuery.attrFn ) {
            jQuery.attrFn[ name ] = true;
        }

        if ( rkeyEvent.test( name ) ) {
            jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
        }

        if ( rmouseEvent.test( name ) ) {
            jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
        }
    });



    /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function(){

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
            expando = "sizcache" + (Math.random() + '').replace('.', ''),
            done = 0,
            toString = Object.prototype.toString,
            hasDuplicate = false,
            baseHasDuplicate = true,
            rBackslash = /\\/g,
            rReturn = /\r\n/g,
            rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
        [0, 0].sort(function() {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function( selector, context, results, seed ) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
                return [];
            }

            if ( !selector || typeof selector !== "string" ) {
                return results;
            }

            var m, set, checkSet, extra, ret, cur, pop, i,
                prune = true,
                contextXML = Sizzle.isXML( context ),
                parts = [],
                soFar = selector;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec( "" );
                m = chunker.exec( soFar );

                if ( m ) {
                    soFar = m[3];

                    parts.push( m[1] );

                    if ( m[2] ) {
                        extra = m[3];
                        break;
                    }
                }
            } while ( m );

            if ( parts.length > 1 && origPOS.exec( selector ) ) {

                if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
                    set = posProcess( parts[0] + parts[1], context, seed );

                } else {
                    set = Expr.relative[ parts[0] ] ?
                        [ context ] :
                        Sizzle( parts.shift(), context );

                    while ( parts.length ) {
                        selector = parts.shift();

                        if ( Expr.relative[ selector ] ) {
                            selector += parts.shift();
                        }

                        set = posProcess( selector, set, seed );
                    }
                }

            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                    Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

                    ret = Sizzle.find( parts.shift(), context, contextXML );
                    context = ret.expr ?
                        Sizzle.filter( ret.expr, ret.set )[0] :
                        ret.set[0];
                }

                if ( context ) {
                    ret = seed ?
                    { expr: parts.pop(), set: makeArray(seed) } :
                        Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

                    set = ret.expr ?
                        Sizzle.filter( ret.expr, ret.set ) :
                        ret.set;

                    if ( parts.length > 0 ) {
                        checkSet = makeArray( set );

                    } else {
                        prune = false;
                    }

                    while ( parts.length ) {
                        cur = parts.pop();
                        pop = cur;

                        if ( !Expr.relative[ cur ] ) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if ( pop == null ) {
                            pop = context;
                        }

                        Expr.relative[ cur ]( checkSet, pop, contextXML );
                    }

                } else {
                    checkSet = parts = [];
                }
            }

            if ( !checkSet ) {
                checkSet = set;
            }

            if ( !checkSet ) {
                Sizzle.error( cur || selector );
            }

            if ( toString.call(checkSet) === "[object Array]" ) {
                if ( !prune ) {
                    results.push.apply( results, checkSet );

                } else if ( context && context.nodeType === 1 ) {
                    for ( i = 0; checkSet[i] != null; i++ ) {
                        if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
                            results.push( set[i] );
                        }
                    }

                } else {
                    for ( i = 0; checkSet[i] != null; i++ ) {
                        if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
                            results.push( set[i] );
                        }
                    }
                }

            } else {
                makeArray( checkSet, results );
            }

            if ( extra ) {
                Sizzle( extra, origContext, results, seed );
                Sizzle.uniqueSort( results );
            }

            return results;
        };

        Sizzle.uniqueSort = function( results ) {
            if ( sortOrder ) {
                hasDuplicate = baseHasDuplicate;
                results.sort( sortOrder );

                if ( hasDuplicate ) {
                    for ( var i = 1; i < results.length; i++ ) {
                        if ( results[i] === results[ i - 1 ] ) {
                            results.splice( i--, 1 );
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function( expr, set ) {
            return Sizzle( expr, null, null, set );
        };

        Sizzle.matchesSelector = function( node, expr ) {
            return Sizzle( expr, null, null, [node] ).length > 0;
        };

        Sizzle.find = function( expr, context, isXML ) {
            var set, i, len, match, type, left;

            if ( !expr ) {
                return [];
            }

            for ( i = 0, len = Expr.order.length; i < len; i++ ) {
                type = Expr.order[i];

                if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
                    left = match[1];
                    match.splice( 1, 1 );

                    if ( left.substr( left.length - 1 ) !== "\\" ) {
                        match[1] = (match[1] || "").replace( rBackslash, "" );
                        set = Expr.find[ type ]( match, context, isXML );

                        if ( set != null ) {
                            expr = expr.replace( Expr.match[ type ], "" );
                            break;
                        }
                    }
                }
            }

            if ( !set ) {
                set = typeof context.getElementsByTagName !== "undefined" ?
                    context.getElementsByTagName( "*" ) :
                    [];
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function( expr, set, inplace, not ) {
            var match, anyFound,
                type, found, item, filter, left,
                i, pass,
                old = expr,
                result = [],
                curLoop = set,
                isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

            while ( expr && set.length ) {
                for ( type in Expr.filter ) {
                    if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
                        filter = Expr.filter[ type ];
                        left = match[1];

                        anyFound = false;

                        match.splice(1,1);

                        if ( left.substr( left.length - 1 ) === "\\" ) {
                            continue;
                        }

                        if ( curLoop === result ) {
                            result = [];
                        }

                        if ( Expr.preFilter[ type ] ) {
                            match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

                            if ( !match ) {
                                anyFound = found = true;

                            } else if ( match === true ) {
                                continue;
                            }
                        }

                        if ( match ) {
                            for ( i = 0; (item = curLoop[i]) != null; i++ ) {
                                if ( item ) {
                                    found = filter( item, match, i, curLoop );
                                    pass = not ^ found;

                                    if ( inplace && found != null ) {
                                        if ( pass ) {
                                            anyFound = true;

                                        } else {
                                            curLoop[i] = false;
                                        }

                                    } else if ( pass ) {
                                        result.push( item );
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if ( found !== undefined ) {
                            if ( !inplace ) {
                                curLoop = result;
                            }

                            expr = expr.replace( Expr.match[ type ], "" );

                            if ( !anyFound ) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if ( expr === old ) {
                    if ( anyFound == null ) {
                        Sizzle.error( expr );

                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function( msg ) {
            throw new Error( "Syntax error, unrecognized expression: " + msg );
        };

        /**
         * Utility function for retreiving the text value of an array of DOM nodes
         * @param {Array|Element} elem
         */
        var getText = Sizzle.getText = function( elem ) {
            var i, node,
                nodeType = elem.nodeType,
                ret = "";

            if ( nodeType ) {
                if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                    // Use textContent || innerText for elements
                    if ( typeof elem.textContent === 'string' ) {
                        return elem.textContent;
                    } else if ( typeof elem.innerText === 'string' ) {
                        // Replace IE's carriage returns
                        return elem.innerText.replace( rReturn, '' );
                    } else {
                        // Traverse it's children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText( elem );
                        }
                    }
                } else if ( nodeType === 3 || nodeType === 4 ) {
                    return elem.nodeValue;
                }
            } else {

                // If no nodeType, this is expected to be an array
                for ( i = 0; (node = elem[i]); i++ ) {
                    // Do not traverse comment nodes
                    if ( node.nodeType !== 8 ) {
                        ret += getText( node );
                    }
                }
            }
            return ret;
        };

        var Expr = Sizzle.selectors = {
            order: [ "ID", "NAME", "TAG" ],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function( elem ) {
                    return elem.getAttribute( "href" );
                },
                type: function( elem ) {
                    return elem.getAttribute( "type" );
                }
            },

            relative: {
                "+": function(checkSet, part){
                    var isPartStr = typeof part === "string",
                        isTag = isPartStr && !rNonWord.test( part ),
                        isPartStrNotTag = isPartStr && !isTag;

                    if ( isTag ) {
                        part = part.toLowerCase();
                    }

                    for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
                        if ( (elem = checkSet[i]) ) {
                            while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                                elem || false :
                                elem === part;
                        }
                    }

                    if ( isPartStrNotTag ) {
                        Sizzle.filter( part, checkSet, true );
                    }
                },

                ">": function( checkSet, part ) {
                    var elem,
                        isPartStr = typeof part === "string",
                        i = 0,
                        l = checkSet.length;

                    if ( isPartStr && !rNonWord.test( part ) ) {
                        part = part.toLowerCase();

                        for ( ; i < l; i++ ) {
                            elem = checkSet[i];

                            if ( elem ) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }

                    } else {
                        for ( ; i < l; i++ ) {
                            elem = checkSet[i];

                            if ( elem ) {
                                checkSet[i] = isPartStr ?
                                    elem.parentNode :
                                    elem.parentNode === part;
                            }
                        }

                        if ( isPartStr ) {
                            Sizzle.filter( part, checkSet, true );
                        }
                    }
                },

                "": function(checkSet, part, isXML){
                    var nodeCheck,
                        doneName = done++,
                        checkFn = dirCheck;

                    if ( typeof part === "string" && !rNonWord.test( part ) ) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
                },

                "~": function( checkSet, part, isXML ) {
                    var nodeCheck,
                        doneName = done++,
                        checkFn = dirCheck;

                    if ( typeof part === "string" && !rNonWord.test( part ) ) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
                }
            },

            find: {
                ID: function( match, context, isXML ) {
                    if ( typeof context.getElementById !== "undefined" && !isXML ) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },

                NAME: function( match, context ) {
                    if ( typeof context.getElementsByName !== "undefined" ) {
                        var ret = [],
                            results = context.getElementsByName( match[1] );

                        for ( var i = 0, l = results.length; i < l; i++ ) {
                            if ( results[i].getAttribute("name") === match[1] ) {
                                ret.push( results[i] );
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },

                TAG: function( match, context ) {
                    if ( typeof context.getElementsByTagName !== "undefined" ) {
                        return context.getElementsByTagName( match[1] );
                    }
                }
            },
            preFilter: {
                CLASS: function( match, curLoop, inplace, result, not, isXML ) {
                    match = " " + match[1].replace( rBackslash, "" ) + " ";

                    if ( isXML ) {
                        return match;
                    }

                    for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
                        if ( elem ) {
                            if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
                                if ( !inplace ) {
                                    result.push( elem );
                                }

                            } else if ( inplace ) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },

                ID: function( match ) {
                    return match[1].replace( rBackslash, "" );
                },

                TAG: function( match, curLoop ) {
                    return match[1].replace( rBackslash, "" ).toLowerCase();
                },

                CHILD: function( match ) {
                    if ( match[1] === "nth" ) {
                        if ( !match[2] ) {
                            Sizzle.error( match[0] );
                        }

                        match[2] = match[2].replace(/^\+|\s*/g, '');

                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
                            match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                                !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }
                    else if ( match[2] ) {
                        Sizzle.error( match[0] );
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },

                ATTR: function( match, curLoop, inplace, result, not, isXML ) {
                    var name = match[1] = match[1].replace( rBackslash, "" );

                    if ( !isXML && Expr.attrMap[name] ) {
                        match[1] = Expr.attrMap[name];
                    }

                    // Handle if an un-quoted value was used
                    match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

                    if ( match[2] === "~=" ) {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },

                PSEUDO: function( match, curLoop, inplace, result, not ) {
                    if ( match[1] === "not" ) {
                        // If we're dealing with a complex expression, or a simple one
                        if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
                            match[3] = Sizzle(match[3], null, null, curLoop);

                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                            if ( !inplace ) {
                                result.push.apply( result, ret );
                            }

                            return false;
                        }

                    } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
                        return true;
                    }

                    return match;
                },

                POS: function( match ) {
                    match.unshift( true );

                    return match;
                }
            },

            filters: {
                enabled: function( elem ) {
                    return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function( elem ) {
                    return elem.disabled === true;
                },

                checked: function( elem ) {
                    return elem.checked === true;
                },

                selected: function( elem ) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if ( elem.parentNode ) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                parent: function( elem ) {
                    return !!elem.firstChild;
                },

                empty: function( elem ) {
                    return !elem.firstChild;
                },

                has: function( elem, i, match ) {
                    return !!Sizzle( match[3], elem ).length;
                },

                header: function( elem ) {
                    return (/h\d/i).test( elem.nodeName );
                },

                text: function( elem ) {
                    var attr = elem.getAttribute( "type" ), type = elem.type;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
                },

                radio: function( elem ) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function( elem ) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function( elem ) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function( elem ) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function( elem ) {
                    return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && "button" === elem.type || name === "button";
                },

                input: function( elem ) {
                    return (/input|select|textarea|button/i).test( elem.nodeName );
                },

                focus: function( elem ) {
                    return elem === elem.ownerDocument.activeElement;
                }
            },
            setFilters: {
                first: function( elem, i ) {
                    return i === 0;
                },

                last: function( elem, i, match, array ) {
                    return i === array.length - 1;
                },

                even: function( elem, i ) {
                    return i % 2 === 0;
                },

                odd: function( elem, i ) {
                    return i % 2 === 1;
                },

                lt: function( elem, i, match ) {
                    return i < match[3] - 0;
                },

                gt: function( elem, i, match ) {
                    return i > match[3] - 0;
                },

                nth: function( elem, i, match ) {
                    return match[3] - 0 === i;
                },

                eq: function( elem, i, match ) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function( elem, match, i, array ) {
                    var name = match[1],
                        filter = Expr.filters[ name ];

                    if ( filter ) {
                        return filter( elem, i, match, array );

                    } else if ( name === "contains" ) {
                        return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

                    } else if ( name === "not" ) {
                        var not = match[3];

                        for ( var j = 0, l = not.length; j < l; j++ ) {
                            if ( not[j] === elem ) {
                                return false;
                            }
                        }

                        return true;

                    } else {
                        Sizzle.error( name );
                    }
                },

                CHILD: function( elem, match ) {
                    var first, last,
                        doneName, parent, cache,
                        count, diff,
                        type = match[1],
                        node = elem;

                    switch ( type ) {
                        case "only":
                        case "first":
                            while ( (node = node.previousSibling) ) {
                                if ( node.nodeType === 1 ) {
                                    return false;
                                }
                            }

                            if ( type === "first" ) {
                                return true;
                            }

                            node = elem;

                        /* falls through */
                        case "last":
                            while ( (node = node.nextSibling) ) {
                                if ( node.nodeType === 1 ) {
                                    return false;
                                }
                            }

                            return true;

                        case "nth":
                            first = match[2];
                            last = match[3];

                            if ( first === 1 && last === 0 ) {
                                return true;
                            }

                            doneName = match[0];
                            parent = elem.parentNode;

                            if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
                                count = 0;

                                for ( node = parent.firstChild; node; node = node.nextSibling ) {
                                    if ( node.nodeType === 1 ) {
                                        node.nodeIndex = ++count;
                                    }
                                }

                                parent[ expando ] = doneName;
                            }

                            diff = elem.nodeIndex - last;

                            if ( first === 0 ) {
                                return diff === 0;

                            } else {
                                return ( diff % first === 0 && diff / first >= 0 );
                            }
                    }
                },

                ID: function( elem, match ) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function( elem, match ) {
                    return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
                },

                CLASS: function( elem, match ) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
                        .indexOf( match ) > -1;
                },

                ATTR: function( elem, match ) {
                    var name = match[1],
                        result = Sizzle.attr ?
                            Sizzle.attr( elem, name ) :
                            Expr.attrHandle[ name ] ?
                                Expr.attrHandle[ name ]( elem ) :
                                elem[ name ] != null ?
                                    elem[ name ] :
                                    elem.getAttribute( name ),
                        value = result + "",
                        type = match[2],
                        check = match[4];

                    return result == null ?
                        type === "!=" :
                        !type && Sizzle.attr ?
                            result != null :
                            type === "=" ?
                                value === check :
                                type === "*=" ?
                                    value.indexOf(check) >= 0 :
                                    type === "~=" ?
                                        (" " + value + " ").indexOf(check) >= 0 :
                                        !check ?
                                            value && result !== false :
                                            type === "!=" ?
                                                value !== check :
                                                type === "^=" ?
                                                    value.indexOf(check) === 0 :
                                                    type === "$=" ?
                                                        value.substr(value.length - check.length) === check :
                                                        type === "|=" ?
                                                            value === check || value.substr(0, check.length + 1) === check + "-" :
                                                            false;
                },

                POS: function( elem, match, i, array ) {
                    var name = match[2],
                        filter = Expr.setFilters[ name ];

                    if ( filter ) {
                        return filter( elem, i, match, array );
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
            fescape = function(all, num){
                return "\\" + (num - 0 + 1);
            };

        for ( var type in Expr.match ) {
            Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
            Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
        }
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
        Expr.match.globalPOS = origPOS;

        var makeArray = function( array, results ) {
            array = Array.prototype.slice.call( array, 0 );

            if ( results ) {
                results.push.apply( results, array );
                return results;
            }

            return array;
        };

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
        } catch( e ) {
            makeArray = function( array, results ) {
                var i = 0,
                    ret = results || [];

                if ( toString.call(array) === "[object Array]" ) {
                    Array.prototype.push.apply( ret, array );

                } else {
                    if ( typeof array.length === "number" ) {
                        for ( var l = array.length; i < l; i++ ) {
                            ret.push( array[i] );
                        }

                    } else {
                        for ( ; array[i]; i++ ) {
                            ret.push( array[i] );
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if ( document.documentElement.compareDocumentPosition ) {
            sortOrder = function( a, b ) {
                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;
                }

                if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };

        } else {
            sortOrder = function( a, b ) {
                // The nodes are identical, we can exit early
                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if ( a.sourceIndex && b.sourceIndex ) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
                    ap = [],
                    bp = [],
                    aup = a.parentNode,
                    bup = b.parentNode,
                    cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if ( aup === bup ) {
                    return siblingCheck( a, b );

                    // If no parents were found then the nodes are disconnected
                } else if ( !aup ) {
                    return -1;

                } else if ( !bup ) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while ( cur ) {
                    ap.unshift( cur );
                    cur = cur.parentNode;
                }

                cur = bup;

                while ( cur ) {
                    bp.unshift( cur );
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for ( var i = 0; i < al && i < bl; i++ ) {
                    if ( ap[i] !== bp[i] ) {
                        return siblingCheck( ap[i], bp[i] );
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
                    siblingCheck( a, bp[i], -1 ) :
                    siblingCheck( ap[i], b, 1 );
            };

            siblingCheck = function( a, b, ret ) {
                if ( a === b ) {
                    return ret;
                }

                var cur = a.nextSibling;

                while ( cur ) {
                    if ( cur === b ) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
        (function(){
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
                id = "script" + (new Date()).getTime(),
                root = document.documentElement;

            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            root.insertBefore( form, root.firstChild );

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if ( document.getElementById( id ) ) {
                Expr.find.ID = function( match, context, isXML ) {
                    if ( typeof context.getElementById !== "undefined" && !isXML ) {
                        var m = context.getElementById(match[1]);

                        return m ?
                            m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
                                [m] :
                                undefined :
                            [];
                    }
                };

                Expr.filter.ID = function( elem, match ) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild( form );

            // release memory in IE
            root = form = null;
        })();

        (function(){
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild( document.createComment("") );

            // Make sure no comments are found
            if ( div.getElementsByTagName("*").length > 0 ) {
                Expr.find.TAG = function( match, context ) {
                    var results = context.getElementsByTagName( match[1] );

                    // Filter out possible comments
                    if ( match[1] === "*" ) {
                        var tmp = [];

                        for ( var i = 0; results[i]; i++ ) {
                            if ( results[i].nodeType === 1 ) {
                                tmp.push( results[i] );
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";

            if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#" ) {

                Expr.attrHandle.href = function( elem ) {
                    return elem.getAttribute( "href", 2 );
                };
            }

            // release memory in IE
            div = null;
        })();

        if ( document.querySelectorAll ) {
            (function(){
                var oldSizzle = Sizzle,
                    div = document.createElement("div"),
                    id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
                    return;
                }

                Sizzle = function( query, context, extra, seed ) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if ( !seed && !Sizzle.isXML(context) ) {
                        // See if we find a selector to speed up
                        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

                        if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
                            // Speed-up: Sizzle("TAG")
                            if ( match[1] ) {
                                return makeArray( context.getElementsByTagName( query ), extra );

                                // Speed-up: Sizzle(".CLASS")
                            } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
                                return makeArray( context.getElementsByClassName( match[2] ), extra );
                            }
                        }

                        if ( context.nodeType === 9 ) {
                            // Speed-up: Sizzle("body")
                            // The body element only exists once, optimize finding it
                            if ( query === "body" && context.body ) {
                                return makeArray( [ context.body ], extra );

                                // Speed-up: Sizzle("#ID")
                            } else if ( match && match[3] ) {
                                var elem = context.getElementById( match[3] );

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if ( elem && elem.parentNode ) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if ( elem.id === match[3] ) {
                                        return makeArray( [ elem ], extra );
                                    }

                                } else {
                                    return makeArray( [], extra );
                                }
                            }

                            try {
                                return makeArray( context.querySelectorAll(query), extra );
                            } catch(qsaError) {}

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                            var oldContext = context,
                                old = context.getAttribute( "id" ),
                                nid = old || id,
                                hasParent = context.parentNode,
                                relativeHierarchySelector = /^\s*[+~]/.test( query );

                            if ( !old ) {
                                context.setAttribute( "id", nid );
                            } else {
                                nid = nid.replace( /'/g, "\\$&" );
                            }
                            if ( relativeHierarchySelector && hasParent ) {
                                context = context.parentNode;
                            }

                            try {
                                if ( !relativeHierarchySelector || hasParent ) {
                                    return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
                                }

                            } catch(pseudoError) {
                            } finally {
                                if ( !old ) {
                                    oldContext.removeAttribute( "id" );
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for ( var prop in oldSizzle ) {
                    Sizzle[ prop ] = oldSizzle[ prop ];
                }

                // release memory in IE
                div = null;
            })();
        }

        (function(){
            var html = document.documentElement,
                matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

            if ( matches ) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
                    pseudoWorks = false;

                try {
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call( document.documentElement, "[test!='']:sizzle" );

                } catch( pseudoError ) {
                    pseudoWorks = true;
                }

                Sizzle.matchesSelector = function( node, expr ) {
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                    if ( !Sizzle.isXML( node ) ) {
                        try {
                            if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
                                var ret = matches.call( node, expr );

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if ( ret || !disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9, so check for that
                                    node.document && node.document.nodeType !== 11 ) {
                                    return ret;
                                }
                            }
                        } catch(e) {}
                    }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function(){
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if ( div.getElementsByClassName("e").length === 1 ) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function( match, context, isXML ) {
                if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            // release memory in IE
            div = null;
        })();

        function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
            for ( var i = 0, l = checkSet.length; i < l; i++ ) {
                var elem = checkSet[i];

                if ( elem ) {
                    var match = false;

                    elem = elem[dir];

                    while ( elem ) {
                        if ( elem[ expando ] === doneName ) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if ( elem.nodeType === 1 && !isXML ){
                            elem[ expando ] = doneName;
                            elem.sizset = i;
                        }

                        if ( elem.nodeName.toLowerCase() === cur ) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
            for ( var i = 0, l = checkSet.length; i < l; i++ ) {
                var elem = checkSet[i];

                if ( elem ) {
                    var match = false;

                    elem = elem[dir];

                    while ( elem ) {
                        if ( elem[ expando ] === doneName ) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if ( elem.nodeType === 1 ) {
                            if ( !isXML ) {
                                elem[ expando ] = doneName;
                                elem.sizset = i;
                            }

                            if ( typeof cur !== "string" ) {
                                if ( elem === cur ) {
                                    match = true;
                                    break;
                                }

                            } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        if ( document.documentElement.contains ) {
            Sizzle.contains = function( a, b ) {
                return a !== b && (a.contains ? a.contains(b) : true);
            };

        } else if ( document.documentElement.compareDocumentPosition ) {
            Sizzle.contains = function( a, b ) {
                return !!(a.compareDocumentPosition(b) & 16);
            };

        } else {
            Sizzle.contains = function() {
                return false;
            };
        }

        Sizzle.isXML = function( elem ) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function( selector, context, seed ) {
            var match,
                tmpSet = [],
                later = "",
                root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
                later += match[0];
                selector = selector.replace( Expr.match.PSEUDO, "" );
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for ( var i = 0, l = root.length; i < l; i++ ) {
                Sizzle( selector, root[i], tmpSet, seed );
            }

            return Sizzle.filter( later, tmpSet );
        };

// EXPOSE
// Override sizzle attribute retrieval
        Sizzle.attr = jQuery.attr;
        Sizzle.selectors.attrMap = {};
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.globalPOS,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        find: function( selector ) {
            var self = this,
                i, l;

            if ( typeof selector !== "string" ) {
                return jQuery( selector ).filter(function() {
                    for ( i = 0, l = self.length; i < l; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack( "", "find", selector ),
                length, n, r;

            for ( i = 0, l = this.length; i < l; i++ ) {
                length = ret.length;
                jQuery.find( selector, this[i], ret );

                if ( i > 0 ) {
                    // Make sure that the results are unique
                    for ( n = length; n < ret.length; n++ ) {
                        for ( r = 0; r < length; r++ ) {
                            if ( ret[r] === ret[n] ) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function( target ) {
            var targets = jQuery( target );
            return this.filter(function() {
                for ( var i = 0, l = targets.length; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[i] ) ) {
                        return true;
                    }
                }
            });
        },

        not: function( selector ) {
            return this.pushStack( winnow(this, selector, false), "not", selector);
        },

        filter: function( selector ) {
            return this.pushStack( winnow(this, selector, true), "filter", selector );
        },

        is: function( selector ) {
            return !!selector && (
                typeof selector === "string" ?
                    // If this is a positional selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    POS.test( selector ) ?
                        jQuery( selector, this.context ).index( this[0] ) >= 0 :
                        jQuery.filter( selector, this ).length > 0 :
                    this.filter( selector ).length > 0 );
        },

        closest: function( selectors, context ) {
            var ret = [], i, l, cur = this[0];

            // Array (deprecated as of jQuery 1.7)
            if ( jQuery.isArray( selectors ) ) {
                var level = 1;

                while ( cur && cur.ownerDocument && cur !== context ) {
                    for ( i = 0; i < selectors.length; i++ ) {

                        if ( jQuery( cur ).is( selectors[ i ] ) ) {
                            ret.push({ selector: selectors[ i ], elem: cur, level: level });
                        }
                    }

                    cur = cur.parentNode;
                    level++;
                }

                return ret;
            }

            // String
            var pos = POS.test( selectors ) || typeof selectors !== "string" ?
                jQuery( selectors, context || this.context ) :
                0;

            for ( i = 0, l = this.length; i < l; i++ ) {
                cur = this[i];

                while ( cur ) {
                    if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
                        ret.push( cur );
                        break;

                    } else {
                        cur = cur.parentNode;
                        if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

            return this.pushStack( ret, "closest", selectors );
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
            }

            // index in selector
            if ( typeof elem === "string" ) {
                return jQuery.inArray( this[0], jQuery( elem ) );
            }

            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this );
        },

        add: function( selector, context ) {
            var set = typeof selector === "string" ?
                jQuery( selector, context ) :
                jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
                all = jQuery.merge( this.get(), set );

            return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
                all :
                jQuery.unique( all ) );
        },

        andSelf: function() {
            return this.add( this.prevObject );
        }
    });

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
    function isDisconnected( node ) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return jQuery.dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return jQuery.nth( elem, 2, "nextSibling" );
        },
        prev: function( elem ) {
            return jQuery.nth( elem, 2, "previousSibling" );
        },
        nextAll: function( elem ) {
            return jQuery.dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return jQuery.dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return jQuery.sibling( elem.firstChild );
        },
        contents: function( elem ) {
            return jQuery.nodeName( elem, "iframe" ) ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray( elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var ret = jQuery.map( this, fn, until );

            if ( !runtil.test( name ) ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                ret = jQuery.filter( selector, ret );
            }

            ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

            if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }

            return this.pushStack( ret, name, slice.call( arguments ).join(",") );
        };
    });

    jQuery.extend({
        filter: function( expr, elems, not ) {
            if ( not ) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
                jQuery.find.matches(expr, elems);
        },

        dir: function( elem, dir, until ) {
            var matched = [],
                cur = elem[ dir ];

            while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                if ( cur.nodeType === 1 ) {
                    matched.push( cur );
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function( cur, result, dir, elem ) {
            result = result || 1;
            var num = 0;

            for ( ; cur; cur = cur[dir] ) {
                if ( cur.nodeType === 1 && ++num === result ) {
                    break;
                }
            }

            return cur;
        },

        sibling: function( n, elem ) {
            var r = [];

            for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 && n !== elem ) {
                    r.push( n );
                }
            }

            return r;
        }
    });

// Implement the identical functionality for filter and not
    function winnow( elements, qualifier, keep ) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep(elements, function( elem, i ) {
                var retVal = !!qualifier.call( elem, i, elem );
                return retVal === keep;
            });

        } else if ( qualifier.nodeType ) {
            return jQuery.grep(elements, function( elem, i ) {
                return ( elem === qualifier ) === keep;
            });

        } else if ( typeof qualifier === "string" ) {
            var filtered = jQuery.grep(elements, function( elem ) {
                return elem.nodeType === 1;
            });

            if ( isSimple.test( qualifier ) ) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter( qualifier, filtered );
            }
        }

        return jQuery.grep(elements, function( elem, i ) {
            return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
        });
    }




    function createSafeFragment( document ) {
        var list = nodeNames.split( "|" ),
            safeFrag = document.createDocumentFragment();

        if ( safeFrag.createElement ) {
            while ( list.length ) {
                safeFrag.createElement(
                    list.pop()
                );
            }
        }
        return safeFrag;
    }

    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style)/i,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
        wrapMap = {
            option: [ 1, "<select multiple='multiple'>", "</select>" ],
            legend: [ 1, "<fieldset>", "</fieldset>" ],
            thead: [ 1, "<table>", "</table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
            area: [ 1, "<map>", "</map>" ],
            _default: [ 0, "", "" ]
        },
        safeFragment = createSafeFragment( document );

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
    if ( !jQuery.support.htmlSerialize ) {
        wrapMap._default = [ 1, "div<div>", "</div>" ];
    }

    jQuery.fn.extend({
        text: function( value ) {
            return jQuery.access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
            }, null, value, arguments.length );
        },

        wrapAll: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapAll( html.call(this, i) );
                });
            }

            if ( this[0] ) {
                // The elements to wrap the target around
                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                if ( this[0].parentNode ) {
                    wrap.insertBefore( this[0] );
                }

                wrap.map(function() {
                    var elem = this;

                    while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapInner( html.call(this, i) );
                });
            }

            return this.each(function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            });
        },

        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );

            return this.each(function(i) {
                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            }).end();
        },

        append: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.appendChild( elem );
                }
            });
        },

        prepend: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.insertBefore( elem, this.firstChild );
                }
            });
        },

        before: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this );
                });
            } else if ( arguments.length ) {
                var set = jQuery.clean( arguments );
                set.push.apply( set, this.toArray() );
                return this.pushStack( set, "before", arguments );
            }
        },

        after: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                });
            } else if ( arguments.length ) {
                var set = this.pushStack( this, "after", arguments );
                set.push.apply( set, jQuery.clean(arguments) );
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function( selector, keepData ) {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
                    if ( !keepData && elem.nodeType === 1 ) {
                        jQuery.cleanData( elem.getElementsByTagName("*") );
                        jQuery.cleanData( [ elem ] );
                    }

                    if ( elem.parentNode ) {
                        elem.parentNode.removeChild( elem );
                    }
                }
            }

            return this;
        },

        empty: function() {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                // Remove element nodes and prevent memory leaks
                if ( elem.nodeType === 1 ) {
                    jQuery.cleanData( elem.getElementsByTagName("*") );
                }

                // Remove any remaining nodes
                while ( elem.firstChild ) {
                    elem.removeChild( elem.firstChild );
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map( function () {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            });
        },

        html: function( value ) {
            return jQuery.access( this, function( value ) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if ( value === undefined ) {
                    return elem.nodeType === 1 ?
                        elem.innerHTML.replace( rinlinejQuery, "" ) :
                        null;
                }


                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                    !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

                    value = value.replace( rxhtmlTag, "<$1></$2>" );

                    try {
                        for (; i < l; i++ ) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( elem.getElementsByTagName( "*" ) );
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch(e) {}
                }

                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },

        replaceWith: function( value ) {
            if ( this[0] && this[0].parentNode ) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if ( jQuery.isFunction( value ) ) {
                    return this.each(function(i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith( value.call( this, i, old ) );
                    });
                }

                if ( typeof value !== "string" ) {
                    value = jQuery( value ).detach();
                }

                return this.each(function() {
                    var next = this.nextSibling,
                        parent = this.parentNode;

                    jQuery( this ).remove();

                    if ( next ) {
                        jQuery(next).before( value );
                    } else {
                        jQuery(parent).append( value );
                    }
                });
            } else {
                return this.length ?
                    this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
                    this;
            }
        },

        detach: function( selector ) {
            return this.remove( selector, true );
        },

        domManip: function( args, table, callback ) {
            var results, first, fragment, parent,
                value = args[0],
                scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
                return this.each(function() {
                    jQuery(this).domManip( args, table, callback, true );
                });
            }

            if ( jQuery.isFunction(value) ) {
                return this.each(function(i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip( args, table, callback );
                });
            }

            if ( this[0] ) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment( args, this, scripts );
                }

                fragment = results.fragment;

                if ( fragment.childNodes.length === 1 ) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if ( first ) {
                    table = table && jQuery.nodeName( first, "tr" );

                    for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
                        callback.call(
                            table ?
                                root(this[i], first) :
                                this[i],
                            // Make sure that we do not leak memory by inadvertently discarding
                            // the original fragment (which might have attached data) instead of
                            // using it; in addition, use the original fragment object for the last
                            // item instead of first because it can end up being emptied incorrectly
                            // in certain situations (Bug #8070).
                            // Fragments from the fragment cache must always be cloned and never used
                            // in place.
                            results.cacheable || ( l > 1 && i < lastIndex ) ?
                                jQuery.clone( fragment, true, true ) :
                                fragment
                        );
                    }
                }

                if ( scripts.length ) {
                    jQuery.each( scripts, function( i, elem ) {
                        if ( elem.src ) {
                            jQuery.ajax({
                                type: "GET",
                                global: false,
                                url: elem.src,
                                async: false,
                                dataType: "script"
                            });
                        } else {
                            jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
                        }

                        if ( elem.parentNode ) {
                            elem.parentNode.removeChild( elem );
                        }
                    });
                }
            }

            return this;
        }
    });

    function root( elem, cur ) {
        return jQuery.nodeName(elem, "table") ?
            (elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
            elem;
    }

    function cloneCopyEvent( src, dest ) {

        if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
            return;
        }

        var type, i, l,
            oldData = jQuery._data( src ),
            curData = jQuery._data( dest, oldData ),
            events = oldData.events;

        if ( events ) {
            delete curData.handle;
            curData.events = {};

            for ( type in events ) {
                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                    jQuery.event.add( dest, type, events[ type ][ i ] );
                }
            }
        }

        // make the cloned public data object a copy from the original
        if ( curData.data ) {
            curData.data = jQuery.extend( {}, curData.data );
        }
    }

    function cloneFixAttributes( src, dest ) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if ( dest.nodeType !== 1 ) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if ( dest.clearAttributes ) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if ( dest.mergeAttributes ) {
            dest.mergeAttributes( src );
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if ( nodeName === "object" ) {
            dest.outerHTML = src.outerHTML;

        } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if ( src.checked ) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if ( dest.value !== src.value ) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if ( nodeName === "option" ) {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;

            // IE blanks contents when cloning scripts
        } else if ( nodeName === "script" && dest.text !== src.text ) {
            dest.text = src.text;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute( jQuery.expando );

        // Clear flags for bubbling special change/submit events, they must
        // be reattached when the newly cloned events are first activated
        dest.removeAttribute( "_submit_attached" );
        dest.removeAttribute( "_change_attached" );
    }

    jQuery.buildFragment = function( args, nodes, scripts ) {
        var fragment, cacheable, cacheresults, doc,
            first = args[ 0 ];

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if ( nodes && nodes[0] ) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if ( !doc.createDocumentFragment ) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
        if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
            first.charAt(0) === "<" && !rnocache.test( first ) &&
            (jQuery.support.checkClone || !rchecked.test( first )) &&
            (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

            cacheable = true;

            cacheresults = jQuery.fragments[ first ];
            if ( cacheresults && cacheresults !== 1 ) {
                fragment = cacheresults;
            }
        }

        if ( !fragment ) {
            fragment = doc.createDocumentFragment();
            jQuery.clean( args, doc, fragment, scripts );
        }

        if ( cacheable ) {
            jQuery.fragments[ first ] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var ret = [],
                insert = jQuery( selector ),
                parent = this.length === 1 && this[0].parentNode;

            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
                insert[ original ]( this[0] );
                return this;

            } else {
                for ( var i = 0, l = insert.length; i < l; i++ ) {
                    var elems = ( i > 0 ? this.clone(true) : this ).get();
                    jQuery( insert[i] )[ original ]( elems );
                    ret = ret.concat( elems );
                }

                return this.pushStack( ret, name, insert.selector );
            }
        };
    });

    function getAll( elem ) {
        if ( typeof elem.getElementsByTagName !== "undefined" ) {
            return elem.getElementsByTagName( "*" );

        } else if ( typeof elem.querySelectorAll !== "undefined" ) {
            return elem.querySelectorAll( "*" );

        } else {
            return [];
        }
    }

// Used in clean, fixes the defaultChecked property
    function fixDefaultChecked( elem ) {
        if ( elem.type === "checkbox" || elem.type === "radio" ) {
            elem.defaultChecked = elem.checked;
        }
    }
// Finds all inputs and passes them to fixDefaultChecked
    function findInputs( elem ) {
        var nodeName = ( elem.nodeName || "" ).toLowerCase();
        if ( nodeName === "input" ) {
            fixDefaultChecked( elem );
            // Skip scripts, get other children
        } else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
            jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
        }
    }

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
    function shimCloneNode( elem ) {
        var div = document.createElement( "div" );
        safeFragment.appendChild( div );

        div.innerHTML = elem.outerHTML;
        return div.firstChild;
    }

    jQuery.extend({
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var srcElements,
                destElements,
                i,
                // IE<=8 does not properly clone detached, unknown element nodes
                clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
                    elem.cloneNode( true ) :
                    shimCloneNode( elem );

            if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes( elem, clone );

                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll( elem );
                destElements = getAll( clone );

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for ( i = 0; srcElements[i]; ++i ) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if ( destElements[i] ) {
                        cloneFixAttributes( srcElements[i], destElements[i] );
                    }
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                cloneCopyEvent( elem, clone );

                if ( deepDataAndEvents ) {
                    srcElements = getAll( elem );
                    destElements = getAll( clone );

                    for ( i = 0; srcElements[i]; ++i ) {
                        cloneCopyEvent( srcElements[i], destElements[i] );
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function( elems, context, fragment, scripts ) {
            var checkScriptType, script, j,
                ret = [];

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if ( typeof context.createElement === "undefined" ) {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( typeof elem === "number" ) {
                    elem += "";
                }

                if ( !elem ) {
                    continue;
                }

                // Convert html string into DOM nodes
                if ( typeof elem === "string" ) {
                    if ( !rhtml.test( elem ) ) {
                        elem = context.createTextNode( elem );
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
                            wrap = wrapMap[ tag ] || wrapMap._default,
                            depth = wrap[0],
                            div = context.createElement("div"),
                            safeChildNodes = safeFragment.childNodes,
                            remove;

                        // Append wrapper element to unknown element safe doc fragment
                        if ( context === document ) {
                            // Use the fragment we've already created for this document
                            safeFragment.appendChild( div );
                        } else {
                            // Use a fragment created with the owner document
                            createSafeFragment( context ).appendChild( div );
                        }

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while ( depth-- ) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if ( !jQuery.support.tbody ) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
                                tbody = tag === "table" && !hasBody ?
                                    div.firstChild && div.firstChild.childNodes :

                                    // String was a bare <thead> or <tfoot>
                                    wrap[1] === "<table>" && !hasBody ?
                                        div.childNodes :
                                        [];

                            for ( j = tbody.length - 1; j >= 0 ; --j ) {
                                if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                                    tbody[ j ].parentNode.removeChild( tbody[ j ] );
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
                        }

                        elem = div.childNodes;

                        // Clear elements from DocumentFragment (safeFragment or otherwise)
                        // to avoid hoarding elements. Fixes #11356
                        if ( div ) {
                            div.parentNode.removeChild( div );

                            // Guard against -1 index exceptions in FF3.6
                            if ( safeChildNodes.length > 0 ) {
                                remove = safeChildNodes[ safeChildNodes.length - 1 ];

                                if ( remove && remove.parentNode ) {
                                    remove.parentNode.removeChild( remove );
                                }
                            }
                        }
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if ( !jQuery.support.appendChecked ) {
                    if ( elem[0] && typeof (len = elem.length) === "number" ) {
                        for ( j = 0; j < len; j++ ) {
                            findInputs( elem[j] );
                        }
                    } else {
                        findInputs( elem );
                    }
                }

                if ( elem.nodeType ) {
                    ret.push( elem );
                } else {
                    ret = jQuery.merge( ret, elem );
                }
            }

            if ( fragment ) {
                checkScriptType = function( elem ) {
                    return !elem.type || rscriptType.test( elem.type );
                };
                for ( i = 0; ret[i]; i++ ) {
                    script = ret[i];
                    if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
                        scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

                    } else {
                        if ( script.nodeType === 1 ) {
                            var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

                            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
                        }
                        fragment.appendChild( script );
                    }
                }
            }

            return ret;
        },

        cleanData: function( elems ) {
            var data, id,
                cache = jQuery.cache,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
                    continue;
                }

                id = elem[ jQuery.expando ];

                if ( id ) {
                    data = cache[ id ];

                    if ( data && data.events ) {
                        for ( var type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if ( data.handle ) {
                            data.handle.elem = null;
                        }
                    }

                    if ( deleteExpando ) {
                        delete elem[ jQuery.expando ];

                    } else if ( elem.removeAttribute ) {
                        elem.removeAttribute( jQuery.expando );
                    }

                    delete cache[ id ];
                }
            }
        }
    });




    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        // fixed for IE9, see #8346
        rupper = /([A-Z]|^ms)/g,
        rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
        rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
        rrelNum = /^([\-+])=([\-+.\de]+)/,
        rmargin = /^margin/,

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },

        // order is important!
        cssExpand = [ "Top", "Right", "Bottom", "Left" ],

        curCSS,

        getComputedStyle,
        currentStyle;

    jQuery.fn.css = function( name, value ) {
        return jQuery.access( this, function( elem, name, value ) {
            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase( name ),
                style = elem.style, hooks = jQuery.cssHooks[ origName ];

            name = jQuery.cssProps[ origName ] || origName;

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                    value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if ( value == null || type === "number" && isNaN( value ) ) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[ name ] = value;
                    } catch(e) {}
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra ) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase( name );
            hooks = jQuery.cssHooks[ name ];
            name = jQuery.cssProps[ name ] || name;

            // cssFloat needs a special treatment
            if ( name === "cssFloat" ) {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if ( curCSS ) {
                return curCSS( elem, name );
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function( elem, options, callback ) {
            var old = {},
                ret, name;

            // Remember the old values, and insert the new ones
            for ( name in options ) {
                old[ name ] = elem.style[ name ];
                elem.style[ name ] = options[ name ];
            }

            ret = callback.call( elem );

            // Revert the old values
            for ( name in options ) {
                elem.style[ name ] = old[ name ];
            }

            return ret;
        }
    });

// DEPRECATED in 1.3, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    if ( document.defaultView && document.defaultView.getComputedStyle ) {
        getComputedStyle = function( elem, name ) {
            var ret, defaultView, computedStyle, width,
                style = elem.style;

            name = name.replace( rupper, "-$1" ).toLowerCase();

            if ( (defaultView = elem.ownerDocument.defaultView) &&
                (computedStyle = defaultView.getComputedStyle( elem, null )) ) {

                ret = computedStyle.getPropertyValue( name );
                if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                    ret = jQuery.style( elem, name );
                }
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
            // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
                width = style.width;
                style.width = ret;
                ret = computedStyle.width;
                style.width = width;
            }

            return ret;
        };
    }

    if ( document.documentElement.currentStyle ) {
        currentStyle = function( elem, name ) {
            var left, rsLeft, uncomputed,
                ret = elem.currentStyle && elem.currentStyle[ name ],
                style = elem.style;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if ( ret == null && style && (uncomputed = style[ name ]) ) {
                ret = uncomputed;
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if ( rnumnonpx.test( ret ) ) {

                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                if ( rsLeft ) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if ( rsLeft ) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWidthOrHeight( elem, name, extra ) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            i = name === "width" ? 1 : 0,
            len = 4;

        if ( val > 0 ) {
            if ( extra !== "border" ) {
                for ( ; i < len; i += 2 ) {
                    if ( !extra ) {
                        val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
                    }
                    if ( extra === "margin" ) {
                        val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
                    } else {
                        val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
                    }
                }
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;

        // Add padding, border, margin
        if ( extra ) {
            for ( ; i < len; i += 2 ) {
                val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
                if ( extra !== "padding" ) {
                    val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
                }
                if ( extra === "margin" ) {
                    val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
                }
            }
        }

        return val + "px";
    }

    jQuery.each([ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {
                    if ( elem.offsetWidth !== 0 ) {
                        return getWidthOrHeight( elem, name, extra );
                    } else {
                        return jQuery.swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, name, extra );
                        });
                    }
                }
            },

            set: function( elem, value ) {
                return rnum.test( value ) ?
                    value + "px" :
                    value;
            }
        };
    });

    if ( !jQuery.support.opacity ) {
        jQuery.cssHooks.opacity = {
            get: function( elem, computed ) {
                // IE uses filters for opacity
                return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                    ( parseFloat( RegExp.$1 ) / 100 ) + "" :
                    computed ? "1" : "";
            },

            set: function( elem, value ) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute( "filter" );

                    // if there there is no filter style applied in a css rule, we are done
                    if ( currentStyle && !currentStyle.filter ) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test( filter ) ?
                    filter.replace( ralpha, opacity ) :
                    filter + " " + opacity;
            }
        };
    }

    jQuery(function() {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if ( !jQuery.support.reliableMarginRight ) {
            jQuery.cssHooks.marginRight = {
                get: function( elem, computed ) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap( elem, { "display": "inline-block" }, function() {
                        if ( computed ) {
                            return curCSS( elem, "margin-right" );
                        } else {
                            return elem.style.marginRight;
                        }
                    });
                }
            };
        }
    });

    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.hidden = function( elem ) {
            var width = elem.offsetWidth,
                height = elem.offsetHeight;

            return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
        };

        jQuery.expr.filters.visible = function( elem ) {
            return !jQuery.expr.filters.hidden( elem );
        };
    }

// These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {

        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i,

                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [ value ],
                    expanded = {};

                for ( i = 0; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
            }
        };
    });




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rspacesAjax = /\s+/,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Document location
        ajaxLocation,

        // Document location segments
        ajaxLocParts,

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch( e ) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

// Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if ( jQuery.isFunction( func ) ) {
                var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
                    i = 0,
                    length = dataTypes.length,
                    dataType,
                    list,
                    placeBefore;

                // For each dataType in the dataTypeExpression
                for ( ; i < length; i++ ) {
                    dataType = dataTypes[ i ];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test( dataType );
                    if ( placeBefore ) {
                        dataType = dataType.substr( 1 ) || "*";
                    }
                    list = structure[ dataType ] = structure[ dataType ] || [];
                    // then we add to the structure accordingly
                    list[ placeBefore ? "unshift" : "push" ]( func );
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
                                            dataType /* internal */, inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[ 0 ];
        inspected = inspected || {};

        inspected[ dataType ] = true;

        var list = structure[ dataType ],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = ( structure === prefilters ),
            selection;

        for ( ; i < length && ( executeOnly || !selection ); i++ ) {
            selection = list[ i ]( options, originalOptions, jqXHR );
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if ( typeof selection === "string" ) {
                if ( !executeOnly || inspected[ selection ] ) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift( selection );
                    selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected );
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
            selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected );
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }
    }

    jQuery.fn.extend({
        load: function( url, params, callback ) {
            if ( typeof url !== "string" && _load ) {
                return _load.apply( this, arguments );

                // Don't do a request if no elements are being requested
            } else if ( !this.length ) {
                return this;
            }

            var off = url.indexOf( " " );
            if ( off >= 0 ) {
                var selector = url.slice( off, url.length );
                url = url.slice( 0, off );
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if ( params ) {
                // If it's a function
                if ( jQuery.isFunction( params ) ) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if ( typeof params === "object" ) {
                    params = jQuery.param( params, jQuery.ajaxSettings.traditional );
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function( jqXHR, status, responseText ) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if ( jqXHR.isResolved() ) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function( r ) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html( selector ?
                            // Create a dummy div to hold the results
                            jQuery("<div>")
                                // inject the contents of the document in, removing the scripts
                                // to avoid any 'Permission Denied' errors in IE
                                .append(responseText.replace(rscript, ""))

                                // Locate the specified elements
                                .find(selector) :

                            // If not, just inject the full result
                            responseText );
                    }

                    if ( callback ) {
                        self.each( callback, [ responseText, status, jqXHR ] );
                    }
                }
            });

            return this;
        },

        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },

        serializeArray: function() {
            return this.map(function(){
                return this.elements ? jQuery.makeArray( this.elements ) : this;
            })
                .filter(function(){
                    return this.name && !this.disabled &&
                        ( this.checked || rselectTextarea.test( this.nodeName ) ||
                            rinput.test( this.type ) );
                })
                .map(function( i, elem ){
                    var val = jQuery( this ).val();

                    return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                            jQuery.map( val, function( val, i ){
                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            }) :
                        { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                }).get();
        }
    });

// Attach a bunch of functions for handling common AJAX events
    jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
        jQuery.fn[ o ] = function( f ){
            return this.on( o, f );
        };
    });

    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
            // shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            if ( settings ) {
                // Building a settings object
                ajaxExtend( target, jQuery.ajaxSettings );
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend( target, settings );
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,
            /*
             timeout: 0,
             data: null,
             dataType: null,
             username: null,
             password: null,
             cache: null,
             traditional: false,
             headers: {},
             */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s &&
                    ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
                    jQuery( callbackContext ) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks( "once memory" ),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // ifModified key
                ifModifiedKey,
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // The jqXHR state
                state = 0,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Fake xhr
                jqXHR = {

                    readyState: 0,

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        if ( !state ) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match === undefined ? null : match;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        statusText = statusText || "abort";
                        if ( transport ) {
                            transport.abort( statusText );
                        }
                        done( 0, statusText );
                        return this;
                    }
                };

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done( status, nativeStatusText, responses, headers ) {

                // Called once
                if ( state === 2 ) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                var isSuccess,
                    success,
                    error,
                    statusText = nativeStatusText,
                    response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
                    lastModified,
                    etag;

                // If successful, handle type chaining
                if ( status >= 200 && status < 300 || status === 304 ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {

                        if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
                            jQuery.lastModified[ ifModifiedKey ] = lastModified;
                        }
                        if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
                            jQuery.etag[ ifModifiedKey ] = etag;
                        }
                    }

                    // If not modified
                    if ( status === 304 ) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        try {
                            success = ajaxConvert( s, response );
                            statusText = "success";
                            isSuccess = true;
                        } catch(e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if ( !statusText || status ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = "" + ( nativeStatusText || statusText );

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }

            // Attach deferreds
            deferred.promise( jqXHR );
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            // Status-dependent callbacks
            jqXHR.statusCode = function( map ) {
                if ( map ) {
                    var tmp;
                    if ( state < 2 ) {
                        for ( tmp in map ) {
                            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                        }
                    } else {
                        tmp = map[ jqXHR.status ];
                        jqXHR.then( tmp, tmp );
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

            // Determine if a cross-domain request is in order
            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                    );
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // If data is available, append data to url
                if ( s.data ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if ( s.cache === false ) {

                    var ts = jQuery.now(),
                        // try replacing _= if it is there
                        ret = s.url.replace( rts, "$1_=" + ts );

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                ifModifiedKey = ifModifiedKey || s.url;
                if ( jQuery.lastModified[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
                }
                if ( jQuery.etag[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout( function(){
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch (e) {
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function( a, traditional ) {
            var s = [],
                add = function( key, value ) {
                    // If value is a function, invoke it and return its value
                    value = jQuery.isFunction( value ) ? value() : value;
                    s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                };

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if ( traditional === undefined ) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                // Serialize the form elements
                jQuery.each( a, function() {
                    add( this.name, this.value );
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for ( var prefix in a ) {
                    buildParams( prefix, a[ prefix ], traditional, add );
                }
            }

            // Return the resulting serialization
            return s.join( "&" ).replace( r20, "+" );
        }
    });

    function buildParams( prefix, obj, traditional, add ) {
        if ( jQuery.isArray( obj ) ) {
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                }
            });

        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
            // Serialize object item.
            for ( var name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {
            // Serialize scalar item.
            add( prefix, obj );
        }
    }

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {

        var contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields,
            ct,
            type,
            finalDataType,
            firstDataType;

        // Fill responseXXX fields
        for ( type in responseFields ) {
            if ( type in responses ) {
                jqXHR[ responseFields[type] ] = responses[ type ];
            }
        }

        // Remove auto dataType and get content-type in the process
        while( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

// Chain conversions given the request and the original response
    function ajaxConvert( s, response ) {

        // Apply the dataFilter if provided
        if ( s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        var dataTypes = s.dataTypes,
            converters = {},
            i,
            key,
            length = dataTypes.length,
            tmp,
            // Current and previous dataTypes
            current = dataTypes[ 0 ],
            prev,
            // Conversion expression
            conversion,
            // Conversion function
            conv,
            // Conversion functions (transitive conversion)
            conv1,
            conv2;

        // For each dataType in the chain
        for ( i = 1; i < length; i++ ) {

            // Create converters map
            // with lowercased keys
            if ( i === 1 ) {
                for ( key in s.converters ) {
                    if ( typeof key === "string" ) {
                        converters[ key.toLowerCase() ] = s.converters[ key ];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[ i ];

            // If current is auto dataType, update it to prev
            if ( current === "*" ) {
                current = prev;
                // If no auto and dataTypes are actually different
            } else if ( prev !== "*" && prev !== current ) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[ conversion ] || converters[ "* " + current ];

                // If there is no direct converter, search transitively
                if ( !conv ) {
                    conv2 = undefined;
                    for ( conv1 in converters ) {
                        tmp = conv1.split( " " );
                        if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
                            conv2 = converters[ tmp[1] + " " + current ];
                            if ( conv2 ) {
                                conv1 = converters[ conv1 ];
                                if ( conv1 === true ) {
                                    conv = conv2;
                                } else if ( conv2 === true ) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if ( !( conv || conv2 ) ) {
                    jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
                }
                // If found converter is not an equivalence
                if ( conv !== true ) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv( response ) : conv2( conv1(response) );
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
        jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            return jQuery.expando + "_" + ( jsc++ );
        }
    });

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

        if ( s.dataTypes[ 0 ] === "jsonp" ||
            s.jsonp !== false && ( jsre.test( s.url ) ||
                inspectData && jsre.test( s.data ) ) ) {

            var responseContainer,
                jsonpCallback = s.jsonpCallback =
                    jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
                previous = window[ jsonpCallback ],
                url = s.url,
                data = s.data,
                replace = "$1" + jsonpCallback + "$2";

            if ( s.jsonp !== false ) {
                url = url.replace( jsre, replace );
                if ( s.url === url ) {
                    if ( inspectData ) {
                        data = data.replace( jsre, replace );
                    }
                    if ( s.data === data ) {
                        // Add callback manually
                        url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[ jsonpCallback ] = function( response ) {
                responseContainer = [ response ];
            };

            // Clean-up function
            jqXHR.always(function() {
                // Set callback back to previous value
                window[ jsonpCallback ] = previous;
                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( previous ) ) {
                    window[ jsonpCallback ]( responseContainer[ 0 ] );
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if ( !responseContainer ) {
                    jQuery.error( jsonpCallback + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // force json dataType
            s.dataTypes[ 0 ] = "json";

            // Delegate to script
            return "script";
        }
    });




// Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    });

// Handle cache's special case and global
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    });

// Bind script tag hack transport
    jQuery.ajaxTransport( "script", function(s) {

        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {

            var script,
                head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

            return {

                send: function( _, callback ) {

                    script = document.createElement( "script" );

                    script.async = "async";

                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function( _, isAbort ) {

                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if ( head && script.parentNode ) {
                                head.removeChild( script );
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore( script, head.firstChild );
                },

                abort: function() {
                    if ( script ) {
                        script.onload( 0, 1 );
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
        xhrOnUnloadAbort = window.ActiveXObject ? function() {
            // Abort all pending requests
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( 0, 1 );
            }
        } : false,
        xhrId = 0,
        xhrCallbacks;

// Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch( e ) {}
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch( e ) {}
    }

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
        /* Microsoft failed to properly
         * implement the XMLHttpRequest in IE7 (can't request local files),
         * so we use the ActiveXObject when it is available
         * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
         * we need a fallback.
         */
        function() {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;

// Determine support properties
    (function( xhr ) {
        jQuery.extend( jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ( "withCredentials" in xhr )
        });
    })( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
    if ( jQuery.support.ajax ) {

        jQuery.ajaxTransport(function( s ) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if ( !s.crossDomain || jQuery.support.cors ) {

                var callback;

                return {
                    send: function( headers, complete ) {

                        // Get a new xhr
                        var xhr = s.xhr(),
                            handle,
                            i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if ( s.username ) {
                            xhr.open( s.type, s.url, s.async, s.username, s.password );
                        } else {
                            xhr.open( s.type, s.url, s.async );
                        }

                        // Apply custom fields if provided
                        if ( s.xhrFields ) {
                            for ( i in s.xhrFields ) {
                                xhr[ i ] = s.xhrFields[ i ];
                            }
                        }

                        // Override mime type if needed
                        if ( s.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( s.mimeType );
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if ( !s.crossDomain && !headers["X-Requested-With"] ) {
                            headers[ "X-Requested-With" ] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }
                        } catch( _ ) {}

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send( ( s.hasContent && s.data ) || null );

                        // Listener
                        callback = function( _, isAbort ) {

                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if ( handle ) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if ( xhrOnUnloadAbort ) {
                                            delete xhrCallbacks[ handle ];
                                        }
                                    }

                                    // If it's an abort
                                    if ( isAbort ) {
                                        // Abort it manually if needed
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if ( xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }

                                        // When requesting binary data, IE6-9 will throw an exception
                                        // on any attempt to access responseText (#11426)
                                        try {
                                            responses.text = xhr.responseText;
                                        } catch( _ ) {
                                        }

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch( e ) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if ( !status && s.isLocal && !s.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch( firefoxAccessException ) {
                                if ( !isAbort ) {
                                    complete( -1, firefoxAccessException );
                                }
                            }

                            // Call complete if needed
                            if ( responses ) {
                                complete( status, statusText, responses, responseHeaders );
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if ( !s.async || xhr.readyState === 4 ) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if ( xhrOnUnloadAbort ) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if ( !xhrCallbacks ) {
                                    xhrCallbacks = {};
                                    jQuery( window ).unload( xhrOnUnloadAbort );
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[ handle ] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function() {
                        if ( callback ) {
                            callback(0,1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
        iframe, iframeDoc,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
        timerId,
        fxAttrs = [
            // height animations
            [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
            // width animations
            [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
            // opacity animations
            [ "opacity" ]
        ],
        fxNow;

    jQuery.fn.extend({
        show: function( speed, easing, callback ) {
            var elem, display;

            if ( speed || speed === 0 ) {
                return this.animate( genFx("show", 3), speed, easing, callback );

            } else {
                for ( var i = 0, j = this.length; i < j; i++ ) {
                    elem = this[ i ];

                    if ( elem.style ) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( (display === "" && jQuery.css(elem, "display") === "none") ||
                            !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                            jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    elem = this[ i ];

                    if ( elem.style ) {
                        display = elem.style.display;

                        if ( display === "" || display === "none" ) {
                            elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function( speed, easing, callback ) {
            if ( speed || speed === 0 ) {
                return this.animate( genFx("hide", 3), speed, easing, callback);

            } else {
                var elem, display,
                    i = 0,
                    j = this.length;

                for ( ; i < j; i++ ) {
                    elem = this[i];
                    if ( elem.style ) {
                        display = jQuery.css( elem, "display" );

                        if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
                            jQuery._data( elem, "olddisplay", display );
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    if ( this[i].style ) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function( fn, fn2, callback ) {
            var bool = typeof fn === "boolean";

            if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
                this._toggle.apply( this, arguments );

            } else if ( fn == null || bool ) {
                this.each(function() {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[ state ? "show" : "hide" ]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function( speed, to, easing, callback ) {
            return this.filter(":hidden").css("opacity", 0).show().end()
                .animate({opacity: to}, speed, easing, callback);
        },

        animate: function( prop, speed, easing, callback ) {
            var optall = jQuery.speed( speed, easing, callback );

            if ( jQuery.isEmptyObject( prop ) ) {
                return this.each( optall.complete, [ false ] );
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend( {}, prop );

            function doAnimation() {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if ( optall.queue === false ) {
                    jQuery._mark( this );
                }

                var opt = jQuery.extend( {}, optall ),
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    name, val, p, e, hooks, replace,
                    parts, start, end, unit,
                    method;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                // first pass over propertys to expand / normalize
                for ( p in prop ) {
                    name = jQuery.camelCase( p );
                    if ( p !== name ) {
                        prop[ name ] = prop[ p ];
                        delete prop[ p ];
                    }

                    if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
                        replace = hooks.expand( prop[ name ] );
                        delete prop[ name ];

                        // not quite $.extend, this wont overwrite keys already present.
                        // also - reusing 'p' from above because we have the correct "name"
                        for ( p in replace ) {
                            if ( ! ( p in prop ) ) {
                                prop[ p ] = replace[ p ];
                            }
                        }
                    }
                }

                for ( name in prop ) {
                    val = prop[ name ];
                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if ( jQuery.isArray( val ) ) {
                        opt.animatedProperties[ name ] = val[ 1 ];
                        val = prop[ name ] = val[ 0 ];
                    } else {
                        opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
                    }

                    if ( val === "hide" && hidden || val === "show" && !hidden ) {
                        return opt.complete.call( this );
                    }

                    if ( isElement && ( name === "height" || name === "width" ) ) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height animated
                        if ( jQuery.css( this, "display" ) === "inline" &&
                            jQuery.css( this, "float" ) === "none" ) {

                            // inline-level elements accept inline-block;
                            // block-level elements need to be inline with layout
                            if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
                                this.style.display = "inline-block";

                            } else {
                                this.style.zoom = 1;
                            }
                        }
                    }
                }

                if ( opt.overflow != null ) {
                    this.style.overflow = "hidden";
                }

                for ( p in prop ) {
                    e = new jQuery.fx( this, opt, p );
                    val = prop[ p ];

                    if ( rfxtypes.test( val ) ) {

                        // Tracks whether to show or hide based on private
                        // data attached to the element
                        method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
                        if ( method ) {
                            jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
                            e[ method ]();
                        } else {
                            e[ val ]();
                        }

                    } else {
                        parts = rfxnum.exec( val );
                        start = e.cur();

                        if ( parts ) {
                            end = parseFloat( parts[2] );
                            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

                            // We need to compute starting value
                            if ( unit !== "px" ) {
                                jQuery.style( this, p, (end || 1) + unit);
                                start = ( (end || 1) / e.cur() ) * start;
                                jQuery.style( this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if ( parts[1] ) {
                                end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
                            }

                            e.custom( start, end, unit );

                        } else {
                            e.custom( start, val, "" );
                        }
                    }
                }

                // For JS strict compliance
                return true;
            }

            return optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },

        stop: function( type, clearQueue, gotoEnd ) {
            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }

            return this.each(function() {
                var index,
                    hadTimers = false,
                    timers = jQuery.timers,
                    data = jQuery._data( this );

                // clear marker counters if we know they won't be
                if ( !gotoEnd ) {
                    jQuery._unmark( true, this );
                }

                function stopQueue( elem, data, index ) {
                    var hooks = data[ index ];
                    jQuery.removeData( elem, index, true );
                    hooks.stop( gotoEnd );
                }

                if ( type == null ) {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
                            stopQueue( this, data, index );
                        }
                    }
                } else if ( data[ index = type + ".run" ] && data[ index ].stop ){
                    stopQueue( this, data, index );
                }

                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                        if ( gotoEnd ) {

                            // force the next step to be the last
                            timers[ index ]( true );
                        } else {
                            timers[ index ].saveState();
                        }
                        hadTimers = true;
                        timers.splice( index, 1 );
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if ( !( gotoEnd && hadTimers ) ) {
                    jQuery.dequeue( this, type );
                }
            });
        }

    });

// Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout( clearFxNow, 0 );
        return ( fxNow = jQuery.now() );
    }

    function clearFxNow() {
        fxNow = undefined;
    }

// Generate parameters to create a standard animation
    function genFx( type, num ) {
        var obj = {};

        jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
            obj[ this ] = type;
        });

        return obj;
    }

// Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx( "show", 1 ),
        slideUp: genFx( "hide", 1 ),
        slideToggle: genFx( "toggle", 1 ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    });

    jQuery.extend({
        speed: function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    jQuery.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

            // normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function( noUnmark ) {
                if ( jQuery.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    jQuery.dequeue( this, opt.queue );
                } else if ( noUnmark !== false ) {
                    jQuery._unmark( this );
                }
            };

            return opt;
        },

        easing: {
            linear: function( p ) {
                return p;
            },
            swing: function( p ) {
                return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
            }
        },

        timers: [],

        fx: function( elem, options, prop ) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function() {
            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            ( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
        },

        // Get the current size
        cur: function() {
            if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
                return this.elem[ this.prop ];
            }

            var parsed,
                r = jQuery.css( this.elem, this.prop );
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function( from, to, unit ) {
            var self = this,
                fx = jQuery.fx;

            this.startTime = fxNow || createFxNow();
            this.end = to;
            this.now = this.start = from;
            this.pos = this.state = 0;
            this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

            function t( gotoEnd ) {
                return self.step( gotoEnd );
            }

            t.queue = this.options.queue;
            t.elem = this.elem;
            t.saveState = function() {
                if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
                    if ( self.options.hide ) {
                        jQuery._data( self.elem, "fxshow" + self.prop, self.start );
                    } else if ( self.options.show ) {
                        jQuery._data( self.elem, "fxshow" + self.prop, self.end );
                    }
                }
            };

            if ( t() && jQuery.timers.push(t) && !timerId ) {
                timerId = setInterval( fx.tick, fx.interval );
            }
        },

        // Simple 'show' function
        show: function() {
            var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

            // Remember where we started, so that we can go back to it later
            this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any flash of content
            if ( dataShow !== undefined ) {
                // This show is picking up where a previous hide or show left off
                this.custom( this.cur(), dataShow );
            } else {
                this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
            }

            // Start by showing the element
            jQuery( this.elem ).show();
        },

        // Simple 'hide' function
        hide: function() {
            // Remember where we started, so that we can go back to it later
            this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
            this.options.hide = true;

            // Begin the animation
            this.custom( this.cur(), 0 );
        },

        // Each step of an animation
        step: function( gotoEnd ) {
            var p, n, complete,
                t = fxNow || createFxNow(),
                done = true,
                elem = this.elem,
                options = this.options;

            if ( gotoEnd || t >= options.duration + this.startTime ) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[ this.prop ] = true;

                for ( p in options.animatedProperties ) {
                    if ( options.animatedProperties[ p ] !== true ) {
                        done = false;
                    }
                }

                if ( done ) {
                    // Reset the overflow
                    if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

                        jQuery.each( [ "", "X", "Y" ], function( index, value ) {
                            elem.style[ "overflow" + value ] = options.overflow[ index ];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if ( options.hide ) {
                        jQuery( elem ).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if ( options.hide || options.show ) {
                        for ( p in options.animatedProperties ) {
                            jQuery.style( elem, p, options.orig[ p ] );
                            jQuery.removeData( elem, "fxshow" + p, true );
                            // Toggle data is no longer needed
                            jQuery.removeData( elem, "toggle" + p, true );
                        }
                    }

                    // Execute the complete function
                    // in the event that the complete function throws an exception
                    // we must ensure it won't be called twice. #5684

                    complete = options.complete;
                    if ( complete ) {

                        options.complete = false;
                        complete.call( elem );
                    }
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if ( options.duration == Infinity ) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
                    this.now = this.start + ( (this.end - this.start) * this.pos );
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend( jQuery.fx, {
        tick: function() {
            var timer,
                timers = jQuery.timers,
                i = 0;

            for ( ; i < timers.length; i++ ) {
                timer = timers[ i ];
                // Checks the timer has not already been removed
                if ( !timer() && timers[ i ] === timer ) {
                    timers.splice( i--, 1 );
                }
            }

            if ( !timers.length ) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function() {
            clearInterval( timerId );
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function( fx ) {
                jQuery.style( fx.elem, "opacity", fx.now );
            },

            _default: function( fx ) {
                if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
                    fx.elem.style[ fx.prop ] = fx.now + fx.unit;
                } else {
                    fx.elem[ fx.prop ] = fx.now;
                }
            }
        }
    });

// Ensure props that can't be negative don't go there on undershoot easing
    jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
        // exclude marginTop, marginLeft, marginBottom and marginRight from this list
        if ( prop.indexOf( "margin" ) ) {
            jQuery.fx.step[ prop ] = function( fx ) {
                jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
            };
        }
    });

    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.animated = function( elem ) {
            return jQuery.grep(jQuery.timers, function( fn ) {
                return elem === fn.elem;
            }).length;
        };
    }

// Try to restore the default display value of an element
    function defaultDisplay( nodeName ) {

        if ( !elemdisplay[ nodeName ] ) {

            var body = document.body,
                elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
                display = elem.css( "display" );
            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if ( display === "none" || display === "" ) {
                // No iframe to use yet, so create it
                if ( !iframe ) {
                    iframe = document.createElement( "iframe" );
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild( iframe );

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if ( !iframeDoc || !iframe.createElement ) {
                    iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
                    iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement( nodeName );

                iframeDoc.body.appendChild( elem );

                display = jQuery.css( elem, "display" );
                body.removeChild( iframe );
            }

            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }

        return elemdisplay[ nodeName ];
    }




    var getOffset,
        rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;

    if ( "getBoundingClientRect" in document.documentElement ) {
        getOffset = function( elem, doc, docElem, box ) {
            try {
                box = elem.getBoundingClientRect();
            } catch(e) {}

            // Make sure we're not dealing with a disconnected DOM node
            if ( !box || !jQuery.contains( docElem, elem ) ) {
                return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
            }

            var body = doc.body,
                win = getWindow( doc ),
                clientTop  = docElem.clientTop  || body.clientTop  || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
                scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
                top  = box.top  + scrollTop  - clientTop,
                left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        getOffset = function( elem, doc, docElem ) {
            var computedStyle,
                offsetParent = elem.offsetParent,
                prevOffsetParent = elem,
                body = doc.body,
                defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
                top = elem.offsetTop,
                left = elem.offsetLeft;

            while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
                if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top  -= elem.scrollTop;
                left -= elem.scrollLeft;

                if ( elem === offsetParent ) {
                    top  += elem.offsetTop;
                    left += elem.offsetLeft;

                    if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
                        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
                    top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                    left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
                top  += body.offsetTop;
                left += body.offsetLeft;
            }

            if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
                top  += Math.max( docElem.scrollTop, body.scrollTop );
                left += Math.max( docElem.scrollLeft, body.scrollLeft );
            }

            return { top: top, left: left };
        };
    }

    jQuery.fn.offset = function( options ) {
        if ( arguments.length ) {
            return options === undefined ?
                this :
                this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
        }

        var elem = this[0],
            doc = elem && elem.ownerDocument;

        if ( !doc ) {
            return null;
        }

        if ( elem === doc.body ) {
            return jQuery.offset.bodyOffset( elem );
        }

        return getOffset( elem, doc, doc.documentElement );
    };

    jQuery.offset = {

        bodyOffset: function( body ) {
            var top = body.offsetTop,
                left = body.offsetLeft;

            if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
                top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
                left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function( elem, options, i ) {
            var position = jQuery.css( elem, "position" );

            // set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            var curElem = jQuery( elem ),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css( elem, "top" ),
                curCSSLeft = jQuery.css( elem, "left" ),
                calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
            }

            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );
            } else {
                curElem.css( props );
            }
        }
    };


    jQuery.fn.extend({

        position: function() {
            if ( !this[0] ) {
                return null;
            }

            var elem = this[0],

                // Get *real* offsetParent
                offsetParent = this.offsetParent(),

                // Get correct offsets
                offset       = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
            offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

            // Add offsetParent borders
            parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
            parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

            // Subtract the two offsets
            return {
                top:  offset.top  - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


// Create scrollLeft and scrollTop methods
    jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
        var top = /Y/.test( prop );

        jQuery.fn[ method ] = function( val ) {
            return jQuery.access( this, function( elem, method, val ) {
                var win = getWindow( elem );

                if ( val === undefined ) {
                    return win ? (prop in win) ? win[ prop ] :
                        jQuery.support.boxModel && win.document.documentElement[ method ] ||
                            win.document.body[ method ] :
                        elem[ method ];
                }

                if ( win ) {
                    win.scrollTo(
                        !top ? val : jQuery( win ).scrollLeft(),
                        top ? val : jQuery( win ).scrollTop()
                    );

                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length, null );
        };
    });

    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        var clientProp = "client" + name,
            scrollProp = "scroll" + name,
            offsetProp = "offset" + name;

        // innerHeight and innerWidth
        jQuery.fn[ "inner" + name ] = function() {
            var elem = this[0];
            return elem ?
                elem.style ?
                    parseFloat( jQuery.css( elem, type, "padding" ) ) :
                    this[ type ]() :
                null;
        };

        // outerHeight and outerWidth
        jQuery.fn[ "outer" + name ] = function( margin ) {
            var elem = this[0];
            return elem ?
                elem.style ?
                    parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
                    this[ type ]() :
                null;
        };

        jQuery.fn[ type ] = function( value ) {
            return jQuery.access( this, function( elem, type, value ) {
                var doc, docElemProp, orig, ret;

                if ( jQuery.isWindow( elem ) ) {
                    // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                    doc = elem.document;
                    docElemProp = doc.documentElement[ clientProp ];
                    return jQuery.support.boxModel && docElemProp ||
                        doc.body && doc.body[ clientProp ] || docElemProp;
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                    doc = elem.documentElement;

                    // when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
                    // so we can't use max, as it'll choose the incorrect offset[Width/Height]
                    // instead we use the correct client[Width/Height]
                    // support:IE6
                    if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
                        return doc[ clientProp ];
                    }

                    return Math.max(
                        elem.body[ scrollProp ], doc[ scrollProp ],
                        elem.body[ offsetProp ], doc[ offsetProp ]
                    );
                }

                // Get width or height on the element
                if ( value === undefined ) {
                    orig = jQuery.css( elem, type );
                    ret = parseFloat( orig );
                    return jQuery.isNumeric( ret ) ? ret : orig;
                }

                // Set the width or height on the element
                jQuery( elem ).css( type, value );
            }, type, value, arguments.length, null );
        };
    });




// Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
    if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
        define( "jquery", [], function () { return jQuery; } );
    }



})( window );

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.nsgInit');

/**
 * This is a function used to initialize NSG JS plugins. We made this to ensure that the NSG JS plugins
 * are being initialized in the correct order. This file is being included in the shell
 */
$(function(){
  // called when the nsgConfig has PLACEMENT set to "prepend"
  if( nsg && nsg.init ){
    nsg.triggerReady = nsg.triggerReady || $.noop;
    nsg.init(nsg.triggerReady);
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.nsgInit. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('polyfills');

(function(){

    /**
     * IE8 Polyfills
     */

    Date.now = Date.now || function() { return +new Date; };


  /**
   * Array.filter
   */
  if (!Array.prototype.filter) {
    Array.prototype.filter = function(fun/*, thisArg*/) {
      'use strict';

      if (this === void 0 || this === null) {
        throw new TypeError();
      }

      var t = Object(this);
      var len = t.length >>> 0;
      if (typeof fun !== 'function') {
        throw new TypeError();
      }

      var res = [];
      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
      for (var i = 0; i < len; i++) {
        if (i in t) {
          var val = t[i];

          // NOTE: Technically this should Object.defineProperty at
          //       the next index, as push can be affected by
          //       properties on Object.prototype and Array.prototype.
          //       But that method's new, and collisions should be
          //       rare, so use the more-compatible alternative.
          if (fun.call(thisArg, val, i, t)) {
            res.push(val);
          }
        }
      }

      return res;
    };
  }

})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing polyfills. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * easyXDM
 * http://easyxdm.net/
 * Copyright(c) 2009-2011, Øyvind Sean Kinsey, oyvind@kinsey.no.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* version: 2.4.19.3 */

(function(N,d,p,K,k,H){var b=this;var n=Math.floor(Math.random()*10000);var q=Function.prototype;var Q=/^((http.?:)\/\/([^:\/\s]+)(:\d+)*)/;var R=/[\-\w]+\/\.\.\//;var F=/([^:])\/\//g;var I="";var o={};var M=N.easyXDM;var U="easyXDM_";var E;var y=false;var i;var h;function C(X,Z){var Y=typeof X[Z];return Y=="function"||(!!(Y=="object"&&X[Z]))||Y=="unknown"}function u(X,Y){return !!(typeof(X[Y])=="object"&&X[Y])}function r(X){return Object.prototype.toString.call(X)==="[object Array]"}function c(){var Z="Shockwave Flash",ad="application/x-shockwave-flash";if(!t(navigator.plugins)&&typeof navigator.plugins[Z]=="object"){var ab=navigator.plugins[Z].description;if(ab&&!t(navigator.mimeTypes)&&navigator.mimeTypes[ad]&&navigator.mimeTypes[ad].enabledPlugin){i=ab.match(/\d+/g)}}if(!i){var Y;try{Y=new ActiveXObject("ShockwaveFlash.ShockwaveFlash");i=Array.prototype.slice.call(Y.GetVariable("$version").match(/(\d+),(\d+),(\d+),(\d+)/),1);Y=null}catch(ac){}}if(!i){return false}var X=parseInt(i[0],10),aa=parseInt(i[1],10);h=X>9&&aa>0;return true}var v,x;if(C(N,"addEventListener")){v=function(Z,X,Y){Z.addEventListener(X,Y,false)};x=function(Z,X,Y){Z.removeEventListener(X,Y,false)}}else{if(C(N,"attachEvent")){v=function(X,Z,Y){X.attachEvent("on"+Z,Y)};x=function(X,Z,Y){X.detachEvent("on"+Z,Y)}}else{throw new Error("Browser not supported")}}var W=false,J=[],L;if("readyState" in d){L=d.readyState;W=L=="complete"||(~navigator.userAgent.indexOf("AppleWebKit/")&&(L=="loaded"||L=="interactive"))}else{W=!!d.body}function s(){if(W){return}W=true;for(var X=0;X<J.length;X++){J[X]()}J.length=0}if(!W){if(C(N,"addEventListener")){v(d,"DOMContentLoaded",s)}else{v(d,"readystatechange",function(){if(d.readyState=="complete"){s()}});if(d.documentElement.doScroll&&N===top){var g=function(){if(W){return}try{d.documentElement.doScroll("left")}catch(X){K(g,1);return}s()};g()}}v(N,"load",s)}function G(Y,X){if(W){Y.call(X);return}J.push(function(){Y.call(X)})}function m(){var Z=parent;if(I!==""){for(var X=0,Y=I.split(".");X<Y.length;X++){Z=Z[Y[X]]}}return Z.easyXDM}function e(X){N.easyXDM=M;I=X;if(I){U="easyXDM_"+I.replace(".","_")+"_"}return o}function z(X){return X.match(Q)[3]}function f(X){return X.match(Q)[4]||""}function j(Z){var X=Z.toLowerCase().match(Q);var aa=X[2],ab=X[3],Y=X[4]||"";if((aa=="http:"&&Y==":80")||(aa=="https:"&&Y==":443")){Y=""}return aa+"//"+ab+Y}function B(X){X=X.replace(F,"$1/");if(!X.match(/^(http||https):\/\//)){var Y=(X.substring(0,1)==="/")?"":p.pathname;if(Y.substring(Y.length-1)!=="/"){Y=Y.substring(0,Y.lastIndexOf("/")+1)}X=p.protocol+"//"+p.host+Y+X}while(R.test(X)){X=X.replace(R,"")}return X}function P(X,aa){var ac="",Z=X.indexOf("#");if(Z!==-1){ac=X.substring(Z);X=X.substring(0,Z)}var ab=[];for(var Y in aa){if(aa.hasOwnProperty(Y)){ab.push(Y+"="+H(aa[Y]))}}return X+(y?"#":(X.indexOf("?")==-1?"?":"&"))+ab.join("&")+ac}var S=(function(X){X=X.substring(1).split("&");var Z={},aa,Y=X.length;while(Y--){aa=X[Y].split("=");Z[aa[0]]=k(aa[1])}return Z}(/xdm_e=/.test(p.search)?p.search:p.hash));function t(X){return typeof X==="undefined"}var O=function(){var Y={};var Z={a:[1,2,3]},X='{"a":[1,2,3]}';if(typeof JSON!="undefined"&&typeof JSON.stringify==="function"&&JSON.stringify(Z).replace((/\s/g),"")===X){return JSON}if(Object.toJSON){if(Object.toJSON(Z).replace((/\s/g),"")===X){Y.stringify=Object.toJSON}}if(typeof String.prototype.evalJSON==="function"){Z=X.evalJSON();if(Z.a&&Z.a.length===3&&Z.a[2]===3){Y.parse=function(aa){return aa.evalJSON()}}}if(Y.stringify&&Y.parse){O=function(){return Y};return Y}return null};function T(X,Y,Z){var ab;for(var aa in Y){if(Y.hasOwnProperty(aa)){if(aa in X){ab=Y[aa];if(typeof ab==="object"){T(X[aa],ab,Z)}else{if(!Z){X[aa]=Y[aa]}}}else{X[aa]=Y[aa]}}}return X}function a(){var Y=d.body.appendChild(d.createElement("form")),X=Y.appendChild(d.createElement("input"));X.name=U+"TEST"+n;E=X!==Y.elements[X.name];d.body.removeChild(Y)}function A(Y){if(t(E)){a()}var ac;if(E){ac=d.createElement('<iframe name="'+Y.props.name+'"/>')}else{ac=d.createElement("IFRAME");ac.name=Y.props.name}ac.id=ac.name=Y.props.name;delete Y.props.name;if(typeof Y.container=="string"){Y.container=d.getElementById(Y.container)}if(!Y.container){T(ac.style,{position:"absolute",top:"-2000px",left:"0px"});Y.container=d.body}var ab=Y.props.src;Y.props.src="javascript:false";T(ac,Y.props);ac.border=ac.frameBorder=0;ac.allowTransparency=true;Y.container.appendChild(ac);if(Y.onLoad){v(ac,"load",Y.onLoad)}if(Y.usePost){var aa=Y.container.appendChild(d.createElement("form")),X;aa.target=ac.name;aa.action=ab;aa.method="POST";if(typeof(Y.usePost)==="object"){for(var Z in Y.usePost){if(Y.usePost.hasOwnProperty(Z)){if(E){X=d.createElement('<input name="'+Z+'"/>')}else{X=d.createElement("INPUT");X.name=Z}X.value=Y.usePost[Z];aa.appendChild(X)}}}aa.submit();aa.parentNode.removeChild(aa)}else{ac.src=ab}Y.props.src=ab;return ac}function V(aa,Z){if(typeof aa=="string"){aa=[aa]}var Y,X=aa.length;while(X--){Y=aa[X];Y=new RegExp(Y.substr(0,1)=="^"?Y:("^"+Y.replace(/(\*)/g,".$1").replace(/\?/g,".")+"$"));if(Y.test(Z)){return true}}return false}function l(Z){var ae=Z.protocol,Y;Z.isHost=Z.isHost||t(S.xdm_p);y=Z.hash||false;if(!Z.props){Z.props={}}if(!Z.isHost){Z.channel=S.xdm_c.replace(/["'<>\\]/g,"");Z.secret=S.xdm_s;Z.remote=S.xdm_e.replace(/["'<>\\]/g,"");ae=S.xdm_p;if(Z.acl&&!V(Z.acl,Z.remote)){throw new Error("Access denied for "+Z.remote)}}else{Z.remote=B(Z.remote);Z.channel=Z.channel||"default"+n++;Z.secret=Math.random().toString(16).substring(2);if(t(ae)){if(j(p.href)==j(Z.remote)){ae="4"}else{if(C(N,"postMessage")||C(d,"postMessage")){ae="1"}else{if(Z.swf&&C(N,"ActiveXObject")&&c()){ae="6"}else{if(navigator.product==="Gecko"&&"frameElement" in N&&navigator.userAgent.indexOf("WebKit")==-1){ae="5"}else{if(Z.remoteHelper){ae="2"}else{ae="0"}}}}}}}Z.protocol=ae;switch(ae){case"0":T(Z,{interval:100,delay:2000,useResize:true,useParent:false,usePolling:false},true);if(Z.isHost){if(!Z.local){var ac=p.protocol+"//"+p.host,X=d.body.getElementsByTagName("img"),ad;var aa=X.length;while(aa--){ad=X[aa];if(ad.src.substring(0,ac.length)===ac){Z.local=ad.src;break}}if(!Z.local){Z.local=N}}var ab={xdm_c:Z.channel,xdm_p:0};if(Z.local===N){Z.usePolling=true;Z.useParent=true;Z.local=p.protocol+"//"+p.host+p.pathname+p.search;ab.xdm_e=Z.local;ab.xdm_pa=1}else{ab.xdm_e=B(Z.local)}if(Z.container){Z.useResize=false;ab.xdm_po=1}Z.remote=P(Z.remote,ab)}else{T(Z,{channel:S.xdm_c,remote:S.xdm_e,useParent:!t(S.xdm_pa),usePolling:!t(S.xdm_po),useResize:Z.useParent?false:Z.useResize})}Y=[new o.stack.HashTransport(Z),new o.stack.ReliableBehavior({}),new o.stack.QueueBehavior({encode:true,maxLength:4000-Z.remote.length}),new o.stack.VerifyBehavior({initiate:Z.isHost})];break;case"1":Y=[new o.stack.PostMessageTransport(Z)];break;case"2":if(Z.isHost){Z.remoteHelper=B(Z.remoteHelper)}Y=[new o.stack.NameTransport(Z),new o.stack.QueueBehavior(),new o.stack.VerifyBehavior({initiate:Z.isHost})];break;case"3":Y=[new o.stack.NixTransport(Z)];break;case"4":Y=[new o.stack.SameOriginTransport(Z)];break;case"5":Y=[new o.stack.FrameElementTransport(Z)];break;case"6":if(!i){c()}Y=[new o.stack.FlashTransport(Z)];break}Y.push(new o.stack.QueueBehavior({lazy:Z.lazy,remove:true}));return Y}function D(aa){var ab,Z={incoming:function(ad,ac){this.up.incoming(ad,ac)},outgoing:function(ac,ad){this.down.outgoing(ac,ad)},callback:function(ac){this.up.callback(ac)},init:function(){this.down.init()},destroy:function(){this.down.destroy()}};for(var Y=0,X=aa.length;Y<X;Y++){ab=aa[Y];T(ab,Z,true);if(Y!==0){ab.down=aa[Y-1]}if(Y!==X-1){ab.up=aa[Y+1]}}return ab}function w(X){X.up.down=X.down;X.down.up=X.up;X.up=X.down=null}T(o,{version:"2.4.19.3",query:S,stack:{},apply:T,getJSONObject:O,whenReady:G,noConflict:e});o.DomHelper={on:v,un:x,requiresJSON:function(X){if(!u(N,"JSON")){d.write('<script type="text/javascript" src="'+X+'"><\/script>')}}};(function(){var X={};o.Fn={set:function(Y,Z){X[Y]=Z},get:function(Z,Y){if(!X.hasOwnProperty(Z)){return}var aa=X[Z];if(Y){delete X[Z]}return aa}}}());o.Socket=function(Y){var X=D(l(Y).concat([{incoming:function(ab,aa){Y.onMessage(ab,aa)},callback:function(aa){if(Y.onReady){Y.onReady(aa)}}}])),Z=j(Y.remote);this.origin=j(Y.remote);this.destroy=function(){X.destroy()};this.postMessage=function(aa){X.outgoing(aa,Z)};X.init()};o.Rpc=function(Z,Y){if(Y.local){for(var ab in Y.local){if(Y.local.hasOwnProperty(ab)){var aa=Y.local[ab];if(typeof aa==="function"){Y.local[ab]={method:aa}}}}}var X=D(l(Z).concat([new o.stack.RpcBehavior(this,Y),{callback:function(ac){if(Z.onReady){Z.onReady(ac)}}}]));this.origin=j(Z.remote);this.destroy=function(){X.destroy()};X.init()};o.stack.SameOriginTransport=function(Y){var Z,ab,aa,X;return(Z={outgoing:function(ad,ae,ac){aa(ad);if(ac){ac()}},destroy:function(){if(ab){ab.parentNode.removeChild(ab);ab=null}},onDOMReady:function(){X=j(Y.remote);if(Y.isHost){T(Y.props,{src:P(Y.remote,{xdm_e:p.protocol+"//"+p.host+p.pathname,xdm_c:Y.channel,xdm_p:4}),name:U+Y.channel+"_provider"});ab=A(Y);o.Fn.set(Y.channel,function(ac){aa=ac;K(function(){Z.up.callback(true)},0);return function(ad){Z.up.incoming(ad,X)}})}else{aa=m().Fn.get(Y.channel,true)(function(ac){Z.up.incoming(ac,X)});K(function(){Z.up.callback(true)},0)}},init:function(){G(Z.onDOMReady,Z)}})};o.stack.FlashTransport=function(aa){var ac,X,ab,ad,Y,ae;function af(ah,ag){K(function(){ac.up.incoming(ah,ad)},0)}function Z(ah){var ag=aa.swf+"?host="+aa.isHost;var aj="easyXDM_swf_"+Math.floor(Math.random()*10000);o.Fn.set("flash_loaded"+ah.replace(/[\-.]/g,"_"),function(){o.stack.FlashTransport[ah].swf=Y=ae.firstChild;var ak=o.stack.FlashTransport[ah].queue;for(var al=0;al<ak.length;al++){ak[al]()}ak.length=0});if(aa.swfContainer){ae=(typeof aa.swfContainer=="string")?d.getElementById(aa.swfContainer):aa.swfContainer}else{ae=d.createElement("div");T(ae.style,h&&aa.swfNoThrottle?{height:"20px",width:"20px",position:"fixed",right:0,top:0}:{height:"1px",width:"1px",position:"absolute",overflow:"hidden",right:0,top:0});d.body.appendChild(ae)}var ai="callback=flash_loaded"+H(ah.replace(/[\-.]/g,"_"))+"&proto="+b.location.protocol+"&domain="+H(z(b.location.href))+"&port="+H(f(b.location.href))+"&ns="+H(I);ae.innerHTML="<object height='20' width='20' type='application/x-shockwave-flash' id='"+aj+"' data='"+ag+"'><param name='allowScriptAccess' value='always'></param><param name='wmode' value='transparent'><param name='movie' value='"+ag+"'></param><param name='flashvars' value='"+ai+"'></param><embed type='application/x-shockwave-flash' FlashVars='"+ai+"' allowScriptAccess='always' wmode='transparent' src='"+ag+"' height='1' width='1'></embed></object>"}return(ac={outgoing:function(ah,ai,ag){Y.postMessage(aa.channel,ah.toString());if(ag){ag()}},destroy:function(){try{Y.destroyChannel(aa.channel)}catch(ag){}Y=null;if(X){X.parentNode.removeChild(X);X=null}},onDOMReady:function(){ad=aa.remote;o.Fn.set("flash_"+aa.channel+"_init",function(){K(function(){ac.up.callback(true)})});o.Fn.set("flash_"+aa.channel+"_onMessage",af);aa.swf=B(aa.swf);var ah=z(aa.swf);var ag=function(){o.stack.FlashTransport[ah].init=true;Y=o.stack.FlashTransport[ah].swf;Y.createChannel(aa.channel,aa.secret,j(aa.remote),aa.isHost);if(aa.isHost){if(h&&aa.swfNoThrottle){T(aa.props,{position:"fixed",right:0,top:0,height:"20px",width:"20px"})}T(aa.props,{src:P(aa.remote,{xdm_e:j(p.href),xdm_c:aa.channel,xdm_p:6,xdm_s:aa.secret}),name:U+aa.channel+"_provider"});X=A(aa)}};if(o.stack.FlashTransport[ah]&&o.stack.FlashTransport[ah].init){ag()}else{if(!o.stack.FlashTransport[ah]){o.stack.FlashTransport[ah]={queue:[ag]};Z(ah)}else{o.stack.FlashTransport[ah].queue.push(ag)}}},init:function(){G(ac.onDOMReady,ac)}})};o.stack.PostMessageTransport=function(aa){var ac,ad,Y,Z;function X(ae){if(ae.origin){return j(ae.origin)}if(ae.uri){return j(ae.uri)}if(ae.domain){return p.protocol+"//"+ae.domain}throw"Unable to retrieve the origin of the event"}function ab(af){var ae=X(af);if(ae==Z&&af.data.substring(0,aa.channel.length+1)==aa.channel+" "){ac.up.incoming(af.data.substring(aa.channel.length+1),ae)}}return(ac={outgoing:function(af,ag,ae){Y.postMessage(aa.channel+" "+af,ag||Z);if(ae){ae()}},destroy:function(){x(N,"message",ab);if(ad){Y=null;ad.parentNode.removeChild(ad);ad=null}},onDOMReady:function(){Z=j(aa.remote);if(aa.isHost){var ae=function(af){if(af.data==aa.channel+"-ready"){Y=("postMessage" in ad.contentWindow)?ad.contentWindow:ad.contentWindow.document;x(N,"message",ae);v(N,"message",ab);K(function(){ac.up.callback(true)},0)}};v(N,"message",ae);T(aa.props,{src:P(aa.remote,{xdm_e:j(p.href),xdm_c:aa.channel,xdm_p:1}),name:U+aa.channel+"_provider"});ad=A(aa)}else{v(N,"message",ab);Y=("postMessage" in N.parent)?N.parent:N.parent.document;Y.postMessage(aa.channel+"-ready",Z);K(function(){ac.up.callback(true)},0)}},init:function(){G(ac.onDOMReady,ac)}})};o.stack.FrameElementTransport=function(Y){var Z,ab,aa,X;return(Z={outgoing:function(ad,ae,ac){aa.call(this,ad);if(ac){ac()}},destroy:function(){if(ab){ab.parentNode.removeChild(ab);ab=null}},onDOMReady:function(){X=j(Y.remote);if(Y.isHost){T(Y.props,{src:P(Y.remote,{xdm_e:j(p.href),xdm_c:Y.channel,xdm_p:5}),name:U+Y.channel+"_provider"});ab=A(Y);ab.fn=function(ac){delete ab.fn;aa=ac;K(function(){Z.up.callback(true)},0);return function(ad){Z.up.incoming(ad,X)}}}else{if(d.referrer&&j(d.referrer)!=S.xdm_e){N.top.location=S.xdm_e}aa=N.frameElement.fn(function(ac){Z.up.incoming(ac,X)});Z.up.callback(true)}},init:function(){G(Z.onDOMReady,Z)}})};o.stack.NameTransport=function(ab){var ac;var ae,ai,aa,ag,ah,Y,X;function af(al){var ak=ab.remoteHelper+(ae?"#_3":"#_2")+ab.channel;ai.contentWindow.sendMessage(al,ak)}function ad(){if(ae){if(++ag===2||!ae){ac.up.callback(true)}}else{af("ready");ac.up.callback(true)}}function aj(ak){ac.up.incoming(ak,Y)}function Z(){if(ah){K(function(){ah(true)},0)}}return(ac={outgoing:function(al,am,ak){ah=ak;af(al)},destroy:function(){ai.parentNode.removeChild(ai);ai=null;if(ae){aa.parentNode.removeChild(aa);aa=null}},onDOMReady:function(){ae=ab.isHost;ag=0;Y=j(ab.remote);ab.local=B(ab.local);if(ae){o.Fn.set(ab.channel,function(al){if(ae&&al==="ready"){o.Fn.set(ab.channel,aj);ad()}});X=P(ab.remote,{xdm_e:ab.local,xdm_c:ab.channel,xdm_p:2});T(ab.props,{src:X+"#"+ab.channel,name:U+ab.channel+"_provider"});aa=A(ab)}else{ab.remoteHelper=ab.remote;o.Fn.set(ab.channel,aj)}var ak=function(){var al=ai||this;x(al,"load",ak);o.Fn.set(ab.channel+"_load",Z);(function am(){if(typeof al.contentWindow.sendMessage=="function"){ad()}else{K(am,50)}}())};ai=A({props:{src:ab.local+"#_4"+ab.channel},onLoad:ak})},init:function(){G(ac.onDOMReady,ac)}})};o.stack.HashTransport=function(Z){var ac;var ah=this,af,aa,X,ad,am,ab,al;var ag,Y;function ak(ao){if(!al){return}var an=Z.remote+"#"+(am++)+"_"+ao;((af||!ag)?al.contentWindow:al).location=an}function ae(an){ad=an;ac.up.incoming(ad.substring(ad.indexOf("_")+1),Y)}function aj(){if(!ab){return}var an=ab.location.href,ap="",ao=an.indexOf("#");if(ao!=-1){ap=an.substring(ao)}if(ap&&ap!=ad){ae(ap)}}function ai(){aa=setInterval(aj,X)}return(ac={outgoing:function(an,ao){ak(an)},destroy:function(){N.clearInterval(aa);if(af||!ag){al.parentNode.removeChild(al)}al=null},onDOMReady:function(){af=Z.isHost;X=Z.interval;ad="#"+Z.channel;am=0;ag=Z.useParent;Y=j(Z.remote);if(af){T(Z.props,{src:Z.remote,name:U+Z.channel+"_provider"});if(ag){Z.onLoad=function(){ab=N;ai();ac.up.callback(true)}}else{var ap=0,an=Z.delay/50;(function ao(){if(++ap>an){throw new Error("Unable to reference listenerwindow")}try{ab=al.contentWindow.frames[U+Z.channel+"_consumer"]}catch(aq){}if(ab){ai();ac.up.callback(true)}else{K(ao,50)}}())}al=A(Z)}else{ab=N;ai();if(ag){al=parent;ac.up.callback(true)}else{T(Z,{props:{src:Z.remote+"#"+Z.channel+new Date(),name:U+Z.channel+"_consumer"},onLoad:function(){ac.up.callback(true)}});al=A(Z)}}},init:function(){G(ac.onDOMReady,ac)}})};o.stack.ReliableBehavior=function(Y){var aa,ac;var ab=0,X=0,Z="";return(aa={incoming:function(af,ad){var ae=af.indexOf("_"),ag=af.substring(0,ae).split(",");af=af.substring(ae+1);if(ag[0]==ab){Z="";if(ac){ac(true)}}if(af.length>0){aa.down.outgoing(ag[1]+","+ab+"_"+Z,ad);if(X!=ag[1]){X=ag[1];aa.up.incoming(af,ad)}}},outgoing:function(af,ad,ae){Z=af;ac=ae;aa.down.outgoing(X+","+(++ab)+"_"+af,ad)}})};o.stack.QueueBehavior=function(Z){var ac,ad=[],ag=true,aa="",af,X=0,Y=false,ab=false;function ae(){if(Z.remove&&ad.length===0){w(ac);return}if(ag||ad.length===0||af){return}ag=true;var ah=ad.shift();ac.down.outgoing(ah.data,ah.origin,function(ai){ag=false;if(ah.callback){K(function(){ah.callback(ai)},0)}ae()})}return(ac={init:function(){if(t(Z)){Z={}}if(Z.maxLength){X=Z.maxLength;ab=true}if(Z.lazy){Y=true}else{ac.down.init()}},callback:function(ai){ag=false;var ah=ac.up;ae();ah.callback(ai)},incoming:function(ak,ai){if(ab){var aj=ak.indexOf("_"),ah=parseInt(ak.substring(0,aj),10);aa+=ak.substring(aj+1);if(ah===0){if(Z.encode){aa=k(aa)}ac.up.incoming(aa,ai);aa=""}}else{ac.up.incoming(ak,ai)}},outgoing:function(al,ai,ak){if(Z.encode){al=H(al)}var ah=[],aj;if(ab){while(al.length!==0){aj=al.substring(0,X);al=al.substring(aj.length);ah.push(aj)}while((aj=ah.shift())){ad.push({data:ah.length+"_"+aj,origin:ai,callback:ah.length===0?ak:null})}}else{ad.push({data:al,origin:ai,callback:ak})}if(Y){ac.down.init()}else{ae()}},destroy:function(){af=true;ac.down.destroy()}})};o.stack.VerifyBehavior=function(ab){var ac,aa,Y,Z=false;function X(){aa=Math.random().toString(16).substring(2);ac.down.outgoing(aa)}return(ac={incoming:function(af,ad){var ae=af.indexOf("_");if(ae===-1){if(af===aa){ac.up.callback(true)}else{if(!Y){Y=af;if(!ab.initiate){X()}ac.down.outgoing(af)}}}else{if(af.substring(0,ae)===Y){ac.up.incoming(af.substring(ae+1),ad)}}},outgoing:function(af,ad,ae){ac.down.outgoing(aa+"_"+af,ad,ae)},callback:function(ad){if(ab.initiate){X()}}})};o.stack.RpcBehavior=function(ad,Y){var aa,af=Y.serializer||O();var ae=0,ac={};function X(ag){ag.jsonrpc="2.0";aa.down.outgoing(af.stringify(ag))}function ab(ag,ai){var ah=Array.prototype.slice;return function(){var aj=arguments.length,al,ak={method:ai};if(aj>0&&typeof arguments[aj-1]==="function"){if(aj>1&&typeof arguments[aj-2]==="function"){al={success:arguments[aj-2],error:arguments[aj-1]};ak.params=ah.call(arguments,0,aj-2)}else{al={success:arguments[aj-1]};ak.params=ah.call(arguments,0,aj-1)}ac[""+(++ae)]=al;ak.id=ae}else{ak.params=ah.call(arguments,0)}if(ag.namedParams&&ak.params.length===1){ak.params=ak.params[0]}X(ak)}}function Z(an,am,ai,al){if(!ai){if(am){X({id:am,error:{code:-32601,message:"Procedure not found."}})}return}var ak,ah;if(am){ak=function(ao){ak=q;X({id:am,result:ao})};ah=function(ao,ap){ah=q;var aq={id:am,error:{code:-32099,message:ao}};if(ap){aq.error.data=ap}X(aq)}}else{ak=ah=q}if(!r(al)){al=[al]}try{var ag=ai.method.apply(ai.scope,al.concat([ak,ah]));if(!t(ag)){ak(ag)}}catch(aj){ah(aj.message)}}return(aa={incoming:function(ah,ag){var ai=af.parse(ah);if(ai.method){if(Y.handle){Y.handle(ai,X)}else{Z(ai.method,ai.id,Y.local[ai.method],ai.params)}}else{var aj=ac[ai.id];if(ai.error){if(aj.error){aj.error(ai.error)}}else{if(aj.success){aj.success(ai.result)}}delete ac[ai.id]}},init:function(){if(Y.remote){for(var ag in Y.remote){if(Y.remote.hasOwnProperty(ag)){ad[ag]=ab(Y.remote[ag],ag)}}}aa.down.init()},destroy:function(){for(var ag in Y.remote){if(Y.remote.hasOwnProperty(ag)&&ad.hasOwnProperty(ag)){delete ad[ag]}}aa.down.destroy()}})};b.easyXDM=o})(window,document,location,window.setTimeout,decodeURIComponent,encodeURIComponent);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing easyXDM. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
// JQuery URL Parser
// Written by Mark Perkins, mark@allmarkedup.com
// License: http://unlicense.org/ (i.e. do what you want with it!)
nike.namespace('jQuery.url');

nike.requireDependency('jQuery');

jQuery.url = function()
{
	var segments = {};
	
	var parsed = {};
	
	/**
    * Options object. Only the URI and strictMode values can be changed via the setters below.
    */
  	var options = {
	
		url : window.location, // default URI is the page in which the script is running
		
		strictMode: false, // 'loose' parsing by default
	
		key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"], // keys available to query 
		
		q: {
			name: "queryKey",
			parser: /(?:^|&)([^&=]*)=?([^&]*)/g
		},
		
		parser: {
			strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,  //less intuitive, more accurate to the specs
			loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // more intuitive, fails on relative paths and deviates from specs
		}
		
	};
	
    /**
     * Deals with the parsing of the URI according to the regex above.
 	 * Written by Steven Levithan - see credits at top.
     */		
	var parseUri = function()
	{
		str = decodeURI( options.url );
		
		var m = options.parser[ options.strictMode ? "strict" : "loose" ].exec( str );
		var uri = {};
		var i = 14;

		while ( i-- ) {
			uri[ options.key[i] ] = m[i] || "";
		}

		uri[ options.q.name ] = {};
		uri[ options.key[12] ].replace( options.q.parser, function ( $0, $1, $2 ) {
			if ($1) {
				uri[options.q.name][$1] = $2;
			}
		});

		return uri;
	};

    /**
     * Returns the value of the passed in key from the parsed URI.
  	 * 
	 * @param string key The key whose value is required
     */		
	var key = function( key )
	{
		if ( jQuery.isEmptyObject(parsed) )
		{
			setUp(); // if the URI has not been parsed yet then do this first...	
		} 
		if ( key == "base" )
		{
			if ( parsed.port !== null && parsed.port !== "" )
			{
				return parsed.protocol+"://"+parsed.host+":"+parsed.port+"/";	
			}
			else
			{
				return parsed.protocol+"://"+parsed.host+"/";
			}
		}
	
		return ( parsed[key] === "" ) ? null : parsed[key];
	};
	
	/**
     * Returns the value of the required query string parameter.
  	 * 
	 * @param string item The parameter whose value is required
     */		
	var param = function( item )
	{
		if ( jQuery.isEmptyObject(parsed) )
		{
			setUp(); // if the URI has not been parsed yet then do this first...	
		}
		return ( parsed.queryKey[item] === null ) ? null : parsed.queryKey[item];
	};

    /**
     * 'Constructor' (not really!) function.
     *  Called whenever the URI changes to kick off re-parsing of the URI and splitting it up into segments. 
     */	
	var setUp = function()
	{
		parsed = parseUri();
		
		getSegments();	
	};
	
    /**
     * Splits up the body of the URI into segments (i.e. sections delimited by '/')
     */
	var getSegments = function()
	{
		var p = parsed.path;
		segments = []; // clear out segments array
		segments = parsed.path.length == 1 ? {} : ( p.charAt( p.length - 1 ) == "/" ? p.substring( 1, p.length - 1 ) : path = p.substring( 1 ) ).split("/");
	};
	
	return {
		
	    /**
	     * Sets the parsing mode - either strict or loose. Set to loose by default.
	     *
	     * @param string mode The mode to set the parser to. Anything apart from a value of 'strict' will set it to loose!
	     */
		setMode : function( mode )
		{
			options.strictMode = mode == "strict" ? true : false;
			return this;
		},
		
		/**
	     * Sets URI to parse if you don't want to to parse the current page's URI.
		 * Calling the function with no value for newUri resets it to the current page's URI.
	     *
	     * @param string newUri The URI to parse.
	     */		
		setUrl : function( newUri )
		{
			options.url = newUri === undefined ? window.location : newUri;
			setUp();
			return this;
		},		
		
		/**
	     * Returns the value of the specified URI segment. Segments are numbered from 1 to the number of segments.
		 * For example the URI http://test.com/about/company/ segment(1) would return 'about'.
		 *
		 * If no integer is passed into the function it returns the number of segments in the URI.
	     *
	     * @param int pos The position of the segment to return. Can be empty.
	     */	
		segment : function( pos )
		{
			if ( jQuery.isEmptyObject(parsed) )
			{
				setUp(); // if the URI has not been parsed yet then do this first...	
			} 
			if ( pos === undefined )
			{
				return segments.length;
			}
			return ( segments[pos] === "" || segments[pos] === undefined ) ? null : segments[pos];
		},
		
		attr : key, // provides public access to private 'key' function - see above
		
		param : param // provides public access to private 'param' function - see above
		
	};
	
}();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.url. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.util.UrlUtil');

nike.requireDependency('jQuery');
nike.requireDependency('jQuery.url');
/**
 * Handy utility to extract a get parameter from a URL.
 *
 * @param   url      The URL to parameterize
 * @param   name     The name of the GET parameter to retrieve
 *
 * @return  {String} String containing the requested value.
 */
nike.util.UrlUtil.getParameter = function(url,name)
{
  name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
  var regexS = "[\\?&]"+name+"=([^&#]*)";
  var regex = new RegExp( regexS );
  var results = regex.exec(url);
  if( results == null ) {
    return "";
  } else {
    return results[1];
  }
};


/**
 * Add the provided parameter with the provided value to the provided URL and return it.
 * This will not add the parameter if it already exists in the URL.
 *
 * TODO: I think this is pretty bad.  Someone should improve it.
 *
 * @param url
 * @param name
 * @param value
 * @returns {String}
 */
nike.util.UrlUtil.addParameter = function(url, name, value) {
  if (url.indexOf(name+'=') === -1) {
    if (url.indexOf('?') >= 0) {
      url += '&';
    } else {
      url += '?';
    }
    url += (name + '=' + encodeURIComponent(value));
  }
  return url;
};

/**
 * Handy utility to extract a specific value out of the l parameter
 *
 * @param   lValue   the value of the l parameter
 * @param   name     The name value to retrieve from the l value
 *
 * @return  {String} String containing the requested value.
 */
nike.util.UrlUtil.getLValue = function(lValue,parameterName)
{
  if(lValue.indexOf(parameterName) > 0)
  {
    // remove everything before the first index of parameter
    lValue = lValue.substring( lValue.indexOf(parameterName)+parameterName.length, lValue.length );

    // remove everything after the parameter and value
    if(lValue.indexOf('/') > 0)
    {
      lValue = lValue.substring( 0, lValue.indexOf('/'));
    }

    return lValue;

  }
  else return "";
};

// TODO: Remove the dependency on jQuery and jQuery.url from this function
nike.util.UrlUtil.getExternalReferrer = function(){
  var referrer;
  var refHost;
  var currentHost;
  var ret;


  $.url.setUrl(window.location.href);

  currentHost = getTopLevelDomain($.url.attr('host'));
  referrer = decodeURIComponent($.url.param('ref'));

  if(referrer == 'undefined' || referrer == undefined || referrer.length == 0){
    var docref = document.referrer;
    nike.log('No existing referrer found so pulling it off the document: '+docref);
    referrer = docref;
  } else {
    nike.log('Using the referrer found on the page already: '+referrer);
  }

  if (referrer) {
    $.url.setUrl(referrer);
    refHost = getTopLevelDomain($.url.attr('host'));
    if(refHost != currentHost){
      ret = referrer;
    } else {
      nike.log('The referrer ('+referrer+') was found to be on the same top level domain as the current request, so skipping it.');
    }
  } else {
    nike.log('No document referrer found.');
  }

  if (ret == undefined || ret == 'undefined'){
    ret = '';
  }

  return ret;

  /*
   * Only return last two sections of domain
   * Ex: store.nike.com returns nike.com
   */
  function getTopLevelDomain(host){
    var hostParts;
    var ret = '';
    if(host != null && host !== undefined){
      hostParts = host.split('.');
      if(hostParts.length > 2 ){
        ret = hostParts[hostParts.length - 2] + '.' + hostParts[hostParts.length - 1];
      }
      else{
        ret = host;
      }
    }
    return ret;
  }
};

nike.util.UrlUtil.parseUrlParams = function(queryToParse, params){
  var i, L;
  var query = stripStartOfQuery(queryToParse);
  var queryParts;

  if(query.length > 0){
    queryParts = query.split('&');
    for(i = 0, L = queryParts.length; i < L; i++){
      var nvPair = queryParts[i].split("=");
      if(nvPair.length == 2){
        params[decodeURIComponent(nvPair[0])] = decodeURIComponent(nvPair[1]);
      }
    }
  }

  /*
   * This will strip the hash or question mark from the front of the query
   * It will handle the case where there is more than one special char at the start of the query (ie #?l=someParam -> l=someParam)
   * Generally we should probably just strip the first char, but our history stuff that uses the hash for old browsers seems to add
   * the ? after the hash, so we do this to be on the safe side.
   */
  function stripStartOfQuery(queryString){
    var ret = '';
    var queryIndex = 0;
    var length = queryString != undefined ? queryString.length : 0;
    if(length > 0){
      while(queryIndex < length &&
            (queryString.charAt(queryIndex) === '?' ||
                queryString.charAt(queryIndex) === '#') ){
        queryIndex++;
      }
      if(queryIndex < length){
        ret = queryString.substring(queryIndex);
      }
    }
    return ret;
  }
};

/**
 * Take a string and attempt to parse it as a query string
 * placing the key/value pairs in an Object
 *
 * @param {String} queryString String to parse
 *
 * @return {Object} representing a map of key/value pairs
 */
nike.util.UrlUtil.getQueryStringParams = function(queryString) {
  var ret = {};
  var query = queryString.substring(queryString.indexOf('?') + 1);
  var parts = query.split('&');

  // Replace each piece of the queryString with its new value
  for (var i = 0; i < parts.length; i++) {
    var keyValue = parts[i].split('=');
    ret[keyValue[0]] = keyValue[1];
  }
  return ret;
};




/**
 * Get the path component of the url.  If there isn't one, return an empty string.
 * @param url The url to search for a path
 */
nike.util.UrlUtil.getPath = function(url){
  var ret = "";
  //Find the first index of ? and # and get everything up to the index of whichever is found first
  var queryStart = url.indexOf('?');
  var hashStart = url.indexOf('#');
  var endOfPath = url.length;
  var firstSlashIndex = -1;

  if(queryStart > 0 && hashStart > 0){
    endOfPath = queryStart < hashStart ? queryStart : hashStart;
  } else if (queryStart > 0){
    endOfPath = queryStart;
  } else if (hashStart > 0){
    endOfPath = hashStart;
  }


  ret = url.substring(0, endOfPath);

  //Now remove the protocol and strip the host by looking for the first forward slash
  ret = ret.replace(/(https?:)?\/\//i, '');
  firstSlashIndex = ret.indexOf('/');
  if(firstSlashIndex > 0){
    ret = ret.substring(firstSlashIndex);
  } else {
    ret = "";
  }

  return ret;
};

/**
 * This will build the query param for the url path without the country/lang_locale/
 * Ex. http://store.nike.com/us/en_us/pw/slugName/hashName/?someQuery=something -> path=pd/slugName/hashName/
 *
 */
nike.util.UrlUtil.buildPathParam = function(url){
  var ret = "";
  var PATH_PARAM_NAME = "path";
  var path = "";
  var pathMatch;
  //This will only capture the path after the country/lang_locale.  If there isn't a country/lang_locale, it will capture the whole path
  var extractPathRegex = new RegExp('(?:/[a-z]{2}/[a-z]{2}_[a-z]{2})?/(.*)', 'i');

  if(url && url.length > 0){
    path = nike.util.UrlUtil.getPath(url);
    if(path && path.length > 0){
      pathMatch = extractPathRegex.exec(path);

      //check that there was a match and that the part of the path we're interested in isn't empty
      if(pathMatch != null && pathMatch.length == 2 && pathMatch[1].length > 0){
        ret = PATH_PARAM_NAME + "=" + pathMatch[1];
      }
    }
  }

  return ret;
};


/**
 * Get the root url for an app with the country
 * and locale added to the path
 * @returns {String}
 */
nike.util.UrlUtil.getLocalizedRootUrl = function() {
  var ret = nike.getServiceUrl("baseStoreURL") +
            nike.COUNTRY.toLowerCase() + '/' +
            nike.LOCALE.toLowerCase() + '/';
  return ret;
};

/**
 * Get the value of a given parameter key in a given URL
 * @param url
 * @param param
 * @returns {String}
 */
nike.util.UrlUtil.getParameterValue = function (url, param) {
  var queryParams = nike.util.UrlUtil.getQueryStringParams(url);
  return queryParams[param];
};

/**
 * Sets the value of a parameter in a URL
 * @param url
 * @param paramKey
 * @param paramValue
 * @returns {String}
 */
nike.util.UrlUtil.setParameterValue = function (url, paramKey, paramValue) {
  var updatedURL = '';

  if (url) {
    var baseURL = url.split('?')[0];
    var queryParams = nike.util.UrlUtil.getQueryStringParams(url);
    var paramKeyValuePairs = [];
    var queryString;

    if (queryParams[paramKey]) {
      //replace the value of the paramKey if it exists
      queryParams[paramKey] = paramValue;
    } else {
      //add the paramKey and value to the URL if it doesn't already exist
      var newParam = {};
      newParam[paramKey] = paramValue;

      $.extend(queryParams, newParam);
    }

    //Building the query string
    for (var index in queryParams) {
      if (queryParams[index]) {
        paramKeyValuePairs[paramKeyValuePairs.length] = encodeURIComponent(index)
                                                      + "="
                                                      + encodeURIComponent(queryParams[index]);
      }
    }

    queryString = decodeURIComponent(paramKeyValuePairs.join('&'));

    updatedURL = baseURL + '?' + queryString;
  }

  return updatedURL;
};

/**
 * Removes parameter from a url
 * @param {String} url - The URL we want to remove a parameter from.
 * @param {String} parameter - The parameter we want removed.
 * @returns {String}
 */
nike.util.UrlUtil.removeURLParameter = function (url, parameter) {
  if (url) {
    var match = url.match(new RegExp('(?:\\?|&)' + parameter + '=[^&]+'));

    if (match) {
      url = url.replace(match[0], '');
    }

    if (url.indexOf('?') == -1) {
      url = url.replace('&', '?');
    }
  }

  return url;
};

/**
 * Checks if the passed url is from this application.
 * @param {String} url - url to test for nike.com, nikedev.com
 * @returns {boolean}
 */
nike.util.UrlUtil.isNikeDomain = function (url) {
  // get either nikedev.com or nike.com
  var domain = nike.getRootUrl().split(".").slice(1,3).join(".").replace("/", "");
  var ret = typeof url === "string" ? (url.split(".").slice(1,3).join(".").indexOf(domain) === 0) : false;
  return ret;
}

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.util.UrlUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/* Modernizr 2.6.1 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-flexbox_legacy-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-websockets-websqldatabase-webworkers-geolocation-inlinesvg-smil-svg-svgclippaths-touch-webgl-shiv-mq-cssclasses-addtest-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-css_boxsizing-css_displaytable-css_overflow_scrolling-load
 */
;



window.Modernizr = (function( window, document, undefined ) {

    var version = '2.6.1',

        Modernizr = {},

        enableClasses = true,

        docElement = document.documentElement,

        mod = 'modernizr',
        modElem = document.createElement(mod),
        mStyle = modElem.style,

        inputElem  = document.createElement('input')  ,

        smile = ':)',

        toString = {}.toString,

        prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



        omPrefixes = 'Webkit Moz O ms',

        cssomPrefixes = omPrefixes.split(' '),

        domPrefixes = omPrefixes.toLowerCase().split(' '),

        ns = {'svg': 'http://www.w3.org/2000/svg'},

        tests = {},
        inputs = {},
        attrs = {},

        classes = [],

        slice = classes.slice,

        featureName,


        injectElementWithStyles = function( rule, callback, nodes, testnames ) {

            var style, ret, node,
                div = document.createElement('div'),
                body = document.body,
                fakeBody = body ? body : document.createElement('body');

            if ( parseInt(nodes, 10) ) {
                while ( nodes-- ) {
                    node = document.createElement('div');
                    node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
                    div.appendChild(node);
                }
            }

            style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
            div.id = mod;
            (body ? div : fakeBody).innerHTML += style;
            fakeBody.appendChild(div);
            if ( !body ) {
                fakeBody.style.background = "";
                docElement.appendChild(fakeBody);
            }

            ret = callback(div, rule);
            !body ? fakeBody.parentNode.removeChild(fakeBody) : div.parentNode.removeChild(div);

            return !!ret;

        },

        testMediaQuery = function( mq ) {

            var matchMedia = window.matchMedia || window.msMatchMedia;
            if ( matchMedia ) {
                return matchMedia(mq).matches;
            }

            var bool;

            injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
                bool = (window.getComputedStyle ?
                        getComputedStyle(node, null) :
                        node.currentStyle)['position'] == 'absolute';
            });

            return bool;

        },


        isEventSupported = (function() {

            var TAGNAMES = {
                'select': 'input', 'change': 'input',
                'submit': 'form', 'reset': 'form',
                'error': 'img', 'load': 'img', 'abort': 'img'
            };

            function isEventSupported( eventName, element ) {

                element = element || document.createElement(TAGNAMES[eventName] || 'div');
                eventName = 'on' + eventName;

                var isSupported = eventName in element;

                if ( !isSupported ) {
                    if ( !element.setAttribute ) {
                        element = document.createElement('div');
                    }
                    if ( element.setAttribute && element.removeAttribute ) {
                        element.setAttribute(eventName, '');
                        isSupported = is(element[eventName], 'function');

                        if ( !is(element[eventName], 'undefined') ) {
                            element[eventName] = undefined;
                        }
                        element.removeAttribute(eventName);
                    }
                }

                element = null;
                return isSupported;
            }
            return isEventSupported;
        })(),


        _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
        hasOwnProp = function (object, property) {
            return _hasOwnProperty.call(object, property);
        };
    }
    else {
        hasOwnProp = function (object, property) {
            return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
        };
    }


    if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {

            var target = this;

            if (typeof target != "function") {
                throw new TypeError();
            }

            var args = slice.call(arguments, 1),
                bound = function () {

                    if (this instanceof bound) {

                        var F = function(){};
                        F.prototype = target.prototype;
                        var self = new F();

                        var result = target.apply(
                            self,
                            args.concat(slice.call(arguments))
                        );
                        if (Object(result) === result) {
                            return result;
                        }
                        return self;

                    } else {

                        return target.apply(
                            that,
                            args.concat(slice.call(arguments))
                        );

                    }

                };

            return bound;
        };
    }

    function setCss( str ) {
        mStyle.cssText = str;
    }

    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    function is( obj, type ) {
        return typeof obj === type;
    }

    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }

    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }

    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                if (elem === false) return props[i];

                if (is(item, 'function')){
                    return item.bind(elem || obj);
                }

                return item;
            }
        }
        return false;
    }

    function testPropsAll( prop, prefixed, elem ) {

        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

        if(is(prefixed, "string") || is(prefixed, "undefined")) {
            return testProps(props, prefixed);

        } else {
            props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
            return testDOMProps(props, prefixed, elem);
        }
    }    tests['flexbox'] = function() {
        return testPropsAll('flexWrap');
    };    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    };

    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    };



    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    };


    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
            bool = true;
        } else {
            injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
                bool = node.offsetTop === 9;
            });
        }

        return bool;
    };



    tests['geolocation'] = function() {
        return 'geolocation' in navigator;
    };


    tests['postmessage'] = function() {
        return !!window.postMessage;
    };


    tests['websqldatabase'] = function() {
        return !!window.openDatabase;
    };

    tests['indexedDB'] = function() {
        return !!testPropsAll("indexedDB", window);
    };

    tests['hashchange'] = function() {
        return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    };

    tests['history'] = function() {
        return !!(window.history && history.pushState);
    };

    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
    };

    tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
    };


    tests['rgba'] = function() {
        setCss('background-color:rgba(150,255,150,.5)');

        return contains(mStyle.backgroundColor, 'rgba');
    };

    tests['hsla'] = function() {
        setCss('background-color:hsla(120,40%,100%,.5)');

        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    };

    tests['multiplebgs'] = function() {
        setCss('background:url(https://),url(https://),red url(https://)');

        return (/(url\s*\(.*?){3}/).test(mStyle.background);
    };    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    };

    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    };



    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    };

    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    };

    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    };


    tests['opacity'] = function() {
        setCssAll('opacity:.55');

        return (/^0.55$/).test(mStyle.opacity);
    };


    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    };


    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    };


    tests['cssgradients'] = function() {
        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';

        setCss(
            (str1 + '-webkit- '.split(' ').join(str2 + str1) +
             prefixes.join(str3 + str1)).slice(0, -str1.length)
        );

        return contains(mStyle.backgroundImage, 'gradient');
    };


    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    };


    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    };


    tests['csstransforms3d'] = function() {

        var ret = !!testPropsAll('perspective');

        if ( ret && 'webkitPerspective' in docElement.style ) {

            injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
                ret = node.offsetLeft === 9 && node.offsetHeight === 3;
            });
        }
        return ret;
    };


    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    };



    tests['fontface'] = function() {
        var bool;

        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function( node, rule ) {
            var style = document.getElementById('smodernizr'),
                sheet = style.sheet || style.styleSheet,
                cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';

            bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });

        return bool;
    };

    tests['generatedcontent'] = function() {
        var bool;

        injectElementWithStyles(['#modernizr:after{content:"',smile,'";visibility:hidden}'].join(''), function( node ) {
            bool = node.offsetHeight >= 1;
        });

        return bool;
    };
    tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('video/ogg; codecs="theora"')      .replace(/^no$/,'');

                bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"') .replace(/^no$/,'');

                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');
            }

        } catch(e) { }

        return bool;
    };

    tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
                bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');

                bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
                bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                              elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
            }
        } catch(e) { }

        return bool;
    };


    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };


    tests['webworkers'] = function() {
        return !!window.Worker;
    };


    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    };


    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    };

    tests['inlinesvg'] = function() {
        var div = document.createElement('div');
        div.innerHTML = '<svg/>';
        return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    };

    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    };


    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    };

    function webforms() {
        Modernizr['input'] = (function( props ) {
            for ( var i = 0, len = props.length; i < len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
                attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
        Modernizr['inputtypes'] = (function(props) {

            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {

                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';

                if ( bool ) {

                    inputElem.value         = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                    if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {

                        docElement.appendChild(inputElem);
                        defaultView = document.defaultView;

                        bool =  defaultView.getComputedStyle &&
                                defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                                (inputElem.offsetHeight !== 0);

                        docElement.removeChild(inputElem);

                    } else if ( /^(search|tel)$/.test(inputElemType) ){
                    } else if ( /^(url|email)$/.test(inputElemType) ) {
                        bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                    } else {
                        bool = inputElem.value != smile;
                    }
                }

                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
    }
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
            featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }

    Modernizr.input || webforms();


    Modernizr.addTest = function ( feature, test ) {
        if ( typeof feature == 'object' ) {
            for ( var key in feature ) {
                if ( hasOwnProp( feature, key ) ) {
                    Modernizr.addTest( key, feature[ key ] );
                }
            }
        } else {

            feature = feature.toLowerCase();

            if ( Modernizr[feature] !== undefined ) {
                return Modernizr;
            }

            test = typeof test == 'function' ? test() : test;

            if (enableClasses) {
                docElement.className += ' ' + (test ? '' : 'no-') + feature;
            }
            Modernizr[feature] = test;

        }

        return Modernizr;
    };


    setCss('');
    modElem = inputElem = null;

    ;(function(window, document) {
        var options = window.html5 || {};

        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

        var saveClones = /^<|^(?:a|b|button|code|div|fieldset|form|h1|h2|h3|h4|h5|h6|i|iframe|img|input|label|li|link|ol|option|p|param|q|script|select|span|strong|style|table|tbody|td|textarea|tfoot|th|thead|tr|ul)$/i;

        var supportsHtml5Styles;

        var expando = '_html5shiv';

        var expanID = 0;

        var expandoData = {};

        var supportsUnknownElements;

        (function() {
            try {
                var a = document.createElement('a');
                a.innerHTML = '<xyz></xyz>';
                supportsHtml5Styles = ('hidden' in a);

                supportsUnknownElements = a.childNodes.length == 1 || (function() {
                    (document.createElement)('a');
                    var frag = document.createDocumentFragment();
                    return (
                        typeof frag.cloneNode == 'undefined' ||
                        typeof frag.createDocumentFragment == 'undefined' ||
                        typeof frag.createElement == 'undefined'
                        );
                }());
            } catch(e) {
                supportsHtml5Styles = true;
                supportsUnknownElements = true;
            }

        }());        function addStyleSheet(ownerDocument, cssText) {
            var p = ownerDocument.createElement('p'),
                parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

            p.innerHTML = 'x<style>' + cssText + '</style>';
            return parent.insertBefore(p.lastChild, parent.firstChild);
        }

        function getElements() {
            var elements = html5.elements;
            return typeof elements == 'string' ? elements.split(' ') : elements;
        }

        function getExpandoData(ownerDocument) {
            var data = expandoData[ownerDocument[expando]];
            if (!data) {
                data = {};
                expanID++;
                ownerDocument[expando] = expanID;
                expandoData[expanID] = data;
            }
            return data;
        }

        function createElement(nodeName, ownerDocument, data){
            if (!ownerDocument) {
                ownerDocument = document;
            }
            if(supportsUnknownElements){
                return ownerDocument.createElement(nodeName);
            }
            if (!data) {
                data = getExpandoData(ownerDocument);
            }
            var node;

            if (data.cache[nodeName]) {
                node = data.cache[nodeName].cloneNode();
            } else if (saveClones.test(nodeName)) {
                node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
            } else {
                node = data.createElem(nodeName);
            }

            return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
        }

        function createDocumentFragment(ownerDocument, data){
            if (!ownerDocument) {
                ownerDocument = document;
            }
            if(supportsUnknownElements){
                return ownerDocument.createDocumentFragment();
            }
            data = data || getExpandoData(ownerDocument);
            var clone = data.frag.cloneNode(),
                i = 0,
                elems = getElements(),
                l = elems.length;
            for(;i<l;i++){
                clone.createElement(elems[i]);
            }
            return clone;
        }

        function shivMethods(ownerDocument, data) {
            if (!data.cache) {
                data.cache = {};
                data.createElem = ownerDocument.createElement;
                data.createFrag = ownerDocument.createDocumentFragment;
                data.frag = data.createFrag();
            }


            ownerDocument.createElement = function(nodeName) {
                if (!html5.shivMethods) {
                    return data.createElem(nodeName);
                }
                return createElement(nodeName, ownerDocument, data);
            };

            ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
                                                                   'var n=f.cloneNode(),c=n.createElement;' +
                                                                   'h.shivMethods&&(' +
                                                                   getElements().join().replace(/\w+/g, function(nodeName) {
                                                                       data.createElem(nodeName);
                                                                       data.frag.createElement(nodeName);
                                                                       return 'c("' + nodeName + '")';
                                                                   }) +
                                                                   ');return n}'
            )(html5, data.frag);
        }        function shivDocument(ownerDocument) {
            if (!ownerDocument) {
                ownerDocument = document;
            }
            var data = getExpandoData(ownerDocument);

            if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
                data.hasCSS = !!addStyleSheet(ownerDocument,
                    'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}' +
                    'mark{background:#FF0;color:#000}'
                );
            }
            if (!supportsUnknownElements) {
                shivMethods(ownerDocument, data);
            }
            return ownerDocument;
        }        var html5 = {

            'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video',

            'shivCSS': (options.shivCSS !== false),

            'supportsUnknownElements': supportsUnknownElements,

            'shivMethods': (options.shivMethods !== false),

            'type': 'default',

            'shivDocument': shivDocument,

            createElement: createElement,

            createDocumentFragment: createDocumentFragment
        };        window.html5 = html5;

        shivDocument(document);

    }(this, document));

    Modernizr._version      = version;

    Modernizr._prefixes     = prefixes;
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;

    Modernizr.mq            = testMediaQuery;

    Modernizr.hasEvent      = isEventSupported;

    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };

    Modernizr.testAllProps  = testPropsAll;


    Modernizr.testStyles    = injectElementWithStyles;
    Modernizr.prefixed      = function(prop, obj, elem){
        if(!obj) {
            return testPropsAll(prop, 'pfx');
        } else {
            return testPropsAll(prop, obj, elem);
        }
    };


    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +

                           (enableClasses ? ' js ' + classes.join(' ') : '');

    return Modernizr;

})(this, this.document);
/*yepnope1.5.4|WTFPL*/
(function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}})(this,document);
Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0));};

// developer.mozilla.org/en/CSS/box-sizing
// github.com/Modernizr/Modernizr/issues/248

Modernizr.addTest("boxsizing",function(){
    return Modernizr.testAllProps("boxSizing") && (document.documentMode === undefined || document.documentMode > 7);
});



// johanbrook.com/browsers/native-momentum-scrolling-ios-5/
// introduced in iOS5b2. Possible API may change...

Modernizr.addTest("overflowscrolling",function(){
    return Modernizr.testAllProps("overflowScrolling");
});


// display: table and table-cell test. (both are tested under one name "table-cell" )
// By @scottjehl

// all additional table display values are here: http://pastebin.com/Gk9PeVaQ though Scott has seen some IE false positives with that sort of weak detection.
// more testing neccessary perhaps.

Modernizr.addTest( "display-table",function(){

    var doc   = window.document,
        docElem = doc.documentElement,
        parent  = doc.createElement( "div" ),
        child = doc.createElement( "div" ),
        childb  = doc.createElement( "div" ),
        ret;

    parent.style.cssText = "display: table";
    child.style.cssText = childb.style.cssText = "display: table-cell; padding: 10px";

    parent.appendChild( child );
    parent.appendChild( childb );
    docElem.insertBefore( parent, docElem.firstChild );

    ret = child.offsetLeft < childb.offsetLeft;
    docElem.removeChild(parent);
    return ret;
});

;
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing Modernizr. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.EventBus');

nike.requireDependency('jQuery');


(function (nike) {

  var deferredBusMap = {};

  nike.EventBus = $.extend(nike.EventBus, {

    /**
     * Attach an event listener that will be called when
     * the event is dispatched
     *
     * @param event String name of event to listen for
     * @param listener Function to call when the event is fired
     */
    listen  : function(event, listener) {
      var events = typeof event == 'string' ? [event] : event;
      for (var i = 0, L = events.length; i < L; i++) {
        $(nike.global).bind(events[i], listener);
      }
    },

    /**
     * Removes a specific listener
     *
     * @param event String name of event to remove listener for
     * @param listener Named function that is a listener
     */
    unlisten  : function(event, listener) {
      var events = typeof event == 'string' ? [event] : event;

      if(events){
        for (var i = 0, L = events.length; i < L; i++) {
          $(nike.global).unbind(events[i], listener);
        }
      }
    },

    /**
     * Lets you know if an Event is already being listened to.
     * If you pass a callback, it will see if the event you passed is being listened to by this callback.
     * @param {String} originalEvent - Something like 'nike.Event.SOME_NAME'.
     * @param {Function} [callback] - The handler for the event.
     * @return {Boolean}
     */
    hasListener : function(originalEvent, callback){
      var hasIt = false;
      $.each($(nike.global).data('events'), function(i, event){
        $.each(event, function(i, eventObj){
          if (callback) {
            if (callback === eventObj.handler && eventObj.type === originalEvent) {
              hasIt = true;
              return false;
            }
          } else if (eventObj.type === originalEvent) {
            hasIt = true;
            return false;
          }
        });
      });
      return hasIt;
    },

    /**
     *
     * @param event
     * @param listener
     */
    deferredListen : function deferredListen (event, listener) {
      if(!event) {
        nike.error("blah");
        return;
      } else if (!deferredBusMap[event]) {
        deferredBusMap[event] = $.Callbacks('unique');
      }

      // TODO: This may change to a listener that has a try/catch inside of it to avoid
      // breaking the bus for future events.  It would then need to return the new listener
      // to allow the unlisten and hasListener methods to work.
      deferredBusMap[event].add(listener);
    },

    deferredUnlisten : function deferredUnlisten (event, listener) {
      if(event && deferredBusMap[event]) {
        deferredBusMap[event].remove(listener);
      }
    },

    deferredHasListener : function deferredHasListener (event, listener) {
      return event && deferredBusMap[event] && deferredBusMap[event].has(listener);
    },

    /**
     * Dispatch an event that will call all listeners
     *
     * @param event String name of event to remove listener for
     * @param [data] Any object to be passed to the event listeners
     */
    dispatchEvent  : function(event, data) {
      if( data ){
        nike.eventLog(event + ' - DATA: ', data);
      }else{
        nike.eventLog(event);
      }

      // if the performance api exists, mark the event
      if(window.performance && window.performance.mark) {
        var markName = event;
        var sep = '_';
        switch(event) {
          case nike.EVENT_GADGET_LOADED:
            markName += sep + data.gadgetName;
            break;
          case nike.EVENT_EXTERNAL_RESOURCES_LOADED:
            if(data.resourcesLoaded) {
              markName += sep + data.resourcesLoaded.join('-');
            }
            break;
          default:
            markName = event;
        }
        window.performance.mark(markName);
      }

      $(nike.global).trigger(event, data);
      if(event && deferredBusMap[event]) {
        setTimeout(function () {
          deferredBusMap[event].fire(event, data);
        }, 0);
      }
    },


    /**
     * Checks the 'data-listens' attribute of an element to
     * determine if it listens to another gadget with a given
     * ID.  If no data-listens property is present it will listen
     * to all elements.
     *
     * @param elementListens jQuery selector to test if listens
     * @param elementListenTo jQuery selector to test if listens to
     */
    gadgetListensTo  : function(elementListens, elementListenTo) {
      var listens = $(elementListens).data('listen');

      // If there is no data-listen attribute or no elementListenTo return true
      if (!listens || !elementListenTo) {
        return true;
      }
      else {
        var items = listens.split(',');
        for (var i = 0; i < items.length; i++) {
          if (items[i] == $(elementListenTo).attr('id')) {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Find all gadgets of the type specified by gadgetName and run
     * a function on each one that listens to the element given.
     *
     * @param gadgetName Name of gadgets to find
     * @param element jQuery selector to test if listening to
     * @param call Function to call on each element listening to 'element' events
     */
    gadgetListensToEach : function(gadgetName, element, call) {
      if (gadgetName && call) {
        $('div[data-gadget="' + gadgetName + '"]').each(function() {
          var gadget = $(this);
          if (nike.EventBus.gadgetListensTo(gadget, element)) {
            call.call($(this));
          }
        });
      }
    }
  });
})(nike);

//Add methods to nike object to ensure backwards compatibility
$.extend(nike, nike.EventBus);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.EventBus. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.ScriptLoader');


/**
 * Make sure external dependencies are
 * required: jQuery and easyXDM
 */
nike.requireDependency('JSON');
nike.requireDependency('jQuery');
nike.requireDependency('easyXDM');
nike.requireDependency('jQuery.url');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('Modernizr');
nike.requireDependency('nike.EventBus');



nike.ScriptLoader = $.extend(nike.ScriptLoader,
/** @lends nike */
{
  /**
   * Type for script tags to indicate the list of scripts contained should be lazy loaded by the script manager.
   * The script contents should be a json array of the asset names to load.
   * Script contents may also define data-script-type "internal" or "external".  If the attribute is omitted, internal is the default
   * This will determine how the scripts are loaded:
   *   internal = nike.requestScripts
   *   external = nike.loadExternalScripts
   *   inline = eval the script - some people will say this is bad, but i think it's fine... so there..I'm doing it because in need to control the timing of inline script execution. im open to suggestions...
   *
   */
  LAZY_LOAD_SCRIPT_TYPE : 'lazy-load-js',
  SCRIPT_TYPE_INTERNAL : 'internal',
  SCRIPT_TYPE_EXTERNAL : 'external',
  SCRIPT_TYPE_INLINE : 'inline',
  GADGET_LOADING : 'gadget-loading',

  /**
   * Text that should precede and logged text.
   * @type {String}
   */
  LOG_PREFIX: '[ScriptLoader]',

  /**
   * scriptsToInclude is declared and populated by GadgetAssetResolverUtil.java
   */
  scriptsToInclude : [],

  /**
   * scriptsToInclude is declared and populated by GadgetAssetResolverUtil.java
   */
  stylesToInclude : [],

  /**
   * Init loaded scripts array
   */
  loadedScripts : [],

  /**
   * List of script arrays to chain together.  These scripts will be looked up on the page by finding any script tag with the type defined by nike.LAZY_LOAD_SCRIPT_TYPE
   * Each script or set of scripts will be requested and loaded before the next set is requested and loaded.
   */
  lazyLoadScriptQueue : [],

  /**
   * The external scripts or css that has been loaded so far
   */
  loadedExternalResources : [],

  /**
   *  Script type for requests - this can be setup via the url param 'format'
   *  Allowed values:
   *  OPTIMIZED, //Single minified asset with all dependencies
   *  RAW, //Single unminified asset with all dependencies.
   *  INCLUDE, //Return a script that adds Script or link elements to the beginning of the body for requested assets and all dependencies. Generally doesn't work.
   *  NO_DEPS  //Return unminified asset without any dependencies
   */
  format : jQuery.url.param('format') || 'optimized',

  /**
   *  Whether or not to show the SF key names or their values
   */
  showFurnitureKeys : jQuery.url.param('showFurnitureKeys') || null,

  /**
   * Indicates if the script and all of its initially requested dependencies
   * have completed loading.  If the format is not 'include' this will be true
   * as soon as this file has loaded. Otherwise it will wait for each included
   * script to complete before setting this to true;
   */
  scriptManagerLoadComplete : false,

  /**
   * Indicates that script inserted with form=include have all been inserted
   * into the page.  This flag may be reset if more scripts are loaded.
   */
  scriptIncludeLoadStart: false,

  /**
   * API/Gadget URL for scripts
   *
   * @param {String} appName The application you need the URL built for.
   * @return {String} The URL to load scripts
   */
  getScriptUrl : function() {
    return nike.getRootUrl() + nike.COUNTRY.toLowerCase() + '/' + nike.LOCALE.toLowerCase() + '/script.js';
  },

  /**
   * API/Gadget URL for styles
   *
   * @param {String} appName
   * @return {String}
   */
  getStyleUrl : function(appName) {
    return nike.getRootUrl() + 'style.css';
  },

  /**
   * Gadget content URL
   */
  getGadgetUrl : function() {
    return nike.getRootUrl() + nike.COUNTRY.toLowerCase() + '/' + nike.LOCALE.toLowerCase() + '/' + nike.DEFAULT_APP_NAME +
           '/gadget';
  },

  /**
   * Cross domain endpoint URL
   */
  getEndpointUrl  : function(appName) {
    return nike.getRootUrl() + 'common/content/endpoint.html';
  },

  /**
   * Cross domain endpoint URL for SSL
   */
  getSecureEndpointUrl  : function(appName) {
    return nike.getSecureRootUrl() + 'common/content/endpoint.html';
  },

  /**
   * Cross domain FlashTransport swf URL
   */
  getFlashTransportUrl : function(appName) {
    return nike.getRootUrl() + 'common/content/easyxdm.swf';
  },

  /**
   * Cross domain FlashTransport swf URL for SSL
   */
  getSecureFlashTransportUrl : function(appName) {
    return nike.getSecureRootUrl() + 'common/content/easyxdm.swf';
  },


  /**
   * Map of tunnels for easyXDM calls indexed
   * by host name
   */
  xdmTunnels:{},

  /**
   * Parse out the domain and protocol of the
   * URL to use as the key for tunnels
   *
   * @param url
   * @param makeSecure Boolean indicating if the
   *        URL needs to be https
   */
  getXdmTunnelKey: function(url, makeSecure){
    var key;
    var parts = jQuery.url.setUrl(url);
    var protocol = makeSecure ? 'https' : parts.attr('protocol');
    var port = parts.attr('port') ? ':' + parts.attr('port') : '';
    key = protocol + '://' + parts.attr('host') + port;
    return key;
  },

  /**
   * Indicates an easyXDM tunnel will be needed
   * for a given URL and should be setup if it
   * doesn't already exist
   *
   * @param url URL that requires easyXDM
   * @param remote
   */
  requireTunnelForUrl: function(url, remote){
    var key = nike.ScriptLoader.getXdmTunnelKey(url);
    if (!nike.ScriptLoader.xdmTunnels[key]){
      nike.ScriptLoader.xdmTunnels[key] = nike.ScriptLoader.createXDMTunnel(url, remote);
    }
  },


  /**
   * Create tunnels for each app that is needed by the gadgets
   * on the page.  Will only create secure tunnels if
   * nike.SSL_ONLY is true.
   */
  setupXDMTunnels : function() {
    var i;
    var L;
    var appName;
    var key;
    var gadgetUrl;

    gadgetUrl = nike.ScriptLoader.getGadgetUrl();
    key = nike.ScriptLoader.getXdmTunnelKey(gadgetUrl, nike.SSL_ONLY);

    // Don't add the tunnel if it has already been setup
    if (!nike.ScriptLoader.xdmTunnels[key]){
      nike.ScriptLoader.xdmTunnels[key] = nike.ScriptLoader.createXDMTunnel(gadgetUrl);
    }

  },


  /**
   * Create an easyXDM tunnel for the appName given
   *
   * @param url URL to setup a tunnel to
   * @param remote The path, including filename, of the remote file on the url. Defaults to /common/content/endpoint.html
   * @return The easyXDM Rpc object for making requests
   */
  createXDMTunnel: function(url, remote){
    var endpointUrl;
    var flashTransportUrl;
    var tunnel;
    var baseUrl = nike.ScriptLoader.getXdmTunnelKey(url); // The key is the baseUrl to the domain

    var path = "";
    if (remote)	{
      if (remote.indexOf('/') != 0) {
        remote = '/' + remote;
      }

      var pathEnds = remote.lastIndexOf('/');
      path = remote.substring(0, pathEnds + 1);
    }
    else {
      path = "/common/content/";
      remote = path + "endpoint.html";
    }


    // Get secure or regular URLs
    endpointUrl = baseUrl + remote;
    flashTransportUrl = baseUrl + path + 'easyxdm.swf';
    tunnel = new easyXDM.Rpc({
      hash: true,
      swf: flashTransportUrl,
      remote: endpointUrl
    }, {
      remote: {
        request: {},
        getImageData: {}
      }
    });
    return tunnel;
  },

  /**
   * Make an ajax request through the easyXDMRpc object
   * provided.  This should only be used internally by
   * nike.ScriptLoader.request().
   *
   * @param easyXDMRpc The easyXDM RPC object to use
   * @param params Parameters to the request e.g. {url:'url', method:'GET'}
   * @param success Success callback
   * @param error Error callback
   */
  makeXDMRequest  : function(easyXDMRpc, params, success, error) {
    params.timeout = params.timeout || 30000;
    easyXDMRpc.request(params, success || nike.emptyFn(), error || nike.error);
  },

  /**
   * Make an ajax call using the default RPC
   * object (may be http or https)
   *
   * @param params Parameters to the request e.g. {url:'url', method:'GET'}
   * @param success Success callback
   * @param error Error callback
   */
  request : function(params, success, error) {
    // Use URL to find appropriate tunnel
    var url = params.url,
        key,
        tunnel;

    // Ensure that a tunnel has been created for this domain
    nike.ScriptLoader.requireTunnelForUrl(url);

    key = nike.ScriptLoader.getXdmTunnelKey(url);
    tunnel = nike.ScriptLoader.xdmTunnels[key];

    // Error if tunnel not setup
    if (!tunnel){
      nike.error('Could not find tunnel for request - URL: ' + url + ' - Call nike.ScriptLoader.requireTunnelForUrl');
    }
    else{
      var successInterceptFn = function(){
          success.apply(this, arguments)
      };

        var errorInterceptFn = function(){
          error.apply(this, arguments)
      };

      // Make request
      nike.ScriptLoader.makeXDMRequest(tunnel, params, successInterceptFn, errorInterceptFn);
    }
  },

  /**
   * Generic CORS method.
   *
   * If request url has the same host as the page, then do normal request.
   *
   * Browser support (http://caniuse.com/#feat=cors)
   * This will auto fail under the following conditions:
   * 	1) Browser is Opera with version less than 12.
   * 	2) Browser is Internet Explorer version less than 8.
   * 	3) Browser is Internet Explorer and attempt to make non-simple request.
   * 		TODO : adjust this for IE10 which should provide full support.
   *
   * A non-simple request is the following:
   * 	1) withCredentials flag is set, to send things like cookies.
   * 	2) Any custom headers are set.
   * 	3) Request type is no 'GET' or 'POST', jQuery.ajax will default to 'GET'.
   *
   * When auto fail happens the error function will be passed no arguments.
   *
   * @param  params		This is the same Object passed into JQuery.ajax method.  (http://api.jquery.com/jQuery.ajax/)
   * 					The xhr property will be set inside this method, so do not set in params map.
   */
  requestCORS : function (params) {
	  //If request url is from same host, then perform regular request.
	  if (
			  params.url.indexOf(window.location.host) >= 0 &&
			  ((params.url.indexOf('http') == 0 && params.url.indexOf(window.location.host) < 8) ||
			  params.url.indexOf(window.location.host) == 0)
		) {
		  $.ajax(params);
		  return;
	  }
	  //Auto fail check
	  if (
			(
			  (//Things that make a non-simple CORS request
				 (params.xhrFields && params.xhrFields.withCredentials) || //passing credentials ie Cookies
				 params.headers != undefined || //Any custom headers
				 (params.type && (params.type.toUpperCase() != 'GET' || params.type.toUpperCase() != 'POST')) //It type is not GET or POST, empty defaults to GET
			   )
				//Browsers that only support simple CORS request are IE 9 and lower.
				&& ($.browser.msie && parseInt($.browser.version) < 10)
			) ||
			//Browsers that do not support CORS at all
			($.browser.msie && parseInt($.browser.version) < 8) ||
			($.browser.opera && parseInt($.browser.version) < 12)
		) {
		  if (params.error) {
			  params.error();
		  } else {
			  nike.error('CORS request auto failed with no fail method.', params);
		  }
		  return;
	  }
	  //store jQuery cors support
	  var prevCors = $.support.cors;
	  //force true, since this will fail in IE even on simple requests
	  $.support.cors = true;
	  //create XDomainRequest object for browers that have it
	  params.xhr = function () {
		  return ($.browser.msie && parseInt($.browser.version) < 10)?new XDomainRequest():new XMLHttpRequest();
	  }
	  //make request
	  $.ajax(params);
	  //return state of cors support
	  $.support.cors = prevCors;
  },


  /**
   * Loads an external script or style using Modernizr and keeps track
   * of what has already been requested.
   *
   * @param {String|Array(String)} resources A string or an array of resources to load
   * @param {Function} [callbackFunc] A function to run when the resources have been loaded
   * @param {Boolean} [noLoad] TRUE if not loading the script, just reporting that you have
   */
  loadExternalResources : function(resources, callbackFunc, noLoad) {
      var requestedResources = (typeof resources === 'string') ? [ resources ] : resources;
      var requiredResources = [];
      var requiredResourceNames = [];
      var curResource;
      var curResourceName;
      var runCallback = function () {
          nike.dispatchEvent(nike.EVENT_EXTERNAL_RESOURCES_LOADED,
              { resourcesRequested: requestedResources, resourcesLoaded: requiredResources });

          if(callbackFunc instanceof Function) {
              try {
                  callbackFunc();
              } catch(e) {
                  nike.error("nike#loadExternalResources(", resources, callbackFunc, ") failed while running callbackFunc. Exception was: ", e );
              }
          }
      };

      // Only load what we haven't loaded yet
      for(var index = 0; index < requestedResources.length; index++ ) {
          curResource = requestedResources[index];
          curResourceName = (curResource.lastIndexOf("/") > 0) ? curResource.substr(curResource.lastIndexOf("/") + 1) : curResource;
          if(!nike.ScriptLoader.getLoadedExternalResource(curResourceName)) {
              requiredResources.push(curResource);
              requiredResourceNames.push(curResourceName);
          }
      }

      if(requiredResources.length > 0 && !noLoad) {
          Modernizr.load({
              load : requiredResources,
              complete : function () {
                  nike.ScriptLoader.loadedExternalResources = nike.ScriptLoader.loadedExternalResources.concat(requiredResourceNames);

                  runCallback();
              }
          });
      } else {
          if( requiredResources.length > 0 && noLoad ) {
              nike.ScriptLoader.loadedExternalResources = nike.ScriptLoader.loadedExternalResources.concat(requiredResourceNames);
          }
          runCallback();
      }
  },

  /**
   * Loads styles from the script manager.  Does not keep track of what has been loaded, just creates a request
   * for styles.
   *
   * @param {String|Array(String)} styles
   */
  requestStyles : function(styles) {
      var stylesString;
      var styleRequestString;

      if(!styles || (styles instanceof Array && styles.length === 0)) {
          return;
      }

      stylesString = (styles instanceof Array) ? styles.join(",") : styles;
      styleRequestString = "?format=" + nike.ScriptLoader.format +
                               "&assets=" + stylesString +
                               "&assetType=STYLE";

      nike.ScriptLoader.loadStyle(nike.ScriptLoader.getStyleUrl() + styleRequestString);
      nike.dispatchEvent(nike.EVENT_REQUESTED_STYLES_LOADED, { requested: styles });
  },

  /**
   * Request the scripts from the server for any API or
   * gadget.  Each script will only be requested if it
   * is not already defined.
   *
   * @param {String|String[]} required A string or array of strings that are
   *    fully qualified namespaces of the API/gadget
   * @param {Function} [callback] An optional callback to call when scripts are loaded
   * @param {Boolean} [preventGadgetLoad] TRUE to prevent gadgets from loading in response to this load
   * @param {Boolean} [scriptOnly] TRUE to load only the scripts, and not the styles.
   * @param {String} [buildRevParam] Optional build revision parameter to append to the end of the request (ex. buildRev=12345)
   */
  requestScripts : function(required, callback, preventGadgetLoad, scriptOnly, buildRevParam) {
    var i;
    var loadedScript;
    var scriptRequestData;
    // Assume this is an array of strings if not a single string
    var items = typeof required == 'string' ? [required] : required;

    // Build comma separated string of required items
    var requiredString = '';
    var buildRevArr;
    for (i = 0; i < items.length; i++) {

      // Only request the script if not already defined
      loadedScript = nike.ScriptLoader.getLoadedScript(items[i]);
      if (!loadedScript) {
        if (requiredString.length > 0) {
          requiredString += ',';
        }
        requiredString += items[i];
      }
    }

    // If there are no scripts to request just fire a scripts loaded event
    if (requiredString.length <= 0) {
      nike.dispatchEvent(nike.EVENT_REQUESTED_SCRIPTS_LOADED,
        { scriptsRequested : required, scriptsLoaded: requiredString, preventGadgetLoad: preventGadgetLoad });
      if(callback && typeof callback === 'function') {
        callback();
      }
    }
    else {
      // Send list of already loaded scripts so duplicates are not returned.
      // Exclude script loaded as dependencies as they will be resolved
      // server side
      var loaded = '';
      for (i = 0; i < nike.ScriptLoader.loadedScripts.length; i++) {
        loadedScript = nike.ScriptLoader.loadedScripts[i];
        if (!loadedScript.isDependency){
          if (loaded.length > 0) {
            loaded += ',';
          }
          loaded += nike.ScriptLoader.loadedScripts[i].name;
        }
      }

      scriptRequestData = {
        assets : requiredString,
        loaded : loaded,
        format : nike.ScriptLoader.format,
        showFurnitureKeys : nike.ScriptLoader.showFurnitureKeys
      };

      //If a buildRevParam was passed in, add it to the request
      if(buildRevParam){
        //Split it on the '=' and add it as a param
        buildRevArr = buildRevParam.split('=');
        if(buildRevArr.length == 2){
          scriptRequestData[buildRevArr[0]] = buildRevArr[1];
        }

      }
      //if script only request, add asset type parameter
      if (scriptOnly) {
        scriptRequestData.assetType = 'SCRIPT';
      }

      // Request the required scripts
      //noinspection JSUnusedLocalSymbols
      $.ajax({
        url:nike.ScriptLoader.getScriptUrl(),
        data: scriptRequestData,
        dataType:'script',
        type:'GET',
        cache:'true',
        success:function(data) {
          // Scripts are loaded unless the 'format' is 'include'
          // They will be loaded individually.
          if (nike.ScriptLoader.format != 'include') {
            // Fire event indicating scripts are loaded
              nike.dispatchEvent(nike.EVENT_REQUESTED_SCRIPTS_LOADED,
                { scriptsRequested : required, scriptsLoaded: requiredString.split(","), preventGadgetLoad: preventGadgetLoad });
            if(callback && typeof callback === 'function') {
                callback();
            }
          }
        },
        error:function(data) {
          nike.error('Error requesting required scripts: ' + data);
        }
      });
    }
  },



  /**
   * Make a request for a gadget with the supplied params.
   *
   * @param {*} placeHolder Valid DOM element whose data will be used to request gadget. if no
   *    success function is provided, placeHolder will be replaced with the new gadget element.
   * @param {Function} [success] function to call on successful gadget request. response parameter includes
   *    gadget HTML markup and headers
   */
  getGadget  : function(placeHolder, success) {

    var holder = $(placeHolder);

    // Get gadget params from data fields
    var gadgetName = holder.attr('data-gadget');
    var gadgetParams = nike.ScriptLoader.parseGadgetDataParams(holder);

    // Make sure the required 'gadget_name' was supplied
    if (!gadgetName) {
      nike.error('Gadget name not supplied to nike.getGadget!');
    }
    else {
      // Add gadget required parameters
      gadgetParams.gadgetName = gadgetName;

      // Add the loading class
      holder.addClass(nike.ScriptLoader.GADGET_LOADING);

      // Build URL
      var url = nike.ScriptLoader.getGadgetUrl();
      var parts = gadgetName.split('.');
      for (var i = 0; i < parts.length; i++) {
        url += '/' + parts[i];
      }

      //Set gadget loaded flag to false because it's waiting to be reloaded
      holder.data(nike.IS_LOADED_KEY, false);

      // Fire an event indicating the load
      nike.dispatchEvent(nike.EVENT_LOAD_GADGET, {gadgetName:gadgetName, element:holder});

      // Request gadget
      nike.ScriptLoader.request({
            url:url,
            method:'GET',
            data:gadgetParams
          },
          function(response) {
            // Call success callback if defined
            if (success) {
              success(response);
            }
            else {
              // Destroy the gadget instances
              nike.ScriptLoader.destroySubGadgets(holder);
              nike.ScriptLoader.destroyGadget(holder);

              // Replace place holder with gadget HTML
              holder.empty().html(response.data);
            }

            // Remove the loading class added earlier
            holder.removeClass(nike.ScriptLoader.GADGET_LOADING);


            // Fire gadget loaded event
            nike.ScriptLoader.dispatchGadgetLoadedEvent({gadgetName:gadgetName, element:holder});
          },

          function(response) {
            nike.dispatchEvent(nike.EVENT_LOAD_GADGET_FAIL, {gadgetName:gadgetName, element:$(placeHolder)});
          });
    }


  },

  /**
   * This will strip the host/path/filename and ? from the url leaving just the querystring
   * If the path contains a slug and hash, they will be added to the querystring.
   */
  _cleanQueryData : function(url) {
    var cleanedQuery = url;
    var questionMarkIndex = url.indexOf('?');
    var hashIndex = url.indexOf('#');
    var urlWithoutQuery = url;
    var splitUrl;
    var pathParam = "";

    if(questionMarkIndex > 0 &&
       (hashIndex < 0 || hashIndex > questionMarkIndex)){
    }


    if (url && url.indexOf('?') >= 0) {
      //Grab everything after the questionmark and before the hash (if the hash exists)
      splitUrl = url.split('#')[0];
      splitUrl = splitUrl.split('?', 2);
      urlWithoutQuery = splitUrl[0];
      cleanedQuery = splitUrl[1];
    }


    //Check if there is a path that needs to be added to the querystring
    pathParam = nike.util.UrlUtil.buildPathParam(urlWithoutQuery);

    if(pathParam !== null){

      //Check if the cleaned query is the same as the url.  If this is the case and the path was matched, the url was not a standalone querystring, it was a url without a querystring so just use the path
      if(url == cleanedQuery){
        cleanedQuery = "";
      }


      //Add path param to cleanedQuery
      if(cleanedQuery.length > 0){
        cleanedQuery += '&';
      }
      cleanedQuery += pathParam;
    }


    return cleanedQuery;
  },

  /**
   * Parse the data attributes of a gadget into an object
   * map.
   *
   * Ignores: data-gadget
   *          data-load
   *          data-listen
   *
   * Parses data-query as a query string delimited by & and =
   *
   * @param element A gadget element
   * @return Object
   */
  parseGadgetDataParams  : function(element) {
    var gadgetParams = {},
        parts,
        param,
        prefix = 'data-';

    $.each($(element)[0].attributes, function(i, attribute) {
      // Ignore standard data attributes
      if (attribute.name.indexOf(prefix) > -1 && attribute.name.indexOf('data-gadget') < 0 &&
          attribute.name.indexOf('data-load') < 0 && attribute.name.indexOf('data-listen') < 0) {

        // Parse query differently
        if (attribute.name === 'data-query') {
          var query = nike.ScriptLoader._cleanQueryData(attribute.value);
          parts = query.split('&');
          for (i = 0; i < parts.length; i++) {
            var props = parts[i].split('=');
            gadgetParams[props[0].toLowerCase()] = props[1];
          }
        }
        else {
          // Most browsers lowercase the params, IE doesn't :(
          param = attribute.name.substring(prefix.length).toLowerCase();
          gadgetParams[param] = attribute.value;
        }

      }
    });

    return gadgetParams;
  },


  /**
   * Reload all gadgets of a certain type that listen to
   * a specific gadget. Replaces the data-query
   * property if supplied.
   *
   * @param gadgetName Name of gadgets on the page to reload
   * @param query String to replace data-query property
   * @param element jQuery selector of element representing the gadget
   */
  reloadListeningGadgets  : function(gadgetName, query, element) {
    nike.gadgetListensToEach(gadgetName, element, function() {
      var gadget = $(this);

      // Change the query for data
      if (query) {


        var existing = gadget.attr('data-query');

        // If a query was supplied and it hasn't changed, quit
        if (query == existing) {
          return;
        }

        gadget.attr('data-query', query);
      }


      // Reload gadget with new query
      nike.ScriptLoader.getGadget(gadget);

    });
  },

  /**
   * Reload the gadget corresponding to the element
   * given.
   *
   * @param element DOM element of gadget
   * @param query String to replace data-query property with
   */
  reloadGadget  : function(element, query) {
    var name = $(element).attr('data-gadget');
    if (name) {
      if (query) {
        // Clean up the query
        var cleaned = nike.ScriptLoader._cleanQueryData(query);
        var existing = $(element).attr('data-query');

        $(element).attr('data-query', query);
      }
      nike.ScriptLoader.getGadget($(element));
    }
  },

  /**
   * Find all DOM elements with the nike-gadget CSS
   * class and attempt to get each one
   */
  loadAllGadgets : function() {
    var _self = this;
    var gadgetsLoaded = $('div[data-gadget]').size() - 1;

    nike.EventBus.listen(nike.EVENT_GADGET_LOADED, function() {
      gadgetsLoaded--;
    });

    nike.log(_self.LOG_PREFIX, 'Loading gadgets');
    $('div[data-gadget]').each(function() {
      var $element = $(this);

      try {
        var gadgetName = $element.data('gadget').replace('nike.gadget.', '');

        if(!nike.ScriptLoader.isGadgetLoaded($element)){
          nike.ScriptLoader.loadGadget($element);

          var gadgetData = JSON.parse(JSON.stringify($element.data()));
          delete gadgetData.gadget;
          nike.log(_self.LOG_PREFIX, 'Gadget:', gadgetName, gadgetData);
        }else{
          nike.log(_self.LOG_PREFIX, 'Skipping '+ gadgetName +' gadget, already loaded');
        }
      } catch (ex) {
        nike.error(_self.LOG_PREFIX, ex);
      }
    });
  },

  /**
   * Check if a gadget is currently loaded.
   * Returns true, if it's loaded, and false if it's not loaded
   * or in the process of loading
   */
  isGadgetLoaded : function(element) {
    var ret = false;
    if (element && element.data() && element.data(nike.IS_LOADED_KEY) !== undefined) {
      ret = element.data(nike.IS_LOADED_KEY) === true;
    }
    return ret;
  },

  /**
   * Dispatch event for gadget loaded and set the gadgets isLoaded flag to true.
   *
   */
  dispatchGadgetLoadedEvent : function(data) {
      data = data || {};
      //Set flag on gadget to indicate the gadget is loaded
      if (data.element) {
          $(data.element).data(nike.IS_LOADED_KEY, true);
      }

      try {
        nike.dispatchEvent(nike.EVENT_GADGET_LOADED, data);
      } catch (ex) {
        nike.error(ex);
      }
  },

  /**
   * Take a gadget element and process it according to its
   * data attributes
   */
  loadGadget  : function(element) {

    var $gadget = $(element);
    var gadgetName = $gadget.data('gadget').replace('nike.gadget.', '');
    var gadgetData = JSON.parse(JSON.stringify($gadget.data()));
    delete gadgetData.gadget;

    // Determines if gadget should not be loaded automatically
    var load = $gadget.data('load');

    // If the lazy parameter is true don't load it
    if (load == 'lazy') {
      nike.log(this.LOG_PREFIX, 'Lazy loading gadget: ' + gadgetName, gadgetData);
    } else if (load == 'preloaded') {
      nike.log(this.LOG_PREFIX, 'Preloaded gadget: ' + gadgetName, gadgetData);
      nike.ScriptLoader.dispatchGadgetLoadedEvent({gadgetName:$gadget.data('gadget'), element:$gadget});
    } else if ($gadget.hasClass(nike.ScriptLoader.GADGET_LOADING)) {
      nike.log(this.LOG_PREFIX, 'Attempting to load a gadget already in progress: ' + gadgetName, gadgetData);
    }
    else {
      nike.ScriptLoader.getGadget($gadget, function (response) {
        // Load any additional lazy-load-js scripts
        // This will not occur on a reloaded gadget!
        var queueLength = nike.ScriptLoader.lazyLoadScriptQueue.length;

        $gadget.empty().html(response.data);
        nike.ScriptLoader.buildLazyLoadScriptQueue($gadget);
        if(queueLength === 0) {
          nike.ScriptLoader.loadLazyScripts();
        }
        // Initialize any sub gadgets
        nike.ScriptLoader.loadSubGadgets($gadget);
      });
    }
  },

  /**
   * Find all gadgets on the page and make a request for their
   * scripts
   */
  loadAllGadgetScripts  : function() {
    // Build a map to get unique gadget requirements
    var scripts = {};

    $('div[data-gadget]').each(function() {
      scripts[$(this).attr('data-gadget')] = true;
    });

    // Convert map to array
    var list = new Array();
    for (var name in scripts) {
      list.push(name);
    }

    // Request all the gadget scripts
    if (list.length > 0) {
      nike.ScriptLoader.requestScripts(list);
    }
  },

  /**
   * Load a list of script urls by adding to them to the dom, running them, then loading the next one once it's complete.
   * The list of script includes is nike.scriptsToInclude and is populated by a generated script
   */
  loadScript  : function(scriptUrl) {

    // Fires the scripts loaded event if all have finished
    function checkAllLoaded() {
      if (nike.ScriptLoader.scriptsToInclude.length == 0) {
        // Reset script include loaded start flag
        nike.ScriptLoader.scriptIncludeLoadStart = false;

        // Fire event indicating scripts are loaded
        nike.dispatchEvent(nike.EVENT_REQUESTED_SCRIPTS_LOADED);
        return true;
      }
      return false;
    }

    // Loads the next script if there is one
    function loadNext() {
      var nextScript = nike.ScriptLoader.scriptsToInclude.shift();
      if (nextScript) {
        nike.ScriptLoader.loadScript(nextScript);
      }
    }

    if (scriptUrl) {
      var doc = document;
      var newScript = doc.createElement('script');
      newScript.type = 'text/javascript';
      newScript.defer = false;
      newScript.src = scriptUrl;


      //gecko onload
      newScript.onload = function() {
        checkAllLoaded();
        if (!newScript.onloadDone) {
          loadNext();
        }
      };

      //IE onload
      newScript.onreadystatechange = function() {
        checkAllLoaded();
        if (('loaded' === newScript.readyState || 'complete' === newScript.readyState ) && !newScript.onloadDone) {
          loadNext();
        }
      };

      doc.body.appendChild(newScript);
    }
    else {
      checkAllLoaded();
    }

  },

  /**
   * Load a list of style urls by adding to them to the dom at the top of the head.
   * The list of style includes is nike.ScriptLoader.stylesToInclude and is populated by a generated script
   */
  loadStyle  : function(styleUrl) {
    var styleLink;

    //Fires the scripts loaded event if all have finished
    function checkAllLoaded() {
      if (!nike.ScriptLoader.stylesToInclude || nike.ScriptLoader.stylesToInclude.length == 0) {
        // Fire event indicating styles are loaded
        nike.dispatchEvent(nike.EVENT_REQUESTED_STYLES_LOADED);
      }
    }

    if (styleUrl) {
      styleLink = jQuery("<link>", {rel: 'Stylesheet', type : 'text/css', href : styleUrl});
      jQuery('head').children().last().after(jQuery(styleLink));
      if (nike.ScriptLoader.stylesToInclude) {
        nike.ScriptLoader.loadStyle(nike.stylesToInclude.shift());
      }
    }
  },

  /**
   * As scripts are loaded they should have their name added to this list so they aren't loaded again
   */
  addLoadedScript  : function(scriptName, isDependency) {
    var i, L;
    var found = false;
    for (var i = 0, L = nike.ScriptLoader.loadedScripts.length; i < L; i++){
      if (nike.ScriptLoader.loadedScripts[i].name === scriptName){
        found = true;
        break;
      }
    }
    if (!found) {
      nike.ScriptLoader.loadedScripts.push({name:scriptName, isDependency:isDependency});
    }
  },

  /**
   * Look for a loadedScript by name and return the object
   * if found
   *
   * @param scriptName
   * @return {name:(string), isDependency:(boolean)}
   */
  getLoadedScript: function(scriptName){
    for (var i = 0, L = nike.ScriptLoader.loadedScripts.length; i < L; i++){
      if (nike.ScriptLoader.loadedScripts[i].name === scriptName){
        return nike.ScriptLoader.loadedScripts[i];
      }
    }

    return null;
  },

  /**
   * Determines if an external resource has already been loaded or not.  This cannot keep track
   * of script or css that was not included with nike.ScriptLoader.loadExternalResource().
   *
   * @param {String} resourceName The name of the resource you want to determine is loaded
   * @return {String|Null} Returns the name of the loaded resources or NULL if not loaded
   */
  getLoadedExternalResource : function (resourceName) {
      for(var index = 0; index < nike.ScriptLoader.loadedExternalResources.length; index++ ) {
          if(nike.ScriptLoader.loadedExternalResources[index] === resourceName) {
              return nike.ScriptLoader.loadedExternalResources[index];
          }
      }

      return null;
  },

  /**
   * Find all gadgets within an element and
   * fire the gadget loaded event to initialize them.
   *
   * @param element The DOM element to find gadgets within
   */
  loadSubGadgets  : function(element) {
    $(element).find('div[data-gadget]').each(function() {
          var gadgetName = $(this).attr('data-gadget');
          nike.dispatchEvent(nike.EVENT_GADGET_LOADED, {gadgetName:gadgetName, element:$(this)});
    });
  },

  /**
   * Find all gadgets on the page with the gadget name specified
   * @param gadgetName the gadget to find
   */
  findGadgets  : function(gadgetName) {
    return $('div [data-gadget="' + gadgetName + '"]')
  },

  /**
   * Find all gadgets on the page
   */
  findAllGadgets : function(gadgetName) {
    return $('div [data-gadget]');
  },
  /**
   * Find a gadgets instance and call destroy on it
   *
   * @param element The DOM element to destroy
   */
  destroyGadget : function(element) {
    var instance = element.data(nike.GADGET_INSTANCE);
    if (instance && instance.destroy) {
      instance.destroy();
    }
  },

  /**
   * Find all gadgets within an element and
   * fire their destroy method if they have one
   *
   * @param element The DOM element to destroy
   */
  destroySubGadgets : function(element) {
    $(element).find('div[data-gadget]').each(function() {
      nike.ScriptLoader.destroyGadget($(this));
    });
  },

  /**
   * @param [element] Optional element to look for script tags in
   */
  buildLazyLoadScriptQueue : function(element){
    var selector = 'script[type="' + nike.ScriptLoader.LAZY_LOAD_SCRIPT_TYPE + '"]';
    var scriptElements = element ? element.find(selector) : $(selector);
    scriptElements.each(
        function(){
          var scriptElement = $(this);
          var contents = scriptElement.html();
          var scriptType = scriptElement.data("scriptType");
          var assetList = undefined;
          var buildRevParam = scriptElement.data("buildRevParam");
          //Default to internal script type
          if(scriptType != nike.ScriptLoader.SCRIPT_TYPE_INTERNAL &&
              scriptType != nike.ScriptLoader.SCRIPT_TYPE_EXTERNAL &&
              scriptType != nike.ScriptLoader.SCRIPT_TYPE_INLINE){
            scriptType = nike.ScriptLoader.SCRIPT_TYPE_INTERNAL;
          }


          try{
            if(scriptType != nike.ScriptLoader.SCRIPT_TYPE_INLINE){
              assetList = JSON.parse(contents);
              nike.debug('Queueing assetList:', assetList);

            } else {
              //Inline scripts
              nike.debug('Queueing inline script:', contents);
            }
          } catch(ex){
            nike.error('Failed to parse lazy load js list in script tag.  Tag contents:', contents, "scriptType: ", scriptType, "exception: ", ex);
          }

          nike.ScriptLoader.lazyLoadScriptQueue.push({'assetList': assetList, 'scriptType' : scriptType, 'contents' : contents, 'buildRevParam' : buildRevParam});

        }
    );
  },

  /**
   * Used to indicate whether the initial lazy loading has been completed to help
   * trigger the gadget loaded events.
   *
   * @type Boolean
   */
  completedInitialLazyLoad : false,

  loadLazyScripts : function(){
    var nextScript = undefined;
    if(nike.ScriptLoader.lazyLoadScriptQueue.length > 0){
      nextScript = nike.ScriptLoader.lazyLoadScriptQueue.shift();
      try{
        if(nextScript.scriptType == nike.ScriptLoader.SCRIPT_TYPE_INTERNAL){
          //Load the internal script and call the next one in the callback
          nike.ScriptLoader.requestScripts(
            nextScript.assetList,
            function() {
              nike.ScriptLoader.asyncLoadGadgets();
              nike.ScriptLoader.loadLazyScripts();
            },
            true,
            true,
            nextScript.buildRevParam
          );
          nike.debug("nike.ScriptLoader.executeLazyLoadScripts: Loading internal scripts: " + nextScript.assetList);

        } else if(nextScript.scriptType == nike.ScriptLoader.SCRIPT_TYPE_EXTERNAL){
          //Load the external script and execute the next one in the callback
          nike.ScriptLoader.loadExternalResources(nextScript.assetList, nike.ScriptLoader.loadLazyScripts);
          nike.debug("nike.ScriptLoader.executeLazyLoadScripts: Loading external scripts: " + nextScript.assetList);

        } else if(nextScript.scriptType == nike.ScriptLoader.SCRIPT_TYPE_INLINE){
          //Execute the inline script and call the next one
          $.globalEval(nextScript.contents);
          nike.debug("nike.executeLazyLoadScripts: Loaded inline script");
          nike.ScriptLoader.loadLazyScripts();

        } else {
          nike.error("nike.ScriptLoader.executeLazyLoadScripts: Invalid script type: " + nextScript.scriptType);
        }
      } catch (ex){
        nike.error("nike.ScriptLoader.executeLazyLoadScripts: Exception requesting scripts.  ScriptObject:", nextScript, " Exception: ", ex);
      }
    } else if (!nike.ScriptLoader.completedInitialLazyLoad) {
      nike.ScriptLoader.completedInitialLazyLoad = true;

      /**
       * If the format requested with the script manager is "include"
       * then the EVENT_REQUESTED_SCRIPTS_LOADED event will fire when
       * they have all loaded.  If any other format all of the scripts
       * are loaded and the event can be fired now.
       */
      if (nike.SCRIPT_MANAGER_FORMAT != 'include') {
        nike.dispatchEvent(nike.EVENT_REQUESTED_SCRIPTS_LOADED);
      }
    }
  },

  asyncLoadGadgets: function() {
    $('div[data-load="preloaded"]').not('div[data-async-loaded="loaded"]').each(function() {
      var $gadget = $(this);

      if(nike.objectDefined($gadget.data('gadget')) && !nike.ScriptLoader.isGadgetLoaded($gadget)) {nike.warn($gadget.data('gadget'), $gadget.attr('data-async-loaded'));
        $gadget.attr('data-async-loaded', 'loaded');
        nike.ScriptLoader.loadGadget($gadget);
      }
    });
  }

});

//Apply this to the base nike object for backwards compatibility
nike = $.extend(nike, nike.ScriptLoader);

/**
 * Add event listener for scripts loaded event that
 * will begin requesting gadget content
 */
nike.listen(nike.EVENT_REQUESTED_SCRIPTS_LOADED, function(event, data) {
  if (nike.ScriptLoader.scriptManagerLoadComplete) {
    nike.debug('Gadget script request complete');
    if(!data || !data.preventGadgetLoad) {
      nike.ScriptLoader.loadAllGadgets();
    }
  }
  else {
    nike.debug('NikeScriptManager request complete');
    nike.ScriptLoader.scriptManagerLoadComplete = true;
    nike.ScriptLoader.setupXDMTunnels();
    if(!data || !data.preventGadgetLoad) {
      nike.ScriptLoader.loadAllGadgetScripts();
    }
  }
});

$(document).ready(function() {
  // Lazy loading anything that needs it
  // Will call EVENT_REQUESTED_SCRIPTS_LOADED when everything or nothing is done.
  nike.ScriptLoader.asyncLoadGadgets();
  nike.ScriptLoader.buildLazyLoadScriptQueue();
  nike.ScriptLoader.loadLazyScripts();
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.ScriptLoader. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}






try{
var nike = nike || {};
//http://jacwright.com/projects/javascript/date_format
Date.prototype.format=function(format){var returnStr='';var replace=Date.replaceChars;for(var i=0;i<format.length;i++){var curChar=format.charAt(i);if(replace[curChar]){returnStr+=replace[curChar].call(this);}else{returnStr+=curChar;}}return returnStr;};Date.replaceChars={shortMonths:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],longMonths:['January','February','March','April','May','June','July','August','September','October','November','December'],shortDays:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],longDays:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],d:function(){return(this.getDate()<10?'0':'')+this.getDate();},D:function(){return Date.replaceChars.shortDays[this.getDay()];},j:function(){return this.getDate();},l:function(){return Date.replaceChars.longDays[this.getDay()];},N:function(){return this.getDay()+1;},S:function(){return(this.getDate()%10==1&&this.getDate()!=11?'st':(this.getDate()%10==2&&this.getDate()!=12?'nd':(this.getDate()%10==3&&this.getDate()!=13?'rd':'th')));},w:function(){return this.getDay();},z:function(){return"Not Yet Supported";},W:function(){return"Not Yet Supported";},F:function(){return Date.replaceChars.longMonths[this.getMonth()];},m:function(){return(this.getMonth()<9?'0':'')+(this.getMonth()+1);},M:function(){return Date.replaceChars.shortMonths[this.getMonth()];},n:function(){return this.getMonth()+1;},t:function(){return"Not Yet Supported";},L:function(){return(((this.getFullYear()%4==0)&&(this.getFullYear()%100!=0))||(this.getFullYear()%400==0))?'1':'0';},o:function(){return"Not Supported";},Y:function(){return this.getFullYear();},y:function(){return(''+this.getFullYear()).substr(2);},a:function(){return this.getHours()<12?'am':'pm';},A:function(){return this.getHours()<12?'AM':'PM';},B:function(){return"Not Yet Supported";},g:function(){return this.getHours()%12||12;},G:function(){return this.getHours();},h:function(){return((this.getHours()%12||12)<10?'0':'')+(this.getHours()%12||12);},H:function(){return(this.getHours()<10?'0':'')+this.getHours();},i:function(){return(this.getMinutes()<10?'0':'')+this.getMinutes();},s:function(){return(this.getSeconds()<10?'0':'')+this.getSeconds();},e:function(){return"Not Yet Supported";},I:function(){return"Not Supported";},O:function(){return(-this.getTimezoneOffset()<0?'-':'+')+(Math.abs(this.getTimezoneOffset()/60)<10?'0':'')+(Math.abs(this.getTimezoneOffset()/60))+'00';},P:function(){return(-this.getTimezoneOffset()<0?'-':'+')+(Math.abs(this.getTimezoneOffset()/60)<10?'0':'')+(Math.abs(this.getTimezoneOffset()/60))+':'+(Math.abs(this.getTimezoneOffset()%60)<10?'0':'')+(Math.abs(this.getTimezoneOffset()%60));},T:function(){var m=this.getMonth();this.setMonth(0);var result=this.toTimeString().replace(/^.+ \(?([^\)]+)\)?$/,'$1');this.setMonth(m);return result;},Z:function(){return-this.getTimezoneOffset()*60;},c:function(){return this.format("Y-m-d")+"T"+this.format("H:i:sP");},r:function(){return this.toString();},U:function(){return this.getTime()/1000;}};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing Date. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.requireDependency('jQuery');
/**
 * Check if selector exists
 * usage: $('myselector).exists();
 */
jQuery.fn.exists = function(){return jQuery(this).length>0;};
jQuery.exists = jQuery.fn.exists;
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.exists. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Event');

/**
 * Global events
 */
nike.Event.GENERIC_LINK = 'genericLinkEvent';

/**
 * Browser Upgrade Events
 */
nike.Event.BROWSER_UPGRADE_MODAL_DISPLAY = 'upgradeBrowserModalDisplay';
nike.Event.BROWSER_UPGRADE_NOW_CLICK = 'upgradeNowClickEvent';
nike.Event.BROWSER_UPGRADE_HELP_CLICK = 'upgradeNowHelpClick';
nike.Event.BROWSER_UPGRADE_EXIT = 'upgradeBrowserModalExit';

/**
 * 3rd Party events
 */
nike.Event.USABILLA_LOADED = 'usabillaLoaded';

/**
 * Checkout Nav Events
 */
nike.Event.CHECKOUT_NAV_CHANGED = 'checkoutNavigationEvent';

/**
 * Cart events
 */
nike.Event.ADD_TO_CART = 'addToCartEvent';
nike.Event.ADD_TO_CART_SUCCESS = 'addToCartSuccessEvent';
nike.Event.ADD_TO_CART_FAIL = 'addToCartFailEvent';
nike.Event.SMART_ADD_TO_CART = 'smartAddToCartEvent';
nike.Event.SMARTCART_OUT_OF_STOCK = 'smartCartOutOfStock';
nike.Event.SMART_ADD_TO_CART_SUCCESS = 'smartAddToCartSuccessEvent';
nike.Event.SMARTCART_INIT = 'smartcartInitializationEvent';
nike.Event.ADD_TO_CART_TIMEOUT = 'addToCartTimeoutEvent';
nike.Event.MULTI_ADD_TO_CART_SUCCESS = 'multiAddToCartSuccessEvent';


nike.Event.REMOVE_FROM_CART = 'removeFromCartEvent';

nike.Event.UPDATE_CART_ITEM = 'updateCartItemEvent';
nike.Event.UPDATE_CART_ITEM_SUCCESS = 'updateCartItemSuccessEvent';
nike.Event.UPDATE_CART_ITEM_FAIL = 'updateCartItemFailEvent';

nike.Event.CART_SUMMARY_REQUEST_SUCCESS = 'cartSummaryRequestSuccessEvent';
nike.Event.LOAD_CART_SUMMARY = 'loadCartSummaryEvent';
nike.Event.LOAD_CART_SUMMARY_SUCCESS = 'loadCartSummarySuccessEvent';
nike.Event.LOAD_CART_SUMMARY_FAIL = 'loadCartSummaryFailEvent';

nike.Event.POPULATE_SKUS = 'populateSkusEvent';
nike.Event.POPULATE_SKUS_SUCCESS = 'populateSkusSuccessEvent';
nike.Event.POPULATE_SKUS_FAIL = 'populateSkusFailEvent';

nike.Event.LOAD_ORDER = 'loadOrderEvent';
nike.Event.LOAD_ORDER_SUCCESS = 'loadOrderSuccessEvent';
nike.Event.LOAD_ORDER_FAIL = 'loadOrderFailEvent';

nike.Event.PRICE_SETUP_COMPLETE = 'priceSetupComplete';

nike.Event.UPDATE_SHIPPING_COUNTRY = 'updateShippingCountryEvent';
nike.Event.UPDATE_SHIPPING_COUNTRY_SUCCESS = 'updateShippingCountrySuccessEvent';
nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL = 'updateShippingCountryFailEvent';
nike.Event.MINIPDP_LOADED = 'cartMiniPDPLoadedEvent';

nike.Event.GIFT_OPTIONS_LOADED = "giftOptionsLoadedEvent";

nike.Event.KIALA_LOCATION_SELECTED = "kialaLocationSelected";


/**
 * Indicates update of country, not specific to the shipping country
 * on the ATG order.
 */
nike.Event.UPDATE_COUNTRY_SUCCESS = 'updateCountrySuccessEvent';
nike.Event.UPDATE_COUNTRY_FAIL = 'updateCountryFailEvent';


/**
 *Checkout events
 */
nike.Event.VIEW_CART_CLICK = 'viewCartClickEvent';
nike.Event.CHECKOUT_CLICK = 'checkOutClickEvent';
nike.Event.PAYPAL_CHECKOUT_CLICK = 'payPalClickEvent';
nike.Event.REMOVE_FROM_CART = 'removeFromCartEvent';
nike.Event.EDIT_CART_CLICK = 'editCartClickEvent';
nike.Event.PROMO_CODE_APPLIED = 'promoCodeAppliedEvent';
nike.Event.SWOOSH_LASTNAME_NO_MATCH = "swooshLastNameNoMatchEvent";
//This event indicates which type of checkout is selected on the login page (registered, guest, paypal)
nike.Event.CHECKOUT_TYPE_SELECTED = 'checkoutTypeSelected';
nike.Event.CHECKOUT_TYPE_LOGIN_FAILURE = 'checkoutTypeloginFailure';
nike.Event.SUBMIT_ORDER = 'submitOrderEvent';
nike.Event.SWOOSH_FRAUD_ERROR = 'swooshFraudError';
nike.Event.MEMBER_LOGIN_CTA_CLICK = 'memberCheckoutCtaClick';
nike.Event.CHECKOUT_MEMBER_LOGIN_FAIL = 'checkoutMemberLoginFailed';
nike.Event.CHECKOUT_MEMBER_LOGIN_SUCCESS = 'checkoutMemberLoginSuccess';

/**
 * Session timeout event
 */
nike.Event.SESSION_TIMEOUT_EVENT = 'sessionTimeoutEvent';

/**
 *Add gift card to cart event
 */
nike.Event.ADD_GIFTCARD_TO_CART = 'addGiftCardToCartEvent';

/**
 * Gift card balance check success event
 */
nike.Event.Gift_CARD_BALANCE_SUCCESS = 'giftCardBalanceSuccessEvent';

/**
 * Wishlist events
 */
nike.Event.ADD_WISHLIST_ITEM_CLICK = 'addWishlistItemClickEvent';
nike.Event.ADD_WISHLIST_ITEM_PROCESS = 'addWishlistItemProcessEvent';
nike.Event.ADD_WISHLIST_ITEM_SUCCESS = 'addWishlistItemSuccessEvent';
nike.Event.ADD_WISHLIST_ITEM_FAIL = 'addWishlistItemFailEvent';
nike.Event.WISHLIST_ITEMS_LOADED = 'wishlistItemsLoaded';

/*
 * Video Player Events
 */
nike.Event.VIDEO_PLAYER_READY = 'videoPlayerReady';
nike.Event.OPEN_VIDEO_PLAYER = 'openVideoPlayerEvent';
nike.Event.CLOSE_VIDEO_PLAYER = 'closeVideoPlayerEvent';

/**
 * Shipping options events
 */
nike.Event.GET_SHIPPING_OPTIONS = 'getShippingOptionsEvent';
nike.Event.GET_SHIPPING_OPTIONS_SUCCESS = 'getShippingOptionsSuccessEvent';
nike.Event.GET_SHIPPING_OPTIONS_FAIL = 'getShippingOptionsFailEvent';

/**
 * Geodetect events
 */
nike.Event.LOAD_COUNTRY_COMPARE = 'loadCountryCompareEvent';
nike.Event.SHOW_LANGUAGE_TUNNEL = 'showLanguageTunnelEvent';
nike.Event.GEODETECT_NOTIFIER_OPENED = 'geodetectNotifierOpened';
nike.Event.GEODETECT_NOTIFIER_CLOSED = 'geodetectNotifierClosed';

/**
 * Language tunnel events
 */
nike.Event.GEO_SELECTED = 'geoSelected';
nike.Event.LANGUAGE_SELECTED = 'languageSelected';

/**
 * Gift card balance
 */
nike.Event.CHECK_GIFT_CARD_BALANCE = 'checkGiftCardBalanceEvent';
nike.Event.CHECK_GIFT_CARD_BALANCE_SUCCESS = 'checkGiftCardBalanceSuccessEvent';
nike.Event.CHECK_GIFT_CARD_BALANCE_FAIL = 'checkGiftCardBalanceFailEvent';
nike.Event.CHECK_GIFT_CARD_BALANCE_VALID = 'checkGiftCardBalanceValid';
nike.Event.CHECK_GIFT_CARD_BALANCE_INVALID = 'checkGiftCardBalanceInvalid';

/**
 * Tracking config events
 */
nike.Event.GET_TRACKING_CONFIG_SUCCESS = 'nike.Event.GET_TRACKING_CONFIG_SUCCESS';
nike.Event.GET_TRACKING_CONFIG_FAIL = 'nike.Event.GET_TRACKING_CONFIG_FAIL';
nike.Event.GET_TRACKING_CONFIG = 'nike.Event.GET_TRACKING_CONFIG';
nike.Event.TRACKING_RESOLVE_VENDOR_INFO = 'nike.Event.TRACKING_RESOLVE_VENDOR_INFO';
nike.Event.TRACKING_DYNAMIC_DATA_READY = 'nike.Event.TRACKING_DYNAMIC_DATA_READY';
nike.Event.TRACKING_TAG_READY_FOR_MAPPING = 'nike.Event.TRACKING_TAG_READY_FOR_MAPPING';
nike.Event.TAG_SEND_COMPLETE = 'nike.Event.TAG_SEND_COMPLETE';
nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED = 'nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED';
nike.Event.TAG_CANCELLED = 'nike.Event.TAG_CANCELLED';
nike.Event.TRACKING_USER_DATA_UPDATED = 'nike.Event.TRACKING_USER_DATA_UPDATED';
nike.Event.PAGEBUILDER_TRACKING_DATA_READY = 'nike.Event.PAGEBUILDER_TRACKING_DATA_READY';

nike.Event.CERTONA_TOOLS_SETUP_COMPLETE = 'certonaToolsSetupCompleteEvent';
nike.Event.REQUESTING_CERTONA_RECOMMENDATIONS = 'requestingCertonaRecommendationsEvent';
nike.Event.CERTONA_RECOMMENDATIONS_SUCCESS = 'certonaRecommendationsSuccessEvent';
nike.Event.CERTONA_RECOMMENDATIONS_FAIL = 'certonaRecommendationsFailEvent';
nike.Event.CROSSSELL_RENDER_COMPLETE = 'crossSellRenderCompleteEvent';

/**
 *page view track event
 */
nike.Event.PAGE_VIEW = 'pageViewEvent';

/**
 *feature track event
 */
nike.Event.FEATURE_CLICK = 'featureClickedEvent';

/**
 *header & footer click event
 */
nike.Event.NAV_CLICK = 'navClickedEvent';

nike.Event.NAV_LINK_TRACKING_EVENT = 'navLinkTrackingEvent';

/**
 * When changing the sort order
 */
nike.Event.SORT_CHANGED = 'sortOptionChanged';

nike.Event.CHANGE_VIEW = 'changeViewEvent';

/**
 * Facet Nav Events
 */
nike.Event.FACET_NAV_CHANGED = 'facetNavChangedEvent';
nike.Event.FACET_NAV_REMOVED = 'facetNavRemovedEvent';
nike.Event.FACET_NAV_SWITCHED = 'facetNavSwitchedEvent';
nike.Event.FACET_NAVIGATION_LOAD_COMPLETE = 'facetNavigationLoadComplete';

nike.Event.GRIDWALL_REDIRECT = 'gridwallRedirect';
nike.Event.GRIDWALL_REFRESH = 'gridwallRefresh';
nike.Event.TOUT_CLICK = 'toutClickEvent';
nike.Event.FULLSCREEN_TOUT_VIDEO_CLICK = 'fstVideoClickEvent';
nike.Event.NAV_ITEM_SELECTION = "navItemSelectionEvent";

/**
* Tracks product position on gridwall when clicked.
*/
nike.Event.GRIDWALL_PRODUCT_CLICK ='gridwallProductClick';

/**
 * Product Wall Breadcrumb Events
 */
nike.Event.BREADCRUMB_ELLIPSIS_EXPANDED = 'breadcrumbEllipsisExpanded';
nike.Event.BREADCRUMB_ELLIPSIS_COLLAPSED = 'breadcrumbEllipsisCollapsed';
nike.Event.BREADCRUMB_LINK_CLICK = 'breadcrumbLinkClickEvent';

/**
 * When a share option button is clicked
 */
nike.Event.SHARE_OPTION_CLICK = 'shareOptionClickEvent';

/**
 *Email signup event
 */
nike.Event.EMAIL_SIGNUP_SUCCESS = 'emailSignUpSuccessEvent';
nike.Event.EMAIL_SIGNUP_FAIL = 'emailSignUpFailEvent';
nike.Event.HIDE_EMAIL_SIGNUP_CONFIRMATION = "hideEmailSignUpConfirmationWindow";

/**
 *Store locator event
 */
nike.Event.STORE_LOCATOR_SEARCH = 'storeLocatorSearchEvent';
nike.Event.STORE_LOCATOR_MAP_CHANGE = 'storeLocatorMapChange';
nike.Event.STORE_LOCATOR_FILTER_CHANGE = 'storeLocatorFilterChange';
nike.Event.STORE_LOCATOR_PHONE_CLICK = 'storeLocatorPhoneClickEvent';
nike.Event.STORE_LOCATOR_GET_DIRECTIONS = 'storeLocatorGetDirections';

/**
 * Help Event
 */
nike.Event.HELP_REQUESTED = 'helpRequestedEvent';

/**
 * Social Events
 */
nike.Event.FACEBOOK_LIKE_SUBSCRIBE = 'facebookLikeSubscribe';
nike.Event.PINTEREST_LINK_CLICK = 'pinterestPostEvent';

/**
 * Mobile Events
 */
nike.Event.MORE_PRODUCTS_SELECTED = 'moreProductsSelected';
nike.Event.MORE_PRODUCTS_SUCCESS = 'moreProductsSuccess';

/**
 * Returns Login Events
 */
nike.Event.HIDE_RETURNS_LOGIN = 'hideReturnsLoginEvent';
nike.Event.CLOSE_RETURNS_LOGIN = 'closeReturnsLoginEvent';
nike.Event.GUEST_RETURNS_LOGIN = 'guestReturnsLoginEvent';
nike.Event.GUEST_RETURNS_LOGIN_SUCCESS = 'guestReturnsLoginSuccessEvent';
nike.Event.SHOW_RETURNS_LOGIN = 'showReturnsLoginEvent';

/**
 * Returns Login History Events
 */
nike.Event.HIDE_RETURNS_HISTORY_LOGIN = 'hideReturnsHistoryLoginEvent';
nike.Event.CLOSE_RETURNS_HISTORY_LOGIN = 'closeReturnsHistoryLoginEvent';
nike.Event.GUEST_RETURNS_HISTORY_LOGIN = 'guestReturnsHistoryLoginEvent';
nike.Event.GUEST_RETURNS_HISTORY_LOGIN_SUCCESS = 'guestReturnsHistoryLoginSuccessEvent';
nike.Event.SHOW_RETURNS_HISTORY_LOGIN = 'showReturnsLoginEvent';


/**
 * Global Window Resize Event
 */
nike.Event.WINDOW_RESIZE = 'windowResizeEvent';

/**
 * Global Window Scroll Event
 */
nike.Event.WINDOW_SCROLL = 'windowScrollEvent';
/**
 * Global Window Scroll Event
 */
nike.Event.WINDOW_HAS_SCROLLED = 'windowHasScrolledEvent';

/**
 * Product Review Events
 */
nike.Event.PRODUCT_REVIEW_PREVIEW = 'productReviewPreview';
nike.Event.PRODUCT_REVIEW_SUBMIT = 'productReviewSubmit';
nike.Event.PRODUCT_REVIEW_START = 'productReviewStart';
nike.Event.PRODUCT_REVIEWS_SORT = 'productReviewsSort';
nike.Event.SCROLL_TO_REVIEW = 'scrollToReview';
nike.Event.SUBMIT_REVIEW = 'submitProductReview';
nike.Event.MORE_REVIEWS_LOADED = 'moreReviewsLoaded';
nike.Event.SHOW_REVIEWS_COMMENT_FORM = 'showReviewsCommentForm';
nike.Event.SHOW_REVIEWS_WRITE_FORM = 'showReviewsWriteForm';
nike.Event.SHOW_REVIEWS_PREVIEW = 'showReviewsPreview';
nike.Event.SHOW_FLAG_REVIEW = 'showFlagReview';
nike.Event.REVIEWS_COMMENT_SUCCESS = 'reviewsCommentSuccess';
nike.Event.REVIEWS_SUBMIT_SUCCESS = 'reviewsSubmitSuccess';
nike.Event.FLAG_REVIEW_SUBMIT_SUCCESS = 'flagReviewSubmitSuccess';
nike.Event.CANCEL_REVIEWS_COMMENT = 'cancelReviewsComment';
nike.Event.CANCEL_WRITE_REVIEW = 'cancelWriteReview';
nike.Event.CANCEL_FLAG_REVIEW = 'cancelFlagReview';
nike.Event.CLOSE_REVIEW_COMFIRMATION = 'closeReviewComfirmation';
nike.Event.CLOSE_REVIEW_PREVIEW = 'closeReviewPreview';
nike.Event.REVIEW_SCROLL_TO = 'reviewScrollTo';
nike.Event.REVIEW_CONTENT_TOGGLED = 'reviewContentToggled';
/**
 * Login Events
 */
nike.Event.LOGIN_FAIL = 'loginFail';
nike.Event.LOGIN_SUCCESS = 'loginSuccessEvent';
nike.Event.LOGIN_ATTEMPT = 'loginAttemptEvent';
nike.Event.CLICK_TO_CALL = 'clickToCallEvent';
nike.Event.ONENIKE_LOGIN_LOADED = 'oneNikeLoginLoaded';
nike.Event.ONENIKE_PROFILE_LOADED = 'oneNikeProfileLoaded';
nike.Event.ONENIKE_PROFILE_API_READY = 'onenikeProfileApiReady';
nike.Event.ONENIKE_PROFILE_API_FAILED = 'onenikeProfileApiFailed';
nike.Event.LOGIN_SUCCESS_NEED_PASSWORD_RESET = 'loginSuccessNeedPasswordReset';
nike.Event.CANCEL_LOGIN = 'cancelLogin';
nike.Event.SHOW_MEMBER_SECTION = "showMemberSection";
nike.Event.HIDE_MEMBER_SECTION = "hideMemberSection";
nike.Event.SHOW_NIKE_PLUS_NOTIFICATION_BOX = "showNikePlusNotificationBox";
nike.Event.HIDE_NIKE_PLUS_NOTIFICATION_BOX = "hideNikePlusNotificationBox";
nike.Event.MEMBER_LOGGED_OUT = 'memberLoggedOut';
nike.Event.LOGIN_STATE_UPDATED = "loginStateUpdated";
nike.Event.NIKE_PLUS_DATA_UPDATE = "nikePlusDataUpdate";
nike.Event.LOGIN_SETUP_COMPLETE = "loginSetupComplete";
nike.Event.FAILED_PROFILE_CALL = "failedProfileCall";
nike.Event.JOIN_CTA_CLICK = 'joinCtaClick';
nike.Event.UNITE_REGISTER_SUCCESS = 'uniteRegisterSuccess';
nike.Event.UNITE_LOGIN_SUCCESS = 'uniteLoginSuccess';

/**
 * Register Events
 */
nike.Event.SHOW_REGISTER = 'showRegisterEvent';
nike.Event.HIDE_REGISTER = 'hideRegisterEvent';
nike.Event.REGISTER_SUCCESS = 'registerSuccessEvent';
nike.Event.REGISTER_FAIL = 'registerFailEvent';
nike.Event.HIDE_REGISTER_AFTER_SUCCESS = 'hideRegisterAfterSuccessEvent';
nike.Event.CANCEL_REGISTER = 'cancelRegisterEvent';
nike.Event.PROFILE_BUTTON_CLICKED = 'profileButtonClicked';
nike.Event.REGISTER = 'registerEvent';
nike.Event.REGISTER_START = "registrationStart";
nike.Event.REGISTER_COMPLETE = "registrationComplete";



/**
 * Password Events
 */
nike.Event.PASSWORD_RESET_FAILED = 'passwordResetFailed';
nike.Event.PASSWORD_RESET_SUCCEEDED = 'passwordResetSucceeded';
nike.Event.PASSWORD_RESET_EMAIL_SENT = 'passwordResetEmailSent';
nike.Event.PASSWORD_RESET_SETUP_COMPLETE = 'passwordResetSetupComplete';
nike.Event.OPEN_FORGOT_PASSWORD = 'openForgotPassword';
nike.Event.CLOSE_FORGOT_PASSWORD = 'closeForgotPassword';

/**
 * Show/Hide Password Reset Events
 */
nike.Event.SHOW_PASSWORD_RESET = 'showPasswordReset';
nike.Event.HIDE_PASSWORD_RESET = 'hidePasswordReset';
nike.Event.CANCEL_PASSWORD_RESET = 'cancelPasswordReset';

/**
 * Show/Hide Login Events
 */
nike.Event.SHOW_LOGIN = 'showLogin';
nike.Event.HIDE_LOGIN = 'hideLogin';
nike.Event.LOGIN_CLOSE_TIMER = 'loginCloseTimer';

/**
 * Show/Hide ForgotPassword Events
 */
nike.Event.SHOW_FORGOT_PASSWORD_MODAL = 'showForgotPasswordModal';
nike.Event.HIDE_FORGOT_PASSWORD_MODAL = 'hideForgotPasswordModal';

/**
 * Show/Hide Help Dropdown Events
 */
nike.Event.SHOW_HELP_DROPDOWN = 'showHelpDropdown';
nike.Event.HIDE_HELP_DROPDOWN = 'hideHelpDropdown';

/**
 * Show/Hide Member Dropdown Events
 */
nike.Event.SHOW_MEMBER_DROPDOWN = 'showMemberDropdown';
nike.Event.HIDE_MEMBER_DROPDOWN = 'hideMemberDropdown';

/**
 * Event for clicks on the global nav
 */
nike.Event.GLOBAL_NAV_CLICK = 'click.nike.GlobalNav';
nike.Event.CONTENT_PANEL_BUTTON_CLICKED = 'contentPanelButtonClicked';
nike.Event.CONTENT_PANEL_OPENED = 'contentPanelOpened';
nike.Event.CONTENT_PANEL_CLOSED = 'contentPanelClosed';
nike.Event.NAV_PANEL_BUTTON_CLICKED = 'navPanelButtonClicked';
nike.Event.NAV_PANEL_OPENED = 'navPanelOpened';
nike.Event.NAV_PANEL_CLOSED = 'navPanelClosed';
nike.Event.NAV_LINK_CLICKED = 'navLinkClicked';

/**
 * Search Event for mobile
 */
nike.Event.SEARCH = "searchEvent";
nike.Event.SEARCH_DISPLAY_CHANGED = "searchDisplayChanged";

/**
 * Cartridge click for mobile
 */
nike.Event.CARTRIDGE_CLICK = "cartridgeClickEvent";

/**
 * Event for page interactions on cq pages that are not covered by other events (used for tracking)
 */
nike.Event.CQ_PAGE_ACTIVITY = "cqPageActivity";
nike.Event.CQ_GRID_HOVER_MODAL = 'modalPageEvent';
nike.Event.CQ_MODAL_PAGE_ACTIVITY = 'cqModalPageActivity';

/**
 * Events for PROFILE
 */
nike.Event.SUCCESSFUL_USER_LOADED = 'successfulUserLoaded';
nike.Event.ADDRESSES_LOADED = 'addressesLoaded';
nike.Event.SHOW_THIS_FORM = 'showThisForm';
nike.Event.CANCEL_CHANGE_FORM = 'cancelChangeForm';
nike.Event.HOME_ADDRESS_UPDATED = 'updateHomeEvent';
nike.Event.SHIPPING_ADDRESS_UPDATED = 'updateShippingEvent';
nike.Event.BILLING_ADDRESS_UPDATED = 'updateBillingEvent';
nike.Event.ADDRESS_UPDATED = 'addressUpdated';
nike.Event.ADDRESS_CREATED = 'addressCreated';
nike.Event.OTHER_ADDRESS_UPDATED = 'updateOtherAddressEvent';
nike.Event.DELETED_ADDRESS = 'deletedAddress';
nike.Event.ADD_SHIPPING_ADDRESS = 'addShippingAddress';
nike.Event.RESET_BASIC_INFO = 'resetProfileBasicInfo';
nike.Event.DEFAULT_HEIGHT_WEIGHT = 'useDefaultHeightWeight';
nike.Event.UPDATE_HEIGHT_WEIGHT_FROM_DEFAULTS = 'changeHeightWeightDefaults';
nike.Event.BASIC_INFO_UPDATED = 'updatePersonalInfo';
nike.Event.MOBILE_ATTRIBUTES_UPDATED = 'updateMobileAttributes';
nike.Event.RESET_PASSWORD = 'resetProfilePassword';
nike.Event.PASSWORD_UPDATED = 'updatePassword';
nike.Event.EMAIL_ADDRESS_UPDATED = 'emailAddressUpdated';
nike.Event.ADDRESS_SHOW = 'showAddressBook';
nike.Event.BASIC_INFO_SHOW = 'showBasicInfo';
nike.Event.MY_FAMILY_SHOW = 'showMyFamily';
nike.Event.FAMILY_MEMBERS_LOADED = 'familyMembersLoaded';
nike.Event.DELETED_FAMILY_MEMBER = 'deletedFamilyMember';
nike.Event.ADD_FAMILY_MEMBER = 'addFamilyMember';
nike.Event.DELETED_FAMILY_MEMBER = 'deletedFamilyMember';
nike.Event.FAMILY_MEMBER_CREATED = 'familyMemberCreated';
nike.Event.FAMILY_MEMBER_UPDATED = 'familyMemberUpdated';
nike.Event.CONFIRM_DEACTIVATION = 'confirmDeactivation';
nike.Event.CANCEL_DEACTIVATION = 'cancelDeactivation';
nike.Event.DEACTIVATE_PROFILE = 'deactivateUserProfile';
nike.Event.SHOW_DEACTIVATE_MODAL = 'showDeactivateModalEvent';
nike.Event.SHOW_DEACTIVATE_ACCOUNT = 'showDeactivateAccountEvent';
nike.Event.SHOW_CONFIRMATION_MODAL = 'showConfirmationModalEvent';
nike.Event.CONFIRM_CONFIRMATION = 'confirmConfirmationEvent';
nike.Event.CANCEL_CONFIRMATION = 'cancelConfirmationEvent';
nike.Event.SHOW_ADDRESS_EDIT_FORM = 'showAddressForm';
nike.Event.COMMUNICATION_SHOW = 'showCommunicationPreferences';
nike.Event.COMMUNICATION_PREFERENCES_UPDATED = 'updateCommunicationPreferences';
nike.Event.PROFILE_TAB_CHANGED = 'profileTabChanged';
nike.Event.SELECTED_COUNTRY_CHANGED = 'selectedCountryChangedEvent';
nike.Event.CONFIRM_DELETION = 'confirmDeletionEvent';
nike.Event.CANCEL_DELETION = 'cancelDeletionEvent';
nike.Event.PRIVACY_SHOW = 'showPrivacy';
nike.Event.SHARE_SHOW = 'showShare';
nike.Event.DEVICE_SHOW = 'showDevice';
nike.Event.DEVICES_LOADED = 'devicesLoadedEvent';
nike.Event.SHOW_MY_FAMILY = 'showMyFamily';
nike.Event.SOCIAL_NETWORK_CONNECTED = 'socialNetworkConnected';
nike.Event.SOCIAL_NETWORK_DISCONNECTED = 'socialNetworkDisconnected';
nike.Event.NETWORKS_LOADED = 'networksLoadedEvent';
nike.Event.PARTNERS_LOADED = 'partnersLoadedEvent';
nike.Event.PARTNERS_REMOVED = 'partnerRemovedEvent';
nike.Event.BROADCASTS_LOADED = 'broadcastLoadedEvent';
nike.Event.AVATAR_CHANGED = 'avatarChangedEvent';
nike.Event.SUCCESSFUL_PROFILE_CALL = 'successfulProfileCall';
nike.Event.SUCCESSFUL_PROFILE_UPDATE = 'successfulProfileUpdate';
nike.Event.PAYMENT_OPTIONS_SHOW='showPaymentOptions';
nike.Event.MOBILE_NUMBER_CHECK_SUCCESS = 'mobileNumberCheckSuccess';
nike.Event.MOBILE_NUMBER_CHECK_ERROR = 'mobileNumberCheckError';
nike.Event.MOBILE_NUMBER_CANCEL_ADD = 'mobileNumberCancelAdd';
nike.Event.MOBILE_NUMBER_CANCEL_VERIFY = 'mobileNumberCancelVerify';
nike.Event.MOBILE_NUMBER_CANCEL_EDIT = 'mobileNumberCancelEdit';
nike.Event.MOBILE_NUMBER_CANCEL_REMOVE = 'mobileNumberCancelRemove';
nike.Event.MOBILE_NUMBER_GO_TO_VERIFY_STEP = 'mobileNumberGoToVerifyStep';
nike.Event.MOBILE_NUMBER_GET_VERIFICATION_CODE = 'mobileNumberGetVerificationCode';
nike.Event.MOBILE_NUMBER_CHECK_VERIFICATION_CODE = 'mobileNumberCheckVerificationCode';
nike.Event.MOBILE_NUMBER_GET_CODE_SUCCESS = 'mobileNumberGetCodeSuccess';
nike.Event.MOBILE_NUMBER_GET_CODE_ERROR = 'mobileNumberGetCodeError';
nike.Event.MOBILE_NUMBER_CHECK_CODE_SUCCESS = 'mobileNumberCheckCodeSuccess';
nike.Event.MOBILE_NUMBER_CHECK_CODE_ERROR = 'mobileNumberCheckCodeError';
nike.Event.MOBILE_NUMBER_EDIT_NUMBER_LINK_CLICK = 'mobileNumberEditNumberLinkClick';
nike.Event.MOBILE_NUMBER_REMOVE_NUMBER_LINK_CLICK = 'mobileNumberRemoveNumberLinkClick';
nike.Event.MOBILE_NUMBER_TRY_AGAIN_LINK_CLICK = 'mobileNumberTryAgainLinkClick';
nike.Event.MOBILE_NUMBER_REMOVE_NUMBER = 'mobileNumberRemoveNumber';
nike.Event.MOBILE_NUMBER_REMOVE_NUMBER_SUCCESS = 'mobileNumberRemoveNumberSuccess';
nike.Event.MOBILE_NUMBER_CLOSE_PANEL = 'mobileNumberClosePanel';
nike.Event.MOBILE_NUMBER_REMOVE_NUMBER_ERROR = 'mobileNumberRemoveNumberError';
nike.Event.MOBILE_NUMBER_GET_AUTH_SUCCESS = 'mobileNumberGetAuthSuccess';
nike.Event.MOBILE_NUMBER_GET_AUTH_ERROR = 'mobileNumberGetAuthError';

nike.Event.SHOW_NOTIFY_ME = 'showNotifyMeEvent';
nike.Event.NOTIFY_ME_SUBMIT_CLICK = 'notifyMeSubmitClickEvent';

/**
 * Orders SMS Events
 */
nike.Event.ORDER_SMS_LEGAL_UNAVAIL = 'ordersSMSLegalTermsUnavailable';
nike.Event.ORDER_SMS_LEGAL_OPEN = 'ordersSMSLegalTermsModalOpen';
nike.Event.ORDER_SMS_LEGAL_TERMS_ACCEPTED = 'ordersSMSLegalTermsAccepted';
nike.Event.ORDER_SMS_LEGAL_TERMS_DECLINED = 'ordersSMSLegalTermsDeclined';


/**
 * My Orders events
 */
nike.Event.MY_ORDERS_LINK_CLICKED = 'myOrdersLinkClickEvent';
nike.Event.SHOW_MODIFY_ORDER_MODAL = 'showModifyOrderModelEvent';
nike.Event.HIDE_MODIFY_ORDERS_MODAL = 'hideModifyOrderModelEvent';
nike.Event.CLOSE_MODIFY_ORDERS_MODAL = 'closeModifyOrderModelEvent';
nike.Event.PAGE_LAYOUT = "nikeLayoutChange";
nike.Event.PDP_SCROLL_TO_REVIEW = 'pdpScrollToReview';
nike.Event.FOOTER_LINK_CLICK = 'footerLinkClickEvent';

/**
 * Swipable events
 */

nike.Event.SWIPABLE_TAPPED = 'swipableTappedEvent';
nike.Event.SWIPABLE_SWIPED = 'swipableSwipedEvent';
nike.Event.SWIPABLE_PINCHED_OPEN = 'swipablePinchedOpen';
nike.Event.SWIPABLE_PINCHED_CLOSE = 'swipablePinchedClose';
nike.Event.SWIPABLE_MOVED = 'swipableMoved';
nike.Event.SWIPABLE_STARTED = 'swipableStarted';
nike.Event.SWIPABLE_ENDED = 'swipableEnded';

/**
 * GiftCard link click event
 */
nike.Event.GIFT_CARD_LINK_CLICKED = 'giftCardLinkClickEvent';

/**
 * Customize with NIKEiD link click event
 */
nike.Event.CUSTOMIZE_NIKE_ID_LINK_CLICKED = 'customizeNikeIdLinkClickEvent';
nike.Event.START_CUSTOMIZING_NIKE_ID_CLICKED = 'startCustomizingClickEvent'


/**
 * Profile menu item clicked event
 */
nike.Event.PROFILE_MENU_ITEM_CLICKED = 'profileMenuItemClickedEvent';

/**
 * Smart Events
 */
nike.Event.SMARTCART_QUEUE_EXIT = 'smartCartQueueExitEvent';
nike.Event.SMARTCART_BUTTON_CLICK = 'smartCartButtonClickEvent';
nike.Event.SMARTCART_MODAL_PAGE_VIEW = 'smartCartModalPageView';
nike.Event.SMARTCART_ARE_YOU_SURE_MODAL_EVENT = 'smartCartAreYouSureModalEvent';
nike.Event.ADA_SMARTCART_CANCEL_AND_LOSE_SPOT = 'adaSmartCartCancelAndLoseSpot';

/**
 * Captcha events
 * @type {string}
 */
nike.Event.GET_CAPTCHA_EVENT = 'getCaptcha';
nike.Event.CAPTCHA_EVENT = 'captchaEvent';
nike.Event.CAPTCHA_SOLVED_EVENT = 'captchaSolved';
nike.Event.CAPTCHA_SUCCESSFULLY_SOLVED = 'captchaSolvedSuccessfully';
nike.Event.CAPTCHA_FAILED_EVENT = 'captchaFailedAttempt';
nike.Event.CAPTCHA_LOADED = 'captchaLoaded';
nike.Event.CAPTCHA_CANCELED = 'captchaCanceled';
nike.Event.CAPTCHA_TIMEOUT_PRE = 'captchaTimeoutPre';
nike.Event.CAPTCHA_TIMEOUT_POST = 'captchaTimeoutPost';
nike.Event.CAPTCHA_500_ERROR = 'captcha500Error';

/**
 * Tethered Access Code
 * @type {string}
 */
nike.Event.TETHERED_ACCESS_CODE_RESPONSE_SUCCESS = 'tetheredAccessCodeResponseSuccess';
nike.Event.TETHERED_ACCESS_CODE_RESPONSE_PROFILE_ERROR = 'tetheredAccessCodeResponseProfileError';
nike.Event.TETHERED_ACCESS_CODE_RESPONSE_INPUT_ERROR = 'tetheredAccessCodeResponseInputError';
nike.Event.TETHERED_ACCESS_CODE_RESPONSE_FAILURE = 'tetheredAccessCodeResponseFailure';
nike.Event.TETHERED_ACCESS_CODE_PROFILE_CHECK_FAILURE = 'tetheredAccessCodeProfileCheckFailure';
nike.Event.TETHERED_ACCESS_CODE_NOT_LOGGED_IN = 'tetheredAccessCodeNotLoggedIn';
nike.Event.TETHERED_ACCESS_CODE_USER_LOGIN_FAILURE = 'tetheredAccessCodeUserLoginFailure';
nike.Event.TETHERED_ACCESS_CODE_USER_LOGIN_SUCCESS = 'tetheredAccessCodeUserLoginSuccess';
nike.Event.TETHERED_ACCESS_CODE_PROFILE_NOT_TETHERED = 'tetheredAccessCodeProfileNotTethered';
nike.Event.TETHERED_ACCESS_CODE_PASSWORD_RESET_EMAIL_SENT = 'tetheredAccessCodePasswordResetEmailSent';
nike.Event.TETHERED_ACCESS_CODE_PASSCODE_NOT_FOUND = 'tetheredAccessCodePasscodeNotFound';

/**
 * Validation Events
 */
nike.Event.ERROR_NOTIFIER_ATTACHED = 'errorNotifierAttachedEvent';
nike.Event.ERROR_NOTIFIER_REMOVED = 'errorNotifierRemovedEvent';

/**
 * Automation Events
 */
nike.Event.ASYNC_COMPLETE_FOR_AUTOMATION = 'asyncCompleteForAutomation';

nike.Event.NIKE_ID_PRODUCT_VIEW_EVENT = "nikeIdProductViewEvent";
nike.Event.NIKE_ID_100_PERCENT_COMPLETE = "nikeId100PercentComplete";

nike.Event.CONTINUE_SHOPPING = 'continueShoppingEvent';

/**
 * GeoPosition Events
 */
nike.Event.GEO_POSITION_FAILED = 'geoPositionFailed';
nike.Event.GEO_POSITION_SUCCEEDED = 'geoPositionSucceeded';

nike.Event.GEARUP_STATE_CHANGED = 'gearupStateChangedEvent';
nike.Event.GEARUP_PAGE_CHANGED = 'gearupPageChangedEvent';
nike.Event.GEARUP_BUY_NOW = 'gearupBuyNowEvent';
nike.Event.GEARUP_ADD_ALL = 'gearupAddAllEvent';
nike.Event.GEAR_UP_ADD_TO_CART = 'gearupAddToCart';
nike.Event.GEARUP_REQUEST_SUCCESS = 'gearupRequestSuccess';
nike.Event.GEARUP_REQUEST_FAIL = 'gearupRequestFail';

/**
 * Orientation Events
 */
nike.Event.ORIENTATION_CHANGE = 'orientationChange';

/**
 * AccessCode Events
 */
nike.Event.UNLOCK_BUTTON_CLICK_EVENT = 'unlockButtonClickEvent';
nike.Event.UNLOCK_MODAL_VIEW_EVENT = 'accessCodeUnlockModalShowing';
nike.Event.ACCESS_CODE_SUCCESS_EVENT = 'accessCodeSuccessEvent';
nike.Event.ACCESS_CODE_ERROR = 'accessCodeError';
nike.Event.ACCESS_CODE_FAILURE = 'accessCodeFailure';
nike.Event.ACCESS_CODE_MODAL_CLICK_EVENT ='accessCodeModalClickEvent';

/**
 * PDP Benefits and Reviews sections Events
 */
nike.Event.PDP_SECTION_ACTIVATED = 'pdpSectionActivated';
nike.Event.PDP_SECTION_TITLE_UPDATE = 'pdpSectionTitleUpdate';
nike.Event.PDP_ACTIVATE_SECTION = 'pdpActivateSection';
nike.Event.PDP_TOGGLE_CONTENT_VISIBILITY = 'pdpToggleContentVisiblity';
nike.Event.PDP_REVIEW_ACTION_EVENT = 'pdpReviewActionEvent';
nike.Event.TAB_BENEFITS_AND_TECH_CLICK = 'pdpTabsClickBenefitsAndTechnology';
nike.Event.TAB_REVIEWS_CLICK = 'pdpTabsClickReviews';
nike.Event.FEATURE_TAB_CLICK = 'featureTabClick';

/**
 * Event to dispatch if cookies are required for a feature but the are not enabled in the browser
 */
nike.Event.FEATURE_REQUIRES_COOKIES = 'featureRequiresCookies';

/* PDP POC Events */
nike.Event.TEMPLATE_RENDER_COMPLETE = 'templateRenderComplete';
nike.Event.INVENTORY_TEMPLATE_RENDER_COMPLETE = "inventoryTemplateRenderComplete";
nike.Event.PDP_TRACKING_DATA_UPDATED = 'pdpTrackingDataUpdated';
nike.Event.CHANGE_HERO_IMAGE = 'changeHeroImageEvent';
nike.Event.HERO_IMAGE_LOADED = 'heroImageLoaded';
nike.Event.CHANGE_COLOR = 'changeColorEvent';
nike.Event.PDP_COLOR_CHANGED = 'pdpColorChanged';
nike.Event.COLORWAY_SELECTED_ONCE_ON_PRODUCT = 'colorwaySelectedOnceOnProduct';
nike.Event.PRODUCT_WIDTH_SELECTED = 'widthSelectorClickEvent';
nike.Event.REVIEW_STAR_CLICKED = 'reviewStarClicked';
nike.Event.BUYING_TOOLS_CUSTOMIZE_IT = 'buyingToolsNikeIDEvent';
nike.Event.PDP_SHIPPING_DETAILS_CLICK = 'shippingDetailsClick';
nike.Event.GOOGLE_PLUS_SUBSCRIBE = 'googlePlusSubscribe';
nike.Event.NIKEiD_LEARN_MORE_CLICK = 'NIKEiDLearnMoreClickEvent';
nike.Event.NIKEiD_CLOSE_CLICK = 'NIKEiDCloseClickEvent';
nike.Event.SIZE_DROPDOWN_CHANGED = 'sizeDropdownChangedEvent';
nike.Event.SIZE_SELECTION_OPEN = 'sizeSelectionOpenEvent';
nike.Event.SIZE_SELECTION_SELECTED = 'sizeSelectionSelectedEvent';
nike.Event.LIVE_CHAT_CLICK = "liveChatClickEvent";
nike.Event.PDP_CUSTOM_MESSAGE_LINK_CLICK = "pdpCustomMessageLinkClick";
// specific to Needle Chat
nike.Event.CHAT_CTA_CLICKED = 'inviteClick';
nike.Event.CHAT_INITIATED = 'qualifiedChat';
nike.Event.ANALYTICS_CHAT_CTA_CLICKED = 'chatCtaClicked';
nike.Event.ANALYTICS_CHAT_INITIATED = 'chatInitiated';

/* PiD Events */
nike.Event.PID_HELP_HOVER = 'pidHelpHover';
nike.Event.PID_FOCUSOUT = 'pidFocusOut';
nike.Event.PID_MOBILE_SAVED = 'pidSaved';
nike.Event.PID_PERSONALIZATION_CHECK = 'pidPersonalizationCheck';
nike.Event.PID_PERSONALIZATION_ATTEMPT = 'pidPersonalizationAttempt';
nike.Event.PID_VALIDATION_RESULT = 'pidValidationResult';

/* PDP Mobile Customize NikeID */
nike.Event.BUYING_TOOLS_MOBILE_CUSTOMIZE_IT = 'buyingToolsMobileCustomizeIt';

nike.Event.NFL_PLAYER_SELECT = 'nflPlayerSelectEvent';
nike.Event.NFL_PLAYER_CHANGED = 'nflPlayerChangedEvent';
nike.Event.NFL_BREADCRUMB_CLICK = 'nflBreadcrumbClickEvent';
/*Image Zoom Events*/
nike.Event.ZOOMED_IMAGE_LOADED = 'zoomedImageLoaded';
nike.Event.CLICK_TOUCH_TO_ZOOM = 'productClickToZoomEvent';

/* NFL Events*/
nike.Event.NFL_TEAM_LOGO_CLICKED = 'nflTeamLogoClicked';
nike.Event.NFL_BADGE_CLICKED = 'nflBadgeClicked';
nike.Event.NFL_EXTENDED_SIZES_CLICKED = 'nflExtendedSizesClicked';
nike.Event.CHANGETEAM_CLICK = 'changeTeamClickedEvent';
nike.Event.MORE_TECH_SPECS = 'moreTechSpechs';

/*VAT Message Event*/
nike.Event.VAT_MESSAGE_CLICKED = 'vatMessageClickedEvent';
nike.Event.FEATURED_TECHNOLOGY_CLICKED = 'featuredTechnologyClicked';

/* Launch Calendar events */
nike.Event.LAUNCH_BREADCRUMB_CLICK = 'launchBreadcrumbClick';
nike.Event.LAUNCH_FAQ_CLICK = 'launchFaqClick';
nike.Event.LAUNCH_MORE_BUTTON_CLICK = 'launchMoreBtnEvent';
nike.Event.LAUNCH_ARCHIVE_CLICK = 'launchArchiveClick';
nike.Event.LAUNCH_BACK_TO_CALENDAR_LINK_BOTTOM = 'launchBackToCalendarLinkBottomEvent';
nike.Event.LAUNCH_VISIT_THE_ARCHIVE_LINK = 'launchVisitTheArchiveLinkEvent';
nike.Event.LAUNCH_CARD_CLICK = 'launchCardClick';
nike.Event.LAUNCH_EXPLORE_MORE_CLICK = 'launchExploreMoreClick';
nike.Event.LAUNCH_FILTER_CLICK = 'launchFilterClick';
nike.Event.LAUNCH_TOTAL_ITEM_COUNT = 'launchTotalItemCount';
nike.Event.LAUNCH_FILTERS_UPDATED = 'launchFiltersUpdated';

/* Orders and Returns */
/* Page Views */
nike.Event.SHOW_ORDERS_LOGIN = 'showOrdersLogin';
nike.Event.SHOW_RETURN_DETAILS_LOGIN = 'showReturnDetailsLogin';
nike.Event.SHOW_ORDER_HISTORY = 'showOrderHistory';
nike.Event.SHOW_ORDER_DETAILS = 'showOrderDetails';
nike.Event.SHOW_ORDER_CANCEL = 'showOrderCancel';
nike.Event.SHOW_RETURN_DETAILS = 'showReturnDetails';
nike.Event.SHOW_RETURN_CANCEL = 'showReturnCancel';
nike.Event.SHOW_EDIT_GIFT_CARD_RECIPIENT = 'showEditRecipient';
nike.Event.SHOW_RETURN_ITEMS = 'showReturnItems';
nike.Event.SHOW_CANCEL_RETURN = 'showCancelReturn';
nike.Event.SHOW_ALMOST_DONE = 'showAlmostDone';

/* Click Events */
nike.Event.ORDER_STATUS_LOGIN_CLICK_EVENT = 'ordersLoginClickEvent';
nike.Event.RETURNS_LOGIN_CLICK_EVENT = 'returnsLoginClickEvent';
nike.Event.ORDER_HISTORY_CLICK_EVENT = 'orderHistoryClickEvent';
nike.Event.ORDER_DETAILS_CLICK_EVENT = 'orderDetailsClickEvent';
nike.Event.RETURN_DETAILS_CLICK_EVENT = 'returnDetailsClickEvent';
nike.Event.RETURN_DETAILS_LABEL_CLICK_EVENT = 'returnDetailsLabelClickEvent';
nike.Event.ORDER_CANCEL_CLICK_EVENT = 'orderCancelClickEvent';
nike.Event.RETURN_CANCEL_CLICK_EVENT = 'returnCancelClickEvent';
nike.Event.EDIT_GIFT_CARD_RECIPIENT_CLICK_EVENT = 'editRecipientClickEvent';
nike.Event.RETURN_ITEMS_CLICK_EVENT = 'returnItemsClickEvent';
nike.Event.RETURN_ITEMS_LABEL_CLICK_EVENT = 'returnItemsLabelClickEvent';
nike.Event.RETURN_ITEMS_SHOW_LABELS = 'returnItemsShowLabelsEvent';
nike.Event.RETURN_ITEMS_LABEL_SUCCESS_EVENT = 'returnItemsLabelSuccessEvent';
nike.Event.RETURN_ITEMS_LABEL_FAIL_EVENT = 'returnItemsLabelFailEvent';
nike.Event.CANCEL_RETURN_CLICK_EVENT = 'cancelReturnClickEvent';
nike.Event.VIEW_RETURN_DETAILS_CLICK_EVENT = 'viewReturnDetailsClickEvent';
nike.Event.ALMOST_DONE_CLICK_EVENT = 'almostDoneClickEvent';

nike.Event.ANALYTICS_SUPPORT_READY = 'analyticsSupportReady';

nike.Event.PROVINCE_CITY_DISTRICT_CHANGED = "provinceCityDistrictChanged";
nike.Event.PROVINCE_CITY_DISTRICT_LIST_READY = "provinceCityDistrictListReady";

nike.Event.SHOW_GIFT_CARD_BALANCE_CHECKER = 'showGiftCardBalanceChecker';
nike.Event.HIDE_GIFT_CARD_BALANCE_CHECKER = 'hideGiftCardBalanceChecker';

// wechat social module
nike.Event.WECHAT_QR_CODE_DISPLAYED = "weChatQrCodeDisplayed";

// China profile mirgation
nike.Event.PROFILE_MIGRATION_SUCCESS = 'profileMigrationSuccess';
nike.Event.PROFILE_MIGRATION_FAIL = 'profileMigrationFail';

//Mobile Pinch-to-Zoom Events
nike.Event.PINCH_ZOOM_START = "pinchZoomStart";
nike.Event.PINCH_ZOOM_END = "pinchZoomEnd";
nike.Event.PINCH_ZOOM_EVENT = "pinchZoomEvent";

//Mobile Carousel Events
nike.Event.CAROUSEL_PANE_CHANGED = "carouselPaneChanged";
nike.Event.CAROUSEL_BULLET_SELECTED = "carouselBulletSelected";
nike.Event.CAROUSEL_ARROW_CLICKED = "carouselArrowClicked";

//Mobile Pinch-to-Zoom Events
nike.Event.JOIN_LINK_CLICKED = "joinLinkClicked";

//Mini PDP events
nike.Event.MINI_PDP_EVENT = 'miniPdpEvent';
nike.Event.PDP_ALT_IMAGE_CLICKED = 'pdpAltImageClicked';
nike.Event.MINI_PDP_LINK_TO_PRODUCT_CLICKED = 'miniPdpLintToProductClicked';

//IC PDP events
nike.Event.IC_PDP_DATA_LOADED = 'icPdpDataLoaded';
nike.Event.IC_PDP_ADD_TO_CART = 'icPdpAddToCart';
nike.Event.IC_PDP_COLORWAY_CHANGE = 'icPdpColorwayChange';
nike.Event.IC_PDP_PERSONALIZE_HELP = 'icPdpPersonalize';

//For profile connected apps
nike.Event.PROFILE_CONNECTED_APPS = 'profileConnectedApps';
nike.Event.PROFILE_NO_CONNECTED_APPS = 'profileNoConnectedApps';
nike.Event.PROFILE_CONNECTED_APPS_ERROR_NO_APPS = 'profileConnectedAppsErrorNoApps';
nike.Event.PROFILE_CONNECTED_APPS_ERROR_SOME_APPS = 'profileConnectedAppsErrorSomeApps';
nike.Event.PROFILE_CONNECTED_APPS_WARN = 'profileConnectedAppsWarn';
nike.Event.PROFILE_CONNECTED_APPS_DISCONNECT_OK = 'profileConnectedAppsDisconnectOk';
nike.Event.PROFILE_CONNECTED_APPS_DISCONNECT_ERROR = 'profileConnectedAppsDisconnectError';
nike.Event.PROFILE_CONNECTED_APPS_DISCONNECT_CANCEL = 'profileConnectedAppsDisconnectCancel';

// Debugging
nike.Event.DEBUG_UPDATE_PROVIDERS = 'debugUpdateProviders';

//NikeiD Mobile B16
nike.Event.NIKE_ID_OPEN_BUYING_TOOLS_BTN_CLICK = 'idOpenBuyingToolsBtnClick';
nike.Event.NIKE_ID_ENTER_BUILDER_BTN_CLICK = 'idEnterBuilderBtnClick';
nike.Event.NIKE_ID_ALT_IMAGE_SELECTED_ON_PRODUCT = 'idAltImageSelectedOnProduct';
nike.Event.NIKE_ID_OPEN_REVIEWS_CONTENT = 'idOpenReviewsContent';
nike.Event.NIKE_ID_SHARE_CTA_BTN_CLICK = 'idShareCTABtnClick';
nike.Event.NIKE_ID_ALT_PREBUILD_CHANGE = 'idPrebuildChangeEvent';
nike.Event.NIKE_ID_BUILDER_DONE = 'idBuilderDone';
nike.Event.NIKE_ID_BUILDER_ALT_IMAGE_SELECTED = 'idBuilderImageEvents';
nike.Event.NIKE_ID_BUILDER_IMAGE_ZOOM = 'idBuilderImageEvents';
nike.Event.NIKE_ID_BUILDER_CUSTOMIZATION_SELECTED = 'idBuilderCustomizationSelected';
nike.Event.NIKE_ID_ADD_TO_CART_ATTEMPT = 'idAddToCartAttempt';
nike.Event.NIKE_ID_ADD_TO_CART_SUCCESS = 'idAddToCartSuccess';
nike.Event.NIKE_ID_EDIT_DESIGN_BTN_CLICK = 'idEditDesignBtnClick';
nike.Event.NIKE_ID_PAGE_VIEW_LOAD = 'idPageViewLoad';
nike.Event.NIKE_ID_EDIT_MODE_BUILDER_READY = 'idEditModeBuilderReady';
nike.Event.NIKE_ID_BUYING_TOOLS_GENDER_SELECT = 'idBuyingToolGenderSelect';
nike.Event.NIKE_ID_BUYING_TOOLS_SIZE_SELECTED = 'idBuyingToolsSizeSelected';
nike.Event.NIKE_ID_MY_DESIGN_SELECTED = 'idMyDesignSelected';
nike.Event.NIKE_ID_ERROR_ON_PAGE = 'idErrorOnPage';

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Event. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * This is a util class for common util functions that manipulate or compare strings.
 */
nike.namespace('nike.util.StringUtil');

/**
 * Function to check if the string specified by str ends with the suffix string
 * @return true if str ends with suffix, false if it doesn't 
 */
nike.util.StringUtil.endsWith = function(str, suffix) {
  var trimStr = str.trim();
  var trimSuffix = suffix.trim();
  
    return trimStr.indexOf(trimSuffix, trimStr.length - trimSuffix.length) !== -1;
};

/**
 * Function to check if the string specified by str ends with the suffix string
 * @return {boolean} true if str ends with suffix, false if it doesn't
 */
nike.util.StringUtil.startsWith = function(str, prefix) {
  var trimStr = str.trim();
  var trimPrefix = prefix.trim();

  return trimStr.substr(0, trimPrefix.length) === trimPrefix;
};


/**
 * Check if both strings are both non-null strings and compare them, ignoring case.
 * 
 * TODO: There's probably a better, more common place to put this.
 */
nike.util.StringUtil.equalsIgnoreCase = function(string1, string2) {
  if (string1 && typeof string1 === 'string' && string2 && typeof string2 === 'string') {
    return string1.toLowerCase() === string2.toLowerCase();
  }
  return false;
};


/**
 * Trim whitespace from either side of a string
 * @param stringToTrim
 * @return trimmed string
 */
nike.util.StringUtil.trim = function(stringToTrim)
{
  return stringToTrim.replace(/^\s+|\s+$/g,"");
};

/**
 * Trim whitespace from the left side of a string
 * @param stringToTrim
 * @return
 */
nike.util.StringUtil.ltrim = function(stringToTrim)
{
  return stringToTrim.replace(/^\s+/,"");
};

/**
 * Trim whitespace from the right side of a string
 * @param stringToTrim
 * @return
 */
nike.util.StringUtil.rtrim = function(stringToTrim)
{
  return stringToTrim.replace(/\s+$/,"");
};

/**
 * Converts a string with multibyte characters(within
 * a range) into a string with single byte characters *
 * @param stringToConvert
 * @returns {XML|string|void}
 */
nike.util.StringUtil.multiByteToSingleByteConverter = function(stringToConvert)
{
  return stringToConvert.replace(/[\uFF10-\uFF5E]/g,
  function(currChar){
    return String.fromCharCode(currChar.charCodeAt(0) - 0xFEE0);
  });
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.util.StringUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.util.BrowserUtil');

nike.util.BrowserUtil.BrowserDetect = function(){

  this.dataOS = [
    {
      string: navigator.userAgent,
      subString: "iPhone",
      factor: "Phone",
      identity: "iOS"
    },
    {
      string: navigator.platform,
      subString: "iPhone",
      factor: "Phone",
      identity: "iOS"
    },
    {
      string: navigator.userAgent,
      subString: "iPad",
      factor: "Tablet",
      identity: "iOS"
    },
    {
      string: navigator.platform,
      subString: "Android",
      factor: "",
      identity: "Android"
    },
    {
      string: navigator.userAgent,
      subString: "Android",
      factor: "",
      identity: "Android"
    },
    {
      string: navigator.platform,
      subString: "Win",
      factor: "Desktop",
      identity: "Windows"
    },
    {
      string: navigator.userAgent,
      subString: "Win",
      factor: "Desktop",
      identity: "Windows"
    },
    {
      string: navigator.platform,
      subString: "Mac",
      factor: "Desktop",
      identity: "Mac"
    },
    {
      string: navigator.platform,
      subString: "Linux",
      factor: "Desktop",
      identity: "Linux"
    }
  ];
  this.factor = this.searchString(this.dataOS);
  this.Version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "";
  this.OS = this.factor.id || "";
  this.formFactor = this.factor.ff || "";
  this.OSVersion = this.factor.osversion || "";
  this.OSMajor = this.factor.osmajor || "";
  this.OSMinor = this.factor.osminor || "";
  };

nike.util.BrowserUtil.searchString = function (data) {
  for (var i=0; i < data.length; i++) {
    var dataString = data[i].string;   /// Platform or userAgent
    var identity = data[i].identity;
    var formFactor;
    var osVersion;
    var osMajVersion;
    var osMinVersion;

    this.versionSearchString = data[i].versionSearch || data[i].identity;

    if (dataString && dataString.indexOf(data[i].subString) != -1){
      if(data[i].subString !== 'Android'){
        formFactor = data[i].factor;
      } else if(data[i].subString === 'Android' && data[i].string.indexOf('Mobile') !== -1){
        formFactor = 'Phone';
      } else{
        formFactor = 'Tablet';
      }

      //OSVersion defined based on iOS or Android platforms
      if(dataString.toUpperCase().indexOf("LIKE MAC") || dataString.toUpperCase().indexOf("ANDROID") ){
        osVersion=dataString.toUpperCase();
        var vStart;
        var vEnd;
        if(osVersion.indexOf("LIKE MAC") >= 0){
          //IOS
          vStart=osVersion.indexOf("OS") + 3;
          vEnd=osVersion.indexOf("LIKE MAC") - 1;
        }
        if(osVersion.indexOf("ANDROID") >= 0){
          //Android
          osVersion=osVersion.substring(osVersion.indexOf("ANDROID"));//Strip all parts before Android, so vEnd is after vStart
          vStart=osVersion.indexOf("ANDROID") + 8;
          vEnd=osVersion.indexOf(";");

          // check for stock Android browser
          if(!/Chrome/i.test(dataString)){
            identity += " stock-Android";
          }
        }
        osVersion=osVersion.substring(vStart,vEnd).replace(/\_/g,".");
        osMajVersion=osVersion.substring(0,osVersion.indexOf("."));
        osMinVersion=osVersion.substring(osVersion.indexOf("."));
      }
      return {
        id : identity,
        ff : formFactor,
        osversion : osVersion,
        osmajor : osMajVersion,
        osminor : osMinVersion
      };
    }
  }
};


nike.util.BrowserUtil.checkCookieEnabled = function(){
  //We aren't even going to bother with navigator.cookieEnabled because it's not reliable crossbrowser.
  var cookieEnabled = false;

  //Try setting a cookie
  document.cookie = 'checkCookiesEnabled=;';

  //check if it was set
  cookieEnabled = document.cookie.indexOf('checkCookiesEnabled') !== -1;

  //Remove the cookie if it was set
  if(cookieEnabled){
    document.cookie = 'checkCookiesEnabled=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  }

  return cookieEnabled;
};

nike.util.BrowserUtil.searchVersion = function (dataString) {
    var index = dataString.indexOf(this.versionSearchString);
    if (index == -1){
      return;
    }
    return dataString.substring(index+this.versionSearchString.length+1);
};

$().ready(function(){
  nike.util.BrowserUtil.BrowserDetect();
  $('body').addClass(nike.util.BrowserUtil.formFactor);
  $('body').addClass(nike.util.BrowserUtil.OS);
  //$('body').addClass(nike.util.BrowserUtil.Version);
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.util.BrowserUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * This is a util class for common util functions that deal with boolean values.
 */
nike.namespace('nike.util.BooleanUtil');

nike.requireDependency('lib.lodash');

nike.util.BooleanUtil = _.extend(nike.util.BooleanUtil, {
    isExplicitlyTrue: function (value) {
        return value === true || ((typeof value == "string") && value.toLowerCase() == "true");
    },

    /**
     * Convenience function for checking boolean values
     */
    getBoolean : function(valueToCheck, defaultValue){
      var ret;

      //Handle regular string and boolean values
      if(valueToCheck === true || valueToCheck === 'true'){
        ret = true;

      } else if (valueToCheck === false || valueToCheck === 'false') {
        ret = false;

      } else {
        ret = defaultValue;
      }

      return ret;
    }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.util.BooleanUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Function');

/*****  Function helper methods *****/
nike.Function = {
    /**
     * Using same terminology as ExtJS 4.0 to avoid creating additional unnecessary confusion.
     * Creates a function which will only execute once when called repeatedly. Each call to the returned function
     * will reset the timeout. For example:
     * if createBuffered is called with ‘100’ as the second argument, and the returned function is called three times
     * 10ms apart, then the function provided as the first argument will be called after a total of 120ms.

     * @param {Function} fn The function to execute eventually
     * @param {int} minDelay How long to wait for the next call, in millis.
     * @param {Object} scope The scope to execute the function in.
     */
    createBuffered: function (fn, minDelay, scope) {
        return (function () {
            var timeoutId;
            return function () {
                var self = this;
                if (timeoutId) {
                    window.clearTimeout(timeoutId);
                }
                timeoutId = window.setTimeout(function () {
                    fn.apply(scope || self, arguments);
                }, minDelay);
            };
        }());
    }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Function. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Util');

nike.requireDependency('Class');
nike.requireDependency('Array');
nike.requireDependency('Date');
nike.requireDependency('jQuery.exists');
nike.requireDependency('jQuery.url');
nike.requireDependency("nike.Event");
nike.requireDependency("nike.EventBus");
nike.requireDependency('nike.util.StringUtil');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('nike.util.BrowserUtil');
nike.requireDependency('nike.util.BooleanUtil');
nike.requireDependency('nike.Function');

nike.Util = {
  logPrefix: '[ UTIL ] -',

    isExplicitlyTrue: function (value) {
      nike.warn("Use nike.util.BooleanUtil.isExplicitlyTrue instead of nike.Util.isExplicitlyTrue.");
      return nike.util.BooleanUtil.isExplicitlyTrue(value);
    },

    /**
     * Return a new set that has the values of originalSet as the keys, and keys as the values.
     * @param {Object} originalSet The set to invert.
     */
    invertSet: function (originalSet) {
        var key;
        var invertedSet = {};
        for (key in originalSet) {
            if (originalSet.hasOwnProperty(key)) {
                invertedSet[originalSet[key]] = key;
            }
        }
        return invertedSet;
    },

    /**
     * Check if varToTest is defined and not null
     */
    isDefined: function (varToTest){
      return varToTest !== undefined && varToTest !== null;
    },

    /**
     * Check if varToTest is defined and if it's a string, make sure it's not blank
     */
    isBlank: function (varToTest){
      var hasContent = nike.Util.isDefined(varToTest);
      if(hasContent && typeof varToTest == ('string')){
        hasContent = nike.util.StringUtil.trim(varToTest) !== '';
      }
      return !hasContent;
    },

    /**
     * 'Apply' the parameters of 'from' onto 'to'. A shallow copy operation, that blindly overwrites any existing
     * values on 'to' that are on 'from' as well.
     * This method corresponds to ExtJS's 'apply', but does not yet implement 'defaults'.
     * @param {Object} to The object to copy parameters onto.
     * @param {Object} from The object to copy parameters from.
     */
    apply: function (to, from) {
        var key;
        for (key in from) {
            if (from.hasOwnProperty(key)) {
                to[key] = from[key];
            }
        }
        return to;
    },

    /**
     * Deep copy, but only if the value on 'to' is an object. Values on To that also exist on From will be overwritten
     * by From.
     * @param to
     * @param from
     * @return {*}
     */
    applyWithMerge: function (to, from, defaults) {
        var key;
        if(defaults){
            to = nike.Util.applyWithMerge(to, defaults);
        }
        for (key in from) {
            if (from.hasOwnProperty(key) && (to[key] && typeof to[key] === 'object' && typeof from[key] === 'object')) {
                /* attempt to merge the nested object, but only if both are objects. */
                nike.Util.applyWithMerge(to[key], from[key], (defaults) ? defaults[key] : undefined);
            }
            else{
                to[key] = from[key];
            }
        }
        return to;
    },

    getObjectFromElementJSON : function (element){
      var ret = undefined;

      if(nike.Util.isDefined(element) && element.length > 0 && element.text().trim().length > 0){
        try{
          ret = $.parseJSON(element.text());
        }
        catch(e){
          nike.error('Error parsing json string in element: ', element, 'Exception: ', e);
        }
      }

      return ret;
    }
};

/**
 * Enforce a range. If value is outside of the specified range this method will return either min or max, otherwise
 * it will return the comparison value.
 * All arguments are required.
 * @param {Number} value The value to compare
 * @param {Number} min The minimum allowable value
 * @param {Number} max The maximum allowable value
 * @return {Number} Value, if [min <= value <= max], else min or max.
 */
nike.Util.minMax = function(value, min, max){
    return value > max ? max : (value < min ? min : value);
};
/**
* Grabs all instances of the review-attribute-slider class and replaces the
* text inside the element with a slider and checkmark representing the numeric
* value inside the element.
*
* @return
*/
nike.Util.createSliderMarkup = function () {
  $.each($('.review-attribute-slider'),function(){

    // get the current rating and check that it is within our bounds
    var rawRating = parseFloat($(this).html());
    if(!isNaN(rawRating))
    {

      rawRating = rawRating > 7 ? 7 : (rawRating < 0 ? 0 : rawRating);

      // nothing scientific about 24, it just turns out that's what puts the
      // checkmark in the right position when the rating is 7.0
      var leftpos = 22.8 * rawRating;

      // replace current review contents with a span and set the calc'd width
      $(this).html('');
      var check = $('<div class="checkmark"><span class="hidden">' + rawRating + '</span></div>')
        .css('left', leftpos);
      $(this).prepend(check);
    }
  });
};

nike.Util.resizeDistributionBars = function() {
  var maxHeight = 65;
  var highestCount = 0;
  var divArray = [];
  var i = 0;

  $.each($('.distribution'),function(){
    divArray[i] = $(this);

    var curNum = parseInt($(".distribution-value", $(this)).html());
    if (curNum > highestCount)
    {
      highestCount = curNum;
    }
    i++;
  });

  for (i=0; i < divArray.length; i++)
  {
    var curNum = parseInt($(".distribution-value", divArray[i]).html());

    if(!isNaN(curNum) && curNum > 0)
    {
      var barHeight = (curNum / highestCount) * maxHeight;
      var labelHeight = barHeight + 5;
      // replace current review contents with a span and set the calc'd width
      $(".distribution-bar", divArray[i]).css("height", barHeight);
      $(".distribution-value", divArray[i]).css("bottom", labelHeight);
    }
    else
    {
      $(".distribution-value", divArray[i]).html("");
    }
  }

};


/**
 * messageFormat
 *
 * This emulates the functionality of java.text.MessageFormat for doing argument replacement in messages
 *
 * usage: messageFormat.format(message, arg1, arg2...)
 *
 */
nike.Util.formatMessage = function(message) {
  var argIndex;
    if(typeof(message) != 'undefined' && $.trim(message).length > 0)
    {
        if(arguments && arguments.length > 0)
        {
          for(argIndex = 1; argIndex < arguments.length; argIndex++)
          {
            //The message is included in the arguments array, so we have to offset it by one when doing the replacement
            if(arguments[argIndex].length>6){
              message = arguments[argIndex];
            }else{
              message = message.replace("{" + (argIndex - 1) + "}", arguments[argIndex]);
            }
          }
        }
    }
    else
    {
        message = "";
    }

    return message;
  };


/**
 * truncateString
 *
 * @param   string          The string to truncate (other types not casted to strings).
 * @param   length          Optional: The length to truncate to, defaults to 5.
 * @param   showEllipsis    Optional: Whether or not to append an ellipses, defaults to true.
 *
 * @return  {String}        The truncated string.
 */
nike.Util.truncateString = function(string, length, showEllipsis) {
  var string = (typeof string == 'string' || typeof string == 'number') ? string.toString() : '',
      length = (typeof length == 'number') ? length : 5,
      showEllipsis = (typeof showEllipsis == 'boolean') ? showEllipsis : true;

  if (string.length > length) {
    var newString = string.substring(0, length);
    newString = showEllipsis ? newString + '...' : newString;

    return newString;
  } else {
    return string;
  }
}



/**
 * function to check if cookies are enabled. returns boolean.
 */
nike.Util.cookiesEnabled= function(){
  var readCookie;
  document.cookie = "revpSrvtareJnfUrer=Gehr";
  readCookie = -1;
  if(document.cookie.length > 0 && document.cookie.indexOf("revpSrvtareJnfUrer=") > -1)
  {
    // oh hey, the cookie was set. nuke it now.
    document.cookie = "revpSrvtareJnfUrer=Gehr; expires=Thu, 01-Jan-70 00:00:01 GMT";
    return true;
  }
  else return false;
};

nike.Util.css3support = (function() {
  var div = document.createElement('div'),
    vendors = 'Webkit Moz O ms Khtml'.split(' '),
    len = vendors.length;

  return function(prop) {
    if ( prop in div.style ) return true;
    prop = prop.replace(/^[a-z]/, function(val) {
      return val.toUpperCase();
    });

      while(len--) {
         if ( vendors[len] + prop in div.style ) {
            return true;
         }
      }
      return false;
  };
})();

/**
 * Enforce maxlength attribute on textarea
 * This will restrict keypress events and will truncate pasted text
 */
nike.Util.enforceTextAreaMaxLength = function()
{
  $("textarea[maxlength]").change(
    function()
    {
      var taValue = $(this).val();
      if(taValue.length >= $(this).attr("maxlength"))
      {
        $(this).val(taValue.substring(0,250));
      }
    }
  );

  $("textarea[maxlength]").keypress(
    function(e)
    {
      //alert(e.keyCode);
      //Allow arrow keys, backspace and delete even if max chars has been reached.
      var allowedCharList = new Array(8,37,38,39,40,46);
      if(!allowedCharList.contains(e.keyCode))
      {
        var taValue = $(this).val();
        if(taValue.length >= $(this).attr("maxlength"))
        {
          return false;
        }
      }
      return true;
    }
  );
};

/**
 * Html encode a value using the browser to do the encoding
 * @param value
 * @return
 */
nike.Util.htmlEncode = function(value){
  return $('<div/>').text(value).html();
};

/**
 * Html decode a value using the browser to do the decoding
 * @param value
 * @return
 */
nike.Util.htmlDecode = function(value){
  return $('<div/>').html(value).text();
};


/**
 * getFormattedFlashVersion
 * Get flash version from document and format it for the tag
 * Code snippet from jquery flash plugin - 'http://jquery.lukelutman.com/plugins/flash'
 */
nike.Util.getFormattedFlashVersion = function()
{
  // ie
  try {
    try {
      // avoid fp6 minor version lookup issues
      // see: http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6/
      var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
      try { axo.AllowScriptAccess = 'always'; }
      catch(e) { return '6,0,0'; }
    } catch(e) {}
    return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
  // other browsers
  } catch(e) {
    try {
      if(navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin){
        return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
      }
    } catch(e) {}
  }
  return "";
};

/**
 * Quick and dirty test to see if the user has flash installed and enabled.
 *
 * @return boolean True if the user has Flash capabilities and false otherwise.
 */
nike.Util.hasFlash = function()
{
  return nike.Util.getFormattedFlashVersion()!== "";
};


/**
* Handy utility to convert a BV datestamp to a nice format
*
* @param   dateStamp   datestamp to convert, ie: 2009-01-19T19:10:09.000-06:00
* @return  {String} mm/dd/yyyy
*/
nike.Util.cleanupDatestamp = function(dateStamp)
{
  // remove everything after the first '.', replace dashes with slashes and T with ' '
  var date = new Date( dateStamp.substring(0,dateStamp.indexOf(".") ).replace(/-/g,"/").replace(/T/g," "));
  return date.format('M jS, Y');
};


/**
 * Check if debug console is present
 */
nike.Util.isDebugConsolePresent = function()
{
  return $('#debug-console').exists();
};

/**
 * Take a URL that includes the style and color as part of the
 * path and modify the path with the new style and color
 *
 * @return modified URL
 */
nike.Util.changeUrlStyleColor = function(url, style, color){
  return url.replace(/[A-Z0-9]{6}_[0-9]{3}/, style + '_' + color);
};

/**
 * Convenience function for checking boolean values
 */
nike.Util.getBoolean = function(valueToCheck, defaultValue){
  nike.warn("Use nike.util.BooleanUtil.getBoolean instead of nike.Util.getBoolean");
  return nike.util.BooleanUtil.getBoolean(valueToCheck, defaultValue);
};



/**
 * take an image element and make sure it loads correctly, the DOM load event is unreliable because some browsers don't fire it (IE eg) if the image is cached
 */
var image;
var cb;
nike.Util.checkImageLoaded = function(image,cb, interval) {
  image = image.length ? image[0] : image,
    cb = cb || function() {};

    if (!image.complete) {
      return false;
    }

    if (typeof image.naturalWidth != "undefined" && image.naturalWidth == 0) {
      return false;
    }

    if (interval) {
      clearInterval(interval);
    }
    setTimeout(function() {cb()}, 100);

    return true;
//    if ($(image).width() > 0) {
//      if (interval) {
//        clearInterval(interval);
//      }
//      setTimeout(function() {cb()}, 100);
//
//      return true;
//    }
//    return false;
};

// TODO: Why do we have a lowercase and an uppercase version of nike.Util?  This seems confusing.  We need to pick one and use it. -twill
nike.namespace("nike.util");


/**
 * bind
 * can be used to define a function and bind it to the current value of "me"
 * This is helpful when using callbackbased libraries, for creating iterator
 * functions to pass to each or eventhandler functions to use with bind
 * Functions created with bind are able to access properties of "me" where they are defined
 * @param fn
 * @param me
 */
nike.Util.bind = function(fn, me){
  return function(){
    return fn.apply(me, arguments);
  };
};

/**
 * This will centralize the window resize event.  By using this we can
 * guarantee that a resize event will not be fired more than once every 20
 * milliseconds, so that there won't be browser overload.
 *
 * On the first call, the window resize listener will be added to the window.
 * It will then use the nike.listen and nike.dispatchEvent to keep track of
 * the passed call back.
 *
 * On additional calls to this method, the callback will be setup to listen
 * to the event.
 *
 * @param callback Callback function to fire once the window resize event has fired.
 */
nike.Util.windowResizeListen = function (callback) {
	function listen(callback) {
		nike.listen(nike.Event.WINDOW_RESIZE, callback);
	}
	function init() {
		var RESIZE_INTERVAL = 20,
			lastFire = 0,
			check = function () {
				nike.dispatchEvent(nike.Event.WINDOW_RESIZE);
				window.clearTimeout(timer);
				timerActive = false;
			},
			timer,
			timerActive = false;

		$(window).resize(function () {
			if (!timerActive) {
				var time = (new Date()).getTime();
				if (lastFire + RESIZE_INTERVAL < time ) {
					lastFire = time;
					nike.dispatchEvent(nike.Event.WINDOW_RESIZE);
				} else {
					timer = window.setTimeout(check, RESIZE_INTERVAL);
					timerActive = true;
				}
			}
		});
	}
	init();
	listen(callback);
	nike.Util.windowResizeListen = listen;
};

/**
 * This will centralize the window scroll event.
 *
 * On the first call, the window resize listener will be added to the window.
 * It will then use the nike.listen and nike.dispatchEvent to keep track of
 * the passed call back.
 *
 * On additional calls to this method, the callback will be setup to listen
 * to the event.
 *
 * @param callback Callback function to fire once the window scroll event has fired.
 */

nike.Util.windowScrollListen = function (callback) {
    function listen(callback) {
        nike.listen(nike.Event.WINDOW_SCROLL, callback);
    }
    function init() {
        $(window).scroll(function () {
            nike.dispatchEvent(nike.Event.WINDOW_SCROLL);
        });
    }
    init();
    listen(callback);
    nike.Util.windowScrollListen = listen;
};

/**
 * Works like windowScrollListen, except that it only triggers after
 * there have been no scroll events for 100ms.
 *
 * @param callback
 */
nike.Util.windowHasScrolledListen = function (callback) {
  /**
   * @type {Number} The delay in milliseconds to consider scroll events "over".
   * @constant
   */
  var SCROLL_DELAY = 100;

  function listen(callback) {
    nike.listen(nike.Event.WINDOW_HAS_SCROLLED, callback);
  }
  function init() {
    $(window).scroll(nike.Function.createBuffered(function () {
      nike.dispatchEvent(nike.Event.WINDOW_HAS_SCROLLED);
    }, SCROLL_DELAY));
  }
  init();
  listen(callback);
  nike.Util.windowHasScrolledListen = listen;
};
/**
 * This is a helper function so that we can tell when a timer has been cleared and
 * then clear it depending on it's being cleared or not.
 * @param fn Function to set timeout with
 * @param interval Number in miliseconds to set interval of the function
 */
nike.Util.timeoutHelper = function (fn, interval) {
  var id = setTimeout(fn, interval);
  this.cleared = false;
  this.clear = function () {
    this.cleared = true;
    clearTimeout(id);
  };
};

/**
 * Adds data-qa attribute to a given element, if QA rendering is enabled. If target selection contains more than one element, attributes are automatically
 * enumerated by appending '_#'.
 * @param {jQuery|Element} target Element to add attribute to
 * @param {String} qaAttrValue Desired value of QA attribute
 * @param {Boolean} [forceEnumerate] Optional: append enumeration to attribute value even if the target selection contains only one element
 */
nike.Util.addQaAttribute = function (target, qaAttrValue, forceEnumerate) {

  // Checking for sp cookie to enable automation data in production
  if (nike.ENV_CONFIG.renderDataQA != "true" && $.CookieUtil('sp') != 'showAutomationData') {
    return;
  }

  if (target.length < 1) {
    nike.error("QA Attribute '" + qaAttrValue + "' not applied. No target element supplied");
    return;
  } else if (target.length == 1) {
    if (forceEnumerate) qaAttrValue = qaAttrValue + '_1';
    $(target).attr('data-qa', qaAttrValue);
  } else {
    $(target).each( function(idx) { $(this).attr('data-qa', qaAttrValue + '_' + (idx + 1))});
  }
};


/**
 * These were refactored to nike.util.StringUtil.  These are duplicated here for backwards compatibility, but we should be using StringUtil directly from now on.
 * If we are only using the string functions on a page, we can replace the util.js include with stringUtil
 */

nike.Util.endsWith = function(str, suffix) {
  nike.warn("Use nike.util.StringUtil.endsWith instead of nike.Util.endsWith.");
  return nike.util.StringUtil.endsWith(str, suffix);
};

nike.Util.equalsIgnoreCase = function(string1, string2) {
  nike.warn("Use nike.util.StringUtil.equalsIgnoreCase instead of nike.Util.equalsIgnoreCase.");
  return nike.util.StringUtil.equalsIgnoreCase(string1, string2);
};

/**
 * @depracted
 */
nike.Util.trim = function(stringToTrim)
{
  nike.warn("Use nike.util.StringUtil.trim instead of nike.Util.trim.");
  return nike.util.StringUtil.trim(stringToTrim);
};

nike.Util.ltrim = function(stringToTrim)
{
  nike.warn("Use nike.util.StringUtil.ltrim instead of nike.Util.ltrim.");
  return nike.util.StringUtil.ltrim(stringToTrim);
};

nike.Util.rtrim = function(stringToTrim)
{
  nike.warn("Use nike.util.StringUtil.rtrim instead of nike.Util.rtrim.");
  return nike.util.StringUtil.rtrim(stringToTrim);
};


/**
 * These were refactored to nike.util.UrlUtil
 * They are included here for backwards compatibility, but they should no longer be used.
 * Use the nike.util.UrlUtil version instead
 *
 */

nike.Util.getParameter = function(url,name)
{
  nike.warn("Use nike.util.UrlUtil.getParameter instead of nike.Util.getParameter.");
  return nike.util.UrlUtil.getParameter(url, name);
};

nike.Util.addParameter = function(url, name, value) {
  nike.warn("Use nike.util.UrlUtil.addParameter instead of nike.Util.addParameter.");
  return nike.util.UrlUtil.addParameter(url, name, value);
};

nike.Util.getLValue = function(lValue,parameterName)
{
  nike.warn("Use nike.util.UrlUtil.getLValue instead of nike.Util.getLValue.");
  return nike.util.UrlUtil.getLValue(lValue, parameterName);
};

nike.Util.getExternalReferrer = function(){
  nike.warn("Use nike.util.UrlUtil.getExternalReferrer instead of nike.Util.getExternalReferrer.");
  return nike.util.UrlUtil.getExternalReferrer();
};

nike.Util.parseUrlParams = function(queryToParse, params){
  nike.warn("Use nike.util.UrlUtil.parseUrlParams instead of nike.Util.parseUrlParams.");
  nike.util.UrlUtil.parseUrlParams(queryToParse, params);
};

/**
 * Wrapper for window.URL if present (referenced via nike.global);
 * if window.URL is not defined, mimics some of the basic functionality of window.URL()
 * described at https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * @param  {String}  urlString  a DOMString representing an absolute URL
 * @return {Object}             an object URL
 */
nike.Util.newURL = function (urlString) {
  if (nike.global.URL) {
    return arguments.length > 1 ? new nike.global.URL(arguments[0], arguments[1]) : new nike.global.URL(urlString);
  }

  var parse_url = /^(?:([A-Za-z]+:))?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:(\/[^?#]*))?(?:(\?[^#]*))?(?:(#.*))?$/;
  var result = parse_url.exec(urlString);
  var props = ['href', 'protocol', 'slash', 'host', 'port', 'pathname', 'search', 'hash', 'password', 'username'];
  var retObj = {};

  for (var i=0; i<props.length; i++) {
    retObj[props[i]] = result[i] || '';
  }

  retObj.hostname = retObj.port ? retObj.host + ':' + retObj.port : retObj.host;
  retObj.origin = retObj.protocol + retObj.slash + retObj.hostname;
  retObj.toString = function () {
    return this.href;
  };

  return retObj;
};

/**
 * This function will take an object and encode its attirbutes using encodeURIComponent
 * @param objectToEncode The object whose attributes you want to include.
 * @returns {*}
 */
nike.Util.encodeObjectAttrs = function(objectToEncode){
  for (var i in objectToEncode){
    if (objectToEncode.hasOwnProperty(i)){
      var attr = objectToEncode[i];
      //test if attribute is a full URL to determine if we
      //should use encodeURI or encodeURIComponent
      if (!/^(f|ht)tps?:\/\//i.test(attr)) {
        objectToEncode[i] = encodeURIComponent(attr);
      } else {
        objectToEncode[i] = encodeURI(attr);
      }
    }
  }
  return objectToEncode
};

/**
 * This function will take in two jQuery DOM objects as parameters and swap their
 * location in the DOM.
 */
nike.Util.swap = function(nodeA, nodeB){
  if ((nodeA.length && nodeA != null) && (nodeB.length && nodeB != null)){
    nodeB = jQuery(nodeB)[0];
    nodeA = jQuery(nodeA)[0];
    var nodeC = nodeA.parentNode.insertBefore(document.createTextNode(''), nodeA);
    nodeB.parentNode.insertBefore(nodeA, nodeB);
    nodeC.parentNode.insertBefore(nodeB, nodeC);
    nodeC.parentNode.removeChild(nodeC);
  } else {
    nike.debug("Failed to swap as one or more parameters is undefined");
  }
};

/**
 * A simple helper to normalize the transitionend event for the browser.
 * @returns {String}
 */
nike.Util.transitionEnd = function(){
  var transEndEventNames = {
    "WebkitTransition" : "webkitTransitionEnd",
    "MozTransition" : "transitionend",
    "OTransition" : "oTransitionEnd",
    "msTransition" : "MSTransitionEnd",
    "transition" : "transitionend"
  };

  var event = transEndEventNames[ Modernizr.prefixed('transition') ];
  var browser = nike.Util.browser();

  // Android 4.1-4.3 & 4.4.2 default browser doesn't return the proper event
  if( browser.stockAndroidBrowser && /4\.(?:[123]|4\.2)/.test(browser.version) ){
    event = 'webkitTransitionEnd';
  }

  return event;
};

/**
 * Normalizes browser userAgent props for easier dev usage. Currently this method only contains logic for devices that
 * we support. If support needs to be expanded to support other devices just add to the 'systems' Object.
 * @returns {Object}
 */
nike.Util.browser = function(){
  var userAgent = navigator.userAgent;
  var systems = {
    iOS : 'i(?:phone|pad|pod)',
    Android : 'android'
  };
  var sysArray = $.map(systems, function(s){ return s; });
  var os = userAgent.match( RegExp('('+sysArray.join('|')+')', 'i') );
  var ver = userAgent.match( RegExp('(?:OS)? ([\\d._]+)', 'i') );

  var ret = {
    iOS : RegExp(systems.iOS, 'i').test(userAgent),
    Android : RegExp(systems.Android, 'i').test(userAgent),
    OS : ( os && os.length == 2 ) ? os[1].toLowerCase() : undefined,
    version : ( ver && ver.length == 2 ) ? ver[1].replace(/_/g, '.') : undefined
  };

  // check for stock Android browser
  if( ret.Android && !/Chrome/.test(userAgent) ){
    ret.stockAndroidBrowser = true;
  }

  return ret;
};

nike.Util.escapeRegExp = function(string) {
  return string ? (''+string).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') : '';
};

/**
 * There have been cases where new provider data loads before the console has. In those cases the console won't be
 * updated with the new data. This method allows for setting up a queue of data that can be read once the console has
 * loaded. If the console is loaded already, the data will be dispatched normally.
 *
 * @param {Object} [data] - An Object containing the `providerDependencies` Array. When not passed, it'll cause a check
 * for the queue, and dispatch data if it exists.
 */
nike.Util.updateProviders = function(data){
  if( !nike.objectDefined('exp.debug', nike) ) nike.namespace('nike.exp.debug');

  // console doesn't exist yet
  if( !nike.exp.debug.teslaConsole ){
    // setup the queue
    if( !nike.exp.debug.asyncProviders ){
      nike.exp.debug.asyncProviders = [];
    }

    nike.exp.debug.asyncProviders.push( data );
  }else{
    // console exists, dispatch data
    if(data){
      nike.dispatchEvent(nike.Event.DEBUG_UPDATE_PROVIDERS, data);
    }
    // console just loaded, if queue exists, update data
    else if(
      !data
      && nike.exp.debug.asyncProviders
    ){
      for(var i=0; i<nike.exp.debug.asyncProviders.length; i++){
        nike.dispatchEvent(nike.Event.DEBUG_UPDATE_PROVIDERS, nike.exp.debug.asyncProviders[i]);
      }

      delete nike.exp.debug.asyncProviders;

      nike.log(this.logPrefix, 'Updated providers with previously loaded content');
    }
  }
};

/**
 * Replaces the domain of the current URL with the nike store domain.
 * @returns {string}
 */
nike.Util.currentUrlToNikeUrl = function(){
  return location.href.replace(location.host, nike.SERVICE_URLS.oneStoreHost.split('/')[2]);
};

/**
 * Searches a string for {x} replacement markers and replaces w/ passed strings
 *
 * @param {String} [args] any number of strings with the first being the string to parse and replace
 * @returns {String}
 */
nike.Util.replaceSiteFurnitureValues = function (str) {
  if (!str || arguments.length === 1) {
    return str;
  }
  var replacements = Array.prototype.slice.call(arguments);
  var ret = str.slice(0); // Make a copy of the string to replace

  // The replacements are all the strings passed here except index 0
  replacements.shift();

  // Iterate through {1}, {2}, {3}, etc. depending on number of arguments passed.
  for (var i = 0; i < replacements.length; i++) {
    ret = ret.replace(new RegExp('\\{'+ (i+1) +'\\}', 'g'), replacements[i]);
  }

  return ret;
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Util. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.Orientation');

nike.requireDependency('nike.Util');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.EventBus');

/**
 * Orientation JS is meant to smooth the inconsistencies seen
 * between different devices implementation of the orientation change
 * event.
 *
 * There will be the following items properties available:
 *
 *  {
 *      trigger : [function] This is a no-param function to trigger an orientation event
 *                            to be dispatched into the nike event system.  Trigger does not start
 *                            the dom listeners, it will only broadcast the nike event.
 *      listen : [function] (callback:function) This accepts a callback function and will start up
 *                            the listeners for the orientation change events.  The passed in callback
 *                            function is what will be passed into the nike.listen as the callback method.
 *      LANDSCAPE : [string] One of the two 'orientations' returned as data from the nike event.
 *      PORTRAIT : [string] One of the two 'orientations' returned as data from the nike event.
 *  }
 *
 * The nike callback event will pass the following data.
 *  {
 *      orientation : [string] Either the value of the LANDSCAPE or PORTRAIT property.
 *      direction : [number] The current direction of the device.
 *            0 = portrait
 *            90 = counter clockwise landscape
 *            -90 = clockwise landscape
 *  }
 *
 *
 * @type {*}
 */
nike.exp.global.Orientation = (function ($, $window) {
  /**
   * CONSTANTS
   */
  var ORIENTATION_CHANGE_EVENT = 'orientationchange',
      ORIENTATION_PORTRAIT = 'portrait',
      ORIENTATION_LANDSCAPE = 'landscape',
      PORTRAIT_DIRECTION = 0,
  //how long to dispatch orientation change events
      DISPATCH_THROTTLE_TIME = 20,
  //controls for throttling the dispatch of the event.
      lastDispatch = 0,
      lastDispatchTimeout,
  //control for polling for orientation complete
      pollForCompleteInterval = null,
  //stores the last direction of the device
      lastDirection = $window[0].orientation,
      hasDirection = typeof lastDirection === 'number',
  /**
   * Obtains the orientation string of the current screen from the window object.
   *
   * Window.width > Window.height = Landscape
   */
      getOrientationFromWindow = function () {
        return $window.width() > $window.height() ? ORIENTATION_LANDSCAPE : ORIENTATION_PORTRAIT;
      },
  /**
   * Obtains the orientation string of the current string from the window.orientation property.
   *
   * 0 = portrait
   */
      getOrientationFromDirection = function () {
        return $window[0].orientation != PORTRAIT_DIRECTION ? ORIENTATION_LANDSCAPE : ORIENTATION_PORTRAIT;
      },
  //stores last orientation
      lastOrientation = getOrientationFromWindow(),
  /**
   * Throttles the amount of dispatches that can be made to prevent spamming the system.
   *
   * @param orientationString   What is the orientation string that should be dispatched.
   * @param orientationDirection   What is the direction value that should be dispatched.
   */
      dispatch = function (orientationString, orientationDirection) {
        var now = (new Date()).getTime();

        $window[0].clearTimeout(lastDispatchTimeout);

        if (lastDispatch + DISPATCH_THROTTLE_TIME < now) {
          lastDirection = orientationDirection;
          lastOrientation = orientationString;
          lastDispatch = now;
          nike.dispatchEvent(nike.Event.ORIENTATION_CHANGE, {orientation : orientationString, direction : orientationDirection});
        } else {
          lastDispatchTimeout = $window[0].setTimeout(
              function () {dispatch(orientationString, orientationDirection);},
              (lastDispatch + DISPATCH_THROTTLE_TIME) - now
            );
        }
      },
  /**
   * Because some devices fire the orientation event before changing the window, a poll needs to be done
   * to check if the orientation has completed before dispatching the event.
   *
   * @param targetOrientation   What is the orientation string that should be dispatched.
   * @param targetDirection   What is the direction value that should be dispatched.
   */
      pollForComplete = function (targetOrientation, targetDirection) {

        if (targetOrientation === getOrientationFromWindow()) {
          if (pollForCompleteInterval != null) {
            $window[0].clearInterval(pollForCompleteInterval);
            pollForCompleteInterval = null;
          }
          dispatch(targetOrientation, targetDirection);
        } else {
          if (pollForCompleteInterval == null) {
            pollForCompleteInterval = $window[0].setInterval(
              function () {pollForComplete(targetOrientation, targetDirection);},
              DISPATCH_THROTTLE_TIME
            );
          }
        }

      },
  /**
   * Callback function for handling the orientation change DOM event.
   */
      onOrientationChange = function () {
        var thisDirection = $window[0].orientation;

        if (thisDirection != lastDirection) {
          if (pollForCompleteInterval != null) {
            $window[0].clearInterval(pollForCompleteInterval);
            pollForCompleteInterval = null;
          }

          if (/android.*mobile/i.test(navigator.userAgent)) {
            pollForComplete(getOrientationFromDirection(), thisDirection);
          } else {
            dispatch(getOrientationFromDirection(), thisDirection);
          }
        }
      },
  /**
   * Callback function for handling the window resize event.
   */
      onWindowResize = function () {
        var thisOrientation = getOrientationFromWindow();

        if (thisOrientation != lastOrientation) {
          dispatch(thisOrientation, $window[0].orientation);
        }
      };

   if (hasDirection) {
     $window.on(ORIENTATION_CHANGE_EVENT, onOrientationChange);
   } else {
     nike.Util.windowResizeListen(onWindowResize);
   }

   return {
     /**
      * Will cause a nike event to be dispatched which with the current browser information.
      */
        trigger : function () {
          if (hasDirection) {
            dispatch(getOrientationFromDirection(), lastDirection);
          } else {
            dispatch(getOrientationFromWindow(), lastDirection);
          }
        },
     /**
      * Will test if the current orientation of the browser is landscape.
      * @return {Boolean}   True if landscape.
      */
        isLandscape : function () {
          return lastOrientation === ORIENTATION_LANDSCAPE;
        },
     /**
      * Will test if the current orientation of the browser is portrait.
      * @return {Boolean}   True if portrait.
      */
        isPortrait : function () {
          return lastOrientation === ORIENTATION_PORTRAIT;
        },
     /**
      * Will setup the callback methods for the DOM as well as add the passed callback
      * into nike.listen.
      *
      * @param callback   The function to execute when the event is fired.
      */
        listen : function (callback) {
          nike.listen(nike.Event.ORIENTATION_CHANGE, callback);
        },
     /**
      * Will remove the callback from listening to the event.
      * @param callback   The function that needs to no longer listen to the orientation change event.
      */
        unlisten : function (callback) {
          nike.unlisten(nike.Event.ORIENTATION_CHANGE, callback);
        },
        LANDSCAPE : ORIENTATION_LANDSCAPE,
        PORTRAIT : ORIENTATION_PORTRAIT
      };
})(jQuery, $(window));

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.Orientation. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.DomReady');

nike.requireDependency('jQuery');

nike.DomReady = function (callback) {
  $(callback);
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.DomReady. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * @namespace nike.exp.global.Modal
 */
nike.namespace("nike.exp.global.Modal");

nike.requireDependency('Class');
nike.requireDependency('nike.exp.global.Orientation');
nike.requireDependency('nike.DomReady');
nike.requireDependency('nike.Util');


/**
 * <p> Instantiating </p>
 * <p>Please use <code> nike.requireDependency('nike.exp.global.Modal') </code> when you need to use this class.
 * <p>The global modal class inserts a jQuery object into the DOM which acts as the "mask" or "blocker"
 * and also wraps the modal elements themselves.  You can instantiate a Modal object by creating a new
 * instance and passing an setup object containing a <code>$content</code> jQuery object.</p>
 *
 *     <code> var bar = $('<div>').html('Here is some content ') </code>
 *     <code> var foo = new nike.exp.global.Modal({$content: bar}); </code>
 *     <code> foo.open() </code>     opens the modal window
 *
 * <p> Closing </p>
 * <p>By default, an open modal window will call its close() method when the mask is clicked, the escape button
 * is pressed, or the modal close glyph is clicked.  The first two conditions can be set by the booleans
 * blockerClickCloses and escKeyCloses, respectively.  The modal close button can be hidden by setting hideCloseButton
 * to true in the setup object.  Modal windows will not be destroyed unless the modal.autoDestroy property is set
 * to true.</p>
 *
 * <p>You can also use the setup object to pass onClose callback methods, which receives the a closingType string
 * to describe the origin of the close method call. </p>
 *
 *
 * @author
 * @version July 2013
 */
nike.exp.global.Modal = (function ($, Class, orientation, domReady, util) {
  /**
   * Constants representing reason for closing modal
   *
   * @type {Object}
   */
  var CLOSE_TYPE = {
    /**
     * Indication that the modal was closed by the close button in the top right corner of the modal.
     * @constant
     */
    BUTTON: 'button',
    ESC_KEY: 'esc_key',
    MASK_CLICK: 'mask_click',
    USURPER: 'usurper',
    PROGRAMMATIC: 'programmatic'
  },

  /**
   * The escape character code
   *
   * @type {Number}
   * @constant
   */
  ESC_CHAR_KEY = 27,
  /**
   * Number of pixels for zero top
   *
   * @type {Number}
   * @constant
   */
  NO_TOP = 0,
  /**
   * Number of pixels in the margin for Modal windows
   *
   * @type {Number}
   * @constant
   */
  MODAL_MARGINS = 40,

  /**
   * Object that holds all of the css class-names used for modals
   * @type {{MASK: string,
   *        MODAL_WINDOW_NAME: string,
   *        MODAL_FULL_WIDTH: string,
   *        MODAL_FULL_SCREEN: string,
   *        MODAL_CONTENT_NAME: string,
   *        MODAL_CLOSE_NAME: string,
   *        MODAL_CLOSE_GLYPH: string,
   *        GLYPH_REPLACE: string,
   *        NO_DIM: string,
   *        MODAL_SHOWING: string}}
   */
  CLASSES = {
    /**
     * The class name of the modal mask
     *
     * @type {String}
     * @constant
     */
    MASK: 'modal-mask-class',
    /**
     * The class name for the modal window
     *
     * @type {String}
     * @constant
     */
    MODAL_WINDOW_NAME: 'modal-window-class',
    /**
     * The class that will be added to the window in order to take up all available width.
     *
     * @type {String}
     * @constant
     */
    MODAL_FULL_WIDTH: 'full-width',
    /**
     * The class to add to the window to occupy the full mobile screen
     *
     * @type {string}
     * @constant
     */
    MODAL_FULL_SCREEN: 'full-screen',
    /**
     * The class to add to the window when fading in or out
     *
     * @type {string}
     * @constant
     */
    CAN_FADE_IN_OUT: 'has--animation',
    /**
     * The class name for the modal content container
     *
     * @type {String}
     * @constant
     */
    MODAL_CONTENT_NAME: 'modal-content-class',
    /**
     * The class name for the modal close button wrapper
     *
     * @type {String}
     * @constant
     */
    MODAL_CLOSE_NAME: 'modal-close',
    /**
     * The class name for the modal close button
     *
     * @type {String}
     * @constant
     */
    MODAL_CLOSE_GLYPH: 'modal-close-glyph',
    /**
     * The class name to invoke glyph replacement
     *
     * @type {String}
     * @constant
     */
    GLYPH_REPLACE: 'nsg-glyph--x',
    /**
     * The class name for the modal mask when not greyed
     *
     * @type {String}
     * @constant
     */
    NO_DIM: 'no-dim',
    /**
     * The class name to apply when actively showing the modal
     *
     * @type {String}
     * @constant
     */
    MODAL_SHOWING: 'modal-show',
    /**
     * The class name for the {@link verticalAlignmentBar}
     *
     * @type {String}
     * @constant
     */
    VERTICAL_ALIGN: 'verticalAlign'
  },

  /**
   * The attribute value added to the close button for qa.
   *
   * @type {String}
   * @constant
   */
  MODAL_CLOSE_BUTTON_QA_ATTRIBUTE = 'modal.button.close',

  /**
   * The character representing the close button glyph for mobile
   *
   * @type {String}
   * @constant
   */
  IOS_NAVBAR_HEIGHT = 60,

  /**
   * The jquery object representing the modal mask
   *
   * @type {jQuery}
   */
  mask = $('<div>', {'class': CLASSES.MASK}),
  /**
   * Hidden alignment div against which to vertically align the modal
   *
   * @type {jQuery}
   */
  verticalAlignmentBar = $('<div>', {'class': CLASSES.VERTICAL_ALIGN}),
  /**
   * Page body.  Set at DomReady
   *
   * @type {jQuery|undefined}
   */
  $body,
  /**
   * The window.  Set at DomReady.
   *
   * @type {jQuery|undefined}
   */
  $window,
  /**
   * Determines if user is viewing site from a mobile device
   *
   * @type {Boolean|undefined}
   */
  isMobile,
  /**
   * Determines if user is viewing site from a tablet device
   *
   * @type {Boolean|undefined}
   */
  isTablet,
  /**
   * Determines if user agent is using iOS, which requires additional position manipulation
   *
   * @type {Boolean|undefined}
   */
  isIOS,
  /**
   * Determines if user agent is using an Android device, which requires additional position manipulation
   *
   * @type {Boolean|undefined}
   */
  isAndroid,

  /**
   * The currently open modal object
   *
   * @type {Modal|undefined}
   */
  currentlyOpen,
  /**
   * The window of the currentlyOpen modal class
   *
   * @type {jQuery|undefined}
   */
  modalWindow,
  /**
   * Number of pixels between the bottom of the modalWindow and the top of the page
   *
   * @type {Number|undefined}
   */
  modalBottom,
  /**
   * Number of pixels between the top of the modalWindow and the top of the page
   *
   * @type {Number|undefined}
   */
  modalTop,
  /**
   * The height of the modalWindow in pixels
   *
   * @type {Number|undefined}
   */
  modalHeight,
  /**
   * Number of pixels between the top of the viewable area and the top of the page
   *
   * @type {Number|undefined}
   */
  windowTop,
  /**
   * Number of pixels between the top and bottom of the viewable area
   *
   * @type {Number|undefined}
   */
  windowHeight,
  /**
   * Number of pixels between the bottom of the viewable area and the top of the page
   *
   * @type {Number|undefined}
   */
  viewableBottom,
  /**
   * Determines if the Modal is occupying the whole mobile screen
   *
   * @type {Boolean}
   */
  fullScreen = false,
  /**
   * Determines if the Modal fades in or out
   *
   * @type {Boolean}
   */
  fadeInOut = false,
  /**
   * Determines if the keyboard is open for touch devices
   *
   * @type {Boolean}
   */
  keyboardOpen = false,
  /**
   * Determines if the modal is currently open
   *
   * @type {Boolean}
   */
  isOpen,
   /**
    * Determines if the browser is currently zoomed in
    */
  isZoomed = false,

  /**
   * Creates jQuery objects for the different wrappers and elements of the modal
   * and returns an assembled modal, with or without a close button.
   *
   * @param hideCloseButton   {Boolean} Determines if the close button element will be added to the modal.
   * @param fullWidth         {Boolean} Determines if the full width class will be added to the modal.
   * @param fullScreen        {Boolean} Determines if the full screen class will be added to the modal.
   * @param {Object} modalRef - Reference to the current Modal.
   * @param fadeInOut         {Boolean} Determines if the fade-in-out class will be added to the modal.
   * @returns {jQuery}  jQuery for the content container.
   */
  modalInsert = function (hideCloseButton, fullWidth, fullScreen, modalRef, fadeInOut) {
    var container = $('<div>', {'class': CLASSES.MODAL_WINDOW_NAME + ' nsg-bg--white'}),
    content = $('<div>', {'class': CLASSES.MODAL_CONTENT_NAME}),
    closeButton = $('<div>', {'class': CLASSES.MODAL_CLOSE_NAME}),

    //Determines if user is on mobile device and if so, loads the mobile glyph.
    closeGlyph = $('<div>', {'class': CLASSES.MODAL_CLOSE_GLYPH + ' ' + CLASSES.GLYPH_REPLACE});

    util.addQaAttribute(closeButton, MODAL_CLOSE_BUTTON_QA_ATTRIBUTE);

    closeButton.append(closeGlyph);
    container.append(content);
    container.addClass(modalRef.windowSelectorClass);

    //apply full width to the modal if requested.
    if (fullWidth) {
      container.addClass(CLASSES.MODAL_FULL_WIDTH);
    }

    if (fullScreen) {
      container.addClass(CLASSES.MODAL_FULL_SCREEN);
    }

    if (fadeInOut && !fullScreen) {
      container.addClass(CLASSES.CAN_FADE_IN_OUT);
    }

    if (!hideCloseButton) {
      container.append(closeButton);
    }
    mask.append(container);
    mask.append(verticalAlignmentBar);
		mask.addClass(modalRef.selectorClass);

    if (isMobile) {
      mask.addClass('isMobile');
    }
    if (isIOS) {
      mask.addClass('isIOS');
    }
    if (isAndroid){
      mask.addClass('isAndroid');
    }
    return content;
  },
  /**
   * Compares borders and position of window to those of a Modal Window and realigns if necessary.
   * Does not realign if the keyboard is open or if browser is zoomed
   *
   */
  reAlignModal = function () {
    // Checks the window width vs page width to determine if the browser is zoomed
    isZoomed = $(window).width() / window.innerWidth > 1;

    if ((isMobile || isIOS || isAndroid) && !keyboardOpen && currentlyOpen && !fullScreen && !isZoomed) {
      nike.debug('Re-aligning modal because of mobile keyboard.');
      modalWindow = currentlyOpen.$contentContainer.parent();
      modalTop = parseInt(modalWindow.css('top')) ? parseInt(modalWindow.css('top')) : NO_TOP;
      modalHeight = modalWindow.outerHeight() + MODAL_MARGINS;
      modalBottom = modalTop + modalHeight;
      windowTop = $window.scrollTop();
      windowHeight = window.innerHeight ? window.innerHeight : $window.height();
      viewableBottom = windowTop + windowHeight;
      isOpen = currentlyOpen.isOpen;

      if (modalHeight > windowHeight) {
        if (isOpen) {
          if (modalBottom < viewableBottom) {
            modalWindow.css('top', viewableBottom - (modalHeight));
          } else if (modalTop > windowTop) {
            // If were at the very top, set it to zero because of rubber band scrolling on ios
            if (window.scrollY <= 0) {
              modalWindow.css('top', 0);
            } else {
              modalWindow.css('top', windowTop);
            }
          }
        } else {
          modalWindow.css('top', windowTop);
        }
      } else {
        modalWindow.css('top', windowTop + ((windowHeight - modalHeight) / 2));
      }
    }
  },

  /**
   * Sets listeners for clicks, ESC keyups, scrolling, and orientation changes
   */
  setListeners = function () {

    // Sets keyboardOpen to true when focus moves to an input or text area
    mask.on('focusin', 'input, textarea', function (e) {
      keyboardOpen = true;
    });

    // Sets keyboardOpen to false when focus moves away from an input or text area
    mask.on('focusout', 'input, textarea', function (e) {
      keyboardOpen = false;
      if (isIOS || isMobile || isAndroid) {
        reAlignModal();
      }
    });

    //Touch handler for focus problems with iOS on the close button
    mask.on('touchstart', '.modal-close', function (e) {
      $(this).removeClass('ignore-hover');
    });
    mask.on('touchend', '.modal-close', function (e) {
      $(this).addClass('ignore-hover');
    });

    //Click handler to close modal when close button container is clicked
    mask.on('click', '.' + CLASSES.MODAL_CLOSE_NAME, function () {
      currentlyOpen.close(CLOSE_TYPE.BUTTON);
    });

    //Click handler to close modal when mask is clicked.  Will not close if blockerClickCloses is false.
    mask.on('click', function (e) {
      if (e.target.className === CLASSES.MASK && currentlyOpen.blockerClickCloses) {
        currentlyOpen.close(CLOSE_TYPE.MASK_CLICK);
      }
    });

    //Stops scrolling on mask to allow single scrolling on modal window (desktop only due to mobile scroll event origin)
    mask.on('scroll', function (e) {
      e.stopPropagation();
    });

    //handle scrolling on a touch device since the scrolling principle is different than desktop
    var lastScroll = null;
    $(document).on('scroll', function (e) {
      if (typeof currentlyOpen != 'undefined' && currentlyOpen != '') {
        if (isIOS || isAndroid) {
          reAlignModal();
        } else {
          if (lastScroll) {
            window.clearTimeout(lastScroll);
          }
          lastScroll = window.setTimeout(reAlignModal, 100);
        }
      } else {
        if (lastScroll) {
          window.clearTimeout(lastScroll);
        }
        lastScroll = null;
      }
    });

    nike.listen(nike.Event.ORIENTATION_CHANGE, function(e){
      if (typeof currentlyOpen != 'undefined' && currentlyOpen != '') {
        if (isIOS || isAndroid) {
          reAlignModal();
        }
      }
      if (isTablet) {
        mask.css('minHeight', $window.height());
      }
    });


    //Key handler to close modal when escape button is pressed and escKeyCloses is true.
    $body.on('keyup', function (e) {
      if (e.which === ESC_CHAR_KEY) {
        if (currentlyOpen && currentlyOpen.isOpen && currentlyOpen.escKeyCloses) {
          currentlyOpen.close(CLOSE_TYPE.ESC_KEY);
        }
      }
    })
  },


  /**
   * The modal class
   * @extends Class
   */
  Modal = Class.extend(
  /** @lends nike.exp.global.Modal.prototype */
  {
    /**
     * The modal content object
     *
     * Type {jQuery|undefined}
     */
    $contentContainer: undefined,

    /**
     * Status of modal's viewable state
     *
     * @type {Boolean}
     * @default false
     */
    isOpen: false,

    /**
     * Determines if mask will show dark or clear
     *
     * @type {Boolean}
     * @default true
     */
    darkMask: true,

    /**
     * Determines if click handler for mask will close the modal
     *
     * @type {Boolean}
     * @default true
     */
    blockerClickCloses: true,

    /**
     * Determines if the escape key will close the modal
     *
     * @type {Boolean}
     * @default true
     */
    escKeyCloses: true,

    /**
     * Determines if closing the modal will cause the modal to be destroyed
     *
     * @type {Boolean}
     * @default false
     */
    autoDestroy: false,

    /**
     * The initialization method for global Modal class
     * @param {Object} setup
     * @param {jQuery} [setup.$content] the jQuery object containing the content of the modal
     * @param {Boolean} [setup.autoDestroy=false] setup.autoDestroy sets modal to destroy itself upon close
     * @param {Boolean} [setup.escKeyCloses=true] setup.escKeyCloses sets the modal to close itself upon esc key press
     * @param {Boolean} [setup.blockerClickCloses=true] setup.blockerClickCloses sets the modal to close itself upon click on mask
     * @param {Boolean} [setup.darkMask=true] setup.darkMask sets the modal to have a dark mask
     * @param {Boolean} [setup.hideCloseButton=false] setup.hideCloseButton sets the modal to hide its default close button.  Cannot be changed later.
     * @param {Boolean} [setup.fullWidth=false] setup.fullWidth Sets the modal to expand the full width of available window space.  Cannot be changed later.
     * @param {Boolean} [setup.fullScreen=false] setup.fullScreen Sets the modal to full screen mode
     * @param {Function} [setup.onClose] a callback to be called on close
     * @param {Boolean} [setup.fadeInOut=false] setup.fadeInOut Sets weather or not the modal fades when opening and closing
     * @constructs
     */
    init: function (setup) {
			/**
			 * A custom selector class that will be added to the modal parent. This will allow for easier targeting of modals for styling.
			 *
			 * @type {String}
			 * @default
			 */
			this.selectorClass = '';
      this.windowSelectorClass = '';

      this.cssModifiers = {
        IS_FADING_IN: 'is--fading-in',
        IS_FADING_OUT: 'is--fading-out'
      }

			$.extend(this, setup);

      this.$contentContainer = modalInsert(setup.hideCloseButton, setup.fullWidth, setup.fullScreen, this, setup.fadeInOut);
      this.setContent(setup.$content);
      if (setup.onClose instanceof Function) {
        this.onClose = setup.onClose;
      } else {
        this.onClose = $.noop;
      }

      fullScreen = !!setup.fullScreen;

      this.fadeInOut = setup.fadeInOut || fadeInOut;

      this.$contentContainer.parent().hide();
    },

    /**
     * Sets the content of the modal.  Replaces any pre-existing content.
     * @param $content
     */
    setContent: function ($content) {
      if ($content) {
        if (this.$contentContainer.children().length == 0) {
          this.$contentContainer.append($content);
        } else {
          this.$contentContainer.children().replaceWith($content);
        }
      }
    },

    /**
     * Closes all open modals and then shows the modal to be opened
     */
    open: function () {
      var _self = this;

      if (currentlyOpen && currentlyOpen.isOpen) {
        currentlyOpen.close(CLOSE_TYPE.USURPER);
      }
      currentlyOpen = this;
      mask.find('.' + CLASSES.MODAL_WINDOW_NAME).hide();
      mask.toggleClass(CLASSES.NO_DIM, !this.darkMask);
      if (isTablet) {
        mask.css('minHeight', $window.height());
      }

      if (this.fadeInOut && !this.fullScreen) {
        mask.fadeIn();
        this.$contentContainer.parent().removeClass(this.cssModifiers.IS_FADING_OUT);
        setTimeout( function() {
          _self.$contentContainer.parent().addClass(_self.cssModifiers.IS_FADING_IN);
        }, 200);
      } else if(this.fadeInOut && this.fullScreen) {
        mask.fadeIn();
      } else {
        mask.show();
      }

      //make platform-specific adjustments to modal positioning behavior
      if (!isMobile && !isIOS && !isAndroid) {
        $('html').addClass(CLASSES.MODAL_SHOWING);
      }
      else if (isMobile || isIOS || isAndroid) {
        if (!this.fullScreen) {
          reAlignModal();
        }
      }
      else {
        this.$contentContainer.parent().css('top', $window.scrollTop());
      }
      //change modal status to open
      this.$contentContainer.parent().css('display', 'inline-block');
      this.isOpen = true;
    },

    /**
     * Calls onClose.  If onClose returns true, closes the modal and hides the mask,
     * sets isOpen to false.
     *
     * @param {string} [closeType]
     */
    close: function (closeType) {
      var _self = this;

      if (typeof closeType === 'undefined') {
        closeType = CLOSE_TYPE.PROGRAMMATIC;
      }
      var confirmClose = this.onClose(closeType);
      if (confirmClose || typeof confirmClose === 'undefined') {

        if (this.fadeInOut && !this.fullScreen) {
          _self.$contentContainer.parent().removeClass(this.cssModifiers.IS_FADING_IN);
          _self.$contentContainer.parent().addClass(this.cssModifiers.IS_FADING_OUT);
          setTimeout(function () {
            mask.fadeOut();
          }, 200);
        } else if(this.fadeInOut && this.fullScreen) {
          mask.fadeOut();
        } else {
          mask.hide();
        }

        this.isOpen = false;
        currentlyOpen = '';
        if (!isMobile) {
          $('html').removeClass(CLASSES.MODAL_SHOWING);
        }
        if (this.autoDestroy) {
          this.destroy();
        }
      }
    },
    /**
     * Property to hold custom callbacks to be fired when a modal is closed.
     * To prevent modal from closing, return false.
     *
     * @param closeType
     * @return
     */
    onClose: function (closeType) {
      return true;
    },

    /**
     * Removes the markup for the modal container.
     */
    destroy: function () {
      this.$contentContainer.parent('.' + CLASSES.MODAL_WINDOW_NAME).remove();
    }


  });

  /**
   * Creates a mask when DOM is ready and sets listeners
   */
  domReady(function () {
    $body = $('body').append(mask);
    $window = $(window);
    isMobile = nike.objectDefined('exp.script.device_detect._isMobile', nike, true) === true;
    isIOS = $body.hasClass('iOS');
    isAndroid = $body.hasClass('Android');
    isTablet = $body.hasClass('Tablet');
    setListeners();
  });

  Modal.CLOSE_TYPE = CLOSE_TYPE;

  return Modal;

})(jQuery, Class, nike.exp.global.Orientation, nike.DomReady, nike.Util);


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.Modal. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Notification');

nike.requireDependency('nike.exp.global.Modal');

nike.Notification = $.extend({}, nike.Notification, {

  /**
   * Instance of the modal popup
   */
  modal:undefined,

  /**
   * DOM element holding the message
   */
  messageBox:undefined,

  /**
   * Create an alert popup window with a custom
   * message and buttons
   *
   * @param message Text to show in the alert box
   * @param [buttons] String or array of strings to use as buttons
   * @param [callback] Function called with clicked button text
   */
  show: function(message, buttons, callback, type){

    var self = this,
        isOutfitter = ($('#exp-outfit-pdp-container').length > 0) ? true : false;

    // If the modal is already showing just append the message
    if (this.modal){
      this.messageBox.append('<br />' + message);
    }
    else{
      var body = $('body');
      var box = $('<div id="NotificationBox"></div>');
      var header = nike.exp.global.LocalValueUtil.getLocal('pdp.error.cartHeader');
      var buttonText;
      var buttonElement;
      var buttonArray;
      var okText;
      var i, L;

      if(isOutfitter){
        box.addClass('outfitter');
        box.attr('data-qa', 'outfitter.pdp.productUnavailableErrorMssg');
      }

      header = '<div class="notification-header nsg-font-family--platform">' + header + '</div>';
      box.append(header);

      // Keep a reference to the message box so we can add to it later
      this.messageBox = $('<div class="notification-message">' + message + '</div>');
      box.append(this.messageBox);

      // Convert a string to an array
      if (buttons){
        buttonArray = typeof buttons === 'string' ? [buttons] : buttons;
      }
      else{
        // Look for localized "OK" if no text is specified
        okText = nike.exp.global.LocalValueUtil.getLocal('notification.ok');
        buttonArray = [okText || 'OK'];
      }

      // Add button divs
      for (i = 0, L = buttonArray.length; i < L; i++){
        buttonText = buttonArray[i];
        buttonElement = $('<button class="notification-button nsg-button nsg-grad--nike-orange" data-index="' + i + '">' + buttonText + '</button>');
        box.append(buttonElement);
      }

      // Add close events to buttons
      box.delegate(".notification-button", "click", function(e){
        e.preventDefault();
        var button = $(this);
        var eventInfo = {'index':button.data('index'), 'text':button.text()};
        //Delete this with UpgradePrompt.js
        if (type) eventInfo.type = "upgradePrompt";

        nike.dispatchEvent(nike.gadget.Event.NOTIFICATION_DISMISS, eventInfo);

        if (callback){
          callback(eventInfo);
        }
        self.modal.close();
      });


      // Create modal popup
      this.modal = new nike.exp.global.Modal({
        $content : box,
        blockerClickCloses: false,
        fullWidth: false,
        autoDestroy: true,
        onClose: function(){
          delete self.modal;
        }
      });

      self.modal.open();

    }
  }

});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Notification. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.ErrorHandler');

nike.requireDependency('nike.Notification');
nike.requireDependency('nike.Event');

/**
 * Listen to events that have error messages
 * that need to be presented to the user
 */
nike.listen([nike.EVENT_LOAD_GADGET_FAIL,
             nike.Event.ADD_TO_CART_FAIL,
             nike.Event.UPDATE_CART_ITEM_FAIL,
             nike.Event.ADD_WISHLIST_ITEM_FAIL], function(event, data){

    var message = '';
    var header  = '';
    var errorMessage;
    var errors;
    var error;
    var i, L;

    if (data &&
        data.response){

      // Direct service calls contain Object[] 'exceptions'
      // TESLA proxied calls contain String[] 'errorMessages'
      errors = data.response.errorMessages || data.response.exceptions;

      if (errors &&
          errors.length > 0){
        // Build error message
        for (i = 0, L = errors.length; i < L; i++){
          error = errors[i];
          errorMessage = error.message || error;
          if (error.errorcode == 'noItemsToAddInStock' && data.requestData.outfitter){
            header = '<h3>' + nike.exp.global.LocalValueUtil.getLocal('outfitpdp.outofstock.errortitle') + '</h3>';
            //message = '<div class="message">' + nike.exp.global.LocalValueUtil.getLocal('outfitpdp.outofstock.message') + '</div>';
            message = '<div class="message nsg-font-family--base">' + errorMessage + '</div>';
            break;
          }
          if (typeof errorMessage == 'string' &&
              errorMessage.length > 0){
            message += ' ' + '<div class="message nsg-font-family--base">' + errorMessage + '</div>';
          }
        }
        if(header != ''){
          message = header + message;
        }
        // Show notification
        if (message.length > 0){
          nike.Notification.show(message);
        }
      }

    }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.ErrorHandler. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace('nike.geo.Configuration');

nike.requireDependency('nike.Util');

/**
 * Geo configuration for the site.  The Regions, countries and languages should be populated from the backend.
 */
nike.geo.Configuration = _.extend(nike.geo.Configuration, {



	/* Format for countries :
	 * {
	 *   "US" : {countryCode: "us",
	 *           displayName : "United States",
	 *           supportedLanguageList : ["en_us" : {lang: "en", dialect: "us", displayName: "English"}],
	 *           mappedCountryList : ["XX", "YY", "ZZ"]
	 *  }
	 * }
	 */
  COUNTRIES : nike.objectDefined('nike.exp.dynamic.AppConfig.COUNTRIES') ? nike.exp.dynamic.AppConfig.COUNTRIES : {},

	/**
	 * Format for REGIONS:
	 * REGIONS : {
	 *   EU : {
	 *     abbrev: "EU",
	 *     displayName: "Europe",
	 *     countryList : ["AT", "BE", "CZ", "GB", ...]
	 *   }
	 * }
	 */
	REGIONS: nike.objectDefined('nike.exp.dynamic.AppConfig.REGIONS') ? nike.exp.dynamic.AppConfig.REGIONS : {},


	LANGUAGES : nike.objectDefined('nike.exp.dynamic.AppConfig.LANGUAGES') ? nike.exp.dynamic.AppConfig.LANGUAGES : {},

	/**
	 * Get the country object for the country code passed in
	 */
	getCountryConfiguration : function(countryCode) {
	  var ret = null;
	  var nikeCode = nike.geo.Configuration.resolveNikeCountry(countryCode);
	  if(nikeCode){
	    ret = nike.geo.Configuration.COUNTRIES[nikeCode.toUpperCase()];
	  }
	  return ret;
	},


	/**
	 * Takes a country code and returns the country code for what what country we will treat it as in code.
	 * This is needed so we can group countries into "zones" which will have a single presentation.
	 * This allows us to support a region rather without having to support each country in the region individually.
	 *
	 *  If no match is found we return undefined which basically means we don't support the country.
	 */
	resolveNikeCountry : function(countryCode){
	  var propName, country;
	  var countryList;
	  var lowerCountryCode;

	  if(countryCode !== undefined && countryCode !== null){

	    lowerCountryCode = countryCode.toLowerCase();

	    //Loop through the country list and try to find a match in either the country code or the list of mapped countries
  	  //I'm not checking if the code is mapped to a property directly because i want to test the countries code, then the map entries in order.
  	  for(propName in nike.geo.Configuration.COUNTRIES){
  	    if(nike.geo.Configuration.COUNTRIES.hasOwnProperty(propName)){
  	      country = nike.geo.Configuration.COUNTRIES[propName];

  	      if(country.countryCode.toLowerCase() == lowerCountryCode){
  	        //If the country is found, return the countryCode
  	        return lowerCountryCode;

  	      } else if(country.mappedCountryList && country.mappedCountryList.length > 0){
  	        //If a mapped country is found, return the main country's countryCode
  	        countryList = country.mappedCountryList;
  	        for(var i=0; i < countryList.length; i++) {

              if(countryList[i].toLowerCase() == lowerCountryCode){
  	            return country.countryCode.toLowerCase();
  	          }
  	        }
  	      }

  	    }
  	  }
	  }
	},


	isSupported : function(countryCode) {
	  return nike.geo.Configuration.resolveNikeCountry(countryCode) !== undefined;
	},

	isSupportedLanguage : function(countryCode, language) {
		var config = nike.geo.Configuration.getCountryConfiguration(countryCode);
		var languages;
		var ret = false;

		if (language && config && config.supportedLanguageList) {
			languages = config.supportedLanguageList;
			return $.inArray(language.toLowerCase(), languages) > -1;
		}

		return ret;
	},

	getDisplayName : function(countryCode) {
		var config = nike.geo.Configuration.getCountryConfiguration(countryCode);
		if (config) {
			return config.displayName;
		} else {
			return null;
		}
	},

	getDefaultLanguage : function(countryCode) {
		var config = nike.geo.Configuration.getCountryConfiguration(countryCode);
		if (config && config.supportedLanguageList && config.supportedLanguageList.length > 0) {
			return config.supportedLanguageList[0];
		} else {
			nike.error('nike.geo.Configuration', 'unsupported country', countryCode);
			return null;
		}
	},

	isSameRegion : function(country1, country2) {

		if (country1 && country2 && country1 === country2) {
			return true;
		}

		var country1Entry = nike.geo.Configuration.getCountryConfiguration(country1);
		var country2Entry = nike.geo.Configuration.getCountryConfiguration(country2);

		return country1Entry && country2Entry && country1Entry.region === country2Entry.region;
	},


	/**
	 * Check if the named region contains the country code (actually the nikeCountryCode resolved from the country code)
	 * If the region and country are both found and the country is contained in the region, return true, otherwise return false
	 */
	isCountryInRegion : function(countryCode, regionName){
	  var ret = false;
	  var regionObj, nikeCountryCode;
	  var countryList, i, L;

	  if(countryCode && regionName && nike.geo.Configuration.REGIONS){
	    nikeCountryCode = nike.geo.Configuration.resolveNikeCountry(countryCode);
	    regionObj = nike.geo.Configuration.REGIONS[regionName.toUpperCase()];

	    //Make sure both country and region were found
	    if(regionObj && regionObj.countryList && nikeCountryCode){

	      //Check if region contains country
	      for(i=0, L=regionObj.countryList.length; i < L; i++){
	        if(regionObj.countryList[i].toLowerCase() == nikeCountryCode.toLowerCase()){
	          ret = true;
	          break;
	        }
	      }
	    }
	  }

	  return ret;
	},

	getSupportedLanguages : function(countryCode) {
		var ret = null;
		var countryConf = nike.geo.Configuration.getCountryConfiguration(countryCode);

		if (countryConf && countryConf.supportedLanguageList) {
			ret = [];

			var languageMap = nike.geo.Configuration.LANGUAGES;
			$.each(countryConf.supportedLanguageList, function(i, lang) {
				var languageConf = languageMap[lang];
				if (languageConf) {
					ret.push(languageConf);
				}
			});
		}
		return ret;
	}
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.geo.Configuration. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.CookieUtil('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.CookieUtil('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.CookieUtil('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.CookieUtil('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: the root path '/').
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.CookieUtil
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.CookieUtil('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @returns {string|undefined} The value of the cookie.
 * @type String
 *
 * @name $.CookieUtil
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

nike.namespace('jQuery.CookieUtil');
nike.requireDependency('jQuery');

jQuery.CookieUtil = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '; path=/';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.CookieUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.geo.Edgescape');

/**
 * This acts as an interface for the Geolocation data.  The object holds the following fields:
 * 
 *  country: The user's country based on their IP address
 *  region: The user's region or state based on their IP address
 *  dma: The user's Nielson's media market based on their IP address
 *  bandwidth: The user's approximate bandwidth in Kbps
 *  timezone: The 3-character code for the user's time zone according to their IP address
 *  latitude: The user's latitude according to their IP address
 *  longitude: The user's longitude according to their IP address
 */
(function() {
	
	var EdgescapeDataType = Class.extend({
		
		EDGESCAPE_COOKIE : "geoloc",
		
		country : null,
		region : null,
		dma : null,
		bandwidth : null,
		timezone : null,
		latitude : null,
		longitude : null,
    trueclientip: null,
		
		/**
		 * Parse the data from the cookie and store it on the object.
		 */
		init : function() {
			var data = jQuery.CookieUtil(this.EDGESCAPE_COOKIE);
			
			if (data) {
				var data_array = data.split(",");
	
				for (var i = 0; i < data_array.length; i++) {
					var pair = data_array[i].split("=");
					var code = pair[0];
					var value = pair[1];
					
					switch (code) {
					case "cc":
						this.country = value;
						break;
					case "rc":
						this.region = value;
						break;
					case "dma":
						this.dma = value;
						break;
					case "bw":
						this.bandwidth = value;
						break;
					case "tz":
						this.timezone = value;
						break;
					case "la":
						this.latitude = value;
						break;
					case "lo":
						this.longitude = value;
						break;
          case 'tcip':
            this.trueclientip = value;
					}
					
				}
			}
		}
	});
	
	nike.geo.Edgescape = new EdgescapeDataType();
}());


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.geo.Edgescape. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.geo.CookieData');

nike.requireDependency("jQuery.CookieUtil");

(function(){

	var CookieDataType = Class.extend({

		CONSUMER_CHOICE_NAME : "CONSUMERCHOICE",
		CONSUMER_CHOSE_NAME : "CONSUMERCHOICE_SESSION",
		COMMERCE_COUNTRY_NAME : "NIKE_COMMERCE_COUNTRY",
		COMMERCE_LANGUAGE_NAME : "NIKE_COMMERCE_LANG_LOCALE",
		GEO_DETECTED_NAME : "nike_locale",

		/**
		 * 
		 */
		consumerChoice : { country : null, language : null },
		commerce : { country : null, language : null },
		sessionDetected : { country : null, language : null },
		consumerChose : false,

		init : function(){
			this.commerce.country = jQuery.CookieUtil(this.COMMERCE_COUNTRY_NAME);
			this.commerce.language = jQuery.CookieUtil(this.COMMERCE_LANGUAGE_NAME);
			this.consumerChoice = this.parseConsumerChoiceCookie();
			this.sessionDetected = this.parseSessionDetectedCookie();
			this.consumerChose = jQuery.CookieUtil(this.CONSUMER_CHOSE_NAME) === "t";
		},

		parseConsumerChoiceCookie : function() {

			var ccObject = { country : null, language : null };
			var consumerChoiceValue = jQuery.CookieUtil(this.CONSUMER_CHOICE_NAME);
			if (consumerChoiceValue) {
				var ccPair = consumerChoiceValue.split("/");
				ccObject.country = ccPair[0];
				ccObject.language = ccPair[1];
			}
			return ccObject;
		},

		parseSessionDetectedCookie : function() {
			var sessionObject = { country : null, language : null };
			var sessionValue = jQuery.CookieUtil(this.GEO_DETECTED_NAME);
			if (sessionValue) {
				var sessionValueArray = sessionValue.split('/');
				sessionObject.country = sessionValueArray[0];
				sessionObject.language = sessionValueArray[1];
			}
			return sessionObject;
		},
		
		setCommerce : function(country, language) {
			
			var formattedCountry = nike.geo.CookieData.formatCountryForCommerce(country);
			var formattedLanguage = nike.geo.CookieData.formatLangLocaleForCommerce(language);

			var changed = false;
			if (formattedCountry && formattedLanguage) {
				
				if (!nike.util.StringUtil.equalsIgnoreCase(formattedCountry, nike.geo.CookieData.commerce.country)) {
				  nike.geo.CookieData.setCookie(nike.geo.CookieData.COMMERCE_COUNTRY_NAME, formattedCountry, "/", nike.geo.CookieData.getCookieDomain());
					nike.geo.CookieData.commerce.country = formattedCountry;
					changed = true;
				}
				
				if (!nike.util.StringUtil.equalsIgnoreCase(formattedLanguage, nike.geo.CookieData.commerce.language)) {
				  nike.geo.CookieData.setCookie(nike.geo.CookieData.COMMERCE_LANGUAGE_NAME, formattedLanguage, "/", nike.geo.CookieData.getCookieDomain());
					nike.geo.CookieData.commerce.language = formattedLanguage;
					changed = true;
				}
			} 
			return changed;
		},
		
		/**
		 * Formats a lang_locale string for the nike commerce locale cookie.
		 * 
		 * @return string in the format lang_LOCALE or null if the provided string was invalid.
		 */
		formatLangLocaleForCommerce : function(language) {
			if (language && typeof language === "string" && language.indexOf("_") >= 0) {
				
				language = language.toLowerCase();
				var lang = null;
				var locale = null;
				
				var underscorePos = language.indexOf("_");
				lang = language.substring(0,underscorePos);
				locale = language.substring(underscorePos+1).toUpperCase();
				
				return lang + "_" +locale;
			} else {
				nike.warn('Unable to format locale '+language+'.  Must be of format LANGUAGE_LOCALE.');
				return null;				
			}
		},
		
		/**
		 * Formats a country string for the nike commerce country cookie.
		 * 
		 * @return string
		 */		
		formatCountryForCommerce : function(country) {
			if (country && typeof country === "string") {
				return country.toUpperCase();
			}
			return null;
		},
		
		/**
		 * This was pulled straight from Countries_Locales_Cookies.js in an attempt to pull
		 * useful functions and leave the rest behind.
		 * 
		 * @returns {String}
		 */
		setCookie : function(name, value, path, domain) {
		    var today = new Date();
		    var expires = new Date();
		    var curCookie;
		    expires.setTime(today.getTime() + 3600000 * 24 * 365);
		    curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") +
		                ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "");
		    document.cookie = curCookie;
		    return curCookie;
		},
		 
		/**
		 * This was pulled straight from Countries_Locales_Cookies.js in an attempt to pull
		 * useful functions and leave the rest behind.
		 * 
		 * @returns {String}
		 */
		getCookieDomain : function () {
		    var hostname = location.hostname;
		    var hnIndexOf = "."+nike.ROOT_DOMAIN;
		    if (hostname.indexOf(hnIndexOf) >= 0) {
		        return hnIndexOf;
		    }
		    else {
		        return "";
		    }
		 
		}
		
	});

	nike.geo.CookieData = new CookieDataType();
	
}());


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.geo.CookieData. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.geo.Util');

nike.requireDependency('jQuery');
nike.requireDependency('jQuery.url');
nike.requireDependency('nike.geo.CookieData');
nike.requireDependency('nike.geo.Configuration');
 
 
nike.geo.Util.FINAL_LANDING_PAGE_PARAM = 'flp';
nike.geo.Util.FINAL_LANDING_HOST_PARAM = 'flh';
nike.geo.Util.FINAL_LANDING_HOST_KEY_NIKESTORE = 'store';
nike.geo.Util.FINAL_LANDING_HOST_KEY_WWW = 'one';
 
/**
 * Redirect the user to a different country/language combination and set
 * the appropriate cookies to indicate they should stay there.
 * 
 * 
 * @param country
 * @param languageLocale A lang_locale combination.  Defaults to the default according to nike.geo.BaseConfiguration.getDefaultLanguage().
 * @param consumerChose Indicates whether or not to set the CONSUMER_CHOICE cookie
 * @param {Number} [delay] Used to delay the redirect by a number of milliseconds
 * @param Allows you to override the URL the user is taken to while still updating the country/language
 */
nike.geo.Util.redirectToLocale = function(country, languageLocale, consumerChose, delay, href) {
    nike.geo.Util.isRedirecting = true;
	  nike.log('called redirectToLocale with '+country+'/'+languageLocale);
	
    country = country || nike.COUNTRY;
    languageLocale = languageLocale || nike.geo.Configuration.getDefaultLanguage(country) || nike.LOCALE;
 
    var newUrl = null;
 
    // Check if the href provided is absolute (including host) or relative
    var absoluteHref = false;
    if (href && href.indexOf('http') === 0) {
        absoluteHref = true;
    }
    
    if (!absoluteHref) {
      newUrl = '/'+country.toLowerCase()+'/'+languageLocale.toLowerCase() + '/';

      if( href ) newUrl += href.replace(/^\//,'');
    } else {
        newUrl = href;
    }
    
    // Add the ref parameter if it doesn't already exist
    var ref = nike.util.UrlUtil.getExternalReferrer();
    if (ref && ref != '') {
        newUrl = nike.util.UrlUtil.addParameter(newUrl, 'ref', encodeURIComponent(ref));
    }
 
    if (consumerChose) {
        nike.geo.Util.updateConsumerChoiceLocale(country, languageLocale);
        
        // If the consumer chose, we can safely set the detected cookie
        // It probably doesn't matter, but should be in sync in case someone tries to use it
        nike.geo.Util.updateDetectedLocale(country, languageLocale);
    } else {
    	nike.geo.Util.clearConsumerChoice();
    }
 
    // Setup listeners fired by updateCommerceLocale()
    nike.listen(nike.Event.UPDATE_COUNTRY_SUCCESS, function(data) {
        nike.geo.Util.redirect(newUrl, delay);
    });
 
    nike.listen(nike.Event.UPDATE_COUNTRY_FAIL, function(data) {
        nike.geo.Util.redirectToLanguageTunnel();
    });
 
    // Don't use updateUserLocaleSettings because detected shouldn't be set in most cases
    // This will allow the geo detection logic to run even after a redirect, which is a requirement
    nike.geo.Util.updateCommerceLocale(country, languageLocale);
    
    
};
 
nike.geo.Util.redirect = function(url, delay) {
	var currentUrl = ''+window.location;
    if (!url) {
        return;
    } else if (currentUrl === url || nike.util.StringUtil.endsWith(currentUrl, url)) {
    	nike.error('NOT redirecting because the destination ('+currentUrl+') is the same as the current url ('+url+').');
   	} else {
        nike.log('Redirecting to '+url);
        
        if (!delay) {
            top.location.assign(url);
        } else {
            setTimeout( function () {
                top.location.assign(url);
            }, delay);      
        }
    }
};
 
/**
 * Take the user to the language tunnel.
 * 
 * TODO: This should probably encapsulate the logic for taking the query string, encoding it,
 *       and setting it as the "page" parameter.  Maybe.
 */
nike.geo.Util.redirectToLanguageTunnel = function(queryString) {
    nike.geo.Util.isRedirecting = true;
    // For some reason on mobile, the page is blank when this is hit
    // so we can't rely on device_detect :\
    var url = ( /m\.nike/.test(location.href) )
      ? nike.getServiceUrl('baseMobileURL') + 'language_tunnel'
      : nike.getServiceUrl('baseBrandURL') + 'language_tunnel';

    var ref = nike.util.UrlUtil.getExternalReferrer();
 
    if (queryString) {
        var host = window.location.hostname;
        if (queryString.indexOf('?') !== 0) {
            url += '?';
        }
        url += queryString;
    }

    if (ref && url.indexOf(ref) === -1) {
        url = nike.util.UrlUtil.addParameter(url, 'ref', ref);
    }
    
    top.location.assign(url);
};
 
/**
 * Update the commerce cookie and detected cookie, optionally updating the consumer choice cookie.
 * 
 * @param country
 * @param language
 * @param consumerChose
 */
nike.geo.Util.updateUserLocaleSettings = function(country, language, consumerChose) {
    if (!country || !(typeof country === 'string') || !language || !(typeof language === 'string')) {
        return;
    }
    
    nike.geo.Util.updateDetectedLocale(country, language);
    
    if (consumerChose) {
        nike.geo.Util.updateConsumerChoiceLocale(country, language);
    } else {
    	nike.geo.Util.clearConsumerChoice();
    }
    
    // No need to listen for the events fired because we don't care
    nike.geo.Util.updateCommerceLocale(country, language);
 
};
 
/**
 * Updates the commerce cookie.  Dispatches nike.Event.UPDATE_COUNTRY_SUCCESS on success and 
 * nike.Event.UPDATE_COUNTRY_FAIL on failure.
 * 
 * @param country
 * @param language
 */
nike.geo.Util.updateCommerceLocale = function(country, language) {
	nike.log('called updateCommerceLocale with '+country+'/'+language);
    if (country && language) {
        
        var initialCommerceCountry = nike.geo.CookieData.commerce.country;
        
        // Update the cookie value
        nike.geo.CookieData.setCommerce(country, language);
        
        // Call ATG if necessary (it's a commerce country and it's in EU)
        if (initialCommerceCountry && !nike.util.StringUtil.equalsIgnoreCase(country, initialCommerceCountry) && nike.geo.Configuration.isCountryInRegion(country, "EU")) {
 
            // Setup listeners before calling cart
            nike.listen(nike.Event.UPDATE_SHIPPING_COUNTRY_SUCCESS, function(data) {
                nike.dispatchEvent(nike.Event.UPDATE_COUNTRY_SUCCESS, {'country': country, 'language': language});
            });
            
            nike.listen(nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL, function(data) {
                nike.dispatchEvent(nike.Event.UPDATE_COUNTRY_FAIL, {'country': country, 'language': language});
            });
          //adding language tunnel check so that the shipping country doesn't get updated by the language tunnel
            var langTest = /language_tunnel/i;
            var loc = top.location.href;
            var test = langTest.test(loc);
            if(!test){
              nike.log('invoking Cart.js to update shipping country to '+country+'/'+language);
              nike.Cart.updateShippingCountry(country, nike.geo.Util.formatLangLocale(language));
            }else{
              nike.dispatchEvent(nike.Event.UPDATE_COUNTRY_SUCCESS, {'country': country, 'language': language});
            }
            
        } else {
            nike.dispatchEvent(nike.Event.UPDATE_COUNTRY_SUCCESS, {'country': country, 'language': language});
        }
 
 
    } else {
        nike.warn('Cannot update country/locale information for an unsupported value: '+country+'/'+language);
        nike.dispatchEvent(nike.Event.UPDATE_COUNTRY_FAIL, {'country' : country, 'language' : language});
    }
    
};
 

/**
 * Update the detected cookie.
 * 
 * @param country
 * @param language
 */
nike.geo.Util.updateDetectedLocale = function(country, language) {
    nike.geo.Util.setDetected(country, language);
};
 
 
 
nike.geo.Util.updateConsumerChoiceLocale = function(country, language) {
       nike.log('nike.geo.Util.updateConsumerChoiceLocale country: '+country+' language: '+language);
    if (language && country) {
 
        if (!nike.geo.CookieData.consumerChose) {
            nike.Countries_Locales_Cookies.setSessionCookie(nike.geo.CookieData.CONSUMER_CHOSE_NAME, "t", "/", nike.Countries_Locales_Cookies.getCookieDomain());
        }
 
        // Check that we're actually updating the cookie to something different
        if (!nike.util.StringUtil.equalsIgnoreCase(country, nike.geo.CookieData.consumerChoice.country) || !nike.Util.equalsIgnoreCase(language, nike.geo.CookieData.consumerChoice.language)) {
            var cookieValue = country.toLowerCase() + "/" + language.toLowerCase();
            nike.Countries_Locales_Cookies.setCookie(nike.geo.CookieData.CONSUMER_CHOICE_NAME, cookieValue, "/", nike.Countries_Locales_Cookies.getCookieDomain());
        }
    }
 
};

nike.geo.Util.clearConsumerChoice = function() {
	var cookieString = nike.geo.CookieData.CONSUMER_CHOICE_NAME + "=;path=/;domain=" + nike.Countries_Locales_Cookies.getCookieDomain() + ";expires=Thu, 01 Jan 1970 00:00:01 GMT";
	nike.log("Clearing consumer choice: "+cookieString);
	document.cookie = cookieString;
};
 
 
nike.geo.Util.buildQuery = function(){
    var util = nike.util.UrlUtil;
    var referrer = encodeURIComponent(util.getExternalReferrer());
    var ret = '';
    var params = {};
    var tempProp;
    
    util.parseUrlParams(top.location.search, params);
    
    if(referrer && referrer.length > 0){
      params.ref = referrer;
    }
    
    //Re add params
    for(tempProp in params){
      if(params.hasOwnProperty(tempProp) && tempProp != 'l'){
        if(ret.length > 0 ){
          ret += "&";
        } else {
          ret = "?";
        }
        ret += tempProp + "=" + params[tempProp];
      }
    }
    
    return ret;
};
 
 
 
 
 
nike.geo.Util.setDetected = function(country, language) {
    
    if (country && typeof country === "string" && language && typeof language === "string") {
        return nike.Countries_Locales_Cookies.setSessionCookie(
                nike.geo.CookieData.GEO_DETECTED_NAME, 
                country.toLowerCase() + '/' + language.toLowerCase(), 
                "/", 
                nike.Countries_Locales_Cookies.getCookieDomain());
    } else {
        return false;
    }
};
 

 
/**
 * Formats a lang_locale combination into the standard format according to how
 * languages are defined in the geo configuration objects.
 * 
 * @param language
 * @returns string lang_locale
 * */
nike.geo.Util.formatLangLocale = function(language) {
    if (language && typeof language === "string" && language.indexOf("_") >= 0) {
        
        language = language.toLowerCase();
        var lang = null;
        var locale = null;
        
        var underscorePos = language.indexOf("_");
        lang = language.substring(0,underscorePos);
        locale = language.substring(underscorePos+1).toUpperCase();
        
        return lang + "_" +locale;
    }
    return null;
};
 
nike.geo.Util.getPathWithoutLocale = function() {
    var query = top.location.search + top.location.hash;
    var path = top.location.pathname;
 
    if (!path || path === '/') {
        path = '';
    }
    
    // TOOD: regex here instead?
    var pathParts = path.split('/');
    // removing empty elements in the array
    for (var i=0; i<pathParts.length; i++) {
        if (pathParts[i] === "") {
            pathParts.splice(i,1);
            i--;
        }
    }
    if (pathParts 
        && pathParts.length >= 2
        && pathParts[0].length == 2
        && pathParts[1].length == 5
        && pathParts[1].indexOf('_') == 2)
    {
 
        // country & lang_locale is /xx/xx_xx/, which is 10 characters. We need everything after that.
        if (path.length >= 11) {
            path = path.substring(10);
        } else {
            path = '';
        }
        nike.log('path: '+path);
    }
    
    nike.log('Found path without locale: '+path+query); 
    return path + query;
};
 
 
nike.geo.Util.buildReturnPath = function() {
    var path = nike.geo.Util.getPathWithoutLocale();
    if (path) {
        return 'flp='+encodeURIComponent(path);
    } else {
        return null;
    }
};
 
 
/**
 * Find the return path specified in the flp parameter and optionally the return host
 * as well if the withHost parameter is set.
 * 
 * There is a dependency here that the flp parameter has to be the first parameter in the list.
 * 
 * @param withHost
 * @returns A string with the return path if withHost is false or a map with a 'path' key containing
 * the return path and 'host' key containing the return host otherwise.
 */
nike.geo.Util.getReturnPath = function(withHost) {
 
    var ret = null;
    var path;
    var queryString = top.location.search;
    var host;
    //Regex used to find and strip out flp and flh params
    var paramsRegex = /^(\?|.*&)((?:flp=|flh=)[^&]*&?)/i;
    var remainingReplacementCount = 2;  //Make sure we don't get an infinite loop when stripping out flp and flh params.  There should only be one of each.

    $.url.setUrl(top.location);
    path = $.url.param('flp');

    if (withHost) {
        host = $.url.param('flh');
    }

    if (path) {

        // Remove landing page params (flp and flh)
        // from original query string. Keep any other URL parameters

        while(remainingReplacementCount > 0 && paramsRegex.test(queryString)){
          queryString = queryString.replace(paramsRegex, '$1');
          remainingReplacementCount--;
        }

        // remove any trailing ? from the URL. This would happen
        // if there were no other parameters other than flp|flh

        if(queryString.match(/\?$/)) {
          queryString = queryString.slice(0,-1);
        }

        // rebuild the query string using the new path

        ret = decodeURIComponent(path) + queryString;
        if (withHost) {
            ret = {'path' : ret, 'host' : host};
        }

    }

    return ret;
};
 
nike.geo.Util.getAbsoluteReturnUrl = function(country, langLocale, link) {
 
    var queryString = top.location.search;
 
    // The path should be everything after 'flp=' incase whoever created this link didn't URL encode it
    var newQueryString = '';
    if (queryString && typeof queryString === 'string') {
        var flpPos = queryString.indexOf(nike.geo.Util.FINAL_LANDING_PAGE_PARAM+'=');
      //Testing for -1, where it wont find 'flp='
        if(flpPos >= 0){
          newQueryString = queryString.substring(flpPos + nike.geo.Util.FINAL_LANDING_PAGE_PARAM.length + 1);
        }
    }
 
    // If there's a hostname param included, translate it into an actual domain
    var hostname = nike.geo.Util.getReturnHost();
 
    var fullUrl = '';
    // Combine the hostname with the path to get the final link
    if (hostname && country && langLocale) {
        fullUrl = hostname + country.toLowerCase() + '/' + langLocale.toLowerCase() + '/';
        
        // If the flp param has a leading slash, remove it here because we just created a base url with a trailing slash
        if (newQueryString.indexOf('/') === 0) {
            newQueryString = newQueryString.substring(1);
        }
        
    // If a final landing host wasn't provided, combine the query string with the link provided
    } else if (link) {
        
        // if link ends with / and so does the flp parameter, remove one to not have a double slash
        if (link.charAt(link.length - 1) === '/' && newQueryString.charAt(0) === '/') {
            newQueryString = newQueryString.substring(1);
        }
        
        fullUrl = link;
    }
    fullUrl += decodeURIComponent(newQueryString);
    
    return fullUrl;
};
 
nike.geo.Util.getReturnHost = function() {
    $.url.setUrl(top.location);
    
    var hostKey = $.url.param(nike.geo.Util.FINAL_LANDING_HOST_PARAM);
    
    var host = null;
    if (hostKey == nike.geo.Util.FINAL_LANDING_HOST_KEY_NIKESTORE) {
        host = nike.getServiceUrl('baseStoreURL');
    } else if (hostKey == nike.geo.Util.FINAL_LANDING_HOST_KEY_WWW) {
        host = nike.getServiceUrl('baseBrandURL');
    }
    
    return host;
};

/**
 * Checks if the provided url is on the Nikestore domain.
 * Note that the url has to be fully qualified, including protocol and host.
 * 
 * @param url
 * @returns {Boolean}
 */
nike.geo.Util.isStoreDomain = function (url) {
	var storeHost = nike.getServiceUrl('baseStoreURL');
	nike.log('Checking if '+url+ ' is on the store domain ('+storeHost+').');
	return (url && url.indexOf(storeHost) === 0);
};

/**
 * Convert unicode characters to their readable String form.
 * @param text
 * @returns {String}
 */
nike.geo.Util.parseUnicodeText = function(text){
  return text.replace(/\\u[\dA-Fa-f][\dA-Fa-f][\dA-Fa-f][\dA-Fa-f]/g, function(match){
    return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
  });
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.geo.Util. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace('nike.ServiceUtil');

/**
 * Put all form input values into an object
 *
 * @param {string|HTMLElement|jQuery} formElement - Form element selector, markup, or HTMLElement.
 * @param  {Boolean} [returnEmpty] - If set to true, and a text input has an empty value, an empty String will be returned.
 * @returns Object with all form values
 */
nike.ServiceUtil.getFormData = function(formElement, returnEmpty){
  // Get all form values
  var value, input, sel, data = {};
  $(formElement).find(':input[name]').each(function(){
     input = $(this);
     if (input.is(':checkbox')){
       data[input.attr('name')] = input.is(':checked');
     }
     else if (input.is(':radio')){
       if (input.is(":checked")) {
         data[input.attr('name')] = input.val();
       }
     }
     else{
       if(input.attr('name') == 'postalCode'){
         input = $(formElement).find('input[name=postalCode]:visible');
       }
       value = input.val();
       if( (value && value.length > 0) || returnEmpty ){
         data[input.attr('name')] = input.val();
       }
       else{
         data[input.attr('name')] = null;
       }
     }
  });
  
  $(formElement).find('select').each(function(){
	  sel = $(this);
    if(sel.attr('name') == 'state'){
      sel = $(formElement).find('.state_select:visible').find('select');
    }
    value = sel.val();

    if( value && value.length > 0 && sel.attr('name') ){
      data[sel.attr('name')] = value;
    }
  });
  return data;
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.ServiceUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.gadget.Event');

nike.gadget.Event.ATGServiceDone = 'atgServiceDone';
/**
 * Pager Events
 */
nike.gadget.Event.PAGE_CHANGED = 'pagerIndexChangedEvent';

/**
 * Sort Options Events
 */
nike.gadget.Event.SORT_CHANGED = 'sortChangedEvent';
nike.gadget.Event.VIEW_CHANGED = 'viewChangedEvent';

/**
 * Buying Tools Events
 */
nike.gadget.Event.COLOR_CHANGED = 'colorChangedEvent';
nike.gadget.Event.SIZE_CHANGED = 'sizeChangedEvent';
nike.gadget.Event.QUANTITY_CHANGED = 'quantityChangedEvent';

/**
 * Store Nav Events
 */
nike.gadget.Event.STORE_NAV_CHANGED = 'storeNavChangedEvent';

/**
 * Loading Screen events
 */
nike.gadget.Event.SHOW_LOADING_SCREEN = 'showLoadingScreenEvent';
nike.gadget.Event.HIDE_LOADING_SCREEN = 'hideLoadingScreenEvent';

/**
 * Facet Nav Events
 */
nike.gadget.Event.FACET_NAV_DISPLAY_TOGGLED = 'facetNavDisplayToggledEvent';
nike.gadget.Event.FACET_NAV_DISPLAY_ANIMATION_DONE = 'facetNavDisplayAnimationDone';
nike.gadget.Event.FACET_NAV_CHANGED = 'facetNavChangedEvent';
nike.gadget.Event.FACET_NAV_REMOVED = 'facetNavRemovedEvent';
nike.gadget.Event.FACET_NAV_SWITCHED = 'facetNavSwitchedEvent';

/**
 * Product Wall Breadcrumb Events
 */
nike.gadget.Event.BREADCRUMB_ELLIPSIS_EXPANDED = 'breadcrumbEllipsisExpanded';
nike.gadget.Event.BREADCRUMB_ELLIPSIS_COLLAPSED = 'breadcrumbEllipsisCollapsed';
nike.gadget.Event.BREADCRUMB_LINK_CLICK = 'breadcrumbLinkClickEvent';

/**
 * Store Header Events
 */
nike.gadget.Event.SEARCH = 'searchEvent';
nike.gadget.Event.SEARCH_AUTO_REDIRECT = 'searchAutoRedirectEvent';


/**
 * Buying Tools Events
 */
nike.gadget.Event.BUYING_TOOLS_NOTIFY_ME = 'buyingToolsNotifyMeEvent';
nike.gadget.Event.BUYING_TOOLS_CUSTOMIZE_IT = 'buyingToolsNikeIDEvent';

nike.gadget.Event.SHOW_NOTIFY_ME = 'showNotifyMeEvent';
nike.gadget.Event.NOTIFY_ME_SUBMIT_CLICK = 'notifyMeSubmitClickEvent';
nike.gadget.Event.NOTIFY_ME_SUCCESS = 'notifyMeSuccessEvent';
/**
 * Buying Options Events
 */
nike.gadget.Event.BUYING_OPTIONS_MORE_COLORS = 'buyingOptionsMoreColors';
nike.gadget.Event.BUYING_OPTIONS_NFL_PLAYER_SELECT = 'buyingOptionsNFLPlayerSelect';

/**
 *
 */
nike.gadget.Event.SCROLL_TO_REVIEW = 'scrollToReview';
nike.gadget.Event.SUBMIT_REVIEW = 'submitProductReview';

/**
 * Events for history manager
 */
nike.gadget.Event.HISTORY_STATE_CHANGED = 'historyStateChangedEvent';
nike.gadget.Event.REPLACE_HISTORY_STATE = 'replaceHistoryStateEvent';
nike.gadget.Event.PUSH_HISTORY_STATE = 'pushHistoryStateEvent';

/**
 * Image Viewer Controls Events
*/
nike.gadget.Event.SELECTED_VIEWER_CHANGED = 'selectedViewerChangedEvent';
nike.gadget.Event.ALT_IMAGE_SELECTED = 'altImageSelectedEvent';
nike.gadget.Event.ALT_IMAGE_SELECTED_ONCE_ON_PRODUCT = 'altImageSelectedOnceOnProduct';
nike.gadget.Event.VIEWER_CONTROLS_CLICK = 'viewerControlClick';

/**
 * Profile Events
 */
nike.gadget.Event.LOGIN_SUCCESS = 'loginSuccessEvent';
nike.gadget.Event.LOGIN_FAIL = 'loginFailEvent';
nike.gadget.Event.LOGIN_SETUP_COMPLETE = 'loginSetupCompleteEvent';
nike.gadget.Event.SHOW_LOGIN = 'showLoginEvent';
nike.gadget.Event.HIDE_LOGIN = 'hideLoginEvent';
nike.gadget.Event.CANCEL_LOGIN = 'cancelLoginEvent';
nike.gadget.Event.LOGOUT_SUCCESS = 'logoutSuccessEvent';
nike.gadget.Event.LOGOUT_FAIL = 'logoutFailEvent';
nike.gadget.Event.REGISTER_SUCCESS = 'registerSuccessEvent';
nike.gadget.Event.REGISTER_FAIL = 'registerFailEvent';
nike.gadget.Event.SHOW_REGISTER = 'showRegisterEvent';
nike.gadget.Event.HIDE_REGISTER = 'hideRegisterEvent';
nike.gadget.Event.HIDE_REGISTER_AFTER_SUCCESS = 'hideRegisterAfterSuccessEvent';
nike.gadget.Event.CANCEL_REGISTER = 'cancelRegisterEvent';
nike.gadget.Event.PASSWORD_RESET_FAILED = 'passwordResetFailed';
nike.gadget.Event.PASSWORD_RESET_EMAIL_SENT = 'passwordResetEmailSent';

/**
 * Review Events
 */
nike.gadget.Event.REVIEW_SORT_CHANGED = 'reviewSortChangedEvent';
nike.gadget.Event.REVIEW_PAGE_CHANGED = "reviewPageChangedEvent";

/**
 * Zoom Viewer Events
 */
nike.gadget.Event.ZOOM_VIEWER_INIT = "zoomViewerInitEvent";
nike.gadget.Event.ZOOM_VIEWER_MOVE = "zoomViewerMove";
nike.gadget.Event.ZOOM_VIEWER_ZOOM = "zoomViewerZoom";
nike.gadget.Event.ZOOM_VIEWER_ZOOM_CHANGED = "zoomViewerZoomZoomChanged";
nike.gadget.Event.ZOOM_VIEWER_ZOOM_IN = "zoomViewerZoomIn";
nike.gadget.Event.ZOOM_VIEWER_ZOOM_OUT = "zoomViewerZoomOut";

/**
 * Zoom Viewer Thumbnail Events
 */
nike.gadget.Event.ZOOM_VIEWER_CHANGE_ZOOM = "zoomViewerChangeZoom";
nike.gadget.Event.ZOOM_VIEWER_THUMBNAIL_MOVE = "zoomViewerThumbnailMove";


/**
 * Profile events
 */
nike.gadget.Event.PROFILE_CHANGE_TAB = "profileChangeTab";

/**
 * Summon PDP Event
 */
nike.gadget.Event.SUMMON_PDP_OVERLAY = "summonPDPOverlay";

/**
 * Mini PDP events
 */
nike.gadget.Event.MINI_PDP_VIEW_DETAILS = "miniPpdViewDetailsEvent";

/**
 * PDP Nikeid base overlay events
 */
nike.gadget.Event.SHOW_PDP_NIKEID_BASE_OVERLAY = 'showPdpNikeidBaseOverlayEvent';
nike.gadget.Event.HIDE_PDP_NIKEID_BASE_OVERLAY = 'hidePdpNikeidBaseOverlayEvent';

/**
 * image viewer
 */
nike.gadget.Event.IMAGE_VIEWER_SHOW_ZOOM = 'imageViewerShowZoom';
nike.gadget.Event.IMAGE_VIEWER_HIDE_ZOOM = 'imageViewerHideZoom';
nike.gadget.Event.IMAGE_VIEWER_CHANGE_VIEW = 'imageViewerChangeView';
nike.gadget.Event.IMAGE_VIEWER_ALT_IMAGE_SCROLL = 'imageViewerAltImageScroll';
nike.gadget.Event.NFL_IMAGE_VIEWER_CHANGE_VIEW = 'nflImageViewerChangeView';

/**
* Mini cart events
*/
nike.gadget.Event.MINI_CART_OPEN = 'miniCartOpen';
nike.gadget.Event.MINI_CART_CLOSE = 'miniCartClose';

/**
* Width Selection Tabs events
*/
nike.gadget.Event.PRODUCT_WIDTH_SELECTED = 'widthSelectorClickEvent';

/**
* Save to locker
*/
nike.gadget.Event.SAVE_TO_LOCKER_INVALID = 'saveToLockerInvalid';

/**
* Cross Sell
*/
nike.gadget.Event.CROSS_SELL_PRODUCT_CLICK = 'crossSellProductClickEvent';

/**
 * Share Option events
 */
nike.gadget.Event.SHARE_OPTION_CLICK = 'shareOptionClickEvent';
nike.gadget.Event.HIDE_SHARE_OPTION = 'hideShareOption';

/**
* PDP Tabs Events
*/
nike.gadget.Event.PDP_TAB_SELECTED = 'pdpTabSelectedEvent';
nike.gadget.Event.SHOW_TAB = "showTab";

/**
* PageBuilder Events
*/
nike.gadget.Event.CARTRIDGE_CLICK = 'cartridgeClickEvent';
nike.gadget.Event.CONTENT_CLICK = 'contentClickEvent';
//This is for CQ5 touts currently.  It might change to be just a cartridge click.
nike.gadget.Event.TOUT_CLICK = 'toutClickEvent';
nike.gadget.Event.PAGE_BUILDER_REDIRECT = 'pageBuilderRedirectEvent';
nike.gadget.Event.GRIDWALL_ITEMS_ADDED = 'gridwallItemsAdded';

/**
 * Notification box events
 */
nike.gadget.Event.NOTIFICATION_DISMISS = 'notificationBoxDismiss';

/**
 * Certona events
 */
nike.gadget.Event.CERTONA_CALL = 'certonaCallEvent';
nike.gadget.Event.CERTONA_CALL_SUCCESS = 'certonaCallSuccessEvent';
nike.gadget.Event.CERTONA_CALL_TIMEOUT = 'certonaCallTimeoutEvent';

/**
 * Collection Item events
 */
nike.gadget.Event.CHECK_COLLECTION_ITEM = 'checkCollectionItem';

/**
 * NFL Team Selector events
 */
nike.gadget.Event.NFL_TEAM_SELECTED = 'nflTeamSelected';
nike.gadget.Event.HIDE_NFL_TEAM_SELECTOR = 'hideNflTeamSelector';
nike.gadget.Event.SHOW_NFL_TEAM_SELECTOR = 'showNflTeamSelector';

/**
 * FuelBandMiniPdp events
*/
nike.gadget.Event.FUEL_BAND_MINI_PDP_CLOSE_CLICKED = 'fuelBandMiniPdpCloseClicked';

nike.gadget.Event.SHOW_LANGUAGE_SELECTOR = 'showLanguageSelector';
nike.gadget.Event.HIDE_LANGUAGE_SELECTOR = 'hideLanguageSelector';
nike.gadget.Event.FUEL_BAND_MINI_PDP_CLOSE_CLICKED = 'fuelBandMiniPdpCloseClicked';

nike.gadget.Event.SHOW_SIZE_CHART = 'showSizeChartEvent';
nike.gadget.Event.HIDE_SIZE_CHART = 'hideSizeChartEvent';

/**
 * Gift Card Balance Checker events
 */
nike.gadget.Event.SHOW_GIFT_CARD_BALANCE_CHECKER = 'showGiftCardBalanceChecker';
nike.gadget.Event.HIDE_GIFT_CARD_BALANCE_CHECKER = 'hideGiftCardBalanceChecker';

nike.gadget.Event.CHANGE_GIFT_CARD_DESIGN = 'changeGiftCardDesign';

/**
 * Email Friend events
 */
nike.gadget.Event.SHOW_EMAIL_FRIEND = 'showEmailFriend';
nike.gadget.Event.HIDE_EMAIL_FRIEND = 'hideEmailFriend';
nike.gadget.Event.EMAIL_FRIEND_SUCCESS = 'emailFriendSuccess';
nike.gadget.Event.EMAIL_FRIEND_FAILURE = 'emailFriendFailure';

/**
 * Email Sign up events
 */
nike.gadget.Event.HIDE_EMAIL_SIGNUP = "hideEmailSignUpWindow";
/**
 * sub Nav from Global Nav Events
 */
nike.gadget.Event.SUB_NAV_VISIBLE = 'subNavVisible';
nike.gadget.Event.SUB_NAV_HIDDEN = 'subNavHidden';
nike.gadget.Event.NOTIFIER_RESIZED = 'notifierResized';
nike.gadget.Event.NOTIFIER_LINK_CLICK = 'notifierLinkClick';
nike.gadget.Event.NOTIFIER_CLOSE_CLICK = 'notifierCloseClick';

/**
 * NFL jersey types selector - Other colors (jersey types) events
 */
nike.gadget.Event.NFL_OTHER_COLORS_CLICK = 'otherColorsClickEvent';

/**
 * generic gadget events
 */
nike.gadget.Event.SHOW_GADGET = 'showGadget';

/**
 * Benefit summary events.
 */
nike.gadget.Event.BENEFIT_SUMMARY_VIEW_MORE = 'benifitSummaryViewMore';
nike.gadget.Event.MORE_TECH_SPECS = 'moreTechSpechs';

/**
 * Cookie Settings Events
 */
nike.gadget.Event.SHOW_COOKIE_SETTINGS_DIALOG_EVENT = "showCookieSettingsDialogEvent";
nike.gadget.Event.COOKIE_SETTINGS_CHANGED_EVENT = "changeCookieSettingsSuccessEvent";

/**
 * 360 Load Error
 */
nike.gadget.Event.GADGET_ERROR = "gadgetError";

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.Event. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('jQuery.cookie');
nike.requireDependency('jQuery');
/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.cookie. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('jQuery.xml2json');
nike.requireDependency('jQuery');
/*
 ### jQuery XML to JSON Plugin v1.3 - 2013-02-18 ###
 * http://www.fyneworks.com/ - diego@fyneworks.com
  * Licensed under http://en.wikipedia.org/wiki/MIT_License
 ###
 Website: http://www.fyneworks.com/jquery/xml-to-json/
*//*
 # INSPIRED BY: http://www.terracoder.com/
           AND: http://www.thomasfrank.se/xml_to_json.html
                      AND: http://www.kawa.net/works/js/xml/objtree-e.html
*//*
 This simple script converts XML (document of code) into a JSON object. It is the combination of 2
 'xml to json' great parsers (see below) which allows for both 'simple' and 'extended' parsing modes.
*/
// Avoid collisions
;if(window.jQuery) (function($){
 
 // Add function to jQuery namespace
 $.extend({
  
  // converts xml documents and xml text to json object
  xml2json: function(xml, extended) {
   if(!xml) return {}; // quick fail
   
   //### PARSER LIBRARY
   // Core function
   function parseXML(node, simple){
    if(!node) return null;
    var txt = '', obj = null, att = null;
    var nt = node.nodeType, nn = jsVar(node.localName || node.nodeName);
    var nv = node.text || node.nodeValue || '';
    /*DBG*/ //if(window.console) console.log(['x2j',nn,nt,nv.length+' bytes']);
    if(node.childNodes){
     if(node.childNodes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'CHILDREN',node.childNodes]);
      $.each(node.childNodes, function(n,cn){
       var cnt = cn.nodeType, cnn = jsVar(cn.localName || cn.nodeName);
       var cnv = cn.text || cn.nodeValue || '';
       /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>a',cnn,cnt,cnv]);
       if(cnt == 8){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>b',cnn,'COMMENT (ignore)']);
        return; // ignore comment node
       }
       else if(cnt == 3 || cnt == 4 || !cnn){
        // ignore white-space in between tags
        if(cnv.match(/^\s+$/)){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>c',cnn,'WHITE-SPACE (ignore)']);
         return;
        };
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>d',cnn,'TEXT']);
        txt += cnv.replace(/^\s+/,'').replace(/\s+$/,'');
                // make sure we ditch trailing spaces from markup
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>e',cnn,'OBJECT']);
        obj = obj || {};
        if(obj[cnn]){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>f',cnn,'ARRAY']);
         
                  // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
                  if(!obj[cnn].length) obj[cnn] = myArr(obj[cnn]);
                  obj[cnn] = myArr(obj[cnn]);
         
                  obj[cnn][ obj[cnn].length ] = parseXML(cn, true/* simple */);
         obj[cnn].length = obj[cnn].length;
        }
        else{
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>g',cnn,'dig deeper...']);
         obj[cnn] = parseXML(cn);
        };
       };
      });
     };//node.childNodes.length>0
    };//node.childNodes
    if(node.attributes){
     if(node.attributes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'ATTRIBUTES',node.attributes])
      att = {}; obj = obj || {};
      $.each(node.attributes, function(a,at){
       var atn = jsVar(at.name), atv = at.value;
       att[atn] = atv;
       if(obj[atn]){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'ARRAY']);
        
                // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
                //if(!obj[atn].length) obj[atn] = myArr(obj[atn]);//[ obj[ atn ] ];
        obj[cnn] = myArr(obj[cnn]);
                
                obj[atn][ obj[atn].length ] = atv;
        obj[atn].length = obj[atn].length;
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'TEXT']);
        obj[atn] = atv;
       };
      });
      //obj['attributes'] = att;
     };//node.attributes.length>0
    };//node.attributes
    if(obj){
     obj = $.extend( (txt!='' ? new String(txt) : {}),/* {text:txt},*/ obj || {}/*, att || {}*/);
     //txt = (obj.text) ? (typeof(obj.text)=='object' ? obj.text : [obj.text || '']).concat([txt]) : txt;
     txt = (obj.text) ? ([obj.text || '']).concat([txt]) : txt;
     if(txt) obj.text = txt;
     txt = '';
    };
    var out = obj || txt;
    //console.log([extended, simple, out]);
    if(extended){
     if(txt) out = {};//new String(out);
     txt = out.text || txt || '';
     if(txt) out.text = txt;
     if(!simple) out = myArr(out);
    };
    return out;
   };// parseXML
   // Core Function End
   // Utility functions
   var jsVar = function(s){ return String(s || '').replace(/-/g,"_"); };
   
      // NEW isNum function: 01/09/2010
      // Thanks to Emile Grau, GigaTecnologies S.L., www.gigatransfer.com, www.mygigamail.com
      function isNum(s){
        // based on utility function isNum from xml2json plugin (http://www.fyneworks.com/ - diego@fyneworks.com)
        // few bugs corrected from original function :
        // - syntax error : regexp.test(string) instead of string.test(reg)
        // - regexp modified to accept  comma as decimal mark (latin syntax : 25,24 )
        // - regexp modified to reject if no number before decimal mark  : ".7" is not accepted
        // - string is "trimmed", allowing to accept space at the beginning and end of string
        var regexp=/^((-)?([0-9]+)(([\.\,]{0,1})([0-9]+))?$)/
        return (typeof s == "number") || regexp.test(String((s && typeof s == "string") ? jQuery.trim(s) : ''));
      };
      // OLD isNum function: (for reference only)
      //var isNum = function(s){ return (typeof s == "number") || String((s && typeof s == "string") ? s : '').test(/^((-)?([0-9]*)((\.{0,1})([0-9]+))?$)/); };
                                
   var myArr = function(o){
    
        // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
        //if(!o.length) o = [ o ]; o.length=o.length;
    if(!$.isArray(o)) o = [ o ]; o.length=o.length;
        
        // here is where you can attach additional functionality, such as searching and sorting...
    return o;
   };
   // Utility functions End
   //### PARSER LIBRARY END
   
   // Convert plain text to xml
   if(typeof xml=='string') xml = $.text2xml(xml);
   
   // Quick fail if not xml (or if this is a node)
   if(!xml.nodeType) return;
   if(xml.nodeType == 3 || xml.nodeType == 4) return xml.nodeValue;
   
   // Find xml root node
   var root = (xml.nodeType == 9) ? xml.documentElement : xml;
   
   // Convert xml to json
   var out = parseXML(root, true /* simple */);
   
   // Clean-up memory
   xml = null; root = null;
   
   // Send output
   return out;
  },
  
  // Convert text to XML DOM
  text2xml: function(str) {
   // NOTE: I'd like to use jQuery for this, but jQuery makes all tags uppercase
   //return $(xml)[0];
   
   /* prior to jquery 1.9 */
   /*
   var out;
   try{
    var xml = ((!$.support.opacity && !$.support.style))?new ActiveXObject("Microsoft.XMLDOM"):new DOMParser();
    xml.async = false;
   }catch(e){ throw new Error("XML Parser could not be instantiated") };
   try{
    if((!$.support.opacity && !$.support.style)) out = (xml.loadXML(str))?xml:false;
    else out = xml.parseFromString(str, "text/xml");
   }catch(e){ throw new Error("Error parsing XML string") };
   return out;
   */

   /* jquery 1.9+ */
   return $.parseXML(str);
  }
    
 }); // extend $

})(jQuery);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.xml2json. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Cart');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.ServiceUtil');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('jQuery');
nike.requireDependency('jQuery.cookie');
nike.requireDependency('nike.EventBus');
nike.requireDependency('nike.ScriptLoader');
nike.requireDependency('jQuery.xml2json');
nike.requireDependency('jQuery.cookie');

/**
 * Make sure a tunnel is setup for the cart
 * service call
 */

nike.ScriptLoader.requireTunnelForUrl(nike.getSecureRootUrl());
nike.ScriptLoader.requireTunnelForUrl(nike.getRootUrl());

/**
 * Name to store the cart summary cookie under
 */
nike.Cart.CART_SUMMARY_COOKIE = 'CART_SUMMARY';

/**
 * The minimum security status before a user is considered logged in
 *
 * @type {Number}
 */
nike.Cart.MINIMUM_LOGGED_IN_SECURITY_STATUS = 3;

/**
 * The number of milliseconds the SmartCart will wait for a response from the service before pinging the service again.
 *
 * @type {Number}
 * @constant
 */
nike.Cart.NO_SERVICE_WAIT_TIME = 30000;

/**
 * The number of milliseconds to wait before retrying the addToCart call when a service failure occurs
 * during a smartCart experience.
 *
 * @type Number
 * @constant
 */
nike.Cart.SERVICE_FAILURE_WAIT_TIME = 5000;

/**
 * The maximum number of times the SmartCart will ping the service with no response before showing the timeout message.
 *
 * @type {Number}
 * @constant
 */
nike.Cart.MAX_NO_SERVICE_RETRIES = 2;

/**
 * The maximum number of times the SmartCart will ping the service with a bad response before
 * showing the timeout message.
 *
 * @type {Number}
 * @constant
 */
nike.Cart.MAX_SERVICE_FAILURE_RETRIES = 3;

/**
 * Enum with each of the possible user types that are returned from the Cart Summary.
 */
nike.Cart.UserType = {
  UNKNOWN: "UNKNOWN",
  DEFAULT_USER: "DEFAULT_USER",
  EMPLOYEE: "EMPLOYEE",
  AFFILIATE: "AFFILIATE"
};

nike.Cart.cookieObjectDefaults = {
  profileId: '',
  cartCount: 0,
  userType: nike.Cart.UserType.DEFAULT_USER,
  securityStatus: 0
};

/**
 * Object to hold the cartSummary cookie values with defaults
 *
 * @type {Object}
 */
nike.Cart.cookieObject = nike.Cart.cookieObjectDefaults;

/**
 * Use the secure url to the cart service
 */
nike.Cart.getCartServiceUrl = function (appName) {
	return nike.getSecureRootUrl() + appName + '/html/services/cartService';
};
nike.Cart.getGiftCardBalanceCartServiceUrl = function (appName) {
	return nike.getSecureRootUrl() + appName + '/html/services/giftCardBalanceCartService';
};
/**
 * sku service url
 */
nike.Cart.getProductSkuServiceUrl = function (appName) {
	return nike.getRootUrl() + appName + '/html/services/product/skuService.xml';
};

nike.Cart.populateSkus = function (data, element, index) {
	if (!element) {
		nike.error('Gadget "element" must be defined when calling populateSkus');
	}
	else {
		var responseData = {'success': false};

		// Get the app name according to the gadget calling this function
		var gadgetAppName = nike.DEFAULT_APP_NAME;

		// Fail function
		var doFail = function (response, element, sizeContainer) {
			nike.dispatchEvent(nike.Event.POPULATE_SKUS_FAIL,
					{'element': element, 'response': response, 'index': index});
		};

		// Make skus request
		nike.request(
				{method: 'GET',
					url: nike.Cart.getProductSkuServiceUrl(gadgetAppName),
					data: data
					// Successful call
				}, function (response) {
					try {
						responseData = $.parseJSON(response.data).response;
					} catch (e) {
						responseData.errorMessages = [e.toString()];
					}

					if (responseData.success) {
						nike.dispatchEvent(nike.Event.POPULATE_SKUS_SUCCESS,
								{element: element, response: responseData, index: index});
					} else {
						doFail(element, responseData, index);
					}

					// Failed call
				}, function (response) {
					responseData.errorMessages = [response.toString()];
					doFail(element, responseData, index);
				});
	}
};

/**
 * If the addToSmartCart request times out, retry after 60sec. IF IE8, retry after 80sec to force the whole
 * retry logic to last 3 min like in REAL BROWSERS.
 * @param iE8Bug
 * @param waitTime
 */
nike.Cart.handleSmartCartTimeout = function(iE8Bug, waitTime){
  if(iE8Bug){
    setTimeout(function(){nike.Cart.addToSmartCart()}, waitTime + (waitTime/3)); // added waitTime/3 cuz IE8 kicks back the 1st request after 20sec or so.
  }
  else {
    nike.Cart.addToSmartCart(waitTime);
  }
};

/**
 * A simplified, streamlined addToCart function with special success and failure callbacks unique to the smartCart
 * experience.
 *
 * @param {Number} [waitTime] The time, in milliseconds, to wait for a response from the service before timing out
 * @param {Object} [captchaParams] Once captcha is solved, send the captcha required params to ATG.
 */
nike.Cart.addToSmartCart = function (waitTime, captchaParams) {
	var smartCart = $('.smart-cart').data('smartCartInstanceObject');
  var requestData = smartCart.getRequestData();
  if(captchaParams){
    if(requestData.pil < 0){
      requestData.pil = undefined;
    }
    $.extend(requestData, captchaParams);
  }
	$.ajax({
		dataType: 'jsonp',
		url: nike.getServiceUrl('jsonCartService'),
		data: requestData,
    jsonpCallback: "nike_Cart_handleJCartResponse",
		timeout: waitTime || smartCart.retries.noResponse.WAIT_TIME,
		success: $.proxy(function smartCartSuccessHandler(response) {
			smartCart.handleResponse(response);
		}),
		error: function smartCartErrorHandler(response) {
			var smartCart = $('.smart-cart').data('smartCartInstanceObject');
      var ie8Bug = response.statusText == "success"; // for some reason, even though we'are inside the error handler, the statusText is success in IE8
			if (response.statusText === "timeout" || ie8Bug) {
				if (smartCart.smartCartData.isWaiting && smartCart.retries.noResponse.attempt < smartCart.retries.noResponse.MAX_ATTEMPTS) {
					smartCart.retries.noResponse.attempt++;
					nike.dispatchEvent(nike.Event.SMART_ADD_TO_CART, {status: 'smart cart timeout retry:' + smartCart.retries.noResponse.attempt});
          nike.Cart.handleSmartCartTimeout(ie8Bug, smartCart.retries.noResponse.WAIT_TIME);
				} else {
					smartCart.smartCartData.isWaiting = false;
					smartCart.showTimeout();
				}
			} else { //non-200 response
				if (smartCart.smartCartData.isWaiting && smartCart.retries.badResponse.attempt < smartCart.retries.badResponse.MAX_ATTEMPTS) {
					smartCart.retries.badResponse.attempt++;
					nike.dispatchEvent(nike.Event.SMART_ADD_TO_CART, {status: 'smart cart timeout retry:' + smartCart.retries.badResponse.attempt});
					setTimeout(function(){nike.Cart.addToSmartCart(smartCart.retries.badResponse.WAIT_TIME)},smartCart.retries.badResponse.RETRY_INTERVAL);
				} else {
					smartCart.smartCartData.isWaiting = false;
					smartCart.showTimeout();
				}
			}
		}
	});
};

/**
 * Load captcha scripts if not already on the page and display captcha
 */
nike.Cart.initializeCaptcha = function (){
  var isMobile = nike.exp.script.device_detect.isMobile();
  var captcha;
  if (!nike.exp.pdp.Captcha) { //load necessary files

    var scripts = ["nike.exp.pdp.Captcha"];
    nike.requestScripts(scripts,
    function instantiateCaptcha() {
      captcha = new nike.exp.pdp.Captcha();
      captcha.getCaptcha({
        displayType: isMobile ? captcha.displayTypes.MOBILE : captcha.displayTypes.DESKTOP
      });
    });
  } else {
    captcha = new nike.exp.pdp.Captcha();
    captcha.getCaptcha({
      displayType: isMobile ? captcha.displayTypes.MOBILE : captcha.displayTypes.DESKTOP
    });
  }
};

/**
 * This is a custom jsonp call back function implemented specifically for Akamai SPA (Shopper Prioritization App)
 * ATG automatically uses it also because it's properly implementing JSONP. The reason the function on the global object
 * is because jquery looks for the jsonpCallback function on the window object.
 * DO NOT DELETE THIS.
 * @param response
 */
window.nike_Cart_handleJCartResponse = function (response){
};

/**
 * Setting the state of the AddToCart button to either enabled or disabled. Pass in true to disable the button,
 * or pass in false to enabled the button
 * @param state
 */
nike.Cart.setATCButtonState = function(state){
  $('.js-add-to-cart').attr('disabled', state);
};

/**
 * Take a data object and post all of its values to the cartService
 * to add an item.  The data should include these input values:
 *
 *  catalogId
 *  country
 *  lang_locale
 *  productId
 *  qty
 *  siteId
 *  skuSize
 *
 * @param data Object holding required post data
 * @param element The gagdet element calling addToCart
 * @param success Success callback
 * @param fail Fail callback
 */
nike.Cart.addToCart = function (data, element, success, fail) {
  nike.Cart.setATCButtonState(true); // disable the ATC button
	var skuParts;
	var trackProduct;

	// Handle Regular Add-To-Cart Experience
	var handleAddToCartResponse = function (response) {
		// Handle parsed response
		if (response.status === 'success') {
			var result = {  element: element,
				response: response,
				productId: data.productId,
				requestData: data,
				trackProduct: trackProduct};

			if (!nike.Cart.order || response.order.itemQuantity > nike.Cart.order.order.itemQuantity) {
				setTimeout(function () {
          nike.dispatchEvent(nike.Event.ADD_TO_CART_SUCCESS, result);
				}, 300);
				if (success) {
					success(result);
				}
			}
		} else {
			//this is an conditional add to cart success wherein the json response status is a failure but
			//it indeed adds items to cart. The scenario being addressed is when user adds 5 items
			//to cart where only 2 quantities are available for purchase.
			if (response.exceptions[0].errorcode === 'notEnoughStockMessage') {
				setTimeout(function () {
					nike.dispatchEvent(nike.Event.ADD_TO_CART_SUCCESS, {'response': response});
				}, 300);
			}
			doFail(response, element);
		}
	};

	var setupSmartCart = function (response) {
		var isMobile = $('body').hasClass('Phone');
		if (!nike.exp.pdp.SmartCart) { //load necessary files
			var scripts = ["nike.exp.pdp.SmartCart"];
			if (isMobile) {
				scripts.push("nike.exp.pdp.mobile.SmartCart");
			}
			nike.requestScripts(scripts,
					function instantiateSmartCart() {
						var smartCart = isMobile ? new nike.exp.pdp.mobile.SmartCart(data) : new nike.exp.pdp.SmartCart(data);
						smartCart.handleResponse(response);
					});
		} else {
			//Retrieve smart cart object reference from the DOM (if available), otherwise instantiate the object
			var smartCart = $('.smart-cart');
      //When changing colorways, multiple smart-cart divs are appended to the page. Fix for EDF-23820
      if (smartCart.length > 1){
        //Remove the old modal window from the previous colorway to prevent doubling up.
        $('.modal-window-class').has('.smart-cart').remove();
      }
      smartCart = smartCart.data('smartCartInstanceObject');
      if (typeof smartCart === "undefined") {
				smartCart = isMobile ? new nike.exp.pdp.mobile.SmartCart(data) : new nike.exp.pdp.SmartCart(data);
			} else {
				smartCart.initSmartCartData();
				smartCart.setRequestData(data);
			}
			smartCart.handleResponse(response);
		}
	};

  /**
   * Track captcha events
   * @param event
   * @param captchaParams
   */
  var proceedToSmartCart = function(event, captchaParams) {
    if(captchaParams.auth_token && captchaParams.server_key && captchaParams.status == "solved"){
      makeCall(captchaParams);
    }
    nike.unlisten(nike.Event.CAPTCHA_SUCCESSFULLY_SOLVED);
  };

	var setupCaptcha = function () {
    nike.listen(nike.Event.CAPTCHA_SUCCESSFULLY_SOLVED, proceedToSmartCart);
    nike.Cart.initializeCaptcha();

	};

	// Make add to cart request
	var makeCall = function (extraParams) {

		if (extraParams) {
			$.extend(data, extraParams);
		}

		var promise = $.ajax({
			dataType: 'jsonp',
			url: nike.getServiceUrl('jsonCartService'),
      jsonpCallback: "nike_Cart_handleJCartResponse",
			data: data,
			timeout: 45000
		});

		// setup success callback
		promise.done(function (response) {

			if (response.status == "captcha") {
				setupCaptcha();
			}
			else if (response.pil) { //This is a throttled checkout
        nike.dispatchEvent(nike.Event.SMARTCART_INIT);
				setupSmartCart(response);
			} else { //This is not a throttled checkout; proceed normally.
				handleAddToCartResponse(response);
			}
		});

		// setup failure callback
    promise.fail(function (response) {

      var modalContentEl = $('.add-to-cart-timeout-modal-content');
      modalContentEl.removeClass('is-hidden');

      if (!nike.Cart.AddToCartErrorModal) {
        nike.Cart.AddToCartErrorModal = new nike.exp.global.Modal({
          $content: modalContentEl,
          onClose: function () {
            modalContentEl.addClass('is-hidden');
          }
        });
        $('.modal-button-container', modalContentEl).on('click', '.ok', function () {
          nike.Cart.AddToCartErrorModal.close();
        });
      }

      nike.Cart.AddToCartErrorModal.open();
      if (response.statusText == "timeout") {
        nike.dispatchEvent(nike.Event.ADD_TO_CART_TIMEOUT, {});
      } else {
        nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL, {});
      }
    });

    promise.always(function(){
      nike.Cart.setATCButtonState(false); // re-enable the ATC button
    });
  };

	if (!element) {
		nike.error('Gadget "element" must be defined when calling addToCart');
	} else {
		data.action = 'addItem'; // Make sure the action is 'addItem'
		data.rt = 'json'; // Response type of JSON
		data.view = 3; // BASIC_ITEM_VIEW - Returns items in order

		// If 'skuAndSize' is present split it into skuId and displaySize
		if (data.skuAndSize) {
			skuParts = data.skuAndSize.split(':');
			data.skuId = skuParts[0];
			if (skuParts[1]) {
				data.displaySize = skuParts[1];
			}
		}

		trackProduct = function () {
			//Remove trackingProduct from request data
			var trackProduct = undefined;
			if (data.trackProduct) {
				trackProduct = $.extend({}, true, data.trackProduct);
				trackProduct.qty = data.qty;
				delete(data.trackProduct);
			} else {
				trackProduct = {
					productId: data.productId,
					qty: data.qty,
					siteId: undefined,
					price: data.price
				};
			}
			trackProduct.sku = data.skuId;
			return trackProduct;
		}();

		// Dispatch add to cart event
    nike.debug(trackProduct);
		nike.dispatchEvent(nike.Event.ADD_TO_CART, {data: data, element: element, trackProduct: trackProduct});

		// Fail function
		var doFail = function (response, element) {
			var errorCode = response.exceptions && response.exceptions[0] && response.exceptions[0].errorcode;
			var result = {'element': element, 'errorcode': errorCode, 'response': response, 'requestData': data, 'trackProduct': trackProduct};
			nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL, result);

			if (fail) {
				fail(result);
			}
		};

		makeCall();
	}
};

/**
 * Retrieves a specific property from the last item added to cart.
 *
 * @param {Object} response - The cart service response.
 * @param {String} attribute - The attribute you want the value of.
 * @returns {*}
 */
nike.Cart.getAddedItemProperty = function (response, attribute) {
  var shippingGroups = nike.objectDefined('order.shippingGroups', response)
    ? response.order.shippingGroups
    : null;
  var item;

  // This object is a map of functions that return the path of the attribute requested
  var pathTo = {
    price: function (item) {
      return item.priceInfo.amount;
    }
  };

  // We get back the full list of cart items back. Use the last one which will be
  // the product last added to the cart.
  if( shippingGroups && shippingGroups.length ){
    for( var i = (shippingGroups.length - 1); i >= 0; i-- ){
      var commerceItems = shippingGroups[i].commerceItems;

      if( commerceItems && commerceItems.length ){
        item = commerceItems[commerceItems.length - 1];
      }
    }
  }

  return (item) ? pathTo[attribute](item) : null;
};

/**
 * Add a digital PiD item to cart.
 *
 * Takes a data object and post all of its values to the consumer choice service.
 * The data should include these properties:
 * eg.
 * {
 *  "pid": "10253925",
 *	"baseStyle": "641858",
 *	"baseColor": "650",
 *	"country": "US",
 *	"locale": "en_US",
 *	"quantity": "1",
 *	"size": "10.5",
 *	"designAttributes": [{
 *		"fieldName": "LeftShort",
 *		"fontColor": "969B9E",
 *		"text": "23"
 *	}, {
 *		"fieldName": "LeftLong",
 *		"fontColor": "969B9E",
 *		"text": "SWOOSH"
 *	}]
 * }
 *
 * @param data Object holding required post data object
 * @param element The element calling digitalPiDAddToCart
 * @param success success callback
 * @param fail failure callback
 */
nike.Cart.digitalPiDAddToCart = function (data, element, success, fail) {
	var responseData = {'success': false};
	var productId = data.productId;
	var url= nike.getServiceUrl('digitalPidAddToCartServiceProxy');
  var recipeId = (
    nike.objectDefined('configuration.ids', data)
    && data.configuration.ids.length
  ) ? data.configuration.ids[0].id : 'missing-recipe-id';

	nike.Cart.setATCButtonState(true);

	nike.dispatchEvent(nike.Event.ADD_TO_CART, {data: data, element: element, trackProduct: {/* @todo: setup tracking data*/}});

	$.ajax({
	    url: url,
	    contentType: 'application/json; charset=UTF-8',
	    type: 'POST',
	    data: JSON.stringify(data),
	    timeout : 45000
	})
	.done(function(response){
	    var dPidResponse = $.xml2json(response);

	    if (dPidResponse && dPidResponse.item && dPidResponse.item.status === 'success') {
	        //  Fetch order details for mini cart display
	        nike.request(
            {
	            method: 'POST',
	            url: nike.Cart.getCartServiceUrl(nike.DEFAULT_APP_NAME),
	            data: {
                country: nike.COUNTRY,
                lang_locale: nike.LOCALE
              }
            },
            function (response) {
              try {
                responseData = $.parseJSON(response.data);
              } catch (e) {
                responseData.errorMessages = [e.toString()];
              }

              if (responseData.success) {
                nike.Cart.order = responseData;

                setTimeout(function () {
                  var parsedQuantity = dPidResponse.item.RecipeId.replace(/[\[\]]/g, '').split(',');
                  var quantity = parsedQuantity.length || 1;
                  var product = ( nike.exp.script.device_detect.isMobile() )
                    ? nike.exp.pdp.mobile.currentProduct
                    : nike.exp.pdp.PdpPage.currentProduct;

                  // Add extra data required for analytics
                  $.extend(product.trackingData.product, {
                    sku: data.skuId,
                    qty: quantity,
                    price: nike.Cart.getAddedItemProperty(responseData, 'price')
                  });

                  nike.dispatchEvent(nike.Event.ADD_TO_CART_SUCCESS, {
                    response: responseData,
                    recipeId: recipeId,
                    isNikeId: false,
                    qty: quantity,
                    sku: data.skuId,
                    productId: productId
                  });

                  if(success && typeof success == "function"){
                    success(responseData);
                  }

                }, 300);
              } else {
                doFail(responseData);
              }
            },
            function (response) {
                doFail(response);
	          }
          );
	    } else {
	        if( dPidResponse.item ){
	            dPidResponse.errorcode = dPidResponse.item.errorCode;

	            if (typeof dPidResponse.item.exception === 'string') {
	                dPidResponse.exceptions = [dPidResponse.item.exception];
	            } else {
	                dPidResponse.exceptions = dPidResponse.item.exception;
	            }

	            doFail(dPidResponse);
	        } else {
	        	doFail(response);
	        	nike.Cart.setATCButtonState(false);
	        	nike.error('Failed to add DigitalPiD item to cart');
	        }
	    }
	})
	.fail(function(response){
		doFail(response);
		nike.error('Failed to add DigitalPiD item to cart');
	})
	.always(function(response){
	    nike.Cart.setATCButtonState(false);
	});

	function doFail(response, element) {
    var modalContentEl = $('.add-to-cart-timeout-modal-content');
		modalContentEl.removeClass('is-hidden');

    if (!nike.Cart.AddToCartErrorModal) {
      nike.Cart.AddToCartErrorModal = new nike.exp.global.Modal({
        $content: modalContentEl,
        onClose: function () {
          modalContentEl.addClass('is-hidden');
        }
      });
      $('.modal-button-container', modalContentEl).on('click', '.ok', function () {
        nike.Cart.AddToCartErrorModal.close();
      });
    }

    if (response.statusText == "timeout") {
      nike.dispatchEvent(nike.Event.ADD_TO_CART_TIMEOUT, {});
      nike.Cart.AddToCartErrorModal.open();
    } else {
      nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL, {'element': element, 'response': response, 'code': response.code});
      nike.Cart.AddToCartErrorModal.open();
    }

    if(fail && typeof fail == "function"){
      fail(response);
	 	}
	}
};

/**
 * Add a gift card item to cart.
 *
 * Take a data object and post all of its values to the cartService
 * to add an item.  The data should include these input values:
 *
 *  catalogId
 *  country
 *  lang_locale
 *  productId
 *  qty
 *  siteId
 *
 * @param data Object holding required post data
 * @param element The gagdet element calling addGiftCardToCart
 */
nike.Cart.addGiftCardToCart = function (data, element) {
  if (!element) {
    throw new Error('Gadget "element" must be defined when calling addGiftCardToCart');
  }

  var responseData = {success: false};
  var gadgetAppName = nike.DEFAULT_APP_NAME;
  data.action = 'addConfigurableItem';

  var requestObj = {
    method: 'POST',
    url: nike.Cart.getCartServiceUrl(nike.DEFAULT_APP_NAME),
    data: data
  };

  var giftCardAddToCartFail = function giftCardAddToCartFail (response, element) {
    nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL, {
      element: element,
      response: response,
      trackProduct: {}
    });
  };

  var giftCardSuccessCallback = function giftCardSuccessCallback (response) {
    try {
      responseData = $.parseJSON(response.data);
    } catch (err) {
      responseData = [err.toString()];
    }

    if (responseData.status === 'success') {
      nike.Cart.order = responseData;
      _.delay(function () {
        nike.dispatchEvent(nike.Event.ADD_TO_CART_SUCCESS, {
          element: element,
          response: responseData,
          productId: data.productId,
          trackProduct: {
            price: data.price,
            qty: data.quantity || 1,
            sku: data.skuId
          }
        });
      }, 300);

    } else {
      giftCardAddToCartFail(responseData, element);
    }
  };

  var giftCardfailureCallback = function giftCardfailureCallback (response) {
    responseData.errorMessages = [];
    giftCardAddToCartFail(responseData, element);
  };



  nike.dispatchEvent(nike.Event.ADD_TO_CART, {
    data: data,
    element: element,
    trackProduct: {}
  });

  nike.request(requestObj, giftCardSuccessCallback, giftCardfailureCallback);
};

/**
 * Post data object with list of items to the cartService
 * to add items.  data should include these input values:
 *
 *  catalogId
 *  country
 *  lang_locale
 *  siteId
 *  itemList (Array)
 *    productId
 *    qty
 *    skuSize
 *
 * @param data Data object to post
 * @param element The gagdet element calling multiAddToCart
 */
nike.Cart.multiAddToCart = function (data, element) {
	var i, L;

	if (!element) {
		nike.error('Gadget "element" must be defined when calling multiAddToCart');
	}
	else {
		var responseData = {'success': false};

		// Get the app name according to the gadget calling this function
		var gadgetAppName = nike.DEFAULT_APP_NAME;
		var trackProductList = data.itemList;
		// Encode itemList as JSON string
		data.itemList = JSON.stringify(data.itemList);

		// Make sure the action is 'addItem'
		data.action = 'addItems';


		//TODO: Double check this for 2012 analytics
		//Products sent to tracking for add to cart should not include a siteId.  This is a omniture specific fix for evar19
		for (i = 0, L = trackProductList.length; i < L; i++) {
			trackProductList[i].siteId = undefined;
		}

		// Dispatch add to cart event
		nike.dispatchEvent(nike.Event.ADD_TO_CART,
				{data: data, element: element, trackProducts: trackProductList});

		// Fail function
		function doFail(response, element) {
			nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL,
					{'element': element, 'response': response});
		}

		// Make add to cart request
    nike.request({
          method: 'POST',
					url: nike.Cart.getCartServiceUrl(gadgetAppName),
					data: data
					// Successful call
				}, function (response) {
					try {
						responseData = $.parseJSON(response.data);
					} catch (e) {
						responseData.errorMessages = [e.toString()];
					}

					// Handle parsed response
					if (responseData.success) {
						nike.Cart.order = responseData;
						nike.dispatchEvent(nike.Event.MULTI_ADD_TO_CART_SUCCESS,
								{element: element, response: responseData});
					}
					else {
						doFail(responseData, element);
					}
					// Failed call
				}, function (response) {
					responseData.errorMessages = [response.toString()];
					doFail(responseData, element);
				});
	}
};

/**
 * Take a list of form elements and post their values to
 * the cartService to add items. Each form should
 * include these input values:
 *
 *  catalogId
 *  country
 *  lang_locale
 *  siteId
 *  productId
 *  qty
 *  skuSize
 *
 *  @param formElements Array of form elements
 * @param element The gagdet element calling formsAddToCart
 */
nike.Cart.formsAddToCart = function (formElements, element) {

	var data;
	var i;
	var formData;

	// Get all form values
	for (i = 0; i < formElements.length; i++) {
		formData = nike.ServiceUtil.getFormData(formElements[i]);
		if (!data) {
			data = {'itemList': []};
			data.siteId = formData.siteId;
			data.catalogId = formData.catalogId;
			data.lang_locale = formData.lang_locale;
			data.country = formData.country;
		}
		data.itemList.push(formData);
	}

	nike.Cart.multiAddToCart(data, element);
};

/**
 * Post data object with list of items to the cartService
 * to add items.  data should include these input values:
 *
 *
 * @param data Data object to post to nikeIdAddToCart service.
 * @param url The URL to call cartService to load order.
 *
 * TODO This needs to be refactored so that it doesn't require a flag based on whether it's an IP item or not
 */
nike.Cart.nikeidAddToCart = function (data, isNikeId, successCallback, failureCallback) {

	var responseData = {'success': false};
  var errorCode = 'no error code available';
  var errorExceptions = [];

	// Fail function
	function doFail(response, element) {
      var modalContentEl = $('.add-to-cart-timeout-modal-content');
      modalContentEl.removeClass('is-hidden');

      if (!nike.Cart.AddToCartErrorModal) {
        nike.Cart.AddToCartErrorModal = new nike.exp.global.Modal({
          $content: modalContentEl,
          onClose: function () {
            modalContentEl.addClass('is-hidden');
          }
        });
        $('.modal-button-container', modalContentEl).on('click', '.ok', function () {
          nike.Cart.AddToCartErrorModal.close();
        });
      }


      if (response.statusText == "timeout") {
        nike.dispatchEvent(nike.Event.ADD_TO_CART_TIMEOUT, {});
        
        if (modalContentEl.length) {
          nike.Cart.AddToCartErrorModal.open();
    	}
      } else if(nike && nike.id && nike.id.frame && nike.id.frame.PageMessageUtil) {
        nike.id.frame.PageMessageUtil.postMessage(nike.id.Event.postMessage.ADD_TO_CART_FAIL, response);
      } else {
        nike.dispatchEvent(nike.Event.ADD_TO_CART_FAIL,
          {'element': element, 'response': response, 'code': response.code});
      }

    if(typeof failureCallback == "function"){
      failureCallback(response);
    }
	}

	nike.request(
			{type: 'POST',
				url: nike.getServiceUrl('nikeIdAddToCartService'),
				data: data,
        timeout : 45000
			}, function (response) {
      var jsonResponse = {};
      var success = true;
        try{
          jsonResponse = $.xml2json(response.data);
        } catch(e){
          nike.log(e);
          success = false;
        }
        //We get either 1 item in response in which we just get whether its a success or not or we get multiple items
        //and check to make sure they were all successful.
      if(jsonResponse.item){
        if(jsonResponse.item.length && jsonResponse.item.length > 0){
          for(var i = 0; i < jsonResponse.item.length && success; i++){
            if(success){
              success = jsonResponse.item[i].status === "success";
            }
            errorCode = jsonResponse.item[i].errorCode;
            errorExceptions.push(jsonResponse.item[i].exception);
          }
        } else {
          success = jsonResponse.item.status === "success";
          errorCode = jsonResponse.item.errorCode;
          errorExceptions.push(jsonResponse.item.exception);
        }
      } else {
        success = false;
      }

      if(success){
        // Successful call
        nike.request({
          method: 'GET',
          url: nike.Cart.getCartServiceUrl(nike.DEFAULT_APP_NAME),
          data: {'country': nike.COUNTRY,
            'lang_locale': nike.LOCALE}
        }, function (response) {
          // Successful call
          try {
            responseData = $.parseJSON(response.data);
          } catch (e) {
            responseData.errorMessages = [e.toString()];
          }
          // Handle parsed response
          if (responseData.success) {
            nike.Cart.order = responseData;
            setTimeout(function () {
              var qtyEl = $("select[name='qty']");
              var quantity = $(qtyEl).find("option:selected").text();
              var skuId;
              if(this.data) {
                skuId = this.data.skuId;
              }
              if(nike && nike.id && nike.id.frame && nike.id.frame.PageMessageUtil){
                nike.id.frame.PageMessageUtil.postMessage(nike.id.Event.postMessage.ADD_TO_CART_SUCCESS, {response: responseData, isNikeId: isNikeId, qty: quantity, sku: skuId});
              } else {
                nike.dispatchEvent(nike.Event.ADD_TO_CART_SUCCESS, {response: responseData, isNikeId: isNikeId, qty: quantity, sku: skuId});
              }

              if(typeof successCallback == "function"){
                successCallback(responseData);
              }

            }, 300);
          }
          else {
            doFail(responseData);
          }
        }, function (response) {
          // Failed call - load cart
          doFail(response);
        });
      } else {
        // Failed on Add NikeId product to cart, "200" with status=failure
        response.code = errorCode;
        response.exceptions = errorExceptions;
        doFail(response);
      }

			}, function (response) {
				// Failed call - Add NikeId product to cart
        if(response.code == undefined) {
          response.code = "no error code available";
        }

        if (response.data.statusText == "timeout") {
          response.statusText = "timeout";
        }
				doFail(response);
				//nike.id.frame.PageMessageUtil.dispatch(nike.id.Event.postMessage.ADD_TO_CART_FAIL, response);
			});
};


/**
 * Take a form and post all of its values to the cartService
 * to update an item.  Updating with a quantity of "0" will
 * remove the item. The data should include these input values:
 *
 *  country
 *  lang_locale
 *  qty
 *  cartItem (shippingGroupId:commerceItemId)
 *
 * @param data Object with required information
 * @param element The gagdet element calling updateCartItem
 */
nike.Cart.updateCartItem = function (appName, data, success, fail) {

	if (!appName) {
		nike.error('appName must be defined when calling updateCartItem');
	}
	else {
		var responseData = {'success': false};

		// Make sure the action is 'updateOrder'
		data.action = 'updateOrder';

		// Dispatch add to cart event
		nike.dispatchEvent(nike.Event.UPDATE_CART_ITEM,
				{data: data});

		// Fail function
		function doFail(response) {
			var result = {'response': response};
			nike.dispatchEvent(nike.Event.UPDATE_CART_ITEM_FAIL,
					result);
		}

		// Success function
		function doSuccess(response) {
			var result = {'response': response};

			// Fire success event
			nike.dispatchEvent(nike.Event.UPDATE_CART_ITEM_SUCCESS, result);

			// Call success callback if supplied
			if (success) {
				success(result);
			}
		}

		// Make add to cart request
    nike.request({
          method: 'POST',
					url: nike.Cart.getCartServiceUrl(appName),
					data: data
					// Successful call
				}, function (response) {
					try {
						responseData = $.parseJSON(response.data).response;
					} catch (e) {
						responseData.errorMessages = [e.toString()];
					}

					// Handle parsed result
					if (responseData.success) {
						doSuccess(responseData);
					}
					else {
						doFail(responseData);
					}
					// Failed call
				}, function (response) {
					responseData.errorMessages = [response.toString()];
					doFail(responseData);
				});
	}
};

/**
 * Check gift card balances by calling the cart service
 *
 * @param checkGiftCardBalance comma-separated list of GC numbers
 */
nike.Cart.checkGiftCardBalance = function (giftCertNumbers) {

	if (!giftCertNumbers) {
		nike.error('giftCertNumbers must be defined when calling checkGiftCardBalance');
	}
	else {
		var responseData = {'success': false};
		var data = {};

		// Make sure the action is 'checkCertificateBalance'
		data.action = 'checkCertificateBalance';
		data.country = nike.COUNTRY;
		data.lang_locale = nike.LOCALE;

		// Set the giftcard numbers param
		data.gift_card_numbers = giftCertNumbers;

		// Get the app name according to the gadget calling this function
		var gadgetAppName = nike.DEFAULT_APP_NAME;

		// Dispatch check gift card event
		nike.dispatchEvent(nike.Event.CHECK_GIFT_CARD_BALANCE, {data: data});

		// Fail function
		function doFail(response) {
			var result = {'response': response};
			nike.dispatchEvent(nike.Event.CHECK_GIFT_CARD_BALANCE_FAIL,
					result);
		}

		// Make check GC balance request
		nike.request(
				{method: 'POST',
					url: nike.Cart.getGiftCardBalanceCartServiceUrl(gadgetAppName),
					data: data
					// Successful call
				}, function (response) {
					try {
						responseData = $.parseJSON(response.data);
					} catch (e) {
						responseData.errorMessages = [e.toString()];
					}

					// Handle parsed result
					if (responseData.success) {
						nike.dispatchEvent(nike.Event.CHECK_GIFT_CARD_BALANCE_SUCCESS,
								{response: responseData});
					}
					else {
						doFail(responseData);
					}
					// Failed call
				}, function (response) {
					responseData.errorMessages = typeof response === 'string' ? [response.toString()] : null;
					doFail(responseData);
				});
	}
};

/**
 * Load the current order
 *
 * @param appName Application to request from
 * @param success Callback for successful request
 * @param fail Callback for failed request
 * @param refresh Force a service call
 */
nike.Cart.loadOrder = function (appName, success, fail, refresh) {

	if (!appName) {
		nike.error('Missing required parameter "appName" to nike.Cart.loadOrder');
	}
	else {

		// Success function
		function doSuccess(response) {

			// Fire success event
			nike.dispatchEvent(nike.Event.LOAD_ORDER_SUCCESS,
					{'response': response});

			// Call success callback if supplied
			if (success) {
				success({'response': response});
			}
		}

		// Fail function
		function doFail(response) {
			var result = {'response': response};
			nike.dispatchEvent(nike.Event.LOAD_ORDER_FAIL,
					result);

			// Call fail callback
			if (fail) {
				fail(result);
			}
		}

		// Call success if order is loaded and not refreshing
		if (!refresh &&
				nike.Cart.order) {
			doSuccess(nike.Cart.order);
		}
		else {
			var responseData = {'success': false};

			// Do request
      nike.request({
            method: 'POST',
						url: nike.Cart.getCartServiceUrl(appName),
						data: {'country': nike.COUNTRY,
							'lang_locale': nike.LOCALE}
					},
					function (response) {
						try {
							// Parse response
							responseData = $.parseJSON(response.data).response;
						} catch (e) {
							responseData.errorMessages = [e.toString()];
						}

						// Success response
						if (responseData.success) {
							nike.Cart.order = responseData;
							doSuccess(responseData);
						}
						// Failed response
						else {
							doFail(responseData);
						}
					},
					// Request failed
					function (response) {
						responseData.errorMessages = [response.toString()];
						doFail(responseData);
					});
		}
	}
};

/**
 * If the cart summary is no longer valid
 * this method will clear it so it is requested
 * again when loadCartSummary is called.
 */
nike.Cart.clearCartSummary = function () {
	delete nike.Cart.cartSummary;
  nike.Cart.cookieObject = nike.Cart.cookieObjectDefaults;
  $.removeCookie(nike.Cart.CART_SUMMARY_COOKIE, { path: '/', domain: location.host.match(/nike.*?\.com$/) });
};

/**
 * Queue of callbacks for loadCartSummary to
 * all be called when the service call returns
 */
nike.Cart.loadCartSummaryCallbacks = {
	success: $.Callbacks(),
	fail: $.Callbacks()
};

/**
 * Flag to indicate if a request for cart summary is currently
 * being made.  We will prevent multiple requests being made
 * at the same time.
 */
nike.Cart.isRequestingLoadCartSummary = false;

/**
 * Load the cart summary from the service
 *
 * @param {String} appName Application to request from
 * @param {Function} [success] Callback for successful request
 * @param {Function} [fail] Callback for failed request
 * @param {Boolean} [refresh] to force a request even if
 *        cartSummary has already been loaded
 */
nike.Cart.loadCartSummary = function (appName, success, fail, refresh, overrideProtector) {
	var i;
	var callback;
	var newRequest;
	var url = nike.getServiceUrl('jsonCartService');
	//noinspection JSDuplicatedDeclaration
	var success = success || $.noop;
	//noinspection JSDuplicatedDeclaration
	var fail = fail || $.noop;

	if (!appName) {
		nike.error('Missing required parameter "appName" to nike.Cart.loadCartSummary');
	}
	else {

		// Success function
		function doSuccess(response) {
			var callback;
			var i;
			var result = {'response': response};

			// Fire success event
			nike.dispatchEvent(nike.Event.LOAD_CART_SUMMARY_SUCCESS,
					result);

			if (!nike.Cart.loadCartSummaryCallbacks.success.firing) {
				nike.Cart.loadCartSummaryCallbacks.success.firing = true;
				nike.Cart.loadCartSummaryCallbacks.success.fire(result);
				nike.Cart.loadCartSummaryCallbacks.success.empty();
				nike.Cart.loadCartSummaryCallbacks.success.firing = false;
			}

			if (!nike.Cart.loadCartSummaryCallbacks.fail.firing) {
				nike.Cart.loadCartSummaryCallbacks.fail.empty();
			}

		}

		// Fail function
		function doFail(response) {
			var result = {'response': response};

			nike.dispatchEvent(nike.Event.LOAD_CART_SUMMARY_FAIL,
					result);

			if (!nike.Cart.loadCartSummaryCallbacks.fail.firing) {
				nike.Cart.loadCartSummaryCallbacks.fail.firing = true;
				nike.Cart.loadCartSummaryCallbacks.fail.fire(result);
				nike.Cart.loadCartSummaryCallbacks.fail.empty();
				nike.Cart.loadCartSummaryCallbacks.fail.firing = false;
			}

			if (!nike.Cart.loadCartSummaryCallbacks.success.firing) {
				nike.Cart.loadCartSummaryCallbacks.success.empty();
			}

		}

		// Makes the service call
		function makeRequest() {
			nike.Cart.isRequestingLoadCartSummary = true;

			var params = {
				"url": url,
				dataType: 'jsonp',
				data: {action: 'getCartSummary',
					rt: 'json',
					country: nike.COUNTRY,
					lang_locale: nike.LOCALE},

				success: function (response) {

					// Handle parsed result
					if (response.status === 'success') {
						response.loggedIn = response.securityStatus >= nike.Cart.MINIMUM_LOGGED_IN_SECURITY_STATUS;
						nike.Cart.cartSummary = response;
            nike.Cart.setCartSummaryObject();
            nike.gadget.CartCount.setup($('[data-gadget="nike.gadget.OneNikeNav"]'));
						// Fire event that cart summary was loaded form the wire.
						nike.dispatchEvent(nike.Event.CART_SUMMARY_REQUEST_SUCCESS, { 'response': response });
						doSuccess(nike.Cart.cartSummary);
					}
					else {
						doFail(response);
					}
					nike.Cart.isRequestingLoadCartSummary = false;
				},
				error: function (response) {
					doFail(response);
					nike.Cart.isRequestingLoadCartSummary = false;
				}
			};

			if (url === undefined) {
				params.error({});
			} else {
				$.ajax(params);
			}
		}

    //     (   )     WARNING - This is a particularly ugly area of our codebase. The code below is related
    //  (   ) (      to the getCartSummaryCall which makes a call to ATG to get the cart count, amongst other things.
    //   ) _   )     Along with the getCartSummary response, they are also setting ALL of our locale cookies. This
    //    ( \_       created a rather ugly bug (EDF-28528), that was infinitely redirecting users between locales.
    //  _(_\ \)__    The code below was modified to address this bug. It also has to be ugly to fit in with all of
    // (____\___))   the ugly code surrounding it. This WILL be refactored.

    var makeRequestProtector = function(){
      //ensure that the getCartSummary call is only executed once.
      if (refresh || !nike.Cart.getCartSummaryExecuted){
        makeRequest();
        nike.Cart.getCartSummaryExecuted = true;
      }
    };

		// If we need to make another request increment the count
		newRequest = !nike.Cart.isRequestingLoadCartSummary &&
				(refresh || !nike.Cart.cartSummary);

		// Queue up callbacks
		nike.Cart.loadCartSummaryCallbacks.success.add(success);
		nike.Cart.loadCartSummaryCallbacks.fail.add(fail);

		// Call success if summary is loaded and not refreshing
		if (!refresh && nike.Cart.cartSummary && !nike.Cart.isRequestingLoadCartSummary) {
			doSuccess(nike.Cart.cartSummary);
		}
		else if (newRequest) {
			// Make cart summary request
      var count = 0;

      if(overrideProtector){ // fix for language tunnel redirect is breaking login/logout workflow
        makeRequestProtector();
      }
      else {
        // we are doing a setInterval in order to ensure that the Locate.js script has completed before calling getCartSummary
        // also, there is no need to call getCartSummary if we are in the middle of executing a redirect
        var s = setInterval(function(){
          count++;
          //if nike.geo doesn't exist, the locate script is not loaded, we can execute the cartSummary req. without worry
          if (!nike.geo || !nike.geo.Locate || ( (nike.geo.Locate && nike.geo.Locate.hasCompleted) && (nike.geo.Util && !nike.geo.Util.isRedirecting) )){
            nike.debug("Nike locate script has finished executing, now safe to make getCartSummary request.");
            makeRequestProtector();
            clearInterval(s);
          } else if (count > 15){
            nike.debug("Nike locate script failed to execute, as such getCartSummary call failed");
            clearInterval(s);
          } else {
            nike.debug("Nike locate script has not finished executing, waiting to make getCartSummary request.");
          }
        }, 1000);
      }

		}
	}
};

/**
 * If the cart summary is stored in a cookie parse it
 * and return an object that looks the same as the
 * response from the loadCartSummary service
 *
 * @return Object matching cartSummary result
 */
nike.Cart.getCartSummaryFromCookie = function () {
  if ($.cookie(nike.Cart.CART_SUMMARY_COOKIE)) {
    return $.cookie(nike.Cart.CART_SUMMARY_COOKIE);
  } else {
    return nike.Cart.cookieObject;
  }

};

nike.Cart.setCartSummaryObject = function () {
  nike.Cart.cookieObject = $.cookie(nike.Cart.CART_SUMMARY_COOKIE);
}

/**
 * Gets the cartCount from the cartSummary cookie and returns it
 *
 * @returns cartCount
 */
nike.Cart.getCartCount = function () {
  var cookieValue = nike.Cart.getCartSummaryFromCookie();
  return cookieValue.cartCount;
}

/**
 * Gets the userType from the cartSummary cookie object
 *
 * @returns userType
 */
nike.Cart.getUserType = function () {
  var cookieValue = nike.Cart.getCartSummaryFromCookie();
  return cookieValue.userType;
}

/**
 * Gets the profileId from the cartSummary cookie object
 *
 * @returns profileId
 */
nike.Cart.getProfileId = function () {
  var cookieValue = nike.Cart.getCartSummaryFromCookie();
  return cookieValue.profileId;
}

/**
 * Finds pricing info on the page and modifies the
 * visible price fields according to user type
 *
 * @param element The gagdet element calling setupPricing
 * @param truncateFlag Flag for truncating prices
 * @param outfitter Flag for the outfitter page
 */
nike.Cart.setupPricing = function (element, truncateFlag, outfitter) {
	var prices;
	var pricingData;
	var rawPrice;
	var userType;

	function truncatePrice(price) {
		return price ? price.replace(/(\.|,)00(\D|$)/, "$2") : "";
	}

	// Gadget element is necessary to get app name
	if (!element) {
		nike.error('Gadget "element" must be defined when calling setupPricing');
	}
	else {
		var gadgetAppName = nike.DEFAULT_APP_NAME;

    userType = nike.Cart.getUserType();

			// Get all pricing containers
			$(element).find('div.prices').each(function () {
				prices = $(this);

				// Get pricing data
				pricingData = prices.find('div.bulk-pricing');
				rawPrice = prices.find('span.raw-price');

				var overriddenPrice = prices.find('span.overridden'),
						localPrice = prices.find('span.local, div.local');

				// Show or remove prices according to user type
				switch (userType) {
					case nike.Cart.UserType.EMPLOYEE:
						//In case there is an overriden price but the original price comes empty
						if (pricingData.attr('data-bp').length == 0 && pricingData.attr('data-obp').length != 0) {
							localPrice.html(pricingData.attr('data-obp'));
							overriddenPrice.html(pricingData.attr('data-bp'));
						} else {
							if(outfitter) {
								localPrice.html('<span class="sale">' + pricingData.attr('data-bp') + '</span>');
							} else {
								localPrice.html(pricingData.attr('data-bp'));
							}

							// for clearance items we want the ob, for non-clearance we need obp
							var basePrice = (pricingData.attr('data-op') && pricingData.attr('data-op') != '')
								? pricingData.attr('data-op')
								: pricingData.attr('data-obp')

							overriddenPrice.html(basePrice);
						}

						if (rawPrice.attr('data-eda') == 'true') {
							rawPrice.html(rawPrice.attr('data-ep'));
						}
						break;
					case nike.Cart.UserType.AFFILIATE:
						overriddenPrice.html(pricingData.attr('data-oap'));
						localPrice.html(pricingData.attr('data-ap'));
						if (rawPrice.attr('data-eda') == 'true') {
							rawPrice.html(rawPrice.attr('data-ap'));
						}
						break;
					default:
						break;
				}

				if (truncateFlag) {
					overriddenPrice.html(truncatePrice(overriddenPrice.html()));
					localPrice.html(truncatePrice(localPrice.html()));
				}
			});

		nike.dispatchEvent(nike.Event.PRICE_SETUP_COMPLETE, { 'element': element });
	}
};

/**
 * Updates shipping country
 */
nike.Cart.updateShippingCountry = function (country, lang_locale) {
	//Get the app name
	var gadgetAppName = nike.DEFAULT_APP_NAME;

	var url = nike.getServiceUrl('jsonCartService');

	nike.log('Posting to ' + url + ' to update shipping country');

	if (url) {
		// Make updateShippingCountry request
		nike.request(
				{type: 'POST',
					url: url,
					data: {'country': country.toUpperCase(),
						'lang_locale': lang_locale,
						'action': 'updateShippingCountry',
						'rt': 'json'}
				},
				function (response) {
					try {
						responseData = $.parseJSON(response.data);
					} catch (e) {
						nike.error('Error parsing cart response');
						nike.error(e);
					}

					if (responseData.status == 'success') {
						nike.dispatchEvent(nike.Event.UPDATE_SHIPPING_COUNTRY_SUCCESS, {'response': responseData});
					}
					else {
						nike.dispatchEvent(nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL, {'response': responseData});
					}
				},
				function (response) {
					nike.log('Received failure response message from cart service');
					var responseData = {};
					responseData.errorMessages = [response.toString()];
					nike.dispatchEvent(nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL, {'response': responseData});
				});
	} else {
		nike.dispatchEvent(nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL);
	}
};

/**
 * ATG multi add to cart
 */
nike.Cart.atgMultiAddToCart = function (products, successCb, errorCb) {
	var dataProductIds = [],
			dataQty = [],
			dataSkuIds = [],
			dataDisplaySizes = [],
			dataStr = 'action=addItems&lang_locale=' + nike.LOCALE + '&country=' + nike.COUNTRY + '&rt=json&view=3';

	function getOrderItemQuantity(order) {
		var quantity = 0;
		if (order.shippingGroups && order.shippingGroups.length > 0) {
			for (var i = 0; i < order.shippingGroups.length; i++) {
				commerceItems = order.shippingGroups[i].commerceItems;
				if (commerceItems && commerceItems.length > 0) {
					for (var j = 0; j < commerceItems.length; j++) {
						quantity += parseInt(commerceItems[j].quantity);
					}
				}
			}
		}
		return quantity;
	}

	nike.SiteIdUtil.getDefaultSiteId(function (siteId) {
		dataStr += '&siteId=' + siteId;
	});

	for (var i = 0, len = products.length; i < len; i++) {
		dataStr += '&productId=' + products[i].productId;
		dataStr += '&qty=' + products[i].qty;
		dataStr += '&skuId=' + products[i].skuId;
		dataStr += '&displaySize=' + products[i].displaySize;
	}

	$.ajax({
		url: nike.getServiceUrl('jsonCartService'),
		dataType: 'jsonp',
		data: dataStr,
		timeout: 30000,

		success: function (response) {
			response.totalItemsInCart = getOrderItemQuantity(response.order);

			nike.dispatchEvent(nike.Event.MULTI_ADD_TO_CART_SUCCESS, response);
			successCb(response);
		},
		error: errorCb
	});
};

$.cookie.json = true;

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Cart. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.gadget.LoadingScreen');

nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.Event');

/**
 * If any loading takes less than (delay)ms, the loading screen isn't displayed.
 * The array catches the different timer instances triggered by the several listening processes.
 */
nike.gadget.LoadingScreen.loadingScreenDelay = (function(){
  var timer;
  var arr = [];
  return {
    setTimer: function(fn, delay){
      timer = setTimeout(fn, delay);
      arr.push(timer);
    },
    clearTimer: function(){
      for(var i=0; i<arr.length; i++){
        clearTimeout(arr[i]);
      }
      arr = [];
    }
  }
})();

/**
 * Keep a single loading screen overlay reference as more
 * than one would not make sense
 */
nike.gadget.LoadingScreen.overlay = $();

nike.gadget.LoadingScreen.showing = false;

/**
 * Do not show the loading screen when the following gadgets are loaded
 */
nike.gadget.LoadingScreen.onGadgetLoadExceptions = ['nike.mobile.gadget.VerticalScrollAsyncLoader','nike.mobile.gadget.Reviews'];

/**
 * Show the loading screen overlay.
 */
nike.gadget.LoadingScreen.show = function() {
  nike.gadget.LoadingScreen.showing = true;
  nike.gadget.LoadingScreen.overlay.addClass('visible');
};

/**
 * Hide the loading screen overlay.
 */
nike.gadget.LoadingScreen.hide = function() {
  nike.gadget.LoadingScreen.showing = false;
  nike.gadget.LoadingScreen.overlay.removeClass('visible');
};

/**
 * Listen for show event
 */
nike.listen(nike.gadget.Event.SHOW_LOADING_SCREEN, function(event, data){
  nike.gadget.LoadingScreen.loadingScreenDelay.setTimer(function(){
    nike.gadget.LoadingScreen.show();
  }, 300);
});

/**
 * Listen for hide event
 */
nike.listen(nike.gadget.Event.HIDE_LOADING_SCREEN, function(event, data){
    nike.gadget.LoadingScreen.loadingScreenDelay.clearTimer();
    nike.gadget.LoadingScreen.hide();
});

/**
 * Listen for events that show the loading screen
 */
nike.listen([nike.EVENT_LOAD_GADGET,
             nike.Event.ADD_TO_CART,
             nike.Event.UPDATE_CART_ITEM,
             nike.Event.ADD_WISHLIST_ITEM_PROCESS], function(event, data){
  
  if(data && data.element != undefined  && data.element.data instanceof Function ){
    if (nike.gadgetListensTo(nike.gadget.LoadingScreen.overlay, data.element) &&
        $.inArray(data.element.data('gadget'), nike.gadget.LoadingScreen.onGadgetLoadExceptions) == -1) {
      nike.dispatchEvent(nike.gadget.Event.SHOW_LOADING_SCREEN);
    }
  }
});

/**
 * Listen for events that hide the loading screen
 */
nike.listen([nike.EVENT_GADGET_LOADED,
             nike.EVENT_LOAD_GADGET_FAIL,
             nike.Event.ADD_TO_CART_SUCCESS,
             nike.Event.ADD_TO_CART_FAIL,
             nike.Event.ADD_TO_CART_TIMEOUT,
             nike.Event.UPDATE_CART_ITEM_SUCCESS,
             nike.Event.UPDATE_CART_ITEM_FAIL,
             nike.Event.ADD_WISHLIST_ITEM_SUCCESS,
             nike.Event.ADD_WISHLIST_ITEM_FAIL], function(event, data){
  // Save reference to loading overlay
  if (data && data.gadgetName == 'nike.gadget.LoadingScreen'){
    nike.gadget.LoadingScreen.overlay = data.element.find('.loading-overlay');
    if(nike.gadget.LoadingScreen.showing) {
      nike.gadget.LoadingScreen.show();
    }
  }
  
  if (nike.gadgetListensTo(nike.gadget.LoadingScreen.overlay, data.element)){
    nike.dispatchEvent(nike.gadget.Event.HIDE_LOADING_SCREEN);
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.LoadingScreen. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Countries_Locales_Cookies');

nike.requireDependency('nike.Cart');
nike.requireDependency('nike.gadget.LoadingScreen');
nike.requireDependency('nike.geo.Util');

nike.Countries_Locales_Cookies = {};

function getSlugUrl(lParam){
	var piid ="";
	var slug ="";
	var pbid= "";
	var slugURL= "product/";
	var params = new Array();
	params= lParam.split("&");
	for(var i=0; i< params.length; ++i){
		if(params[i].indexOf("pbid") > -1){
			pbid = params[i].substring(params[i].indexOf("pbid") + 5,params[i].length);
		}else if(params[i].indexOf("piid") > -1){
			piid = params[i].substring(params[i].indexOf("piid") + 5,params[i].length);
		}else if(params[i].indexOf("slug") > -1){
			slug = params[i].substring(params[i].indexOf("slug") + 5,params[i].length);
		}
	}
	if(piid == "" && pbid == ""){
		slugURL = slugURL + slug+ "/";
	}else if(piid !== "" && pbid == ""){
		slugURL = slugURL + slug+ "/?piid="+ piid;
	}else{
		slugURL = slugURL + slug+ "/?piid="+ piid + "#?pbid="+pbid;
	}
	return slugURL;
}

nike.Countries_Locales_Cookies.setUSLocale = function(language, country, lParam) {

    country = country.toUpperCase();
    language = language.toUpperCase();
    var lang_locale = language.toLowerCase() + "_" + country;

    var storeURL = nike.getRootUrl()
    storeURL = storeURL + country.toLowerCase();
    storeURL = storeURL + "/";
    storeURL = storeURL + lang_locale.toLowerCase() + "/";
    if (lParam &&  lParam !== "" && lParam.indexOf("slug") == -1){
		storeURL = storeURL + "?l=" + lParam;
	} //Added for slug URLS
    else if(lParam && lParam !== ""){
    	storeURL = storeURL + getSlugUrl(lParam);
    }

    nike.Countries_Locales_Cookies.setUSCookie(country, language);
    nike.Countries_Locales_Cookies.redirectURL(storeURL);
};

nike.Countries_Locales_Cookies.redirectURL = function(storeURL) {
    if (typeof window.parent !== "undefined") {
        if (typeof window.parent.mainframeurl !== "undefined") {
            window.parent.location = storeURL;
            return
        }
    }
    window.location = storeURL;
};

nike.Countries_Locales_Cookies.setUSCookie = function(country, language) {
    var oldStore_locale = country + "_" + country + "_" + language;
    var cd = nike.Countries_Locales_Cookies.getCookieDomain();
    nike.Countries_Locales_Cookies.setCookie("locale", oldStore_locale, "/", cd);
    nike.Countries_Locales_Cookies.deleteCookie("EMEA_store_locale", "/", cd);
    nike.Countries_Locales_Cookies.deleteCookie("EMEA_store_country", "/", cd);
    nike.Countries_Locales_Cookies.setCountryLanguageCookie(language.toLowerCase(), country);

};

nike.Countries_Locales_Cookies.setCookie = function(name, value, path, domain) {
    var today = new Date();
    var expires = new Date();
    var curCookie;
    expires.setTime(today.getTime() + 3600000 * 24 * 365);
    curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") +
                ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "");
    document.cookie = curCookie;
};

nike.Countries_Locales_Cookies.deleteCookie = function(name, path, domain) {

    var today = new Date();
    var expires = new Date();
    var curCookie;
    expires.setTime(today.getTime() - (360000 * 24 * 365));
    curCookie = name + "=" + escape("") + ((expires) ? "; expires=" + expires.toGMTString() : "") +
                ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "");
    document.cookie = curCookie;

};

nike.Countries_Locales_Cookies.getCookieDomain = function () {
    var hostname = location.hostname;
    var hnIndexOf = "."+nike.ROOT_DOMAIN;
    if (hostname.indexOf(hnIndexOf) >= 0) {
        return hnIndexOf;
    }
    else {
        return "";
    }

};

nike.Countries_Locales_Cookies.deleteAllCookies = function() {
    nike.Countries_Locales_Cookies.deleteCookie("locale", "/", nike.Countries_Locales_Cookies.getCookieDomain());
    nike.Countries_Locales_Cookies.deleteCookie("EMEA_store_locale", "/",
            nike.Countries_Locales_Cookies.getCookieDomain());
    nike.Countries_Locales_Cookies.deleteCookie("EMEA_store_country", "/",
            nike.Countries_Locales_Cookies.getCookieDomain());
    nike.Countries_Locales_Cookies.deleteCookie("NIKE_COMMERCE_COUNTRY", "/",
            nike.Countries_Locales_Cookies.getCookieDomain());
    nike.Countries_Locales_Cookies.deleteCookie("NIKE_COMMERCE_LANG_LOCALE", "/",
            nike.Countries_Locales_Cookies.getCookieDomain());
};

nike.Countries_Locales_Cookies.setEMEALocale = function(language, country, lParam) {
    //console.log("SetEMEALocale");
    country = country.toUpperCase();
    language = language.toLowerCase();

    var lang_locale = "";

//    if (language == "en") {
//        lang_locale = "en_GB";
//    } else if (language == "es") {
//        lang_locale = "es_ES";
//    } else if (language == "de") {
//        lang_locale = "de_DE";
//    } else if (language == "fr") {
//        lang_locale = "fr_FR";
//    } else if (language == "it") {
//        lang_locale = "it_IT";
//    } else if (language == "zh") {
//        lang_locale = "zh_CN";
//    } else if (language == "ko") {
//        lang_locale = "ko_KO";
//    }

   lang_locale = nike.Countries_Locales_Cookies.setEMEACookie(country, language, lang_locale);
   var pth = ""+language+"_"+country;
    // when EMEA country is changed, shipping country needs to be updated

    nike.dispatchEvent(nike.gadget.Event.SHOW_LOADING_SCREEN);
//    nike.listen([nike.Event.UPDATE_SHIPPING_COUNTRY_SUCCESS, nike.Event.UPDATE_SHIPPING_COUNTRY_FAIL], doRedirect);
//    nike.Cart.updateShippingCountry(country, lang_locale);
    nike.geo.Util.redirectToLocale(country, pth, true);

    /**
     * Function to do the redirect after the shipping country is updated on the order
     */
    function doRedirect(){
      try{
    var storeURL = nike.getRootUrl();
    var isDomainSet = false;

    if (country == "CN") {
        storeURL = "http://www.nikestore.com.cn/";
        isDomainSet = true;
        nike.Countries_Locales_Cookies.deleteAllCookies()();
    } else if (country == "KO") {
        storeURL = "http://www.nikestore.co.kr/";
        isDomainSet = true;
        nike.Countries_Locales_Cookies.deleteAllCookies();
    } else if (country == "NO" || country == "CH") {
        // don't cookie these users
        nike.Countries_Locales_Cookies.deleteAllCookies();

        // send to nikeid.com
        //http://nikeid.nike.com/nikeid/index.jsp?sitesrc=NSLP_EN&channel=EMEA_NIKEID&region=EMEA&country=uk&language=uk

        var nikeid_country = country.toLowerCase();
        var nikeid_language;

        if (language == "en") {
            nikeid_language = "uk";
        }
        else {
            nikeid_language = language;
        }

        var nikeid_sitesrc = "NSLP_" + language.toUpperCase();

        storeURL = "";
        storeURL = storeURL + "http://nikeid.nike.com/nikeid/index.jsp";
        storeURL = storeURL + "?sitesrc=" + nikeid_sitesrc;
        storeURL = storeURL + "&channel=EMEA_NIKEID";
        storeURL = storeURL + "&region=EMEA";
        storeURL = storeURL + "&country=" + nikeid_country;
        storeURL = storeURL + "&language=" + nikeid_language;
        isDomainSet = true;
    }
    else {
        storeURL = storeURL + country.toLowerCase();
        storeURL = storeURL + "/";
            storeURL = storeURL + lang_locale.toLowerCase() + "/";

        if (lParam !== undefined) {
            if (lParam.search("nike.ugc.bazaarvoice.com") > 0) {
                lParam = lParam.replace("ctr-submitReview", "ctr-inline");
                lParam = lParam.substr(0, lParam.indexOf("&", 0));
            }
                if (lParam !== "" && lParam.indexOf("slug") == -1){
                	storeURL = storeURL + "?l=" + lParam;
            }// Added for slug URLS
                else if(lParam !== ""){
                	storeURL = storeURL + getSlugUrl(lParam);
            }
        }
    }

    var cDomain = document.domain;
    var cURL = "";

    if (!isDomainSet) {
        if (storeURL.indexOf("http://") >= 0) {
            cURL = storeURL;
        }
        else {
            cURL = "http://" + cDomain + storeURL;
        }
    }
    else {
        cURL = storeURL;
    }


    nike.Countries_Locales_Cookies.redirectURL(cURL);

      } catch (ex){
        nike.dispatchEvent(nike.gadget.Event.HIDE_LOADING_SCREEN);
      }


    }
};

nike.Countries_Locales_Cookies.setEMEACookie = function(country, language, lang_locale) {
    var cd = nike.Countries_Locales_Cookies.getCookieDomain();
    nike.Countries_Locales_Cookies.setCookie("EMEA_store_locale", lang_locale, "/", cd);
    nike.Countries_Locales_Cookies.setCookie("EMEA_store_country", country, "/", cd);
    nike.Countries_Locales_Cookies.deleteCookie("locale", "/", cd);
    lang_locale = nike.Countries_Locales_Cookies.setCountryLanguageCookie(language.toLowerCase(), country);
    return lang_locale;
};

nike.Countries_Locales_Cookies.setCountryLanguageCookie = function(language, country) {

    country = country.toUpperCase();
    language = language.toLowerCase();
    var lang_locale = "";

    if (country == "US") {
        lang_locale = "en_US";
    } else if (country == "AT") {
        lang_locale = "de_DE";
    } else if (language == "es") {
        lang_locale = "es_ES";
    } else if (language == "de") {
        lang_locale = "de_DE";
    } else if (language == "fr") {
        lang_locale = "fr_FR";
    } else if (language == "it") {
        lang_locale = "it_IT";
    }
    else {
        lang_locale = "en_GB";
    }

    if (country == "EMEA" || language == "emea") {
        country = "NL";
        lang_locale = "en_GB";
    }

    var cd = nike.Countries_Locales_Cookies.getCookieDomain();
    if (country != "NO" && country != "CH") {
        nike.Countries_Locales_Cookies.setCookie("NIKE_COMMERCE_LANG_LOCALE", lang_locale, "/", cd);
        nike.Countries_Locales_Cookies.setCookie("NIKE_COMMERCE_COUNTRY", country, "/", cd);

        var consumerChoice = nike.Countries_Locales_Cookies.buildConsumerChoiceCookie(country, lang_locale);
        nike.Countries_Locales_Cookies.setCookie("CONSUMERCHOICE", consumerChoice, "/", cd);
    }
    nike.Countries_Locales_Cookies.setSessionCookie("CONSUMERCHOICE_SESSION", "t", "/", cd);
    return lang_locale;
};

nike.Countries_Locales_Cookies.setSessionCookie = function(name, value, path, domain) {
    var curCookie;
    curCookie = name + "=" + escape(value) + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "");
    document.cookie = curCookie;
};

nike.Countries_Locales_Cookies.buildConsumerChoiceCookie = function(country, lang_locale) {
	return country.toLowerCase() + '/' + lang_locale.toLowerCase();
};

nike.Countries_Locales_Cookies.setLocale = function(href) {
    var vals = href.split("/");
    //FORCE LANG LOCALE BACK TO US
    var languageId = vals[vals.length - 2].split("_")[0].toLowerCase();//langId;
    var countryId = vals[vals.length - 3].toLowerCase();
    //console.log("sl: " + languageId + ' / ' + countryId);

    //if(countryId == "US") languageId = "EN";

    if (countryId == "us") {
        languageId = "en";
    }

    //console.log("setLocale.countryId:" + countryId);
    //console.log("setLocale.languageId:" + languageId);

    if (languageId == "en" && countryId == "us") {
        nike.Countries_Locales_Cookies.setUSLocale(languageId, countryId);
    }
    else {
        var pURL = "";
        //If US is not the previously selected country use the previous hash in the new country/language

        var urlType = "search", path, substring = 3;
        if ($.browser.msie && window.location.hash.length > 0) {
        	urlType = "hash";
        	substring = 4;
        }
        //path = window.location[urlType].substr(substring);
        path = window.location[urlType].split("?l=")[1];

        //console.log("URL: " + path);

        if (nike.COUNTRY != "US") {
            if (path != null && path != undefined && path != "") {
                pURL = path;
            }
            else {
                pURL = "shop,home";
            }
            pURL = unescape(pURL);
            //console.log("setLocale()pURL=1 " + pURL);
        }
        else {
            //console.log("setLocale()pURL=2 " + pURL);
            pURL = "shop,home";
        }
        nike.Countries_Locales_Cookies.setEMEALocale(languageId, countryId, pURL);
    }

};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Countries_Locales_Cookies. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.geo.Locate');
/*
 * Geo-locates the user based on the nike.geo.Edgescape data and gets them to the correct country/language
 * combination according to the Crazy Geo Requirements Matrix (CGRM).
 *
 * A note about verbiage in this file.  References to "language" indicate a lang_locale combination is
 * required.  References to "locale" indicate a combination of country and lang_locale.
 */
nike.requireDependency('nike.geo.Configuration');
nike.requireDependency('nike.Event');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.util.StringUtil');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('nike.geo.Edgescape');
nike.requireDependency('nike.geo.CookieData');
nike.requireDependency('nike.geo.Util');
nike.requireDependency('nike.Countries_Locales_Cookies');


(function(){
    // If this fires an event, it will be stored here in case something needs it but isn't listening yet
    nike.geo.firedEvents = {};

    /**
     * This is used on Desktop (for now), when the GeodetectNotifier is open.
     * It helps us block the CookieSettingsManager from opening over the top
     * of it.
     * @type {boolean}
     */
    nike.geo.geodetectNotifierIsOpen = false;

    var PrivateClosure = {

        /**
         * Holds the user's country code according to their IP address.
         * The language field is always null.
         */
        ipData : { country : null , language : null },

        /**
         * Holds the country and language included in the URL as query
         * string parameters.
         */
        urlData : { country : null , language : null },

        /**
         * Holds the country and language identified in the Nike
         * Commerce Cookie.
         */
        commerceData : { country : null , language : null },

        /**
         * Holds the country and language, if any, that the user
         * has explicitly chosen from some kind of language selector.
         */
        consumerChoiceData : { country : null , language : null },

        /**
         * Holds the country and language that has been detected by the system
         * after going through the geo-location process.  It's used as a
         * short circuit so we don't waste time going through this
         * process more than once per user.
         */
        detectedData : { country : null , language : null },

        /**
         * A true or false value indiciating whether or not the user has
         * explicitly selected a country/language combination during
         * the current browser session.
         */
        consumerChose : false,

        /**
         * A simple array containing (currently) EU expansion countries for use in
         * selectively invalidating lang/locale cookies. This is used when we
         * roll out new languages, so that customers are given the option to select from one
         * the new languages.
         */
        expansionCountries : ['PL', 'BE', 'NL', 'ES'],

        /**
         * Whether or not the user is on the language tunnel page already.
         */
        onLangTunnelPage: /language_tunnel/.test(location.href),

        /**
         * Initialize private fields, sanitizing the data.
         */
        init : function() {
            // We want the ip country whether or not it's supported
            this.ipData.country = nike.geo.Edgescape.country;

            if (nike.geo.Configuration.isSupported(nike.COUNTRY)) {
                this.urlData.country = nike.COUNTRY;
            }

            if (nike.geo.Configuration.isSupported(nike.geo.CookieData.commerce.country)) {
                this.commerceData.country = nike.geo.CookieData.commerce.country;
            }

            if (nike.geo.Configuration.isSupported(nike.geo.CookieData.consumerChoice.country)) {
                this.consumerChoiceData.country = nike.geo.CookieData.consumerChoice.country;
            }

            if (nike.geo.Configuration.isSupported(nike.geo.CookieData.sessionDetected.country)) {
                this.detectedData.country = nike.geo.CookieData.sessionDetected.country;
            }

            this.urlData.language = nike.LOCALE;
            this.commerceData.language = nike.geo.CookieData.commerce.language;
            this.consumerChoiceData.language = nike.geo.CookieData.consumerChoice.language;
            this.detectedData.language = nike.geo.CookieData.sessionDetected.language;
            this.consumerChose = nike.geo.CookieData.consumerChose;
        },



        /**
         * Check if the consumer choice data exists and whether any action needs to happen based
         * on that data, then execute that action.
         *
         * @returns {Boolean} true if some action was taken based on the consumer choice cookie (including just verifying that it
         *     exists and is valid) or false if there was not enough information to take action.
         */
        handledConsumerChoiceAction : function() {
            if (this.consumerChose && this.consumerChoiceData.country && this.consumerChoiceData.language) {
                var urlCountry = this.urlData.country ? this.urlData.country.toLowerCase() : null;
                var urlLanguage = this.urlData.language ? this.urlData.language.toLowerCase() : null;

                var correctCountry = this.consumerChoiceData.country.toLowerCase();
                var correctLanguage = this.consumerChoiceData.language.toLowerCase();

                // If user is coming from an expansion country (country in which we are adding additional languages)
                // then we will want to invalidate their lang/locale cookies so they are given the option of
                // choosing the new language.
                if (urlCountry && ($.inArray(urlCountry.toUpperCase(), this.expansionCountries) != -1) ){
                  this.checkCCRCookie();
                }

                // Double-check that the consumer choice values are compatible with the current configuration
                if (correctCountry && correctLanguage && !nike.geo.Configuration.isSupportedLanguage(correctCountry, correctLanguage)) {
                    correctLanguage = this.determineLanguage(correctCountry);
                }

                if(
                  (correctCountry !== urlCountry || correctLanguage !== urlLanguage)
                  && !this.onLangTunnelPage
                ){

                    nike.debug("Found need to redirect based on consumer choice: "+correctCountry+"/"+correctLanguage);

                    // exclude these from redirecting
                    var excludedHosts = /(^help-|-help\.nike|secure-nikeplus)/;
                    var excludedPages = /^\/events-registration/;

                    if(
                      !location.host.match(excludedHosts)
                      && !location.pathname.match(excludedPages)
                    ){
                      // The "Consumer Decided" cookie is already set so we don't need to pass true, but just to be safe and clear...
                      nike.geo.Util.redirectToLocale(correctCountry, correctLanguage, true, 0, nike.geo.Util.getReturnPath() || nike.geo.Util.getPathWithoutLocale());
                    }
                } else {
                    nike.debug("Consumer choice scenario is a match. No need to redirect.");
                }

                // Whether or not a redirect happened, the fact that the cookie values and urls were set indicates TRUE is appropriate
                return true;
            }
            // For users with no cookies, we want to set the NIKE_COMMERCE_CCR so that they aren't accidentally
            // redirected to the language tunnel. See: EDF-28089
						$.CookieUtil( "NIKE_COMMERCE_CCR", Date.now(),
              { expires: 365,
                path: '/',
                domain: nike.Countries_Locales_Cookies.getCookieDomain()
              });
            nike.debug("Not enough information to locate the user based on consumer choice data.");

            // Not enough data to make a decision
            return false;
        },

        /**
         * Check if the geo detected session data exists and whether any action needs to happen based
         * on that data, then execute that action.
         *
         * @returns {Boolean} true if some action was taken based on the geo detected session cookie (including just verifying that it
         *     exists and is valid) or false if there was not enough information to take action.
         */
        handledSessionDetectedAction : function() {
            if (this.detectedData.country && this.detectedData.language && this.urlData.country && this.urlData.language) {
                // Make sure they're all the same case before comparing
                var dCountry = this.detectedData.country.toLowerCase();
                var dLanguage = this.detectedData.language.toLowerCase();
                var urlCountry = this.urlData.country.toLowerCase();
                var urlLanguage = this.urlData.language.toLowerCase();

                // Here we can only confirm that the data is as expected but can't take any action
                // If there is a mismatch, they'll have to run through the geo locate process
                if (dCountry === urlCountry && dLanguage === urlLanguage && nike.geo.Configuration.isSupportedLanguage(dCountry, dLanguage)) {
                    nike.debug("User has previously been detected in this lang/locale combination. Success.");
                    /*
                     * EDF-26525: check to see if a consumer choice cookie is present, if not use the detected data to set one.
                     * This avoid an issue in Mobile where the lack of a CONSUMERCHOICE cookie makes the cart go to the gb locale
                     */
                    if(this.consumerChoiceData.country == null && this.consumerChoiceData.language == null){
                      nike.debug("setting consumer choice cookie using the detected lang/locale combination: ", dLanguage +", "+dCountry);
                      nike.geo.Util.updateConsumerChoiceLocale(dCountry, dLanguage);
                    }
                    return true;
                }
            }
            else if(!this.urlData.country && this.detectedData.country && this.detectedData.language && !this.onLangTunnelPage){
              nike.debug('User is at a URL without a country but has been detected at: '+this.detectedData.country+' language: '+this.detectedData.language);
              nike.geo.Util.redirectToLocale(this.detectedData.country, this.detectedData.language, true, 0, nike.geo.Util.getReturnPath() || nike.geo.Util.getPathWithoutLocale());
              return true;
            }
            nike.debug("This user has not been previously geo detected or the detected locale is different from the current URL.");

            // Not enough data to make a decision
            return false;
        },

        /**
         * Determine if the user is supposed to be and redirect them to it if so.
         *
         * @return true if the user needs to be at the language tunnel and false otherwise.
         */
        handledLanguageTunnelAction : function() {
            var cookieCountry = this.commerceData.country;
            var urlCountry = this.urlData.country;
            var ipCountry = nike.geo.Configuration.resolveNikeCountry(this.ipData.country);

            if(
              !cookieCountry && !urlCountry && !ipCountry
              && !this.onLangTunnelPage
            ){

                var path = nike.geo.Util.getPathWithoutLocale();
                if (path) {

                    // check if the return path was explicitly passed in already
                    if (nike.geo.Util.getReturnPath()) {
                        var param = path;
                    } else {

                    	// Add the ref parameter if it doesn't already exist
                        var ref = nike.util.UrlUtil.getExternalReferrer();
                        if (ref && ref != '') {
                            path = nike.util.UrlUtil.addParameter(path, 'ref', encodeURIComponent(ref));
                        }

                        var flh = nike.geo.Util.FINAL_LANDING_HOST_KEY_WWW;
                        if (nike.geo.Util.isStoreDomain(''+window.location)) {
                        	flh = nike.geo.Util.FINAL_LANDING_HOST_KEY_NIKESTORE;
                        }
                        var param = 'flh='+flh+'&flp='+encodeURIComponent(path);
                    }
                }

                nike.debug("Redirecting user to the language tunnel.");
                nike.geo.Util.redirectToLanguageTunnel(param);
                return true;
            }

            nike.debug("The user does not need to visit the language tunnel based on their geo information.");
            return false;
        },

        /**
         * Determine if the user should be redirected to a different country/lang_locale combination
         * and redirect them if so.
         *
         * In general we redirect when we detected the user previously shopped in a different country and Akamai confirms
         * that they're not in the country the URL says.  Or if there isn't a url in the country or cookie, we'll use
         * Akamai as a best guess.
         *
         * @return false if the user hasn't been redirected to another country/lang_locale combination.
         */
        handledCountryRedirect : function() {
            var cookieCountry = this.commerceData.country;
            var urlCountry = this.urlData.country;
            var correctLanguage = null;
            var correctCountry = null;

            var redirectLocale = false;
            var redirectLangTunnel = false;

            if(nike.geo.Configuration.isSupportedLanguage(urlCountry, this.urlData.language)){
              nike.debug("Country is set and language is supported...no need to redirect to a different country/language.");

            } else {

              if(urlCountry){
                // We have a valid country, but the language is wrong.
                nike.debug("Current language is not supported for current country. Redirecting to correct language.");
                correctCountry = urlCountry;
              } else {
                // No country in url...figure out the country based on the cookie or geo-detection
                if (cookieCountry) {
                  correctCountry = cookieCountry;
                } else {
                  correctCountry = nike.geo.Configuration.resolveNikeCountry(this.ipData.country);
                }
              }


              if(correctCountry){
                correctLanguage = this.determineLanguage(correctCountry);
                redirectLocale = true;

              } else {
                nike.debug("No country is set and we can't detect a country to go to. This somehow slipped through the cracks...redirecting to language tunnel.");
                redirectLangTunnel = true;
              }
            }


            if( redirectLocale && !this.onLangTunnelPage ){
              nike.debug("Redirecting to a valid country/locale: "+correctCountry+"/"+correctLanguage);
              nike.geo.Util.redirectToLocale(correctCountry, correctLanguage, false, 0, nike.geo.Util.getReturnPath() || nike.geo.Util.getPathWithoutLocale());

            } else if ( redirectLangTunnel && !this.onLangTunnelPage ){
              nike.debug("No country is set and we can't detect a country to go to. This somehow slipped through the cracks...redirecting to language tunnel.");
              nike.geo.Util.redirectToLanguageTunnel();
            }

            return redirectLocale || redirectLangTunnel;
        },


        /**
         * Determine if the user needs to be shown a dialogue asking whether they would like to switch to another country,
         * and then fire the event that shows that dialogue if so, returning true.
         *
         * This function assumes the URL country is valid because if it isn't, it should have been taken care of in a
         * previous function call.
         *
         */
        handledCountryChangePrompt : function() {
            var cookieCountry = this.commerceData.country;
            var urlCountry = this.urlData.country;
            var urlLanguage = this.urlData.language;
            var ipCountry = null;
            var parentContext = this;

            if (nike.geo.Configuration.isSupported(this.ipData.country)) {
                ipCountry = nike.geo.Configuration.resolveNikeCountry(this.ipData.country);
            }

            var countryPrompt = null;

            if (cookieCountry && !nike.util.StringUtil.equalsIgnoreCase(cookieCountry, urlCountry)) {
                countryPrompt = cookieCountry;
            } else if (ipCountry && !nike.util.StringUtil.equalsIgnoreCase(ipCountry, urlCountry)) {
                countryPrompt = ipCountry;
            }

            if (countryPrompt) {
                // The user is here for now, we need to make sure their cookies are right in case they stay here
                nike.geo.Util.updateUserLocaleSettings(urlCountry, urlLanguage);

                nike.debug("User should be prompted to change country to "+countryPrompt);

                $(document).ready(function(){
                  var eventObject = parentContext.buildCompareEventObject(urlCountry, countryPrompt);
                  nike.dispatchEvent(nike.Event.LOAD_COUNTRY_COMPARE, eventObject);
                  nike.geo.firedEvents[nike.Event.LOAD_COUNTRY_COMPARE] = eventObject;
                });

                return true;
            }

            nike.debug("Not prompting the user to change countries.");
            return false;
        },

        /**
         * Figure out the correct language to direct the user to based on their country.
         * Examines the consumer choice cookie, commerce cookie, url param, and then the default
         * configuration to make the decision.
         */
        determineLanguage : function(country) {
            var language = null;

            if (nike.geo.Configuration.isSupportedLanguage(country, this.consumerChoiceData.language)) {
                language = this.consumerChoiceData.language;
            } else if (nike.geo.Configuration.isSupportedLanguage(country, this.commerceData.language)) {
                language = this.commerceData.language;
            } else if (nike.geo.Configuration.isSupportedLanguage(country, this.urlData.language)) {
                language = this.urlData.language;
            } else {
                language = nike.geo.Configuration.getDefaultLanguage(country);
            }
            return language;
        },


        /**
         * Determines whether geo detection is supported for the current user agent.
         */
        unsupportedAgent : function() {
            // Currently the only unsupported agent is a search bot
            return this.botAccess();
        },

        /**
         * Determine if the page/site is accessed by "bot".
         */
        botAccess : function() {
          var botRegEx = new RegExp("spider|crawl|slurp|bot", "i");
          var userAgent = navigator.userAgent;
          var spCookie = jQuery.CookieUtil("sp");
          return (userAgent.match(botRegEx) || (spCookie && spCookie.match(botRegEx)));
        },

        /**
         * Build an object with the fields the nike.Event.LOAD_COUNTRY_COMPARE event parameter is expecting.
         */
        buildCompareEventObject : function(currentCountry, countryOption) {
            return { 'data' : { 'original_country' : currentCountry.toUpperCase(), 'compare_country' : countryOption.toUpperCase() }};
        },

        /**
         * EU Expansion Logic:
         * This method will check the NIKE_COMMERCE_CCR cookie to validate that it is set and is a valid timestamp.
         * If it is not set to a valid timestamp, we will redirect the user to the Language Tunnel so that they
         * are given the option to select a new language for their country.
         */
        checkCCRCookie : function () {
          var ccrCookie = $.CookieUtil("NIKE_COMMERCE_CCR");
          var date = new Date(parseInt(ccrCookie));
          var params = {};
          var path = nike.geo.Util.getPathWithoutLocale();

          if (path){
            params.flp = path;
            params.flh = location.hostname.match(/store/) ? nike.geo.Util.FINAL_LANDING_HOST_KEY_NIKESTORE : nike.geo.Util.FINAL_LANDING_HOST_KEY_WWW;
          }
          params.loc = this.urlData.country;
          params = $.param(params);

          if( date == "Invalid Date" && !this.onLangTunnelPage ){
            nike.geo.Util.redirectToLanguageTunnel(params);
          }
        }
    };

    nike.geo.Locate = function() {

        //     (   )     WARNING - This is a particularly ugly area of our codebase. The code that you see below
        //  (   ) (      was modified (namely the nike.geo.Locate.hasCompleted statements) to address
        //   ) _   )     a particularly nasty bug (EDF-28528) in which the call to ATG's getCartSummary method
        //    ( \_       was causing an infinite redirect between locales because they are overriding all of our
        //  _(_\ \)__    locale cookies, making the logic in this script fail. All of this is going to be refactored
        // (____\___))   in the near future.

        // setup private fields
        PrivateClosure.init();

        nike.debug("Initializing geo location");
        nike.debug("URL data: "+PrivateClosure.urlData.country+"/"+PrivateClosure.urlData.language);
        nike.debug("Consumer Choice data: "+PrivateClosure.consumerChoiceData.country+"/"+PrivateClosure.consumerChoiceData.language+" "+PrivateClosure.consumerChose);
        nike.debug("Commerce data: "+PrivateClosure.commerceData.country+"/"+PrivateClosure.commerceData.language);
        nike.debug("IP data: "+PrivateClosure.ipData.country+"/"+PrivateClosure.ipData.language);
        nike.debug("Detected data: "+PrivateClosure.detectedData.country+"/"+PrivateClosure.detectedData.language);

        nike.debug(nike.geo.Edgescape);
        nike.debug(nike.geo.CookieData);
        nike.debug(nike.geo.Configuration);

        /**
         *
         * The order of these is really important. Some functions rely on cases having been handled
         * in previous function calls.  Don't change the order of the following calls unless the
         * requirements change and you know the implications of the changes you're making.
         *
         */

        if (PrivateClosure.unsupportedAgent()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        else if (PrivateClosure.handledConsumerChoiceAction()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        else if (PrivateClosure.handledSessionDetectedAction()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        else if (PrivateClosure.handledLanguageTunnelAction()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        else if (PrivateClosure.handledCountryRedirect()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        else if (PrivateClosure.handledCountryChangePrompt()) {
            nike.geo.Locate.hasCompleted = true;
            return;
        }

        nike.debug("Setting the user's detected country/language to "+PrivateClosure.urlData.country+"/"+PrivateClosure.urlData.language+" and leaving them alone.");

        // The user has been detected to be in the right place by default
        nike.geo.Util.updateUserLocaleSettings(PrivateClosure.urlData.country, PrivateClosure.urlData.language, false);
        nike.geo.Locate.hasCompleted = true;
    };



}());

nike.geo.Locate();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.geo.Locate. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.ImageUtil');

nike.requireDependency('lib.lodash');

/**
 * Builds image URLs
 */
nike.ImageUtil = _.extend(nike.ImageUtil, {

  /**
   * All properties used to generate image URLs
   * with some defaults set
   */
  defaultProps: {
      appName:nike.DEFAULT_APP_NAME,
      style:undefined,
      styleNumber:undefined,
      color:undefined,
      templatePath:'THN_PM/',
      imagePath:undefined,
      view:'A',
      extension:'jpg',
      format:'jpg',
      presetPrefix:  ( nike.exp.script.device_detect.isMobile() ) ? 'NIKE_M' : 'NIKE'
  },

  /**
   * Build the image URL for an inline product
   *
   * @param properties Properties requried to build a URL
   * @return Fully qualified image URL
   */
  getInlineImageUrl: function(properties, removeQueryParams){
    var imageArgs;
    var color='';
    var setQueryParams = true;
    if(removeQueryParams){
      setQueryParams = false;
    }
    var props = _.extend({}, this.defaultProps, properties);
    //set the color to be use
    if (props.color!=undefined){
     color = props.color;
    }
    var imageUrl = nike.getServiceUrl('baseImageURL');
    imageUrl += props.templatePath + '-' +
      props.style + '_' +
      color + '.' +
      props.extension;

    // Get query params params
    if(setQueryParams){
      imageArgs = this.buildImageArgs(props);
      if (imageArgs.length > 0){
        imageUrl += '?' + imageArgs
      }
    }

    return imageUrl;
  },


  /**
   * Build a string of image args that can be
   * added to the query string
   */
  buildImageArgs: function(properties){
    var props = [];

    if (properties.format){
      props.push('fmt=' + properties.format);
    }
    if (properties.height){
      props.push('hei=' + properties.height);
    }
    if (properties.width){
      props.push('wid=' + properties.width);
    }

    return props.join('&');
  },

  /**
  * Build the image URL for an inline product
  *
  * @param properties Properties requried to build a URL
  * @return Fully qualified image URL
  */
  getGridwallImageUrl : function(properties) {
      var color='';
      var imageUrl = undefined;
      var props = _.extend({}, this.defaultProps, properties);
      //set the color to be use
      if (props.color!=undefined){
          color = props.color;
      }

      props.templatePath = nike.ImageUtil.getTemplatePath(props.nikeType.toUpperCase());

      if(properties.isSecure === true){
        imageUrl = nike.getServiceUrl('secureBaseImageURL');
      }

      if(imageUrl === undefined) {
        imageUrl = nike.getServiceUrl('baseImageURL');
      }

      imageUrl += props.styleNumber + '_' +
                  color + '?$' +
                  props.presetPrefix +
                  props.templatePath + '$';

      return imageUrl;
  },

  getNikeIdImageUrl: function(properties){
        var props = _.extend({}, this.defaultProps, {extension: 'tif'}, properties);
        var imageUrl = undefined;

        if(properties.isSecure === true){
          imageUrl = nike.getServiceUrl('secureBaseNikeIdS7ImageURL');
        }

        if(imageUrl === undefined) {
          imageUrl = nike.getServiceUrl('baseNikeIdS7ImageURL');
        }

        props.templatePath = nike.ImageUtil.getTemplatePath(props.nikeType.toUpperCase());

        imageUrl += 'ugc/' + props.styleNumber + '.' +
                    props.extension + '?$' + props.presetPrefix + props.templatePath + '$';

        return imageUrl;
  },

  getTemplatePath : function(type) {
    var nikeType = [];
    nikeType['FOOTWEAR'] = '_PWP_GRAY';
    nikeType['APPAREL'] = '_PWP_GRAY';
    nikeType['EQUIPMENT'] = '_PWP_GRAY';
    nikeType['ACCESSORY'] = '_PWP_GRAY';
    nikeType['NIKEID'] = '_PWP_FTWR_GRAY';
    nikeType['SHOES'] = '_PWP_FTWR_GRAY';
    nikeType['CLOTHING'] = '_PWP_GRAY';
    nikeType['GEAR'] = '_PWP_GRAY';
    nikeType['UNKNOWN'] = '_PWP_FTWR_GRAY';
    nikeType[''] = '_PWP_FTWR_GRAY';

    return nikeType[type] ? nikeType[type] : '_PWP_GRAY';
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.ImageUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}



try{
var nike = nike || {};
/*
 * jQuery MD5 Plugin 1.2.1
 * https://github.com/blueimp/jQuery-MD5
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://creativecommons.org/licenses/MIT/
 * 
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jslint bitwise: true */
/*global unescape, jQuery */

nike.namespace('jQuery.md5');
nike.requireDependency('jQuery');

(function ($) {
    'use strict';

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;                        
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }
    
    $.md5 = function (string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            } else {
                return raw_md5(string);
            }
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        } else {
            return raw_hmac_md5(key, string);
        }
    };
    
}(typeof jQuery === 'function' ? jQuery : this));
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.md5. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.analytics.TrackingConfigUtil');

nike.requireDependency('Array');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.util.UrlUtil');

/**
 * Debug logging function
 */  
nike.analytics.TrackingConfigUtil.isDebugEnabled = false;

nike.analytics.TrackingConfigUtil.debug = function(){
  if(nike.analytics.TrackingConfigUtil.isDebugEnabled){
    nike.debug.apply(this, arguments);
  }
};



/**
 * Dynamic element parsing functions
 */


/*********************************************
 * Functions to find dynamic values for tags
 *********************************************/

/**
 * Find the data elements on the page that we need for dynamic data
 * 
 * @param dataElements list of data elements to look for
 * @param eventData the data element from the event that triggered this tag.  If it wasn't an event, it will be undefined.
 * @param caller A reference to the trackData object created for this tag.  This is to ensure that the event only gets handled by
 *   the caller.
 * @param maxTimeout The max amount of time we are willing to wait for dynamic data.  If it takes longer, we will just return
 *   whatever we have and send the tag.  Additionally tagTimedOut will be set to true on the dynamicElements.                           
 */
nike.analytics.TrackingConfigUtil.findPageElements = function (dataElements, eventData, caller, maxTimeout, waitForData){
  var i;
  var dynamicElements = {data: {}, 'caller' : caller, 'tagTimedOut' : false }; 
  var fallBackTimeout;
  var debug = nike.analytics.TrackingConfigUtil.debug;
  var allGadgets;
  var waitingGadgets = [];
  // @Todo ggranum: Just saw this; oh dear.
  if(waitForData == undefined){
    waitForData = true;
  }

  //Fire data ready immediately if there is not dynamic data to find
  if(dataElements === undefined || dataElements.length == 0){
    fireDataReadyEvent();
    
  } else {
  
  
    //Setup gadget loaded event listener so we can detect when any gadgets are loaded
    nike.listen(nike.EVENT_GADGET_LOADED, gadgetLoadedHandler);
    
    //Setup timeout in case this takes too long
    fallBackTimeout = setTimeout(tagTimedOut, maxTimeout);
  
    
    //Do initial check for dynamic data that is already loaded
    findDynamicDataOnPage();
    
    // If we have all of our data, fire the data ready event 
    // (we only check gadgets, because we expect elementId's to be there when we check the dom)
    if(waitingGadgets.length == 0){
      fireDataReadyEvent();
    }
  }
  
  
  /**
   * Search elements on page and see if we can resolve any of the dynamic data
   */
  function findDynamicDataOnPage(){
    var trackingConfigUtil = nike.analytics.TrackingConfigUtil;
    var i;
    var L;
    var dataElement;

    debug('findDynamicDataOnPage - dataElements: ', dataElements);
    for(i = 0, L = dataElements.length; i < L; i ++){
      dataElement = dataElements[i];
      debug('findDynamicDataOnPage - dataElement: ', dataElement);
      if(dataElement.gadget && dataElement.gadget.length > 0){
        debug('finding gadget: ', dataElement.gadget);
        findGadget(dataElement.gadget, dataElement.alias);
        
      } else if (dataElement.elementId && dataElement.elementId.length > 0){
        debug('finding element: ', dataElement.elementId);
        findElementById(dataElement.elementId, dataElement.alias);
        
      } else if (dataElement.eventData !== undefined && dataElement.eventData == true ){
        debug('settingEvent: ', eventData);
        dynamicElements.data[dataElement.alias] = eventData;
        
      } else if (dataElement.urlData !== undefined && dataElement.urlData == true){
        debug('setting url');
        dynamicElements.data[dataElement.alias] = trackingConfigUtil.parseUrlData();
        
      } else if (dataElement.objectName !== undefined && dataElement.objectName.length > 0){
        //If object is defined, set it in dynamic elements
        dynamicElements.data[dataElement.alias] = nike.objectDefined(dataElement.objectName, nike.global, true);
        
      } else if (dataElement.cacheBuster !== undefined && dataElement.cacheBuster == true){
        //Generate random number.  This is intended to be used as a cachebuster to ensure requests are not cached
        //Let's do a 13 digit random number.
        dynamicElements.data[dataElement.alias] = Math.floor(Math.random() * Math.pow(10,13))
      } else if (dataElement.localStorage == true){
          var storeKey = 'analyticsData';
          debug('getting local storage data');
          dynamicElements.data[dataElement.alias] = trackingConfigUtil.getLocalData(storeKey);
      } else if (dataElement.userData === true) {
          debug('getting user data');
          dynamicElements.data[dataElement.alias] = nike.analytics.Tracking.userData;
      } else if (dataElement.cookieData === true) {
        debug('getting cookie data');
        dynamicElements.data[dataElement.alias] = getCookieMap();
      }
    }
    
    function findGadget(gadgetName, alias){
      var gadget;
      
      //Only get all the gadgets once
      if(allGadgets === undefined){
        allGadgets = nike.findAllGadgets();
      }
      
      gadget = allGadgets.filter('[data-gadget="' + gadgetName + '"]');
      if(gadget.length == 0){
        //Gadget not found on page, throw a warning and add it as undefined
        nike.warn("gadget not found on page: ", gadgetName);
        dynamicElements.data[alias] = undefined;
        
      } else if (!nike.isGadgetLoaded(gadget) && waitForData){
        //Gadget not loaded yet, so add it to the list of waiting gadgets
        waitingGadgets.push({gadgetName: gadgetName, alias: alias});
        
      } else {
        //Gadget was found, so add it to the dynamicElements list
        dynamicElements.data[alias] = gadget.data();
      }
    }
    
    function findElementById(elementId, alias){
      var element;
      
      element = $('#' + elementId);
      
      if(element.length != 0 && element.data()){
        //Element found and it has data, add it to dynamicElements.data 
        dynamicElements.data[alias] = element.data().trackingData;
        
      } else {
        //Element not found, add it as undefined
        nike.warn("element not found on page: ", elementId);
        dynamicElements.data[alias] = undefined;
      }
    }

    function getCookieMap() {
      var cookieData = {};
      if (document.cookie && document.cookie !== '') {
        var cookies = document.cookie.split(';');
        $.each(cookies,
            function (name, value) {
              var cookie = $.trim(value);
              var cookieName = $.trim(cookie.substring(0, cookie.indexOf('=')));
              cookieData[cookieName] = $.trim(decodeURIComponent(cookie.substring(cookie.indexOf('=') + 1)));
            });
      }
      return cookieData;
    }
        
  }
  

  /**
   * Function to run if we are taking to long finding dynamic data
   */
  function tagTimedOut(){
    debug("Tag Timed out.  Sending with whatever we have");
    dynamicElements.tagTimedOut = true;
    
    //Check the page elements one last time before moving on
    findDynamicDataOnPage();
    
    fireDataReadyEvent();
  }
  
  function fireDataReadyEvent(){
    clearTimeout(fallBackTimeout); //Clear the timeout
    nike.unlisten(nike.EVENT_GADGET_LOADED, gadgetLoadedHandler); //Unlisten to the event
    //Fire dynamicData ready event
    debug('Resolved page elements: ', dynamicElements);
    nike.dispatchEvent(nike.Event.TRACKING_DYNAMIC_DATA_READY, dynamicElements);
  }
  
  /**
   * Handler for gadget loaded events
   * This will check the element that was loaded to see if it has dynamic data we are interested in, 
   * and if it does, we will add it's tracking data to the dynamicElements object
   */
  function gadgetLoadedHandler(event, data){
    var i;
    var L;
    var gadget;
    var indexesToRemove = [];
    
    debug('GadgetLoaded for ' + data.gadgetName);
    
    //Check if gadget name is one we are interested in - if so, add it to the dynamic elements and remove if from the list of gadget names
    for(i = 0, L = waitingGadgets.length; i < L; i++){
      gadget = waitingGadgets[i];
      if(gadget.gadgetName == data.gadgetName){
        //Found element - don't break here because the same element could have multiple aliases
        dynamicElements.data[gadget.alias] = data.element.data().trackingData;
        indexesToRemove.push(i);
      }
    }
    
    for(i = indexesToRemove.length - 1; i >= 0; i--){
      waitingGadgets.splice(i, 1);
    }

    if(waitingGadgets.length == 0){
      fireDataReadyEvent()
    }
  }
};


/**
 * Url functions
 */
nike.analytics.TrackingConfigUtil.parseUrlData = function(){
  
  var loc = nike.analytics.TrackingConfigUtil.getCurrentAnalyticLocation();
  var util = nike.util.UrlUtil;
  var url = {
    host: loc.host,
    path: loc.pathname,
    protocol: loc.protocol,
    query: loc.search, 
    hash: loc.hash,
    params: {},
    referrer: util.getExternalReferrer(),
    url: loc.href
  };

  util.parseUrlParams(url.query, url.params);
  util.parseUrlParams(url.hash, url.params);
  return url;
};

/**
 * @returns {Location} The location that should be used to determine the current analytic page name
 */
nike.analytics.TrackingConfigUtil.getCurrentAnalyticLocation = function () {
  var nikeDomainTest = /\.nike(dev)?\.com/i;
  if (top == window) {
    return window.location;
  } else {
    // We are in an iframe
    if (parent == top) {
      try {
        if (nikeDomainTest.test(top.location.hostname)) {
          return top.location;
        } else {
          return window.location;
        }
      } catch (exp) {
        // permission errors, use the window
        return window.location;
      }
    } else {
      // We are really deep in iframes
      var curr = self;
      var valid = curr;
      while (curr != top) {
        try {
          if (nikeDomainTest.test(curr.location.hostname)) {
            valid = curr;
          }
        } catch (exp) {
          // Permission errors
          break;
        }
        // Try the next one
        curr = curr.parent;
      }
      return valid.location;
    }
  }
};

/***********************************
 * Do value replacement
 ************************************/
nike.analytics.TrackingConfigUtil.replaceValues = function (params, dynamicElements){
  var debug = nike.analytics.TrackingConfigUtil.debug;
  
  //Replace all the params using the dynamic elements
  doParamReplace(params);
  
  function doParamReplace(params){
    var i;
    var L;
    var paramObj;
    
    if(params instanceof Array){
      //Handle arrays (trackElements)
      if(params.length > 0){
        for(i = 0, L = params.length; i < L; i++){
          //If this is an array of strings, do the replace here so we can ensure the new string is placed in the array
          if(typeof(params[i]) == 'string'){
            params[i] = replaceDynamicValues(params[i]);
          } else {
            paramReplaceHelper(params[i]);
          }
        }
      }
    } else {
      //Handle non array objects (params)
      for(paramObj in params){
        if(params.hasOwnProperty(paramObj)){
          paramReplaceHelper(params[paramObj]);
        }
      }
    }
    
    function paramReplaceHelper(trackParam){
      var conditionalIndex;
      var conditional;
      var i,L;
      //Replace conditionals
      if(trackParam.conditionals && trackParam.conditionals.length > 0){
        for(i=0,L=trackParam.conditionals.length; i < L; i++){
          conditional = trackParam.conditionals[i];
          conditional.leftArg = replaceDynamicValues(conditional.leftArg);
          conditional.rightArg = replaceDynamicValues(conditional.rightArg);
          conditional.arg = replaceDynamicValues(conditional.arg);
        }
      }

      if(trackParam.trackElements && trackParam.trackElements.length > 0){
        doParamReplace(trackParam.trackElements);
      } else if(trackParam.values && trackParam.values.length > 0) {
        doParamReplace(trackParam.values);
      } else if(trackParam.value && trackParam.value.length > 0){
        trackParam.value = replaceDynamicValues(trackParam.value);
      }
    }
  }
  
  /**
   * Do the actual value replacement
   */
  function replaceDynamicValues(baseValue){
    var replaceToken;
    var replaceValue;
    var alias;
    var propertyName;
    var useObject = true;
    var ret = baseValue; //This indicates if the js object should be used or if we should use it's string value
    var varMatcher = /\$\{[^}]*}/i;
    var dataElement;

    debug('BaseVal: ' + baseValue);
    
    if (ret) {
      
     
      //Loop through matches and do replacement - we need to loop to ensure we catch the case where there are multiple replacements
      while (varMatcher.test(ret)) {

        //First part of match is the alias for the data element
        replaceToken = varMatcher.exec(ret);
        
        //set replace token to first element in match object - this is the matched text
        replaceToken = replaceToken[0];
        
        if (replaceToken != baseValue) {
          //If there is more text in the value, we are assuming we're using the objectVal as a string.
          useObject = false;
        }
        
        debug('Replace: ' + replaceToken);
        
        //Remove leading ${ and ending } and add tracking data object to expression.  
        replaceToken = replaceToken.substring(2, replaceToken.length - 1);
        
        //Parse alias from replace token.
        alias = replaceToken.split('.', 1)[0];
        
        //get property name by removing alias
        if(replaceToken.length == alias.length){
          propertyName = "";
          
        } else {
          propertyName = replaceToken.substring(alias.length + 1);
        }
        
        
        dataElement = dynamicElements.data[alias];
        
        debug('dynamicElements: ', dynamicElements.data);
        debug('dataElement:', dataElement, ' alias: ', alias, ' propertyName: ', propertyName);

        //Only do replacement if dataElement is populated
        if(dataElement !== undefined){
          if(propertyName.length > 0){
            // All tracking data should be pulled from the tracking data object.
            replaceValue = nike.objectDefined(propertyName, dataElement, true);
          } else {
            //If propertyName is empty, use the root dataElement
            replaceValue = dataElement;
          }
          
        } else {
          //Data not found - set replace value to undefined
          replaceValue = undefined;
        }

        debug('PropertyName: ', propertyName);
        debug('replaceValue', replaceValue);
        debug('useObject: ' + useObject);

        if (replaceValue === undefined && useObject == false) {
          replaceValue = '';
        }

        if (useObject) {
          ret = replaceValue;
          //Break because if you use the object, it can only have one value so you don't need to check for additional matches
          break;
        } else {
          ret = ret.replace(varMatcher, replaceValue);
        }
      }
    
    }
    return ret;
  }
  
};


/*******************************************************
 * Methods for evaluating conditionals 
 *******************************************************/


/**
 * Evaluate conditional statements and remove elements containing them if they fail.
 * Any dynamic values in the conditional args should have been already replaced.
 */
nike.analytics.TrackingConfigUtil.evaluateTagConditionals = function(params){
  var i;
  var paramObj;
  var debug = nike.analytics.TrackingConfigUtil.debug;
  
  debug('Evaluating conditionals');

  if(params instanceof Array){
    //Handle arrays (trackElements)
    if(params.length > 0){
      for(i = params.length - 1; i >= 0; i--){
        if(!evalConditionalHelper(params[i]) || params[i].remove){
          //Remove the element from the array
          params.splice(i, 1);
        }
      }
    }
  } else {
    //Handle non array objects (params)
    for(paramObj in params){
      if(params.hasOwnProperty(paramObj)){
        if(!evalConditionalHelper(params[paramObj]) || params[paramObj].remove){
          //Delete the element from the object
          delete params[paramObj];
        }
      }
    }
  }
  
  
  function evalConditionalHelper(trackParam, parentObject, isParamArray){
    var i, L;
    var ret = true;
    
    if(trackParam.trackElements && trackParam.trackElements.length > 0){
      nike.analytics.TrackingConfigUtil.evaluateTagConditionals(trackParam.trackElements);

    } else if(trackParam.conditionals && trackParam.conditionals.length > 0){
      for(i = 0, L = trackParam.conditionals.length; i < L; i++){
        if(!nike.analytics.TrackingConfigUtil.evaluateConditional(trackParam.conditionals[i])){
          //If conditional fails, set return val to false so we know to remove the param
          ret = false;
          break;
        }
      }
    }
    return ret;
  }
};  

/**
 * Evaluate conditional statments on an event and return false if any of them fail.
 * Any dynamic values in the conditional args should have been already replaced.
 */
nike.analytics.TrackingConfigUtil.evaluateEventConditionals = function(event){
  var i, L;
  var ret = true;
  var debug = nike.analytics.TrackingConfigUtil.debug;
    
  if(event.conditionals && event.conditionals.length > 0){
    for(i = 0, L = event.conditionals.length; i < L; i++){
      debug('Evaluating event conditional: ', event.conditionals[i]);
      if(!nike.analytics.TrackingConfigUtil.evaluateConditional(event.conditionals[i])){
        //If conditional fails, set ret to false and break;
        debug('Conditional failed');
        ret = false;
        break;
      }
    }
  }
  debug('Event conditional eval result: ', ret);
  return ret;
};  


/**
 * Evaluate conditional and return the result.  This assumes any dynamic values have been replaced already.
 */
nike.analytics.TrackingConfigUtil.evaluateConditional = function(conditional) {
  var conditionalMatch = false;
  var debug = nike.analytics.TrackingConfigUtil.debug;
  
  debug('testing conditional:', conditional);
  try {

    if (!isBlank(conditional.type)) {
      switch (conditional.type) {
      case 'equal':
        conditionalMatch = conditional.leftArg == conditional.rightArg;
        break;

      case 'notEqual':
        conditionalMatch = conditional.leftArg != conditional.rightArg;
        break;

      case 'greaterThan':
        conditionalMatch = conditional.leftArg > conditional.rightArg;
        break;

      case 'greaterThanOrEqual':
        conditionalMatch = conditional.leftArg >= conditional.rightArg;
        break;

      case 'lessThan':
        conditionalMatch = conditional.leftArg < conditional.rightArg;
        break;

      case 'lessThanOrEqual':
        conditionalMatch = conditional.leftArg <= conditional.rightArg;
        break;

      case 'true':
        conditionalMatch = conditional.arg == true || conditional.arg == 'true';
        break;

      case 'false':
        conditionalMatch = conditional.arg == false || conditional.arg == 'false';
        break;

      case 'empty':
          conditionalMatch = isEmpty(conditional.arg);
        break;

      case 'notEmpty':
          conditionalMatch = !isEmpty(conditional.arg);
        break;
        
      case 'exists':
        conditionalMatch = isDefined(conditional.arg);
      break;
      
      case 'notExists':
        conditionalMatch = !isDefined(conditional.arg);
      break;

      case 'contains':
        conditionalMatch = contains(conditional.leftArg, conditional.itemTemplate, conditional.rightArg);
      break;
      
      case 'notContains':
        conditionalMatch = !contains(conditional.leftArg, conditional.itemTemplate, conditional.rightArg);
      break;
      
      case 'regexMatch':
        conditionalMatch = isMatch(conditional.leftArg, conditional.rightArg);
      break;
      
      case 'notRegexMatch':
        conditionalMatch = !isMatch(conditional.leftArg, conditional.rightArg);
      break;
        
      default:
        nike.error('unsupported conditional type: ' + conditional.type);
        conditionalMatch = false;
      }
    }
  } catch (exception) {
    // If there is an exception, remove the value entirely.
    conditionalMatch = false;
  }
  debug('conditionalResult: ', conditionalMatch);
  return conditionalMatch;
  
  
  /**
   * Conditional helper functions
   */
  function isDefined(varToCheck){
    return varToCheck != undefined && varToCheck != null; 
  }
  
  function isBlank(varToCheck){
    var blank = false;

    if(!isDefined(varToCheck)){
      blank = true;
    }
    else if(!varToCheck.trim){
      blank = varToCheck.trim().length == 0;
    }
    else{
      blank = varToCheck.length == 0;
    }
    return blank;
  }

  function isEmpty(varToCheck) {
      return (varToCheck) ? varToCheck.length === 0 : true;
  }
  
  function contains(src, itemTemplate, varToCheck){
    var ret = false;
    var i, L;
    var tempObj;
    if(src.length && src.length > 0){
      
      if(typeof(src) == 'string'){
        if(typeof(varToCheck) == 'string'){
          //For strings - contains checks if the varToCheck occurs in the src
          ret = src.indexOf(varToCheck) != -1;
        }
        
      } else if (src instanceof Array){
        for(i = 0, L = src.length; i < L; i++){
          tempObj = src[i];
          if(isDefined(tempObj)){
            if(itemTemplate){
              tempObj = nike.objectDefined(itemTemplate, tempObj, true);
            }
            ret = isDefined(tempObj) && tempObj == varToCheck;
            if(ret){
              break;
            }
          }
        } 
      }
    }
    return ret;
  }
  
  //Regex match - case insensitive and max 250 chars on the src
  function isMatch(src, regexStr){
    var ret = false;
    
    if(typeof(src) == 'string' && typeof(regexStr) == 'string'){
      //Make sure src isn't huge - it can cause performance issues to apply a regex to a really long string
      if(src.length > 250){
        nike.error('conditional isMatch error - src is too long.  max: 250 actual: ' + src.length);
        nike.debug('src: ' + src);
      } else {
      
        try{
          ret = RegExp(regexStr, 'i').test(src);
        } catch (ex){
          nike.error('Error building or executing regex: ' + regexStr, ex);
          ret = false;
        }
      }
    }
    return ret;
  }
};

/**
 * Using an array of keys, collects all data from the params supplied that match
 *
 * @param {String[]} paramArray An array of keys that should map to data in params
 * @param {Object[]} params The data that should be matched to the keys in paramArray
 * @return {Object|undefined} Returns a map of values that match the keys in paramArray or undefined otherwise.
 */
nike.analytics.TrackingConfigUtil.getEventDataForLocalStorage = function (paramArray, params) {
    var eventParams;

    for(var index = 0; index < paramArray.length; index++ ) {
        var key = paramArray[index];
        if(params && params[key]) {
            eventParams = eventParams || {};
            eventParams[key] = params[key];
        }
    }

    return eventParams;
}

/**
 * Get the TrackingData that needs to be sent on the next page load from the TrackingConfig. For example, if
 * this page is going to immediately redirect the user we don't want to delay the redirect simply to fire an
 * analytics tag. So we will cache the data in the users' cookies or local storage and fire it on the next
 * page the load.
 * @param trackParams
 * @return {Object}
 */
nike.analytics.TrackingConfigUtil.getDataForLocalStorage = function(trackParams){
  var dataForNextPageView = {};
  var paramName;
  var hasData= false;

  for (paramName in trackParams) {
    if (trackParams.hasOwnProperty(paramName) && trackParams[paramName].storeForNextPageView === true) {
      if(trackParams[paramName].trackElements && trackParams[paramName].trackElements.length) {
        dataForNextPageView[paramName] = [];
        for(var index=0; index<trackParams[paramName].trackElements.length;index++) {
          dataForNextPageView[paramName].push(trackParams[paramName].trackElements[index].value);
        }
      } else if (typeof trackParams[paramName].value !== 'string' || trackParams[paramName].value) {
        dataForNextPageView[paramName] = trackParams[paramName].value;
      }
      //Remove data so that we don't process it now
      delete trackParams[paramName];
      hasData = true;
    }
  }
  
  return hasData ? dataForNextPageView : null;
};

/**
 *  Function to persist storage buffer data to local storage
 * @param storeData
 * @param {Boolean} mergeWithExisting Merge the data with the data already present in the data store. If false, the provided
 * data will overwrite the existing data.
 */
nike.analytics.TrackingConfigUtil.pushDataToLocalDatabase = function (storeData, mergeWithExisting, key) {
    nike.analytics.TrackingConfigUtil.saveLocalData(storeData, mergeWithExisting, key);
};

nike.analytics.TrackingConfigUtil.saveLocalData = function (data, mergeWithExisting, key) {
    /**
     * Removing Local Storage branch since we can't keep data in sync across sub domains or protocols
     */
    if (nike.Util.cookiesEnabled()) {
        //browser does not support localStorage. Write to cookie
        nike.analytics.TrackingConfigUtil.saveToCookie(key, data, mergeWithExisting);
    }
};

/**
 * Utility function to store non-empty data object to localStorage for next page view
 * @param storeKey
 * @param data
 * @param mergeWithExisting
 */
nike.analytics.TrackingConfigUtil.saveToLocalStore = function (storeKey, data, mergeWithExisting) {
    var existingDataAsString;
    var existingData;
    var dataToStore;
    if(data && !$.isEmptyObject(data)){
        try {
            if (mergeWithExisting === true) {
                existingDataAsString = JSON.parse(window.localStorage.getItem(storeKey));
                if (existingDataAsString) {
                    existingData = existingDataAsString;
                }
                dataToStore = {};
                nike.Util.apply(dataToStore, data);
                nike.Util.applyWithMerge(dataToStore, existingData);
            }
            else {
                dataToStore = data;
            }
            window.localStorage.setItem(storeKey, JSON.stringify(dataToStore));
        }
        catch (e) {
            nike.error("nike.analytics.TrackingConfigUtil", "#saveToLocalStore(", storeKey, data, mergeWithExisting, ") failed with exception: ", e);
        }
    } else if (!mergeWithExisting) {
        window.localStorage.removeItem(storeKey);
    }
};

/**
 * Utility function to store data as a session cookie for next page view.
 * Note: The cookie will not be retained when browser exits and only save non
 * empty data object.
 * @param storeData
 */
nike.analytics.TrackingConfigUtil.saveToCookie = function (storeKey, data, mergeWithExisting) {
    var existingDataAsString;
    var existingData;
    var dataToStore;

    if(data && !$.isEmptyObject(data)){
        try{
            if(mergeWithExisting === true){
                existingDataAsString = $.CookieUtil(storeKey);
                if (existingDataAsString) {
                    existingData = JSON.parse(existingDataAsString);
                }
                dataToStore = {};
                nike.Util.apply(dataToStore, data);
                nike.Util.applyWithMerge(dataToStore, existingData);
            }
            else{
                dataToStore = data;
            }

            $.CookieUtil(storeKey, JSON.stringify(dataToStore), { path: '/', domain: nike.ROOT_DOMAIN });
        }
        catch(e){
            nike.error("nike.analytics.TrackingConfigUtil", "#saveToCookie(", storeKey, data, mergeWithExisting, ") failed with exception: ", e);
        }
    } else if (!mergeWithExisting) {
        // Remove the cookie
        $.CookieUtil(storeKey, null, { domain: nike.ROOT_DOMAIN, path: '/', expires: -1 });
    }

};

/**
 * This will either remove a record from database or just do a read based on remove flag boolean value.
 * @param storeKey record access key
 * @param {Boolean} remove flag for read/delete record
 * @return {*} retrieved record
 */
nike.analytics.TrackingConfigUtil.getLocalData = function (storeKey, remove) {
    var localTrackingData;
    remove = !!remove;

    /**
     * Removed local storage branch since we store data across sub domains or protocols
     */
    if (nike.Util.cookiesEnabled()) {
        localTrackingData = nike.analytics.TrackingConfigUtil.getDataFromCookie(storeKey, remove);
    }

    return localTrackingData;
};

nike.analytics.TrackingConfigUtil.getDataFromLocalStorage = function (storeKey, remove) {
    var existingDataAsString = window.localStorage.getItem(storeKey);
    var existingData;

    if (existingDataAsString && existingDataAsString !== 'null' && existingDataAsString !== 'undefined') {
        try {
            existingData = JSON.parse(existingDataAsString);
        } catch (e) {
            nike.error("nike.analytics.TrackingConfigUtil", "#getDataFromLocalStorage(", storeKey, remove, ") has failed to parse: ", existingDataAsString, "with exception: ", e);
        }
    }

    if(remove) {
        window.localStorage.removeItem(storeKey);
    }

    return existingData || null;
};

nike.analytics.TrackingConfigUtil.getDataFromCookie = function (storeKey, remove) {
    var existingDataAsString = $.CookieUtil(storeKey);
    var existingData;

    if (existingDataAsString && existingDataAsString !== 'null' && existingDataAsString !== 'undefined') {
        try {
            existingData = JSON.parse(existingDataAsString);
        } catch (e) {
            nike.error("nike.analytics.TrackingConfigUtil", "#getDataFromCookie(", storeKey, remove, ") has failed to parse: ", existingDataAsString, "with exception: ", e);
        }
    }

    if (remove) {
        // Remove the cookie
        $.CookieUtil(storeKey, null, { domain: nike.ROOT_DOMAIN, path: '/', expires: -1 });
    }

    return existingData || null;
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.TrackingConfigUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.global.CookieSettingsCheck');

nike.requireDependency("jQuery");
nike.requireDependency("jQuery.CookieUtil");
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.ScriptLoader');

nike.exp.global.CookieSettingsCheck = {
  /**
   * Mask for Functional and Performance cookies
   *
   * @constant
   * @private
   * @type Number
   */
  FP_MASK : 1,

  /**
   * Mask for Advertising cookies
   *
   * @constant
   * @private
   * @type {number}
   */
  AD_MASK : 2,

  /**
   * Queue for deferred Functional & Performance calls
   *
   * @private
   * @type {Array}
   */
  deferredFPCalls: [],

  /**
   * Queue for deferred Advertising calls
   *
   * @private
   * @type {Array}
   */
  deferredAdCalls: [],

  isCookieSettingsEnabled : function () {
      return nike.IS_COOKIE_SETTINGS_ENABLED;
  },

  isFPCookiesAllowed : function() {
      //noinspection NonShortCircuitBooleanExpressionJS
    return !this.isCookieSettingsEnabled() || !!($.CookieUtil('sq') & this.FP_MASK);
  },

  isAdCookiesAllowed : function() {
      //noinspection NonShortCircuitBooleanExpressionJS
    return !this.isCookieSettingsEnabled() || !!($.CookieUtil('sq') & this.AD_MASK);
  },

  queueFPCall : function(func) {
    if (this.isFPCookiesAllowed()) {
      func();
    } else {
      this.deferredFPCalls.push(func);
    }
  },

  queueAdCall : function(func) {
    if (this.isAdCookiesAllowed()) {
      func();
    } else {
      this.deferredAdCalls.push(func);
    }
  },

  init : function() {
    nike.listen(nike.gadget.Event.COOKIE_SETTINGS_CHANGED_EVENT, $.proxy(function() {
      if (this.isFPCookiesAllowed()) {
        while(this.deferredFPCalls.length) {
          this.deferredFPCalls.shift()();
        }
      }

      if (this.isAdCookiesAllowed()) {
        while(this.deferredAdCalls.length) {
          this.deferredAdCalls.shift()();
        }
      }
    }, this));
  }
};

nike.exp.global.CookieSettingsCheck.init();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.CookieSettingsCheck. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * Tracking.js
 *
 * This handles loading the tracking config and using it to send analytics and marketing tags.
 *
 * @author twill
 */
nike.namespace('nike.analytics.Tracking');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.Cart');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency("jQuery.md5");
nike.requireDependency('nike.analytics.TrackingConfigUtil');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.util.BooleanUtil');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('nike.exp.global.CookieSettingsCheck');

//Flag to toggle logging because the debug statements in the tracking js are pretty verbose
nike.analytics.Tracking.isDebugEnabled = false;

nike.analytics.Tracking = {

  DEFAULT_USER_TYPE : 'DEFAULT_USER',

  //Object to hold tracking config
  config : undefined,
  trackData : {},
  isVendorInfoLoaded : false,
  hasInitBeenCalled : false,
  initialTagSent : false,
  vendorInfoTimeout : undefined,

  //Array of marketing tag images.  This will keep a reference to the object until it can be loaded at which time it should be removed
  marketingTagImages : [],
  maxMarketingTagLoadTime: 20000,
  maxConcurrentMarketingTags: 4,

  analyticsSupportIsReady : false,

  /*
   * wrap debug logging so it can be disabled just for tracking
   */
  debug : nike.analytics.Tracking.isDebugEnabled ? nike.debug : nike.emptyFn,

  /**
   * Get the url for the tracking config
   */
  getTrackingConfigServiceUrl : function(appName) {
    return nike.getRootUrl() + appName + '/html/services/trackingConfig';
  },

  /**
   * Flag to indicate if the eventListners specified in the track config have been setup
   */
  eventListenersRegistered : false,

  /**
   * List of all registered tracking listeners
   */
  trackingListeners : [],

  //Keys for auto-generated track params
  IS_PAGE_VIEW : 'isPageView',
  REGION : 'region',
  COUNTRY : 'country',
  LOCALE : 'locale',
  REFERRER : 'referrer',
  IS_BOT : 'isBot',
  SITE_ID : 'siteId'
};



/**
 * initTracking
 * This will do all the tasks required to initialize the tracking object.
 * It will first call loadTrackingConfig to get the config from the server for the appname and presentation.
 * If the config request is successful, it will call configureTrackingObject which will handle
 * setting up tracking for the page based on the config.
 * If the request fails, an error will be logged to the console.
 *
 * @param appName The app to be tracked
 * @param presentation The presentation to be tracked
 *
 */
nike.analytics.Tracking.init = function(appName, presentation) {

  var tracking = nike.analytics.Tracking;
  var log = tracking.debug;

  if(!tracking.hasInitBeenCalled) {
    tracking.hasInitBeenCalled = true;

    log('init tracking called for app: ' + appName + ' presentation: ' + presentation);


    //Setup a listener for cartSummarySuccess events so the userData is always up to date
    nike.listen(nike.Event.CART_SUMMARY_REQUEST_SUCCESS, function(event, data) {
      var userData;
      log('Loaded cart summary');
      tracking.setupUserData(data.response, false);
    });

    //Whenever tracking userdata is reset, update the vendor info
    nike.listen(nike.Event.TRACKING_USER_DATA_UPDATED, function(event, data){
      log('Tracking userData reset');
      tracking.resolveVendorInfo(tracking.config, tracking.userData.userType);
    });

    //Setup a listener for loadTrackingConfigSuccess events so the trackingVendorInfo is updated when the config is returned
    nike.listen(nike.Event.GET_TRACKING_CONFIG_SUCCESS, function(event, data) {
      $(".trackingDataAuto").each(function(){
        nike.analytics.TrackingUtil.setupTrackingData($(this));
      });

      log('Loaded trackingConfig');
      // Set config in tracking object
      tracking.config = data.responseData.response;
      tracking.resolveVendorInfo(tracking.config, tracking.userData.userType);
      tracking.configureTrackingObject.call(window);
    });

    nike.listen(nike.Event.TRACKING_TAG_READY_FOR_MAPPING, tracking.sendTagToMapping);
    nike.listen(nike.Event.TAG_SEND_COMPLETE, tracking.registerEventListeners);
    nike.listen(nike.Event.TAG_CANCELLED, tracking.registerEventListeners);

    tracking.initTrackingUserData(appName, presentation);

    tracking.loadTrackingConfig(appName, presentation);

    nike.listen(nike.gadget.Event.COOKIE_SETTINGS_CHANGED_EVENT);
  }
};


/**
 * Do initial userData setup
 * This will setup default userData and initiate a call to get updated data from the CartSummary service so we make sure to keep the user data current.
 */
nike.analytics.Tracking.initTrackingUserData = function(appName, presentation){

  var tracking = nike.analytics.Tracking;

  //************************
  //Setup User info
  //************************
  //Get userData, which may be required to get correct vendor specific info
  //Check cookie for userData
  tracking.setupUserData(null, true);

  //If we don't get the userData from the cookie, just use the default user info so we can ensure the tag fires quickly
  //This could cause slight misreporting for vendor info based on userType, but it's more important for the tag to fire right away
  if(tracking.userData == undefined){
    tracking.setupDefaultUserData();
  }
};




/**
 * Load tracking config
 *
 * This will request the tracking config and the cart summary. Callbacks will be
 * setup for both requests. The callback for the config request will configure
 * nike.analytics.Tracking.config and the callback for the cartsummary should
 * resolve the vendor info.
 *
 * @param appName The appName to use when getting the tracking config
 * @param presentation The presentation to use when looking up config
 */
nike.analytics.Tracking.loadTrackingConfig = function(appName, presentation, success, fail){
  var data;
  var responseData = {'success':false};
  var log = nike.analytics.Tracking.debug;
  var tracking = nike.analytics.Tracking;

  // Check if app name is specified in the gadget. If not, use the default for the gadget server
  if (appName == undefined || appName.length == 0) {
    appName = nike.DEFAULT_APP_NAME;
  }

  // Send event to indicate we are about to request the tracking config
  data = {'appName':appName, 'presentation':presentation};
  nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG, {'data':data});


  // Request the tracking config
  nike.request({
    method : 'GET',
    url : tracking.getTrackingConfigServiceUrl(appName),
    data : data,
    cache : true
    }, function(response) {
        //Tracking config returned successfully
        var responseData;

        log(response);
        try {
          responseData = $.parseJSON(response.data);
        } catch (e) {
          log(e);
          responseData = responseData || {};
          responseData.errorMessages = [ e.toString() ];
        }

        if (responseData && responseData.success) {
          //Get Tracking config succeeded.  Dispatch an event.
          log('dispatch GET_TRACKING_CONFIG_SUCCESS');
          log({'appName':appName, 'presentation':presentation, 'responseData':responseData});
          nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG_SUCCESS,
              {'appName':appName, 'presentation':presentation, 'responseData':responseData});

        } else {
          //Failed getting tracking config.  Send an event and log the error
          nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG_FAIL,
              {'appName':appName, 'presentation':presentation, 'responseData':responseData});
          nike.error('Failed to load tracking config', response);
        }

        // Failed call
    }, function(response) {
      //Tracking config request failed
      responseData.errorMessages = [ response.toString() ];
      nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG_FAIL,
          {'appName':appName, 'presentation':presentation, 'responseData':responseData});
      nike.error('Tracking config request failed', responseData);
    });



  if (tracking.userData) {
    // Use userType from cookie to setup vendor info
    tracking.resolveVendorInfo(tracking.config, tracking.userData.userType);
  }

  /*****************************************************************************
   * Internal functions
   ****************************************************************************/

  // Success function for getTrackingConfig.
  function doSuccess(appName, presentation, response) {
    log('dispatch GET_TRACKING_CONFIG_SUCCESS');
    log({'appName':appName, 'presentation':presentation, 'response':response}.response);
    nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG_SUCCESS,
        {'appName':appName, 'presentation':presentation, 'response':response});

    // Set config in tracking object
    tracking.config = response;

    // Call callback
    if (success) {
      success.call(window);
    }
  }

  // Fail function for getTrackingConfig.
  function doFail(appName, presentation, response) {
    var result = {'appName':appName, 'presentation':presentation, 'response':response};
    nike.dispatchEvent(nike.Event.GET_TRACKING_CONFIG_FAIL,
        result);

    // Call fail callback
    if (fail) {
      fail(result);
    }
  }

};

/************************************
 * Setup user data from cart summary
 ************************************/
nike.analytics.Tracking.setupUserData = function(cartSummary, checkCookie) {
  var tracking = nike.analytics.Tracking;
  var log = nike.analytics.Tracking.debug;
  var userData = undefined;
  var cartSummaryResult;

  log('cartSummary', cartSummary);

  if (!cartSummary) {
    if (checkCookie) {
      // See if values exist on the cookie
      cartSummaryResult = nike.Cart.getCartSummaryFromCookie();
      if(cartSummaryResult){
        userData = $.extend({}, cartSummaryResult);
      }
    }
  } else {
    userData = $.extend({}, cartSummary);
  }

  log('userData', userData);

  // User is logged in as far as analytics is concerned when security status is higher than 0
  if(userData) {
    userData.loggedIn = !!(userData.securityStatus >= 1);
  }
  tracking.userData = userData;

  //Dispatch event if userdata was updated
  if(userData !== undefined){
    nike.dispatchEvent(nike.Event.TRACKING_USER_DATA_UPDATED, tracking.userData);
  }

  return tracking.userData;
};


/**
 * Setup userData with default values.  This is most commonly used to make sure a tag fires immediately so
 * we don't have to wait for the userType to return.  This is especially important for capturing campaign codes.
 * This will not overwrite userData if it's been set.
 */
nike.analytics.Tracking.setupDefaultUserData = function() {
  var tracking = nike.analytics.Tracking;
  var log = nike.analytics.Tracking.debug;

  if(tracking.userData === undefined){
    log("Setting up default userData");
    nike.analytics.Tracking.setupUserData({userType : tracking.DEFAULT_USER_TYPE}, false);
  }
  return tracking.userData;
};



/**
 * configureTrackingObject
 * This will setup the base tracking object and configure any event listeners based on the page and the tracking config.
 *
 * This is where most of the work is done.
 *
 */
nike.analytics.Tracking.configureTrackingObject = function() {
  var tempObj;
  var log = nike.analytics.Tracking.debug;
  var trackConfig = nike.analytics.Tracking.config;
  var tracking = nike.analytics.Tracking;
  var defaultTrackObject;

  // Check if the user agent is a bot or a monitoring service
  // These will never convert so they water down our conversion, so in general, this can be used to exclude them from tagging to prod.
  var isBot = (navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/gomez|bot|slurp/)) ? true : false;

  log('configureTrackingObject started.');
  log(trackConfig);

  //Setup initial track config object
  tracking.defaultTrackObject = { params:{}, dataList: []};
  defaultTrackObject = tracking.defaultTrackObject;


  // Add region and country to the params
  defaultTrackObject.params[tracking.REGION] = {value : nike.REGION, name : tracking.REGION};
  defaultTrackObject.params[tracking.COUNTRY] = {value : nike.COUNTRY, name : tracking.COUNTRY};
  defaultTrackObject.params[tracking.LOCALE] = {value : nike.LOCALE, name : tracking.LOCALE};
  defaultTrackObject.params[tracking.REFERRER] = {value : nike.util.UrlUtil.getExternalReferrer(), name : tracking.REFERRER};
  defaultTrackObject.params[tracking.IS_BOT] = {value : isBot, name : tracking.IS_BOT};


  // Add site id
  defaultTrackObject.params[tracking.SITE_ID] = {value : nike.analytics.Tracking.resolveSiteId(trackConfig.presentation, trackConfig.siteName), name : tracking.SITE_ID };

  //Template tags is a link by default.  The initial page view will set this to true automatically
  defaultTrackObject.params[tracking.IS_PAGE_VIEW] = {value : false, name : tracking.IS_PAGE_VIEW };

  //Tags wait for all the needed gadgets to load by default
  defaultTrackObject.waitForData = true;

  //Add config level data elements
  defaultTrackObject.dataList = defaultTrackObject.dataList.concat(trackConfig.dataList);


  //Add config level params
  $.extend(defaultTrackObject.params, trackConfig.trackParams);

  /*
   * Setup baseSiteTrackingObject:
   * This is a config level tracking object - this is used when an event doesn't want to merge the current pages params with it's own
   */
  tracking.baseSiteTrackObject = $.extend(true, {}, defaultTrackObject);

  trackConfig.pageId = nike.analytics.Tracking.resolvePageId();

  // Resolve pageId
  log('PageId: ' + trackConfig.pageId);

  // Setup pageSpecific params
  trackConfig.pageInfo = trackConfig.pageConfigMap[trackConfig.pageId];
  log('PageConfigMap', trackConfig.pageConfigMap);
  log('PageInfo', trackConfig.pageInfo);

  if (trackConfig.pageInfo) {
    defaultTrackObject.marketingTagUrls = trackConfig.pageInfo.marketingTagUrls;

    //Add page level data elements
    defaultTrackObject.dataList = defaultTrackObject.dataList.concat(trackConfig.pageInfo.dataList);

    //Add page specific track params
    $.extend(defaultTrackObject.params, trackConfig.pageInfo.trackParams);

  } else {
    // Create empty pageInfo object
    trackConfig.pageInfo = {eventListeners:[], marketingTagUrls:[], trackParams:{}};
  }

  if(!nike.analytics.Tracking.initialTagSent){
    nike.analytics.Tracking.initialTagSent = true;

    var trackData = {};

    //Check if page is configured to fire the tag automatically when the page is viewed (default behavior)
    if(!trackConfig.pageInfo ||
       !trackConfig.pageInfo.trackParams ||
       !trackConfig.pageInfo.trackParams.tagPageView ||
       !trackConfig.pageInfo.trackParams.tagPageView == true){

      trackData = jQuery.extend(true, {}, defaultTrackObject);

      // Initial tag is a page view, the rest are events
      trackData.params[tracking.IS_PAGE_VIEW] = {value : true, name : tracking.IS_PAGE_VIEW};

      nike.analytics.Tracking.sendTag(trackData);
    } else {
      nike.dispatchEvent(nike.Event.TAG_CANCELLED, {});
    }

  }
};

/******************************************
 * Remove all tracking listeners from page
 ******************************************/
nike.analytics.Tracking.removeEventListenersFromPage = function(){
  var i;
  var L;
  var listenerInfo;

  for(i = 0, L = nike.analytics.Tracking.trackingListeners.length; i < L; i++){
    listenerInfo = nike.analytics.Tracking.trackingListeners[i];
    nike.unlisten(listenerInfo.event, listenerInfo.handler);
  }

  //Reset listener array
  nike.analytics.Tracking.trackingListeners = [];
  nike.analytics.Tracking.eventListenersRegistered = false;

};

/*****************************************************
 * Setup all tracking event listeners for page events
 *****************************************************/
nike.analytics.Tracking.setupEventListenersForPage = function(){
  var trackConfig = nike.analytics.Tracking.config;
  var trackingListeners = nike.analytics.Tracking.trackingListeners;

  var log = nike.analytics.Tracking.debug;
  var util = nike.analytics.TrackingConfigUtil;
  var tempObj;
  var index;
  var L;

  //Setup global events
  if (trackConfig.globalEventListeners.length > 0) {
    for (index = 0; index < trackConfig.globalEventListeners.length; index++) {
      tempObj = trackConfig.globalEventListeners[index];
      trackingListeners.push(setupEventListener(tempObj));
    }
  }

  // Get event listeners
  for (index = 0, L = trackConfig.pageInfo.eventListeners.length; index < L; index++) {
    tempObj = trackConfig.pageInfo.eventListeners[index];
    trackingListeners.push(setupEventListener(tempObj));
  }

  /**
   * Setup an event listener based on a config object
   *
   * The eventId is the event name that should be listened to.
   * This checks the event config for what additional elements should be tracked and adds them to a copy
   * of the existing page tag and fires it.
   */
   function setupEventListener(eventConfigOriginal) {


    log('Setting up event listener for eventId: ' + eventConfigOriginal.id);
    log(eventConfigOriginal);
    nike.listen(eventConfigOriginal.id, executeEventTag);

    //Return info about event that was setup so we can remove it if we need to
    return {'event': eventConfigOriginal.id, 'handler': executeEventTag};

    function executeEventTag(event, data){
      //Clone base tracking object so we don't modify the base object.  This would dirty it up and mess up other tagging events
      var trackData;
      var i;
      var L;
      var startingIndex = 0; //Index to start adding items to an existing list
      var tempPropName; //temp var to hold prop names in a for-loop

      //Clone event data so we don't overwrite the replacement values in the event conditionals (this can probably be optimized)
      var eventConfig = jQuery.extend(true, {}, eventConfigOriginal);

      //Clones the tracking data based on the event config
      trackData = cloneTrackingData(eventConfig);


      trackData.eventData = data;
      trackData.waitForData = eventConfig.waitForData;
      trackData.saveDataForNextPageLoad = eventConfig.saveDataForNextPageLoad;

      //Add extra data elements
      trackData.dataList = trackData.dataList.concat(eventConfig.dataList);

      log('Tracking event fired for event: ' + eventConfig.id, eventConfig);
      log('EventData: ', trackData.eventData);

      log('EventListener conditionals: ', eventConfig.conditionals);
      if(eventConfig.conditionals === undefined || eventConfig.conditionals.length == 0){
        //No event conditionals, so just send the tag
        log('No event conditionals - sending tag: ', eventConfig.conditionals);
        sendEventTag();

      } else {
        //Evaluate conditionals to decide if event should send tag or not
        log('Evaluating eventListener conditionals');
        nike.listen(nike.Event.TRACKING_DYNAMIC_DATA_READY, conditionalDataReady);
        util.findPageElements(trackData.dataList, trackData.eventData, trackData, nike.analytics.Tracking.config.maxPageViewTagDelay, trackData.waitForData);
      }


      /**
       * This evaluates the events conditionals and fires the tag if they eval to true
       */
      function conditionalDataReady(event, data){


        //Make sure we are getting the data we requested for this eventConfig
        if(trackData === data.caller){
          //Remove listener
          nike.unlisten(nike.Event.TRACKING_DYNAMIC_DATA_READY, conditionalDataReady);

          //Replace all values in conditionals so we can check if this should be cancelled or not
          util.replaceValues([eventConfig], data);

          log('Event conditional dynamic values resolved: ', eventConfig.conditionals);
          if(util.evaluateEventConditionals(eventConfig)){
            //Conditionals evaluated to true, so event tag should be sent
            log('Event conditionals returned true, sending tag');
            sendEventTag();
          }
        }
      }

      function sendEventTag(){

        //Check if event should cause a pageInfo refresh
        if(eventConfig.refreshPageInfo === true){
            //YUCK!  I have to wait a split second (50ms) to make sure the url is changed before reconfiguring the page
            setTimeout(function(){
            log('Refreshing pageInfo');
            //Refresh page config before executing tag
            nike.analytics.Tracking.removeEventListenersFromPage();
            nike.analytics.Tracking.configureTrackingObject();

            //Recopy trackData from new defaultTrackObject
            trackData = cloneTrackingData(eventConfig);
            sendEventTag();
          }, 50);

        } else{
          sendEventTag();
        }

        function sendEventTag(){
          // Add additional marketing tag urls for event
          trackData.marketingTagUrls = trackData.marketingTagUrls || [];
          startingIndex = trackData.marketingTagUrls.length;
          if(!startingIndex){ startingIndex = 0; }
          for (var index = 0; index < eventConfig.marketingTagUrls.length; index++) {
            trackData.marketingTagUrls[startingIndex + index] = eventConfig.marketingTagUrls[index];
          }

          $.extend(trackData.params, eventConfig.trackParams);

          nike.analytics.Tracking.sendTag(trackData);
        }
      }

      /*
       * Clone the current tracking data.  If merge is true, it will clone the current pageTag, if false if will clone the base site tag.
       * If merge is not specified, events sent as an event tag will clone the pageTag, events sent as a pageView will clone the base site tag.
       */
      function cloneTrackingData(eventConfig){
        var mergedConfig;
        var tracking = nike.analytics.Tracking;
        var mergePageConfig = nike.util.BooleanUtil.getBoolean(eventConfig.mergePageConfig, undefined);

        if( mergePageConfig === undefined){
          //Default this to true - this is the most common case
          mergePageConfig = true;
        }

        if(mergePageConfig){
          mergedConfig = jQuery.extend(true, {}, tracking.defaultTrackObject);
        } else {
          mergedConfig = jQuery.extend(true, {}, tracking.baseSiteTrackObject);
        }

        /* Save the event parameter names that are to be saved for the next page load for reference later */
        if(eventConfig.saveDataForNextPageLoad) {
            mergedConfig.eventParams = [];
            for(var paramKey in eventConfig.trackParams) {
                if(eventConfig.trackParams.hasOwnProperty(paramKey)) {
                    mergedConfig.eventParams.push(paramKey);
                }
            }
        }

        return mergedConfig;
      }
    } //End executeEventTag
  }//End setupEventListener
};



/**
 * Build vendor info objects
 *
 * There can only be one vendor info object selected per unique vendor.
 * This will check based on the best match using the following criteria:
 *
 * Region and UserType match
 * Region and Empty UserType match
 * Empty Region and UserType match
 * Empty Region and Empty UserType match
 *
 * The vendorInfo object on nike.analytics.Tracking will be set with the correct tracking info for this user for each vendor
 */
nike.analytics.Tracking.resolveVendorInfo = function(trackConfig, userType){
  var vendorInfoList = {};
  var matchQualityList = {};
  var index = 0;
  var vendorInfo;
  var region = nike.REGION.toLowerCase();
  var log = nike.analytics.Tracking.debug;

  // We can't resolve the vendor info until we have the tracking config
  function trackingConfigListener(event, data) {
    nike.analytics.Tracking.resolveVendorInfo(data.response, userType);

  }

  nike.listen(nike.Event.GET_TRACKING_CONFIG_SUCCESS, trackingConfigListener);

  if(trackConfig && trackConfig.trackingVendorInfoList &&
      trackConfig.trackingVendorInfoList.length > 0 &&
      nike.analytics.Tracking.isVendorInfoLoaded !== true)
  {
    //Remove the timeout for getting vendor info if cart service takes too long
    clearTimeout(nike.analytics.Tracking.vendorInfoTimeout);

    log('UserType:');
    log(userType);

    // Get each of the configured vendors
    // CHANGE: We will no longer be determining match quality and simply include each vendor defined.
    for (index = 0; index < trackConfig.trackingVendorInfoList.length; index++) {
      vendorInfo = trackConfig.trackingVendorInfoList[index];
      vendorInfoList[vendorInfo.vendorName] = vendorInfo;
    }

    nike.analytics.Tracking.vendorInfo = vendorInfoList;
    log("vendor info selected:");
    log(nike.analytics.Tracking.vendorInfo);
    nike.analytics.Tracking.isVendorInfoLoaded = true;
    nike.dispatchEvent(nike.Event.TRACKING_RESOLVE_VENDOR_INFO, {'success': true, 'trackConfig': trackConfig, 'vendorInfo': vendorInfoList});
  }

};



/**
 * This will get the page id based on the pageIdSelectors in the tracking config.
 * The page selectors will traversed in order and the first match will be used.
 * In the case of a pageIdParam or pageIdFunction,
 *
 * If no page name is found via the selectors, return 'noPageIdDefined';
 */
nike.analytics.Tracking.resolvePageId = function() {
  var trackConfig = nike.analytics.Tracking.config;
  var pageIdIndex = 0;
  var selector;
  var locationObj = nike.analytics.TrackingConfigUtil.getCurrentAnalyticLocation();
  var pathUrl = locationObj.pathname;
  var fullUrl = locationObj.href + '?' + locationObj.search;
  var defaultReturnValue = 'noPageIdDefined';
  var resolvedPageId = defaultReturnValue;
  var pathPattern;
  var urlPattern;
  var pageIdJSVar;
  var log = nike.analytics.Tracking.debug;



  for (pageIdIndex = 0; pageIdIndex < trackConfig.pageIdSelectors.length; pageIdIndex++) {
    selector = trackConfig.pageIdSelectors[pageIdIndex];
    try {
      if (selector.pageId.length > 0) {
        if (selector.path.length > 0) {
          // Check if paths match
          if (locationObj.pathname == selector.path) {
            resolvedPageId = selector.pageId;
          }
        } else if (selector.urlPattern.length > 0) {
          // Create pattern
          urlPattern = new RegExp(selector.urlPattern, 'i');
          if (urlPattern.test(fullUrl)) {
            resolvedPageId = selector.pageId;
          }
        } else if(selector.pathPattern.length > 0){
            pathPattern = new RegExp(selector.pathPattern, 'i');
            if(pathPattern.test(pathUrl)){
                resolvedPageId = selector.pageId;
            }
        } else {
          //If a pageId has no selectors, use it (used for a default if no others are matched)
          resolvedPageId = selector.pageId;
        }

      } else if (selector.pageIdFunction.length > 0) {
        pageIdJSVar = nike.objectDefined(selector.pageIdFunction, undefined, true);
        log('PageIdFunction: ', pageIdJSVar);

        if($.isFunction(pageIdJSVar)){
          resolvedPageId = pageIdJSVar();
        }

      } else if (selector.pageIdParam.length > 0) {
        pageIdJSVar = nike.objectDefined(selector.pageIdParam, undefined, true);
        if(pageIdJSVar !== undefined && pageIdJSVar !== null){
          resolvedPageId = pageIdJSVar;
        }

      } else if(selector.pageId.length > 0 &&
          selector.path.length == 0 &&
          selector.path.length == 0 &&
          selector.path.length == 0 &&
          selector.path.length == 0) {
        // No selectors defined - this must be the default page
        resolvedPageId = selector.pageId;
      }

      //Break if a valid page name was returned
      if(resolvedPageId !== defaultReturnValue &&
          resolvedPageId !== undefined &&
          resolvedPageId !== null &&
          resolvedPageId.length > 0){
        break;
      }
    } catch (ex) {
      nike.error('Error executing page selector: ', ex, 'Selector: ', selector);
    }
  }

  return resolvedPageId;
};


/******
 * Check data param that indicates if the tag should be cancelled
 */
nike.analytics.Tracking.isTagCancelled = function(trackData){
  var ret = trackData &&
     trackData.params &&
     (trackData.params.cancelTag &&
     (trackData.params.cancelTag.value === 'true' || trackData.params.cancelTag.value === true)) ||
      (trackData.saveDataForNextPageLoad === 'true' || trackData.saveDataForNextPageLoad === true);

  return ret;
};



/**
 * Send the tag.
 * This should ensure that any required dynamic data is present before the tag is fired.
 * This handles doing the replacement for dynamic data also -
 * TrackParams and their contained TrackElements support dynamic values
 */
nike.analytics.Tracking.sendTag = function(trackData) {

  // Find all values that need to be replaced
  var tracking = nike.analytics.Tracking;
  var util = nike.analytics.TrackingConfigUtil;

  var log = nike.analytics.Tracking.debug;

  log('Sending tag', trackData);

  //Setup listeners
  nike.listen(nike.Event.TRACKING_DYNAMIC_DATA_READY, dataReady);
  nike.listen(nike.Event.TRACKING_TAG_READY_FOR_MAPPING, sendTagToMapping);

  util.findPageElements(trackData.dataList, trackData.eventData, trackData, tracking.config.maxPageViewTagDelay, trackData.waitForData);



  /**
   * This fires when all the dynamic data is ready to be used to replace params and conditionals
   */
  function dataReady(event, data){

    //Make sure the dataReady event is for this tag
    log("dataReady Caller Check: ", trackData === data.caller, "TrackData: ", trackData, "Caller: ", data.caller);
    log("dataReady: data:", data);

    if(trackData === data.caller){
      //Remove listener
      nike.unlisten(nike.Event.TRACKING_DYNAMIC_DATA_READY, dataReady);

      //Replace all values
      util.replaceValues(trackData.params, data);

      // If there was eventData stored and this is a page view
      var isPageView = trackData.params[nike.analytics.Tracking.IS_PAGE_VIEW];
      if(isPageView && isPageView.value === true || isPageView.value === 'true') {

          var eventData = nike.analytics.TrackingConfigUtil.getLocalData('analyticsEventData', true);

          if(eventData) {
              $.extend(trackData.params, eventData);
          }

      }

      //Run all conditionals and remove any failed props
      util.evaluateTagConditionals(trackData.params);

      /*
       * Vendor info is required for loading tags, so we need to check for it before we send the tag to the mapping.
       * If it's not setup yet, we need to wait for it so we setup a listener that will send the tag to the mapping as soon as it's resolved.
       * If it is setup, we can send the tag right away.
       */
      if (!tracking.isVendorInfoLoaded) {
        log('Vendor info not yet set.  Waiting to send tag.')
        nike.listen(nike.Event.TRACKING_RESOLVE_VENDOR_INFO, vendorInfoListener);
      } else {


        //Send tag ready to be mapped event
        tagSentToMapping = true;
        nike.dispatchEvent(nike.Event.TRACKING_TAG_READY_FOR_MAPPING, {'caller': trackData});
      }
    }
  }

  function sendTagToMapping(event, data){
    var tracking = nike.analytics.Tracking;
    var trackData = data.caller;
    var log = tracking.debug;
    var tagReady = false;

    //Try to send tag when vendor info is resolved.  This will also make sure the appropriate caller is set.
    function vendorInfoListener(vendorEvent, vendorData){
      //Make sure it's only fired once, even if multiple vendorInfoResolved events are fired
      if(!vendorInfoResolved){
        vendorInfoResolved = true;
        sendTagToMapping(vendorEvent, $.extend({}, vendorData, {caller : data.caller }) );
      }
    }

    log("sendTagToMapping Caller Check: ", trackData === data.caller, "TrackData: ", trackData, "Caller: ", data.caller);
    if(data.caller && data.caller === trackData){
      nike.unlisten(nike.Event.TRACKING_TAG_READY_FOR_MAPPING, sendTagToMapping);

      //Vendor info is required for loading tags, so if it's not resolved yet, setup a listener and wait to send to mapping
      if (!tracking.isVendorInfoLoaded) {
        log('Vendor info not yet set.  Waiting to send tag.');
        nike.listen(nike.Event.TRACKING_RESOLVE_VENDOR_INFO, vendorInfoListener);
      } else {
        nike.unlisten(nike.Event.TRACKING_RESOLVE_VENDOR_INFO, vendorInfoListener);
        // Make sure userdata and vendor info is set
        trackData.userData = nike.analytics.Tracking.userData;
        tagReady = true;
      }

      if (tagReady) {
        log('Tag - pre session check:', trackData);
        var dataToStoreLocal = nike.analytics.TrackingConfigUtil.getDataForLocalStorage(trackData.params) || {};

        if(trackData.saveDataForNextPageLoad) {
            var eventData;
            eventData = nike.analytics.TrackingConfigUtil.getEventDataForLocalStorage(trackData.eventParams, trackData.params);
            nike.analytics.TrackingConfigUtil.saveLocalData(eventData, false, 'analyticsEventData');
        }

        if(!tracking.isTagCancelled(trackData)){
          //If it's not a page view, the local storage data should merge, otherwise overwrite it
          var mergeData = !trackData.params[nike.analytics.Tracking.IS_PAGE_VIEW].value;
          nike.analytics.TrackingConfigUtil.pushDataToLocalDatabase(dataToStoreLocal, mergeData, 'analyticsData');

          // Send tag to mapping functions which will make the actual request
          log('Sending tag to mapping functions:');
          log('     VendorInfo', nike.analytics.Tracking.vendorInfo);
          log('     Tag', trackData);

          nike.analytics.Tracking.sendOmnitureRequest(trackData);
          // If we have the necessary data setup on the crossSell gadget, we already fired this request.
          if(!nike.analytics.Tracking.certonaRequestSetup){
              nike.exp.global.CookieSettingsCheck.queueFPCall(function() {
                nike.analytics.Tracking.sendCertonaRequest(trackData,  nike.analytics.CertonaMapping);
              });
          }

          nike.exp.global.CookieSettingsCheck.queueAdCall(function() {
            nike.analytics.Tracking.sendMarketingRequest(trackData);
          });
        } else {
          //If the tag is cancelled, just save any local storage data.  This should always merge
          nike.analytics.TrackingConfigUtil.pushDataToLocalDatabase(dataToStoreLocal, true, 'analyticsData');
            //Fire tags sent event
            nike.dispatchEvent(nike.Event.TAG_SEND_COMPLETE, trackData);
        }
        nike.analytics.Tracking.registerEventListeners();
      }
      tracking.executeMarketingTags();
    }

    //Fire tags sent event
    nike.dispatchEvent(nike.Event.TAG_SEND_COMPLETE, trackData);
  }
};

/**
 * Event listeners should be registered only after the first tag is sent
 */
nike.analytics.Tracking.registerEventListeners = function(){

    if(!nike.analytics.Tracking.eventListenersRegistered)
    {
        //Set event listener flag to true so we don't register the events more than once
        nike.analytics.Tracking.eventListenersRegistered = true;

        //Setup event listeners
        nike.analytics.Tracking.setupEventListenersForPage();

        nike.dispatchEvent(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, {});
    }
};


nike.analytics.Tracking.initialTrackData = [];
/******************************************
 * Send omniture tags if vendor is configured
 *****************************************/
/**
 * Nikestore and Cole Haan have separate Omniture mapping, but both are using tracking.js to send tags
 * to their respective collection servers. Below logic sends tag based on which object is defined, where
 * nike.analytics.omnitureSupport is defined only for Store.
 */
nike.analytics.Tracking.sendOmnitureRequest = function(trackData){
    var pageViewKey = nike.analytics.Tracking.IS_PAGE_VIEW;
    if (nike.analytics.Tracking.isAnalyticsFrameworkAvailable() && nike.analytics.Tracking.vendorInfo['omniture']) {
        // Send omniture tag for store
        var isPageView = trackData.params[pageViewKey].value === true || trackData.params[pageViewKey].value == 'true';
        nike.exp.global.CookieSettingsCheck.queueFPCall(function() {
          nike.analytics.Tracking.debug('     Send omniture tag');
          trackData.isPageView = isPageView;
          trackData.vendorInfo = nike.analytics.Tracking.vendorInfo['omniture'];
          nike.analytics.AnalyticsSupport.sendAnalyticsRequestFor(trackData.vendorInfo.vendorName, trackData);
        });
    }
    else{
      nike.log('===========================   queueing for later');
      nike.analytics.Tracking.initialTrackData.push(trackData);
    }
};
/**
 * utility function to send tag when required Analytics support script is loaded and data is ready
 */
nike.analytics.Tracking.analyticsSupportReady = function(){
  nike.analytics.Tracking.analyticsSupportIsReady = true;
  nike.dispatchEvent(nike.Event.ANALYTICS_SUPPORT_READY, { vendor: "omniture" });
  var dataLength = nike.analytics.Tracking.initialTrackData.length;
  for(var i=0;i<dataLength;i++){
    nike.analytics.Tracking.sendOmnitureRequest(nike.analytics.Tracking.initialTrackData[i]);
  }
};
/**
 * Check to see if we are using the newer analytics framework
 * @return {Boolean}
 */
nike.analytics.Tracking.isAnalyticsFrameworkAvailable = function(){
    return nike.analytics.Tracking.analyticsSupportIsReady;
};

/******************************************
 * Send certona tags if vendor configured
 *****************************************/
nike.analytics.Tracking.sendCertonaRequest = function (trackData, certonaMapping) {
    if (certonaMapping && nike.analytics.Tracking.vendorInfo[certonaMapping.VENDOR_NAME]) {
      nike.analytics.Tracking.debug('     Send certona tag');
      certonaMapping.trackEvent(trackData, nike.analytics.Tracking.vendorInfo[certonaMapping.VENDOR_NAME]);
    }
};

/***********************************************
 * Send any generic marketing tags on page view
 ***********************************************/
nike.analytics.Tracking.sendMarketingRequest = function (trackData) {
    var marketingUrls;
    var marketingUrlElement;
    var marketingUrlValue;
    var i;
    var L;
    var j;
    var L1;

    marketingUrls = trackData.params['marketingUrls'];

    if (trackData.params[nike.analytics.Tracking.IS_PAGE_VIEW].value && marketingUrls && marketingUrls.trackElements.length > 0) {
        nike.analytics.Tracking.debug('     Sending marketing tags', marketingUrls);
        //Send each url as an img request
        for (i = 0, L = marketingUrls.trackElements.length; i < L; i++) {
            marketingUrlElement = marketingUrls.trackElements[i];
            if (marketingUrlElement.values.length > 0) {
                for (j = 0, L1 = marketingUrlElement.values.length; j < L1; j++) {
                    marketingUrlValue = marketingUrlElement.values[j];
                    nike.analytics.Tracking.queueMarketingTag(marketingUrlValue.type, marketingUrlValue.value);
                }
            } else {
                nike.analytics.Tracking.queueMarketingTag('image', marketingUrlElement.value);
            }
        }


        nike.analytics.Tracking.executeMarketingTags();
    }
};

//Execute queued marketing tags
nike.analytics.Tracking.executeMarketingTags = function () {
  var tracking = nike.analytics.Tracking;
  var debug = tracking.debug;
  var i, L;

  L = tracking.marketingTagImages.length;
  if(L > tracking.maxConcurrentMarketingTags){
    L = tracking.maxConcurrentMarketingTags;
  }



  for (i = 0; i < L; i++) {
    executeTag();
  }


  function executeTag(){
    var mktgTags = tracking.marketingTagImages;
    var imgRequest;
    //Get next tag from queue
    if(mktgTags.length > 0){
      imgRequest = mktgTags.shift();

      debug("Sending Tag: " + imgRequest.tagUrl);
      debug("Tags Left: " + tracking.marketingTagImages.length);

      if(tracking.isDebugEnabled){
        imgRequest.startTime = (new Date()).getTime();
      }

      imgRequest.img.onload = cleanUpTag;
      imgRequest.img.src = imgRequest.tagUrl;
      imgRequest.clearMeTimeout = setTimeout(cleanUpTag, tracking.maxMarketingTagLoadTime);
    }

    function cleanUpTag(){
      var i, L;
      var endTime;

      //Debugging
      if(tracking.isDebugEnabled){
        endTime = (new Date()).getTime();
        debug('TagRequestRemoved');
        debug('Url: ' + imgRequest.img.src);
        debug('Duration (ms): ' + (endTime - imgRequest.startTime));
      }

      //Clear src and clear timeout
      imgRequest.img.src = '';
      clearTimeout(imgRequest.clearMeTimeout);
      imgRequest.onload = undefined;

      //Execute the next tag
      if(tracking.marketingTagImages.length > 0){
        executeTag();
      }
    }
  }
};

/********************************
 * Function to queue a mktg tag
 ********************************/
nike.analytics.Tracking.queueMarketingTag = function (tagType, tagUrl){
  var imgRequest;
  var tracking = nike.analytics.Tracking;
  var debug = tracking.debug;
  var mktgTags = tracking.marketingTagImages;

  debug('Queueing tag: ', tagUrl);
  if(tagType == "script"){
    //Add tag as a script
    debug('queueing MarketingScript');
    $.getScript(tagUrl)
  } else {
    //Add tag as an image request
    imgRequest = {img: new Image(), tagUrl: tagUrl};
    mktgTags.push(imgRequest);
  }
};

/**
 * This will get the site id based on the appname, presentation, and region in the tracking config.
 *
 */
nike.analytics.Tracking.resolveSiteId = function(presentation, siteName) {

    var defaultSiteId;
    var US_HTML_PRESENTATION = 70;
    var US_MOBILE_PRESENTATION = 73;
    var EU_HTML_PRESENTATION = 71;
    var EU_MOBILE_PRESENTATION = 74;


    if (siteName == 'store') {
	  if (nike.REGION == "US") {
	    if (presentation == 'html') {
	      defaultSiteId = US_HTML_PRESENTATION;
	    } else if (presentation == 'mobile') {
	      defaultSiteId = US_MOBILE_PRESENTATION;
	    } else {
	      nike.warn("US store is not configured with a default Site ID for presentation " + presentation);
	    }
	  }
	  else if (nike.REGION == "EMEA") {
        if (presentation == 'html') {
	      defaultSiteId = EU_HTML_PRESENTATION;
	    } else if (presentation == 'mobile') {
	      defaultSiteId = EU_MOBILE_PRESENTATION;
	    } else {
	      nike.warn("EMEA store is not configured with a default Site ID for presentation " + presentation);
	    }
	  }
	  else {
	    nike.warn("Region " + nike.REGION + " is not configured with a default Site ID.");
	  }
	}
	else {
	  nike.warn("Site " + siteName + " is not configured with a default Site ID.");
	}

	return defaultSiteId;
};


/********************************
 * List of all defined events
 ********************************/
nike.analytics.Tracking.trackingEvents = {
  SimpleProductView : 'SimpleProductView',
  ProductView : 'ProductView',
  GiftCardProductView : 'GiftCardProductView',
  MiniPDPProductView : 'MiniPDPProductView',
  NikeIdProductView : 'NikeIdProductView',
  ProductViewDuplicate : 'ProductViewDuplicate',
  CartAdd : 'CartAdd',
  CartAddNikeId : 'CartAddNikeId',
  CartAddFromCheckout : 'CartAddFromCheckout',
  CartRemove : 'CartRemove',
  CartOpen : 'CartOpen',
  CartView : 'CartView',
  CheckoutStart : 'CheckoutStart',
  CheckoutStartFromCart : 'CheckoutStartFromCart',
  CheckoutStartFromPDP : 'CheckoutStartFromPDP',
  Purchase : 'Purchase',
  ShippingAmount: 'ShippingAmount',
  TaxAmount: 'TaxAmount',
  VasRevenueAmount : 'VasRevenueAmount',
  Register : 'Register',
  SearchSuccess : 'SearchSuccess',
  EmailSignup : 'EmailSignup',
  Login : 'Login',
  LoginViaOverlay : 'LoginViaOverlay',
  LoginAttempted : 'LoginAttempted',
  AddToLocker : 'AddToLocker',
  AddToLockerFromInline : 'AddToLockerFromInline',
  AddToLockerFromIdBuilder: 'AddToLockerFromIdBuilder',
  NikeIdAddToLocker : 'NikeIdAddToLocker',
  AddToLockerFromCheckout : 'AddToLockerFromCheckout',
  AddGiftcardToCart : 'AddGiftcardToCart',
  GiftCardCrossSell : 'GiftCardCrossSell',
  CrossSellClick : 'CrossSellClick',
  CrossSellClickFromCheckout : 'CrossSellClickFromCheckout',
  RegistrationStart : 'RegistrationStart',
  RegistrationStartFromCheckout : 'RegistrationStartFromCheckout',
  OutOfStockProductSelected : 'OutOfStockProductSelected',
  ProductReviewSubmit : 'ProductReviewSubmit',
  NikeIdProductReviewSubmit : 'NikeIdProductReviewSubmit',
  NikeIdProductReviewStart : 'NikeIdProductReviewStart',
  RegistrationComplete : 'RegistrationComplete',
  KialaLocationSelected : 'KialaLocationSelected',
  NikeIdBuilderStart : 'NikeIdBuilderStart',
  NikeIdBuilderComplete : 'NikeIdBuilderComplete',
  NikeIdReviewStarClicked : 'NikeIdReviewStarClicked',
  NikeIdBuilderDesignColorComplete : 'NikeIdBuilderDesignColorComplete',
  NikeIdBuilderPiDComplete : 'NikeIdBuilderPiDComplete',
  NikeIdBuilderSizingComplete : 'NikeIdBuilderSizingComplete',
  NikeIdBuilderPerformanceComplete : 'NikeIdBuilderPerformanceComplete',
  NikeIdBuilderStepView : 'NikeIdBuilderStepView',
  NikeIdHtml5BuilderTrackingEnhancements: 'NikeIdHtml5BuilderTrackingEnhancements',
  ToutImpression : 'ToutImpression',
  ToutClick : 'ToutClick',
  navItemSelection : 'navItemSelection',
  LeftNavClick : 'LeftNavClick',
  AdViewthrough : 'AdViewthrough', //Tracks if user has saw an ad and visited the site.  Not sure how this is done.
  AdImpression : 'AdImpression', //Similar to viewThrough.  Not sure how to track.
  AdClick : 'AdClick', //Similar to AdImpressing and AdViewThrough.  Not sure how to track.
  Error : 'Error',
  EmailSent : 'EmailSent', //Something about ET integration? No idea.
  EmailDelivered : 'EmailDelivered', //Something about ET integration? No idea.
  EmailOpened : 'EmailOpened', // Probably not tracked with this script,
  EmailLinkClick : 'EmailLinkClicked', // Not sure how to track
  EmailUnsubscribe : 'EmailUnsubscribe', // ET integration
  EmailTotalBounces : 'EmailTotalBounces', // ET integration
  SurveyView : 'SurveyViews',
  SurveyResponse : 'SurveyResponse',
  StoreLocator : 'StoreLocator',
  CartridgeClick : 'CartridgeClick',
  CartValue : 'CartValue',
  SearchFail : 'SearchFail',
  OutOfStockValue : 'OutOfStockValue',
  CheckOutValue : 'CheckOutValue',
  HelpRequest : 'HelpRequest',
  GridwallView : 'GridwallView',
  StorefrontView : 'StoreFrontView',
  ShareEvent : 'ShareEvent',
  AddToCartSuccessEvent: 'AddToCartSuccessEvent',
  PDPAddToCartSuccessEvent: 'PDPAddToCartSuccessEvent',
  DPiDAddToCartSuccessEvent: 'DPiDAddToCartSuccessEvent',
  ShareSuccessEvent : 'ShareSuccessEvent',
  MyLockerValue : 'MyLockerValue',
  MyLockerUnits : 'MyLockerUnits', // EDF-8969 - event44 and event45 are required in s.products string when tag is fired on Add To Mylocker event
  PDPFeatureImpression : 'PDPFeatureImpression',
  PDPFeatureClick : 'PDPFeatureClick',
  FacetSearchCompleted : 'FacetSearchCompleted',
  CartUnitsOnAbandon : 'CartUnitsOnAbandon',
  PageView : 'PageView',
  VideoViewed : 'VideoViewed',
  SiteInteraction: 'SiteInteraction',
  GridwallSearch : 'GridwallSearch',
  GridwallSearchNoResults : 'GridwallSearchNoResults',
  MobileSearch : 'MobileSearch',
  MobileSearchNoResults : 'MobileSearchNoResults',
  LanguageSelected : 'LanguageSelected',
  GeoSelected : 'GeoSelected',
  InternalPromotion : 'InternalPromotion',
  OrderSubmit : 'OrderSubmit',
  ContentClick : 'ContentClick',
  CheckoutUnits : 'CheckoutUnits',
  CheckoutValue : 'CheckoutValue',
  CheckoutUnitsFromPDP : 'CheckoutUnitsFromPDP',
  CheckoutValueFromPDP : 'CheckoutValueFromPDP',
  GiftWrapRevenue: 'GiftWrapRevenue', // event10
  ProductOutFitView: 'ProductOutFitView',
  ProductOutFitViewOOSItems: 'ProductOutFitViewOOSItems', //event38 - outfits that have OOS items
  DidYouMeanPresent: 'DidYouMeanPresent',
  DidYouMeanRedirect: 'DidYouMeanRedirect',
  TypeAheadSearchUsed: 'TypeAheadSearchUsed',
  UserTypedSearch: 'UserTypedSearch',
  TypeAheadSearch: 'TypeAheadSearch',
  DYMRedirect: 'DYMRedirect',
  AutoRedirectedSearch: 'AutoRedirectedSearch',
  SmartCartAddToCart: 'SmartCartAddToCart', // Not mapped, only to trigger linkTrackVars
  AddToCartCaptcha: 'AddToCartCaptcha', // Not mapped, only to trigger linkTrackVars
	AddProductsToSTL: 'AddProductsToSTL', // Not mapped, only to trigger linkTrackVars
  FSTVideoClick: 'FSTVideoClick', // full screen tout video click
  ValueAddedServiceRevenue : 'ValueAddedServiceRevenue',
  ICPDPCartAdd : 'ICPDPCartAdd',
  ICPDPCartAddSuccess : 'ICPDPCartAddSuccess',
  ModalMiniPDPDataLoaded: 'ModalMiniPDPDataLoaded',
  IcPdpProductView: 'IcPdpProductView',
  icPdpDataLoaded: 'icPdpDataLoaded',
  icPdpColorwayChange: 'icPdpColorwayChange',
  icPdpPersonalize: 'icPdpPersonalize',
  Personalize: 'Personalize',
  MaxCapacity: 'MaxCapacity',
  NikeIdEditDesign: 'NikeIdEditDesign',
  CustomizeOptionAvailable: 'CustomizeOptionAvailable',
  NikeIdAddToCartAttempt: 'NikeIdAddToCartAttempt',
  NikeIdAddToCartSuccess: 'NikeIdAddToCartSuccess',
  NikeIdBuildStartEdit: 'NikeIdBuildStartEdit',
  NikeIdPageViewLoad: 'NikeIdPageViewLoad',
  NikeIdEditModeBuilderReady: 'NikeIdEditModeBuilderReady',
  NikeIdInBuilderEventData: 'NikeIdInBuilderEventData',
  NikeIdGenderSelect: 'NikeIdGenderSelect',
  NikeIdBuyingToolsSizeSelected: 'NikeIdBuyingToolsSizeSelected',
  NikeIdProductString: 'NikeIdProductString',
  NikeIdLoadPrebuildMyDesign: 'NikeIdLoadPrebuildMyDesign',
  ProductPosition: 'ProductPosition'
};


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.Tracking. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}



try{
var nike = nike || {};
nike.namespace('jQuery.formatCurrency');
nike.requireDependency('jQuery');

//  This file is part of the jQuery formatCurrency Plugin.
//
//    The jQuery formatCurrency Plugin is free software: you can redistribute it
//    and/or modify it under the terms of the GNU General Public License as published 
//    by the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.

//    The jQuery formatCurrency Plugin is distributed in the hope that it will
//    be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
//    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License along with 
//    the jQuery formatCurrency Plugin.  If not, see <http://www.gnu.org/licenses/>.

//    http://code.google.com/p/jquery-formatcurrency/
//    version - 1.4.0

(function($) {

	$.formatCurrency = {};

	$.formatCurrency.regions = [];

	// default Region is en
	$.formatCurrency.regions[''] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.fn.formatCurrency = function(destination, settings) {

		if (arguments.length == 1 && typeof destination !== "string") {
			settings = destination;
			destination = false;
		}

		// initialize defaults
		var defaults = {
			name: "formatCurrency",
			colorize: false,
			region: '',
			global: true,
			roundToDecimalPlace: 2, // roundToDecimalPlace: -1; for no rounding; 0 to round to the dollar; 1 for one digit cents; 2 for two digit cents; 3 for three digit cents; ...
			eventOnDecimalsEntered: false
		};
		// initialize default region
		defaults = $.extend(defaults, $.formatCurrency.regions['']);
		// override defaults with settings passed in
		settings = $.extend(defaults, settings);

		// check for region setting
		if (settings.region.length > 0) {
			settings = $.extend(settings, getRegionOrCulture(settings.region));
		}
		settings.regex = generateRegex(settings);

		return this.each(function() {
			var $this = $(this);

			// get number
			var num = '0';
			num = $this[$this.is('input, select, textarea') ? 'val' : 'html']();

			//identify '(123)' as a negative number
			if (num.search('\\(') >= 0) {
				num = '-' + num;
			}

			if (num === '' || (num === '-' && settings.roundToDecimalPlace === -1)) {
				return;
			}

			// if the number is valid use it, otherwise clean it
			if (isNaN(num)) {
				// clean number
				num = num.replace(settings.regex, '');
				
				if (num === '' || (num === '-' && settings.roundToDecimalPlace === -1)) {
					return;
				}
				
				if (settings.decimalSymbol != '.') {
					num = num.replace(settings.decimalSymbol, '.');  // reset to US decimal for arithmetic
				}
				if (isNaN(num)) {
					num = '0';
				}
			}
			
			// evalutate number input
			var numParts = String(num).split('.');
			var isPositive = (num == Math.abs(num));
			var hasDecimals = (numParts.length > 1);
			var decimals = (hasDecimals ? numParts[1].toString() : '0');
			var originalDecimals = decimals;
			
			// format number
			num = Math.abs(numParts[0]);
			num = isNaN(num) ? 0 : num;
			if (settings.roundToDecimalPlace >= 0) {
				decimals = parseFloat('1.' + decimals); // prepend "0."; (IE does NOT round 0.50.toFixed(0) up, but (1+0.50).toFixed(0)-1
				decimals = decimals.toFixed(settings.roundToDecimalPlace); // round
				if (decimals.substring(0, 1) == '2') {
					num = Number(num) + 1;
				}
				decimals = decimals.substring(2); // remove "0."
			}
			num = String(num);

			if (settings.groupDigits) {
				for (var i = 0; i < Math.floor((num.length - (1 + i)) / 3); i++) {
					num = num.substring(0, num.length - (4 * i + 3)) + settings.digitGroupSymbol + num.substring(num.length - (4 * i + 3));
				}
			}

			if ((hasDecimals && settings.roundToDecimalPlace == -1) || settings.roundToDecimalPlace > 0) {
				num += settings.decimalSymbol + decimals;
			}

			// format symbol/negative
			var format = isPositive ? settings.positiveFormat : settings.negativeFormat;
			var money = format.replace(/%s/g, settings.symbol);
			money = money.replace(/%n/g, num);

			// setup destination
			var $destination = $([]);
			if (!destination) {
				$destination = $this;
			} else {
				$destination = $(destination);
			}
			// set destination
			$destination[$destination.is('input, select, textarea') ? 'val' : 'html'](money);

			if (
				hasDecimals && 
				settings.eventOnDecimalsEntered && 
				originalDecimals.length > settings.roundToDecimalPlace
			) {
				$destination.trigger('decimalsEntered', originalDecimals);
			}

			// colorize
			if (settings.colorize) {
				$destination.css('color', isPositive ? 'black' : 'red');
			}
		});
	};

	// Remove all non numbers from text
	$.fn.toNumber = function(settings) {
		var defaults = $.extend({
			name: "toNumber",
			region: '',
			global: true
		}, $.formatCurrency.regions['']);

		settings = jQuery.extend(defaults, settings);
		if (settings.region.length > 0) {
			settings = $.extend(settings, getRegionOrCulture(settings.region));
		}
		settings.regex = generateRegex(settings);

		return this.each(function() {
			var method = $(this).is('input, select, textarea') ? 'val' : 'html';
			$(this)[method]($(this)[method]().replace('(', '(-').replace(settings.regex, ''));
		});
	};

	// returns the value from the first element as a number
	$.fn.asNumber = function(settings) {
		var defaults = $.extend({
			name: "asNumber",
			region: '',
			parse: true,
			parseType: 'Float',
			global: true
		}, $.formatCurrency.regions['']);
		settings = jQuery.extend(defaults, settings);
		if (settings.region.length > 0) {
			settings = $.extend(settings, getRegionOrCulture(settings.region));
		}
		settings.regex = generateRegex(settings);
		settings.parseType = validateParseType(settings.parseType);

		var method = $(this).is('input, select, textarea') ? 'val' : 'html';
		var num = $(this)[method]();
		num = num ? num : "";
		num = num.replace('(', '(-');
		num = num.replace(settings.regex, '');
		if (!settings.parse) {
			return num;
		}

		if (num.length == 0) {
			num = '0';
		}

		if (settings.decimalSymbol != '.') {
			num = num.replace(settings.decimalSymbol, '.');  // reset to US decimal for arthmetic
		}

		return window['parse' + settings.parseType](num);
	};

	function getRegionOrCulture(region) {
		var regionInfo = $.formatCurrency.regions[region];
		if (regionInfo) {
			return regionInfo;
		}
		else {
			if (/(\w+)-(\w+)/g.test(region)) {
				var culture = region.replace(/(\w+)-(\w+)/g, "$1");
				return $.formatCurrency.regions[culture];
			}
		}
		// fallback to extend(null) (i.e. nothing)
		return null;
	}

	function validateParseType(parseType) {
		switch (parseType.toLowerCase()) {
			case 'int':
				return 'Int';
			case 'float':
				return 'Float';
			default:
				throw 'invalid parseType';
		}
	}
	
	function generateRegex(settings) {
		if (settings.symbol === '') {
			return new RegExp("[^\\d" + settings.decimalSymbol + "-]", "g");
		}
		else {
			var symbol = settings.symbol.replace('$', '\\$').replace('.', '\\.');		
			return new RegExp(symbol + "|[^\\d" + settings.decimalSymbol + "-]", "g");
		}	
	}

})(jQuery);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.formatCurrency. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('jQuery.formatCurrency.all');
nike.requireDependency('jQuery.formatCurrency');
nike.requireDependency('jQuery');

//  This file is part of the jQuery formatCurrency Plugin.
//
//    The jQuery formatCurrency Plugin is free software: you can redistribute it
//    and/or modify it under the terms of the GNU General Public License as published 
//    by the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.

//    The jQuery formatCurrency Plugin is distributed in the hope that it will
//    be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
//    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License along with 
//    the jQuery formatCurrency Plugin.  If not, see <http://www.gnu.org/licenses/>.

//    http://code.google.com/p/jquery-formatcurrency/
//    version - 1.4.0


(function($) {

	$.formatCurrency.regions['af-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['am-ET'] = {
		symbol: 'ETB',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-AE'] = {
		symbol: 'د.إ.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-BH'] = {
		symbol: 'د.ب.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-DZ'] = {
		symbol: 'د.ج.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-EG'] = {
		symbol: 'ج.م.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-IQ'] = {
		symbol: 'د.ع.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-JO'] = {
		symbol: 'د.ا.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-KW'] = {
		symbol: 'د.ك.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-LB'] = {
		symbol: 'ل.ل.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-LY'] = {
		symbol: 'د.ل.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-MA'] = {
		symbol: 'د.م.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-OM'] = {
		symbol: 'ر.ع.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-QA'] = {
		symbol: 'ر.ق.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-SA'] = {
		symbol: 'ر.س.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-SY'] = {
		symbol: 'ل.س.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-TN'] = {
		symbol: 'د.ت.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ar-YE'] = {
		symbol: 'ر.ي.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['arn-CL'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['as-IN'] = {
		symbol: 'ট',
		positiveFormat: '%n%s',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['az-Cyrl-AZ'] = {
		symbol: 'ман.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['az-Latn-AZ'] = {
		symbol: 'man.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['ba-RU'] = {
		symbol: 'һ.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['be-BY'] = {
		symbol: 'р.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['bg-BG'] = {
		symbol: 'лв',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['bn-BD'] = {
		symbol: '৳',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['bn-IN'] = {
		symbol: 'টা',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['bo-CN'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['br-FR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['bs-Cyrl-BA'] = {
		symbol: 'КМ',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['bs-Latn-BA'] = {
		symbol: 'KM',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ca-ES'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['co-FR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['cs-CZ'] = {
		symbol: 'Kč',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['cy-GB'] = {
		symbol: '£',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['da-DK'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['de-AT'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['de-CH'] = {
		symbol: 'SFr.',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: '\'',
		groupDigits: true
	};

	$.formatCurrency.regions['de-DE'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['de-LI'] = {
		symbol: 'CHF',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: '\'',
		groupDigits: true
	};

	$.formatCurrency.regions['de-LU'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['de'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['dsb-DE'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['dv-MV'] = {
		symbol: 'ރ.',
		positiveFormat: '%n %s',
		negativeFormat: '%n %s-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['el-GR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['en-029'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-AU'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-BZ'] = {
		symbol: 'BZ$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-CA'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-GB'] = {
		symbol: '£',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-IE'] = {
		symbol: '€',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-IN'] = {
		symbol: 'Rs.',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-JM'] = {
		symbol: 'J$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-MY'] = {
		symbol: 'RM',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-NZ'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-PH'] = {
		symbol: 'Php',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-SG'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-TT'] = {
		symbol: 'TT$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-US'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['en-ZW'] = {
		symbol: 'Z$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-AR'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-BO'] = {
		symbol: '$b',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-CL'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-CO'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-CR'] = {
		symbol: '₡',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-DO'] = {
		symbol: 'RD$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-EC'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-ES'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-GT'] = {
		symbol: 'Q',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-HN'] = {
		symbol: 'L.',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-MX'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-NI'] = {
		symbol: 'C$',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-PA'] = {
		symbol: 'B/.',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-PE'] = {
		symbol: 'S/.',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-PR'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-PY'] = {
		symbol: 'Gs',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-SV'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-US'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['es-UY'] = {
		symbol: '$U',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es-VE'] = {
		symbol: 'Bs',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['es'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['et-EE'] = {
		symbol: 'kr',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: '.',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['eu-ES'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['fa-IR'] = {
		symbol: 'ريال',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '/',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['fi-FI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fil-PH'] = {
		symbol: 'PhP',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['fo-FO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-BE'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-CA'] = {
		symbol: '$',
		positiveFormat: '%n %s',
		negativeFormat: '(%n %s)',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-CH'] = {
		symbol: 'SFr.',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: '\'',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-FR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-LU'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fr-MC'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fr'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['fy-NL'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ga-IE'] = {
		symbol: '€',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['gl-ES'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['gsw-FR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['gu-IN'] = {
		symbol: 'રૂ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ha-Latn-NG'] = {
		symbol: 'N',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['he-IL'] = {
		symbol: '₪',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['hi-IN'] = {
		symbol: 'रु',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['hr-BA'] = {
		symbol: 'KM',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['hr-HR'] = {
		symbol: 'kn',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['hsb-DE'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['hu-HU'] = {
		symbol: 'Ft',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['hy-AM'] = {
		symbol: 'դր.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['id-ID'] = {
		symbol: 'Rp',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ig-NG'] = {
		symbol: 'N',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ii-CN'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['is-IS'] = {
		symbol: 'kr.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['it-CH'] = {
		symbol: 'SFr.',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: '\'',
		groupDigits: true
	};

	$.formatCurrency.regions['it-IT'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['it'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['iu-Cans-CA'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['iu-Latn-CA'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ja-JP'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ja'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ka-GE'] = {
		symbol: 'Lari',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['kk-KZ'] = {
		symbol: 'Т',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '-',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['kl-GL'] = {
		symbol: 'kr.',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['km-KH'] = {
		symbol: '៛',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['kn-IN'] = {
		symbol: 'ರೂ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ko-KR'] = {
		symbol: '₩',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['kok-IN'] = {
		symbol: 'रु',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ky-KG'] = {
		symbol: 'сом',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: '-',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['lb-LU'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['lo-LA'] = {
		symbol: '₭',
		positiveFormat: '%n%s',
		negativeFormat: '(%n%s)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['lt-LT'] = {
		symbol: 'Lt',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['lv-LV'] = {
		symbol: 'Ls',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['mi-NZ'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['mk-MK'] = {
		symbol: 'ден.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ml-IN'] = {
		symbol: 'ക',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['mn-MN'] = {
		symbol: '₮',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['mn-Mong-CN'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['moh-CA'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['mr-IN'] = {
		symbol: 'रु',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ms-BN'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ms-MY'] = {
		symbol: 'R',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['mt-MT'] = {
		symbol: 'Lm',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['nb-NO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['ne-NP'] = {
		symbol: 'रु',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['nl-BE'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['nl-NL'] = {
		symbol: '€',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['nn-NO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['nso-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['oc-FR'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['or-IN'] = {
		symbol: 'ଟ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['pa-IN'] = {
		symbol: 'ਰੁ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['pl-PL'] = {
		symbol: 'zł',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['prs-AF'] = {
		symbol: '؋',
		positiveFormat: '%s%n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ps-AF'] = {
		symbol: '؋',
		positiveFormat: '%s%n',
		negativeFormat: '%s%n-',
		decimalSymbol: '٫',
		digitGroupSymbol: '٬',
		groupDigits: true
	};

	$.formatCurrency.regions['pt-BR'] = {
		symbol: 'R$',
		positiveFormat: '%s %n',
		negativeFormat: '-%s %n',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['pt-PT'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['qut-GT'] = {
		symbol: 'Q',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['quz-BO'] = {
		symbol: '$b',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['quz-EC'] = {
		symbol: '$',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['quz-PE'] = {
		symbol: 'S/.',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['rm-CH'] = {
		symbol: 'fr.',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: '\'',
		groupDigits: true
	};

	$.formatCurrency.regions['ro-RO'] = {
		symbol: 'lei',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['ru-RU'] = {
		symbol: 'р.',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['rw-RW'] = {
		symbol: 'RWF',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sa-IN'] = {
		symbol: 'रु',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['sah-RU'] = {
		symbol: 'с.',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['se-FI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['se-NO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['se-SE'] = {
		symbol: 'kr',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['si-LK'] = {
		symbol: 'රු.',
		positiveFormat: '%s %n',
		negativeFormat: '(%s %n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['sk-SK'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sl-SI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sma-NO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sma-SE'] = {
		symbol: 'kr',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['smj-NO'] = {
		symbol: 'kr',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['smj-SE'] = {
		symbol: 'kr',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['smn-FI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sms-FI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sq-AL'] = {
		symbol: 'Lek',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sr-Cyrl-BA'] = {
		symbol: 'КМ',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sr-Cyrl-CS'] = {
		symbol: 'Дин.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sr-Latn-BA'] = {
		symbol: 'KM',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sr-Latn-CS'] = {
		symbol: 'Din.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sv-FI'] = {
		symbol: '€',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['sv-SE'] = {
		symbol: 'kr',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['sw-KE'] = {
		symbol: 'S',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['syr-SY'] = {
		symbol: 'ل.س.‏',
		positiveFormat: '%s %n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ta-IN'] = {
		symbol: 'ரூ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['te-IN'] = {
		symbol: 'రూ',
		positiveFormat: '%s %n',
		negativeFormat: '%s -%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['tg-Cyrl-TJ'] = {
		symbol: 'т.р.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ';',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['th-TH'] = {
		symbol: '฿',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['tk-TM'] = {
		symbol: 'm.',
		positiveFormat: '%n%s',
		negativeFormat: '-%n%s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['tn-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['tr-TR'] = {
		symbol: 'TL',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['tt-RU'] = {
		symbol: 'р.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['tzm-Latn-DZ'] = {
		symbol: 'DZD',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['ug-CN'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['uk-UA'] = {
		symbol: 'грн.',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['ur-PK'] = {
		symbol: 'Rs',
		positiveFormat: '%s%n',
		negativeFormat: '%s%n-',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['uz-Cyrl-UZ'] = {
		symbol: 'сўм',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['uz-Latn-UZ'] = {
		symbol: 'su\'m',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['vi-VN'] = {
		symbol: '₫',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: '.',
		groupDigits: true
	};

	$.formatCurrency.regions['wo-SN'] = {
		symbol: 'XOF',
		positiveFormat: '%n %s',
		negativeFormat: '-%n %s',
		decimalSymbol: ',',
		digitGroupSymbol: ' ',
		groupDigits: true
	};

	$.formatCurrency.regions['xh-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['yo-NG'] = {
		symbol: 'N',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh-CN'] = {
		symbol: '￥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh-HK'] = {
		symbol: 'HK$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh-MO'] = {
		symbol: 'MOP',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh-SG'] = {
		symbol: '$',
		positiveFormat: '%s%n',
		negativeFormat: '(%s%n)',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh-TW'] = {
		symbol: 'NT$',
		positiveFormat: '%s%n',
		negativeFormat: '-%s%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zh'] = {
		symbol: '¥',
		positiveFormat: '%s%n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

	$.formatCurrency.regions['zu-ZA'] = {
		symbol: 'R',
		positiveFormat: '%s %n',
		negativeFormat: '%s-%n',
		decimalSymbol: '.',
		digitGroupSymbol: ',',
		groupDigits: true
	};

})(jQuery);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.formatCurrency.all. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.CurrencyUtil');

nike.requireDependency('jQuery.formatCurrency');
nike.requireDependency('jQuery.formatCurrency.all');

/**
 * Returns a string with the currency formatted for the specified ISO Currency Code
 * @param {Number|String} numberToFormat - Something like '1,349.00' OR 1349
 * @param {String} iso - Something like USD or EUR
 * @param {String} [format] - Something like '$0.00' OR '0,00 €'
 * @returns {String}
 */
nike.CurrencyUtil.formatCurrency = function(numberToFormat, iso, format){
  var tempTotal = $('<span></span>');
  tempTotal.html(numberToFormat);

  var formattedPrice = tempTotal.formatCurrency({region: nike.CurrencyUtil.getCurrencyCodeFromISO(iso)}).html();

  // formatCurrency returns the currency with the symbol in the wrong place in some locales
  // if the format is defined, use it to place it in the correct place
  if( format ){
    // replace the number with a token that we'll replace with the price
    format = format.replace(/[\d,.]+/, '~P~');
    // remove any pricing characters or spaces before reformatting
    return format.replace( /~P~/, formattedPrice.replace(/[\s\W]+/, '') );
  }else{
    return formattedPrice;
  }
};

nike.CurrencyUtil.getCurrencyCodeFromISO = function (iso) {
  var countryCode;

  switch(iso) {
    case 'USD':
      countryCode = 'en-US';
      break;
    case 'GBP':
      countryCode = 'en-GB';
      break;
    case 'SEK':
      countryCode = 'sv-SE';
      break;
    case 'DKK':
      countryCode = 'da-DK';
      break;
    case 'PLN':
      countryCode = 'pl-PL';
      break;
    case 'JPY':
      countryCode = 'ja-JP';
      break;
    case 'CNY':
      countryCode = 'zh-CN';
      break;
    case 'EUR':
      //This can be many countries, and we don't want to use the locale because it might not match the EUR currency. Manually find it.
      countryCode = nike.CurrencyUtil.getCountryCodeByCountry(nike.COUNTRY);
      break;
    default:
      // ISO not found! use the locale then.
      countryCode = nike.LOCALE.replace('_','-');
      break;
  }

  return countryCode;
};

nike.CurrencyUtil.getCountryCodeByCountry = function(country) {
    var code;

    switch(country.toUpperCase()) {
      case 'GB':
        code = 'en-GB';
        break;
      case 'IT':
        code = 'it-IT';
        break;
      case 'ES':
        code = 'es-ES';
        break;
      case 'FR':
        code = 'fr-FR';
        break;
      case 'DE':
        code = 'de-DE';
        break;
      case 'BE':
        code = 'fr-BE';
        break;
      case 'CZ':
        code = 'cs-CZ';
        break;
      case 'AT':
        code = 'de-AT';
        break;
      case 'DK':
        code = 'da-DK';
        break;
      case 'FI':
        code = 'fi-FI';
        break;
      case 'GR':
        code = 'el-GR';
        break;
      case 'HU':
        code = 'hu-HU';
        break;
      case 'IE':
        code = 'en-IE';
        break;
      case 'LU':
        code = 'fr-LU';
        break;
      case 'NL':
        code = 'nl-NL';
        break;
      case 'PL':
        code = 'pl-PL';
        break;
      case 'PT':
        code = 'pt-PT';
        break;
      case 'SI':
        code = 'sl-SI';
        break;
      case 'SE':
        code = 'se-SE';
        break;
      case 'JP':
        code = 'ja-JP';
        break;
      default:
        // Picking a code that always produces the Euro, in case we don't know the country.
        code = 'nl-NL';
        break;
    }
    return code;
};

/**
 * Retrieves the ISO 4217 code for the major currency in the passed country
 *
 * @param {String} country ISO 3166 short (Alpha-2) code for a country
 * @returns {String}
 */
nike.CurrencyUtil.getCurrencyCodeByCountry = function(country) {
    var code;

    switch(country.toUpperCase()) {
      case 'AT':
      case 'BE':
      case 'DE':
      case 'ES':
      case 'FI':
      case 'FR':
      case 'GR':
      case 'IE':
      case 'IT':
      case 'LU':
      case 'NL':
      case 'PT':
      case 'SK':
        code = 'EUR';
        break;
      case 'PR':
      case 'US':
        code = 'USD';
        break;
      case 'AE':
        code = 'AED';
        break;
      case 'AR':
        code = 'ARS';
        break;
      case 'AU':
        code = 'AUD';
        break;
      case 'BG':
        code = 'BGN';
        break;
      case 'BR':
        code = 'BRL';
        break;
      case 'BZ':
        code = 'BZD';
        break;
      case 'CA':
        code = 'CAD';
        break;
      case 'CH':
        code = 'CHF';
        break;
      case 'CL':
        code = 'CLP';
        break;
      case 'CN':
        code = 'CNY';
        break;
      case 'CZ':
        code = 'CZK';
        break;
      case 'DK':
        code = 'DKK';
        break;
      case 'EG':
        code = 'EGP';
        break;
      case 'GB':
        code = 'GBP';
        break;
      case 'HK':
        code = 'HKD';
        break;
      case 'HR':
        code = 'HRK';
        break;
      case 'HU':
        code = 'HUF';
        break;
      case 'ID':
        code = 'IDR';
        break;
      case 'IL':
        code = 'ILS';
        break;
      case 'IN':
        code = 'INR';
        break;
      case 'JP':
        code = 'JPY';
        break;
      case 'KR':
        code = 'KRW';
        break;
      case 'MA':
        code = 'MAD';
        break;
      case 'MX':
        code = 'MXN';
        break;
      case 'MY':
        code = 'MYR';
        break;
      case 'NO':
        code = 'NOK';
        break;
      case 'NZ':
        code = 'NZD';
        break;
      case 'PH':
        code = 'PHP';
        break;
      case 'PL':
        code = 'PLN';
        break;
      case 'RO':
        code = 'RON';
        break;
      case 'RU':
        code = 'RUB';
        break;
      case 'SA':
        code = 'SAR';
        break;
      case 'SE':
        code = 'SEK';
        break;
      case 'SG':
        code = 'SGD';
        break;
      case 'SI':
        code = 'SIT';
        break;
      case 'TH':
        code = 'THB';
        break;
      case 'TR':
        code = 'TRY';
        break;
      case 'TW':
        code = 'TWD';
        break;
      case 'UY':
        code = 'UYU';
        break;
      case 'VN':
        code = 'VND';
        break;
      case 'ZA':
        code = 'ZAR';
        break;
      default:
        code = '';
        break;
    }
    return code;
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.CurrencyUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
//resxclsa.js v3.5 Copyright 2004-2011 Certona Corporation www.certona.com
/*
 * twill - Removed 'nike.analytics.certonaResx.run();' so we can call it manually
 *         namespaced certona function so it conforms to our standards (replaced certonaResx with nike.analytics.certonaResx)
 *         TODO: namespace global resx variable (this might be a bad idea since it's a vendor library)
 */

nike.namespace('nike.analytics.certonaResx');
nike.requireDependency('nike.exp.global.CookieSettingsCheck');

nike.analytics.certonaResx = function() {
  var ak = false,
  ay = null,
  di = location.protocol.toLowerCase() == "https:" ? "https://" : "http://",
  cm = "www.res-x.com",
  cj = "/ws/r2/Resonance.aspx",
  cs = "4.2x",
  i = "RES_TRACKINGID",
  s = "RES_SESSIONID",
  ai = "ResonanceSegment",
  b = "",
  l = "",
  d = "",
  ao = "",
  z = "",
  o = false,
  u = "nike.analytics.certonaResx.showResponse",
  ac = false,
  h = false,
  n = 0;

  function k(df) {
    return parseInt(df, 10);
  }

  function a(dl) {
    try {
      if (dl != null && dl != "null" && dl != "") {
        return true;
      }
    } catch (ex) {}
    return false;
  }

  function aq() {
    return resx.rrelem;
  }

  function at(cf) {
    try {
      var bf = null;
      if (a(cf)) {
        bf = new Array();
        if (a(document.getElementById(cf))) {
          bf[0] = cf;
        } else {
          var by = cf.replace(/[,;\-:]/g, ".").split(".");
          for (var ag = 0; ag < by.length; ag++) {
            if (a(document.getElementById(by[ag]))) {
              bf[ag] = by[ag];
            } else {
              bf[ag] = "";
            }
          }
        }
      }
      return bf;
    } catch (ex) {
      c("", ex);
    }
    return null;
  }

  function m() {
    try {
      if (resx.rrelem !== undefined) {
        var e = at(aq());
        if (e != null) {
          var t = null;
          for (var ag = 0; ag < e.length; ag++) {
            t = document.getElementById(e[ag]);
            if (a(t)) {
              t.style.visibility = "visible";
            }
          }
        }
      }
    } catch (ex) {}
  }

  function c(de, af) {
    try {
      if (!ak) {
        ak = true;
        ay = escape(de + "|" + (af.number !== undefined ? af.number : "undefined") + "|" + (af.name !== undefined ? af.name : "undefined") + "|" + (af.description !== undefined ? af.description : "undefined"));
      }
    } catch (ex) {} finally {
      m();
    }
  }

  function ae(ah) {
    try {
      if (document.cookie.length > 0) {
        var y = document.cookie.indexOf(ah + "=");
        if (y != -1) {
          y += ah.length + 1;
          var bl = document.cookie.indexOf(";", y);
          if (bl == -1) {
            bl = document.cookie.length;
          }
          return unescape(document.cookie.substring(y, bl));
        }
      }
    } catch (ex) {
      c("", ex);
    }
    return null;
  }

  function q(ah, dr, as, dn, cx) {
    try {
      var ax = new Date();
      if (as != null) {
        ax.setTime(ax.getTime() + (as * 3600 * 1000));
      }
      nike.exp.global.CookieSettingsCheck.queueFPCall(function() {
        document.cookie = ah + "=" + escape(dr) + ((a(as)) ? "; expires=" + ax.toGMTString() : "") + ((a(dn)) ? "; path=" + dn : "; path=/") + ((a(cx)) ? "; domain=" + cx : "");
      })
    } catch (ex) {
      c("", ex);
    }
  }

  function bz(dt, dq) {
    try {
      if (dq !== undefined && dq != null) {
        for (var ag = 0; ag < dq.length; ag++) {
          if ((dq[ag] + "") == dt) {
            return true;
          }
        }
      }
    } catch (ex) {}
    return false;
  }

  function bw() {
    try {
      var x = resx.rrec !== undefined && (resx.rrec == true || resx.rrec == "true") && d == "1" && !ak;
      if (x) {
        if (!h) {
          x = false;
          if (resx.rrelem !== undefined) {
            var e = at(aq());
            if (e != null) {
              for (var ag = 0; ag < e.length; ag++) {
                if (a(e[ag])) {
                  x = true;
                  break;
                }
              }
            }
          }
        }
        if (x) {
          if (resx.useitems === undefined || !a(resx.useitems)) {
            x = false;
            if (resx.rrnum !== undefined) {
              var ds = resx.rrnum + "";
              ds = ds.replace(/,/g, ";");
              var co = ds.split(";");
              for (var ag = 0; ag < co.length; ag++) {
                if (!isNaN(co[ag]) && k(co[ag]) > 0) {
                  x = true;
                  break;
                }
              }
            }
          }
        }
      }
      return x;
    } catch (ex) {}
    return false;
  }

  function dk(df) {
    try {
      var dh = "";
      df += "";
      for (var ag = df.length - 1; ag >= 0; ag--) {
        dh += df.charAt(ag);
      }
      return dh;
    } catch (ex) {}
    return "";
  }

  function ad() {
    try {
      var dp = "";
      if (navigator.userAgent.toLowerCase().indexOf("mac") == -1) {
        dp = Math.floor(Math.random() * 1000000000000000);
        dp += "";
      } else {
        var bt = Math.floor(Math.random() * 1000000),
        dg = new Date(),
        cd = dg.getTime();
        cd += "";
        var cn = dk(cd);
        bt += "";
        dp = bt + cn.substring(0, 11);
      }
      return dp;
    } catch (ex) {
      c("guid", ex);
    }
    return "";
  }

  function bi(bh, bp, az, dd, dc, dj) {
    try {
      var be = "",
      aj = null,
      cv = "";
      if (typeof bh === "object") {
        aj = document.getElementsByTagName("a");
      } else {
        var bs = document.getElementById(bh);
        if (a(bs)) {
          aj = bs.getElementsByTagName("a");
          cv = bh;
        }
      }
      if (aj !== undefined && aj != null) {
        var al = null,
        bo = null,
        bn = null,
        cl = 0,
        bk = "",
        an = "",
        bx = "",
        bj = "",
        ck = "",
        au = null;
        if (a(bp)) {
          bn = -1;
          bo = new Array();
          for (var ag = 0; ag < bp.length; ag++) {
            al = document.getElementById(bp[ag]);
            if (a(al)) {
              au = al.getElementsByTagName("a");
              for (var dx = 0; dx < au.length; dx++) {
                bn++;
                bo[bn] = au[dx] + "";
              }
            }
          }
        }
        for (var ag = 0; ag < aj.length; ag++) {
          if (cl == dj) {
            break;
          }
          bk = aj[ag] + "";
          if (a(bk)) {
            an = escape(bk);
            bj = "";
            if (a(az)) {
              an = an.match(az) + "";
            }
            if (a(an)) {
              bj = an.match(dd) + "";
            }
            if (a(bj + "")) {
              if (!bz(bk, bo)) {
                ck = an.match(dc) + "";
                bx = bj + escape("|") + cv + escape("|") + (a(ck) ? ck : "") + ";";
                if (be.indexOf(bx) == -1) {
                  be += bx;
                  cl++;
                }
              }
            }
          }
        }
      }
      return be;
    } catch (ex) {
      c("gpl", ex);
    }
    return "";
  }

  function ct(aa) {
    try {
      ac = true;
      if (!h) {
        var t = null;
        for (var ag = 0; ag < aa.Resonance.Response.length; ag++) {
          if (aa.Resonance.Response[ag].display == "yes") {
            t = document.getElementById(aa.Resonance.Response[ag].scheme);
            if (a(t)) {
              t.innerHTML = aa.Resonance.Response[ag].output;
            }
          }
        }
      }
    } catch (ex) {} finally {
      m();
    }
  }

  function bv() {
    try {
      if (!ac && !h) {
        if (n < 2000) {
          n = n + 50;
          window.setTimeout(nike.analytics.certonaResx.checkCallback, 50);
        } else {
          h = true;
          m();
        }
      }
    } catch (ex) {
      m();
    }
  }

  function cr(p) {
    try {
      var cc = "",
      j = "",
      ab = "";
      if (typeof p === "boolean" && p === true) {
        if (resx.rrcall !== undefined && a(resx.rrcall)) {
          j = resx.rrcall;
        } else {
          j = u;
        }
      } else if (typeof p === "string") {
        j = p;
      }
      if (j.length > 0) {
        if (j == u) {
          ab = "&cb=";
        } else {
          ab = "&ccb=";
        }
        ab += j;
      }
      cc = (resx.useitems !== undefined && a(resx.useitems) ? "&ui=" + resx.useitems : "&no=" + resx.rrnum) + (resx.exitemid !== undefined && a(resx.exitemid) ? "&ex=" + resx.exitemid : "") + (resx.rrqs !== undefined ? "&" + resx.rrqs : "") + ab;
      return cc;
    } catch (ex) {}
    return "";
  }

  function bu() {
    try {
      var w = location.hostname;
      if (a(w)) {
        if (!w.match(/(\d{1,3}\.){3}\d{1,3}/)) {
          var cb = w.split(".");
          if (cb.length > 1) {
            w = "." + cb[cb.length - 2] + "." + cb[cb.length - 1];
            var dv = /\.(co|com)\.\w{2}$/;
            if (w.toLowerCase().match(dv) && cb.length > 2) {
              w = "." + cb[cb.length - 3] + w;
            }
          }
        }
        return w;
      }
    } catch (ex) {
      c("gcd", ex);
    }
    return null;
  }

  function ce(cq) {
    try {
      var av = location.search,
      y = av.indexOf("?" + cq + "=");
      if (y == -1) {
        y = av.indexOf("&" + cq + "=");
      }
      if (y > -1) {
        y = y + cq.length + 2;
        var bl = av.indexOf("&", y);
        if (bl == -1) {
          return av.substring(y);
        } else {
          return av.substring(y, bl);
        }
      }
    } catch (ex) {}
    return null;
  }

  function bg() {
    try {
      var br = "",
      db = "";
      for (var ag = 0; ag < 51; ag++) {
        if (resx["cv" + ag] !== undefined) {
          db = resx["cv" + ag] + "";
          db = db.replace(/\+/g, "%2B");
          br += "&cv" + ag + "=" + encodeURIComponent(db);
        }
      }
      return br;
    } catch (ex) {
      c("gcv", ex);
    }
    return "";
  }

  function bm(g) {
    try {
      var r = {
        callback: false
      };
      if (g === undefined) {
        var g = r;
      } else {
        for (var aw in r) {
          if (g[aw] === undefined) {
            g[aw] = r[aw];
          }
        }
      }
      ak = false;
      ay = null;
      b = "";
      l = "";
      d = "";
      ao = "";
      z = "";
      o = false;
      ac = false;
      h = false;
      n = 0;
      var f = bu();
      if (location.search.indexOf("resxtrack=") > 0 && (resx.trackingid === undefined || !a(resx.trackingid))) {
        b = ce("resxtrack");
      }
      if (resx.trackingid === undefined || !a(resx.trackingid)) {
        if (!isNaN(k(b))) {
          q(i, b, 87648, null, f);
          if (!a(ae(i))) {
            q(i, b, null, null, f);
          }
          q(s, "", -1, null, f);
        } else {
          b = ae(i);
          if (isNaN(k(b))) {
            b = ad();
            q(i, b, 87648, null, f);
            if (!a(ae(i))) {
              q(i, b, null, null, f);
            }
          }
        }
        if (resx.segment === undefined || !a(resx.segment)) {
          var v = k(b);
          if (!isNaN(v) && v > 0) {
            v += "";
            v = v.substring(1, 6);
            v = k(v);
            var ch = k(resx.top1),
            cg = k(resx.top2),
            da = k(resx.top3),
            du = 100000;
            if (!(isNaN(ch) && isNaN(cg) && isNaN(da))) {
              if (isNaN(ch)) {
                ch = 0;
              }
              if (isNaN(cg)) {
                cg = ch;
              }
              if (isNaN(da)) {
                da = cg;
              }
              if (v < ch) {
                d = "1";
              } else if (v < cg) {
                d = "2";
              } else if (v < da) {
                d = "3";
              } else if (v < du) {
                d = "4";
              }
            }
          }
          q(ai, d, 1440, null, f);
          if (!a(ae(ai))) {
            q(ai, d, null, null, f);
          }
        }
      } else {
        b = resx.trackingid;
      }
      if ((resx.sessionid === undefined || !a(resx.sessionid)) && (resx.trackingid === undefined || !a(resx.trackingid))) {
        l = ae(s);
        if (!a(l)) {
          l = ad();
        }
        q(s, l, .5, null, f);
        if (!a(ae(s))) {
          q(s, l, null, null, f);
        }
      } else {
        l = resx.sessionid;
      }
      if (resx.segment !== undefined && a(resx.segment)) {
        d = resx.segment;
      }
      if (isNaN(k(d))) {
        d = "1";
      }
      if (resx.pageid !== undefined && a(resx.pageid)) {
        ao = resx.pageid;
      } else {
        ao = ad();
      }
      var bd = (resx.links !== undefined ? resx.links + "" : "");
      if (a(bd)) {
        var ar = bd.replace(/\,/g, ";").replace(/\|/g, "%7C").split(";", 50);
        for (var ag = 0; ag < ar.length; ag++) {
          z += ar[ag] + ";";
        }
      }
      var bc = (resx.maxl !== undefined && !isNaN(resx.maxl) ? k(resx.maxl) : 20),
      bb = (resx.lkmatch !== undefined ? resx.lkmatch : ""),
      ca = (resx.ltmatch !== undefined ? resx.ltmatch : "");
      if (a(bb)) {
        var ba = (resx.plkmatch !== undefined ? resx.plkmatch : ""),
        e = null;
        if (resx.rrelem !== undefined) {
          e = at(aq());
        }
        if (e != null) {
          for (var ag = 0; ag < e.length; ag++) {
            if (a(e[ag])) {
              z += bi(e[ag], null, ba, bb, ca, 50);
            }
          }
        }
        if (bc > 0) {
          z += bi(document, e, ba, bb, ca, bc);
        }
      }
      if (((typeof g.callback === "string" && g.callback != u) || g.callback == false) || (resx.rrcall !== undefined && a(resx.rrcall) && resx.rrcall != u)) {
        h = true;
      }
      o = bw() && a(b) && a(ao);
      if (!o) {
        m();
      }
    } catch (ex) {
      c("pv", ex);
    }
  }

  function cw(p) {
    try {
      if (d == "1" || d == "2" || d == "3") {
        if (o) {
          window.setTimeout(nike.analytics.certonaResx.checkCallback, 50);
        }
        var ap = "appid=" + (resx.appid !== undefined ? resx.appid : "") + "&tk=" + (a(b) ? b : "") + "&ss=" + (a(l) ? l : "") + "&sg=" + (a(d) ? d : "") + "&pg=" + (a(ao) ? ao : "") + "&vr=" + cs + "&bx=" + o + "&CountryCode=" + resx.country + "&CurrencyCode=" + resx.currency,
        cu = "";
        if (resx.rrelem !== undefined) {
          var cz = aq().replace(/[,;\-:]/g, ".").split(".");
          if (cz != null) {
            for (var ag = 0; ag < cz.length; ag++) {
              cu += "&sc=" + cz[ag];
            }
          }
        }
        ap += cu + (resx.event !== undefined ? "&ev=" + resx.event : "") + (resx.gearup !== undefined && resx.gearup != "" ? "&gearup=" + resx.gearup : "") + (resx.itemid !== undefined ? "&ei=" + resx.itemid : "") + (resx.qty !== undefined ? "&qty=" + resx.qty : "") + (resx.price !== undefined ? "&pr=" + resx.price : "") + (resx.shipping !== undefined ? "&sh=" + resx.shipping : "") + (resx.total !== undefined ? "&tt=" + resx.total : "") + (resx.currencycode !== undefined ? "&cc=" + resx.currencycode : "") + (resx.customerid !== undefined ? "&cu=" + resx.customerid : "") + (resx.transactionid !== undefined ? "&tr=" + resx.transactionid : "");
        ap += (o ? cr(p) : "") + bg() + "&ur=" + escape(location.href.substring(0, 400)) + "&plk=" + (a(z) ? z : "") + "&rf=" + escape(document.referrer) + ((ak) ? "&er=" + ak + "&em=" + ay : "");
        var ci = cm;
        if (resx.host !== undefined && a(resx.host)) {
          ci = resx.host;
        }
        var cy = di + ci + cj + "?" + ap;

        return (cy.substring(0, 2083));
      }
    } catch (ex) {
      c("", ex);
    }
    return "";
  }

  function cp(src) {
    try {
      if (src != "") {
        var am = document.createElement('script');
        am.type = 'text/javascript';
        am.async = true;
        am.src = src;
        var bq = document.getElementsByTagName('script')[0];
        bq.parentNode.insertBefore(am, bq);
        //this method takes the script source (containing the certona params) and stores it in an object
        jg(src);
      }
    } catch (ex) {
      c("", ex);
    }
  }

  function jg(src){
    nike.exp.certona = {};
    nike.exp.certona.requestUrl = src;
    src.split('?')[1].split('&').forEach(function(el){
      var split = el.split('=');
      nike.exp.certona[split[0]] = split[1];
    });


  }

  function dm(g) {
    var r = {
      callback: false
    };
    if (g === undefined) {
      var g = r;
    } else {
      for (var aw in r) {
        if (g[aw] === undefined) {
          g[aw] = r[aw];
        }
      }
    }
    return cw(g.callback);
  }

  function dw() {
    bm({
      callback: true
    });
    var src = cw(true);
    cp(src);
  }
  return {
    checkCallback: function() {
      bv();
    },
    showResponse: function(aa) {
      ct(aa);
    },
    getURL: function(g) {
      bm(g);
      return dm(g);
    },
    run: function() {
      dw();
    }
  }
}();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.certonaResx. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 *  Tools for interacting with certona service.  This is basically sending tags and getting recommendations
 */
nike.namespace('nike.analytics.crosssell.CertonaTools');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('nike.CurrencyUtil');
nike.requireDependency('nike.analytics.certonaResx');


nike.analytics.crosssell.CertonaTools = function(){
  var DEFAULT_TIMEOUT = 10000;

  //Build public object to return
  return {
    buildProductStrings : buildProductStrings,
    //Flag to indicate if setup has been run
    isInitialized : false,
    defaultEventName : undefined,

    /**
     * Available schemes that we can send to certona when requesting recommendations
     */
    recommendationSchemes : {
      INLINE_PDP : 'product_rr',
      NIKEID_PDP : 'nikeidpdp_rr',
      CART : 'cart_rr',
      PURCHASE : 'purchase_rr',

      NFL_BUILDER_PDP : 'nflbuilderpdp_rr',
      NFL_JERSEY_PDP : 'nfljerseypdp_rr',
      NFL_JERSEY_KID_PDP : 'nfljerseykidspdp_rr',

      PAGE_NOT_FOUND_1 : 'error4041_rr',
      PAGE_NOT_FOUND_2 : 'error4042_rr',
      PAGE_NOT_FOUND_3 : 'error4043_rr',

      NULL_SEARCH_1 : 'nosearch1_rr',
      NULL_SEARCH_2 : 'nosearch2_rr',

      INACTIVE_PDP_1 : 'inactivepdp1_rr',
      INACTIVE_PDP_2 : 'inactivepdp2_rr'

    },


    /*********************************
     * Setup resx object based on crossSellSetupData that is passed in
     *
     * crossSellSetupData:
     *  Required:
     *     crossSellHost : hostname to send tags to (dev or prod version) Ex. www.res-x.com
     *     appid : appId to use Ex. nike01
     *     country : current selected country Ex. us
     *     siteName : the name of the site determined by siteId Ex. nikecomprod  (see site id list in nike.analytics.Tracking.siteIdMap)
     *     products : Array of products in the current order or the order that was just placed Ex. [{productId: '12345', qty : '1', price : '100'}]
     *       Required for cart and purchase events
     *
     *  Order info (purchase events only):
     *     isPurchaseConfirm : true (set this only on a purchase event)
     *     orderId : order id for the purchase Ex. o1234567
     *     orderTotal : total for the order.  Todo: Which totals should this include (shipping, tax, just subtotal?)
     *
     *  Optional:
     *    defaultEventName: event name that will be used if none is specified.
     *    profileId : Users profile id
     *    userType : the usertype Ex. swoosh, default_user
     *    productImpressions : Array of products or productIds that the user is looking at Ex [{productId: '123456'}] or ['123456']
     *
     ********************************/
    setup : function(crossSellSetupData) {

      var resx = nike.analytics.certonaResx;

      //This has to be set in the global namespace to work properly
      if(!window.resx){
        window.resx = resx;
      }
      nike.debug("CertonaMapping: SetupData: ", crossSellSetupData);

      resx.host = crossSellSetupData.crossSellHost;
      resx.appid = crossSellSetupData.appId + crossSellSetupData.country;
      resx.top1 = 100000;
      resx.top2 = 100000;
      resx.links = buildProductIdList(crossSellSetupData.productImpressions);
      resx.cv1 = crossSellSetupData.siteName;
      resx.country = nike.COUNTRY;
      resx.currency = nike.CurrencyUtil.getCurrencyCodeByCountry(nike.COUNTRY);
      if(crossSellSetupData.outfitId){
        resx.cv3 = crossSellSetupData.outfitId;
      }
      resx.customerid = crossSellSetupData.profileId;
      resx.gearup = crossSellSetupData.gearup;

      var lineItems = buildProductStrings(crossSellSetupData.products);
      if (lineItems && lineItems.itemIds){
        //Setup vars for purchase/cart page
        resx.itemid = lineItems.itemIds;
        if (crossSellSetupData.isPurchaseConfirm)
        {
          resx.qty = lineItems.qtys;
          resx.price = lineItems.prices;
          resx.transactionid = crossSellSetupData.orderId;
          resx.total = crossSellSetupData.orderTotal;
        }
      }
      nike.analytics.crosssell.CertonaTools.defaultEventName = crossSellSetupData.defaultEventName;
      nike.analytics.crosssell.CertonaTools.isInitialized = true;
      nike.dispatchEvent(nike.Event.CERTONA_TOOLS_SETUP_COMPLETE, {});
    },

    /*********************************
     * This is used to track page events such as pageView or add to cart
     ********************************/
    sendTag : function(certonaEventName) {
      var eventName = !nike.Util.isBlank(certonaEventName) ? certonaEventName : nike.analytics.crosssell.CertonaTools.defaultEventName;
      nike.analytics.certonaResx.rrec=false;
      nike.analytics.certonaResx.event = eventName;
      nike.analytics.certonaResx.run();
    },


    /*******************************
     * This is used to request recommendations.  If you fire this you should not fire a separate pageView event.  This will fire the event along with the recommendations request.
     *
     * crossSellRequestData:
     *  Required:
     *    currency : Iso currency code (USD, GBP, EUR, etc)
     *    language : two char language (en, de, fr, es)
     *    numProducts : number of products to request
     *    schemeNames : array of scheme names - see nike.analytics.crosssell.CertonaTools.recommendationSchemes
     *
     *  Optional:
     *    eventName : event name to send with tag.  If not specified it will used whatever is currently sent in the resx object (this is probably what you want)
     *    successCallback : function for successful recommendation requests
     *    failCallback : function for failed recommendation requests
     *    timeout : the timeout to use for the request.  The default is defined at DEFAULT_TIMEOUT
     *    nflTeamName : if this request has an associated team, set it here
     *
     *
     *******************************/
    getRecommendations : function(crossSellRequestData) {

      var recommendationUrl;
      var hasRequiredParams;

      //Validate expected fields are present in request
      hasRequiredParams = validateRequired(crossSellRequestData, 'crossSellRequestData');

      if(hasRequiredParams){
        hasRequiredParams = hasRequiredParams && validateRequired(crossSellRequestData.currency, 'crossSellRequestData.currency');
        hasRequiredParams = hasRequiredParams && validateRequired(crossSellRequestData.language, 'crossSellRequestData.language');
        hasRequiredParams = hasRequiredParams && validateRequired(crossSellRequestData.numProducts, 'crossSellRequestData.numProducts');
        hasRequiredParams = hasRequiredParams && validateRequired(crossSellRequestData.schemeNames, 'crossSellRequestData.schemeNames');
      }

      if(hasRequiredParams){
        //Get recommendation url based on request data
        recommendationUrl = buildRecommendationUrl(crossSellRequestData);

        //Send request for recommendations
        nike.dispatchEvent(nike.Event.REQUESTING_CERTONA_RECOMMENDATIONS, { crossSellRequestData: crossSellRequestData, requestUrl: recommendationUrl});

        $.ajax({
          url: recommendationUrl,
          dataType: 'jsonp',
          jsonp : 'jsonp',
          timeout : crossSellRequestData.timeout || DEFAULT_TIMEOUT,
          success: function (response) {
            //Extract products from certona response
            var productLists = extractProductsFromCertonaResponse(response);

            //TODO: This should be figured out based on the response from certona and should be localized

            nike.dispatchEvent(nike.Event.CERTONA_RECOMMENDATIONS_SUCCESS, {
              crossSellRequestData: crossSellRequestData, requestUrl: recommendationUrl, productLists: productLists, response: response });

            if(crossSellRequestData.successCallback){
              crossSellRequestData.successCallback(productLists);
            }
          },
          error: function (jqXHR, textStatus, errorThrown) {
              // Can be used for debugging if there are json parsing errors from bad data

            nike.dispatchEvent(nike.Event.CERTONA_RECOMMENDATIONS_FAIL, {
              crossSellRequestData: crossSellRequestData, requestUrl: recommendationUrl, errorType: textStatus});

            if(crossSellRequestData.failCallback){
              crossSellRequestData.failCallback();
            }
          }
        });
      }
    }

  };


  /***********************
   * Helper functions
   ***********************/

  /**
   * Check that a required param is present and set
   */
  function validateRequired(param, paramName){
    var isPresent = !nike.Util.isBlank(param);
    if(!isPresent){
      nike.error('Param is required but it was empty.  ParamName: ' + paramName );
    }
    return isPresent;
  }

  /**
   * Build the request url to get certona recommendations based on how the nike.analytics.certonaResx object is currently setup and the crossSellRequestData that is passed in
   * @param crossSellRequestData
   * @returns recommendationUrl
   */
  function buildRecommendationUrl(crossSellRequestData){

    var recommendationUrl = '';
    var eventName = !nike.Util.isBlank(crossSellRequestData.eventName) ? crossSellRequestData.eventName : nike.analytics.crosssell.CertonaTools.defaultEventName;

    // adding parameters needed for recommendation
    nike.analytics.certonaResx.event = eventName;
    nike.analytics.certonaResx.rrec = true;
    //Scheme names are semicolon delimited
    nike.analytics.certonaResx.rrelem = crossSellRequestData.schemeNames.join(';');
    nike.analytics.certonaResx.rrnum = crossSellRequestData.numProducts;
    nike.analytics.certonaResx.rrqs = 'language=' + crossSellRequestData.language + getTeamNameParams(crossSellRequestData.nflTeamName);
    //Build recommendation url
    recommendationUrl = nike.analytics.certonaResx.getURL();
    createAutomationObject(recommendationUrl);
    nike.exp.certona.requestUrl = recommendationUrl;
    // deleting parameters added specifically for recommendations request.
    delete nike.analytics.certonaResx.rrec;
    delete nike.analytics.certonaResx.rrelem;
    delete nike.analytics.certonaResx.rrnum;
    delete nike.analytics.certonaResx.rrqs;

    if (crossSellRequestData.studio) {
      recommendationUrl = nike.util.UrlUtil.addParameter(recommendationUrl, 'studio', 'true');
    }

    return recommendationUrl;
  }

  /**
   * This method was added for the purposes of automation. It will take the most recent Certona request URL and
   * convert it into an object called nike.exp.certona.
   * @param url
   */
  function createAutomationObject(url){
    nike.exp = nike.exp || {};
    nike.exp.certona = {};
    var arr = url.split('?')[1].split('&');

    for (var x=0; x<arr.length; x++){
      var split = arr[x].split('=');
      nike.exp.certona[split[0]] = split[1];
    }
  }

  /**
   * Return the array of products returned by certona recommendation request
   */
  function extractProductsFromCertonaResponse(response){
    var productLists = [];
    var products = [];
    var i, L;
    var productIndex, productsLength;
    var tempProductList;
    var schemes=response.resonance.schemes;
    var title = '';
    var currentStoreUrl = undefined
    var certonaPdpRootUrl = undefined;
    var countryLocaleRegex = undefined;
    var currentCountryLocalePath = undefined;
    var currentStoreUrl = nike.getServiceUrl('baseStoreURL');

    if(nike.ENV_CONFIG === undefined || nike.ENV_CONFIG['certonaPdpRootUrl'] === undefined){
      nike.warn("CertonaTools: nike.ENV_CONFIG['certonaPdpRootUrl'] is required to replace pdp url to use the correct environment.")
    } else {
      certonaPdpRootUrl = nike.ENV_CONFIG['certonaPdpRootUrl'];
    }

    //Setup country lang locale replacement for urls
    if(!nike.Util.isBlank(nike.COUNTRY) && !nike.Util.isBlank(nike.LOCALE))
    {
      countryLocaleRegex = new RegExp('^' + currentStoreUrl.replace(/\./g, '\\.') + '[A-Za-z]{2}/[a-zA-Z]{2}_[a-zA-Z]{2}/(.*)');
      currentCountryLocalePath = nike.COUNTRY.toLowerCase() + '/' + nike.LOCALE.toLowerCase() + '/';
    }

    nike.debug("Certona Response: ", response);


    for(i=0, L=schemes.length; i < L; i++){


      //the first recommended item will be an empty object when service returns empty response.
      if (schemes[i].display == "yes" && !$.isEmptyObject(schemes[i].items[0])){

        tempProductList = {
            schemeName : schemes[i].scheme,
            explanation : schemes[i].explanation,
            products : schemes[i].items
        };

        //Fix pdp url so it use's correct base url
        if(currentStoreUrl !== undefined){
          //Remove the prod url from the pdpUrl that comes back from certona and prepend the base url for the current environment
          for(productIndex = 0, productsLength=tempProductList.products.length; productIndex < productsLength; productIndex++){

            //Remove production base url
            if(certonaPdpRootUrl !== undefined && currentStoreUrl !== undefined){
              tempProductList.products[productIndex].pdpURL = tempProductList.products[productIndex].pdpURL.replace(certonaPdpRootUrl, currentStoreUrl);
            }

            //Remove html encoded & from pdp URL (NIKEiD product has it)
            tempProductList.products[productIndex].pdpURL = tempProductList.products[productIndex].pdpURL.replace(/\&amp;/g, '&');

            //Update country/langLocale to match current country/lang_locale in pdp url
            if(countryLocaleRegex !== undefined && currentCountryLocalePath !== undefined && countryLocaleRegex.test(tempProductList.products[productIndex].pdpURL)){
              tempProductList.products[productIndex].pdpURL = tempProductList.products[productIndex].pdpURL.replace(countryLocaleRegex, currentStoreUrl + currentCountryLocalePath + '$1');
            }

            tempProductList.products[productIndex].pdpURL = tempProductList.products[productIndex].pdpURL.replace('pd//', 'pd/null/');

            //Remove html encoding from styleName
            tempProductList.products[productIndex].styleName =
              tempProductList.products[productIndex].styleName
                .replace(/\&amp;/g, '&')
                .replace(/&#\d*;/g, function (m) {
                  return String.fromCharCode(parseInt(m.substr(2), 10));
                });

          }

        }
        //Add tempProductList to product lists
        productLists.push(tempProductList);
      }
    }


    return productLists;
  }


  /**
   * Format the teamname param for the query string.  Currently this is only for nfl.
   */
  function getTeamNameParams(nflTeamName) {
      var textArray;
      var result = '';
      if(!nike.Util.isBlank(nflTeamName)){
        textArray = nflTeamName.split(',');

        result = '&league=nfl';
        for (var i = 0; i < textArray.length; i++) {
          result += '&nflteamname=' + textArray[i];
        }
      }
      return result;
  }


  /**
   * Build certona formatted productId list
   */
  function buildProductIdList (productArray){
    var i, L;
    var j, L1;
    var ret = '';
    var productIdArray = [];

    if(nike.Util.isDefined(productArray)){

      if(!(productArray instanceof Array)){
        nike.error("productArray must be an array");
      } else {
        for(i = 0, L = productArray.length; i < L; i++){
          if(typeof productArray[i] === "object"){
            if(productArray[i].hasOwnProperty('productId')){
              productIdArray.push(productArray[i].productId);

            }else if(productArray[i].hasOwnProperty('id')){
              productIdArray.push(productArray[i].id);

            } else {
              //Skip this because we don't know where the product id is in the object
              nike.warn("Skipping product because it's an object, but the product id is not in a property we expect (assuming it is a product object)");
            }

          } else if (typeof productArray[i] === "string" ){
            productIdArray.push(productArray[i]);

          } else if (typeof productArray[i] === "number" ){
            productIdArray.push(productArray[i].toString());

          } else {
            //Skip this because we dont know what it is
            nike.warn("Skipping product because we don't know how to get the product id");
          }
        }
      }

      if(productIdArray.length > 0){
        ret = formatArrayForTag(productIdArray, ret);
      }
    }


    nike.debug ('Formatted Certona productIds: ', ret);
    return ret;

  }


  /**
   * Function to concat productIds into a delimited string for the certona tag
   */
  function formatArrayForTag (productIdArray, existingValue, delimeter){
    var ret;
    var i, L;

    var theDelimiter = delimeter ? delimeter : ';';

    if(existingValue && existingValue.length > 0){
      ret = existingValue;

    } else {
      ret = '';
    }


    if(productIdArray && productIdArray.length > 0){
      for(i = 0, L = productIdArray.length; i < L; i++){
        if(ret.length > 0){
          ret += theDelimiter;
        }
        ret += productIdArray[i];
      }
    }
    return ret;
  }


  /**
   * Function to build product strings for purchased/cart products
   *
   */
  function buildProductStrings (products, delimiter){
    var i, L;
    var product;
    var itemIds = [];
    var qtys = [];
    var prices = [];
    var ret;

    if(nike.Util.isDefined(products) && products.length > 0){

      for(i = 0, L = products.length; i < L; i++){
        product = products[i];
        itemIds.push(product.productId);
        qtys.push(product.qty);
        prices.push(product.price);
      }

      ret = {
          itemIds : formatArrayForTag(itemIds,delimiter),
          qtys : formatArrayForTag(qtys,delimiter),
          prices : formatArrayForTag(prices,delimiter)
      }

    }
    return ret;
  }

}();


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.crosssell.CertonaTools. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.analytics.CertonaMapping');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.analytics.Tracking');
nike.requireDependency('nike.analytics.crosssell.CertonaTools');

nike.analytics.CertonaMapping = function() {
  //Flag to toggle logging because the debug statements in the tracking js are pretty verbose
  var isDebugEnabled = false;

  //wrap debug logging so it can be disabled just for tracking
  function debug(){
    if(isDebugEnabled){
      nike.debug.apply(this, arguments);
    }
  }
  
  return {
    VENDOR_NAME : 'certona',
    IS_CERTONA_PAGEVIEW_EVENT : 'isCertonaPageViewEvent',
    IS_CERTONA_EVENT: 'isCertonaEvent',

    trackEvent : function(tag, vendorInfo){
      var trackConfig = nike.analytics.Tracking.config;
      var isPageView = resolveParam(tag, nike.analytics.Tracking.IS_PAGE_VIEW) == 'true';
      var isPurchaseConfirm = resolveParam(tag, 'isPurchaseConfirm') == 'true';
      var certona = nike.analytics.CertonaMapping;
      
      // there is a possibility the siteId parameter is not set on PDP because of race condition.
      // if siteId parameter is not set, resolve siteId using tracking script method.
      var siteId = resolveParam(tag, 'siteId');
      if(!siteId) {
          siteId = nike.analytics.Tracking.resolveSiteId(trackConfig.presentation, trackConfig.siteName);
      }
      
      var eventName = resolveParam(tag, 'certonaEvent');
      var profileId = tag.userData.profileId;
      var userType = tag.userData.userType;
      var nflTeamName = resolveParam(tag, 'nflTeamName');
      var country = resolveParam(tag, 'country');
      var appId = resolveParam(tag, 'certonaAppId');
      var certonaEnabled = resolveParam(tag, 'certonaEnabled');
      var whitelistedParams = resolveParam(tag, 'whiteListedParams');
      var productImpressions =normalizeProducts(getParamValue(tag.params.productImpressions));
      var products = getProductsFromTag(tag);
      var outfitId = resolveParam(tag, 'outfitId');
      
      var csData;
      
      if(nike.util.BooleanUtil.getBoolean(certonaEnabled, false)){
        if(!nike.objectDefined('nike.ENV_CONFIG.certonaHost')){
          nike.error('Certona mapping must have the host defined.  This should come from the ENV_CONFIG map in the nike object.  No certona tag will be sent.');
        } else if (nike.Util.isBlank(appId)){
          nike.error('Certona app id cannot be blank')
        } else if (nike.Util.isBlank(country)){
          nike.error('Country cannot be blank')
        } else {
          //Build certonaDataRequest
          var csData = {
              crossSellHost : nike.ENV_CONFIG.certonaHost,
              appId : appId,
              country : country,
              productImpressions : productImpressions,
              profileId : profileId,
              userType : userType,
              nflTeamName : nflTeamName,
              products : products,
              gearup : whitelistedParams
          };
      
          if(resolveParam(tag, 'isPurchaseConfirm') == 'true'){
            //Order info (purchase events only)
            csData.isPurchaseConfirm = true;
            csData.orderId = resolveParam(tag, 'orderId');
            csData.orderTotal = resolveParam(tag, 'orderTotal');
          }
      
          //Set the defaultEventName if it's a pageview
          if(isPageView){
            csData.defaultEventName = eventName;  
          }
          
          if(outfitId){
            csData.outfitId = outfitId;
          }
          //Setup certona tools with tracking data from current tag
          nike.analytics.crosssell.CertonaTools.setup(csData);
      
          debug('isPageView: ', isPageView);
          
          if (isPageView && resolveParam(tag, certona.IS_CERTONA_PAGEVIEW_EVENT) == 'true')
          {
            debug("CERTONA_PAGEVIEW_EVENT firing of Certona tag");
            nike.analytics.crosssell.CertonaTools.sendTag(eventName);
            
          } else if (resolveParam(tag, certona.IS_CERTONA_EVENT) == 'true') {
            debug("IS_CERTONA_EVENT firing of Certona tag");
            nike.analytics.crosssell.CertonaTools.sendTag(eventName);
          }
        }
      }
    }
  };
  
  
  /**
   * Get object value for a track param
   * 
   * Note: This kinda sucks because it's very similar logic to what's done in the TagUtilType.js but since
   * those scripts are not managed in the script manager, I can't use them here. 
   */
  function getParamValue(trackParam){
    var i, L;
    var trackElements;
    var ret;
    
    if(nike.Util.isDefined(trackParam)){
      if(!nike.Util.isBlank(trackParam.value)){
        ret = trackParam.value;
        
      } else if (trackParam.trackElements.length > 0){
        ret = [];
        trackElements = trackParam.trackElements;
        
        for(i=0, L=trackElements.length; i < L; i++){
          if(!nike.Util.isBlank(trackElements[i].value)){
            if(trackElements[i].value instanceof Array){
              ret = ret.concat(trackElements[i].value);
            } else{
              ret.push(trackElements[i].value);
            } 
          } else if (trackElements[i].values instanceof Array){
            ret = ret.concat(trackElements[i].values);
          }
        }
      }
    }
    
    return ret;
  }
  
  
  //TODO: Refactor this to use getParamValue if it makes sense
  function resolveParam(tag, paramName){
    var param;
    var ret = '';
    var i,L;
  
    if(tag && tag.params && paramName){
      param = tag.params[paramName];
  
      if(param){
        if(param.value !== undefined && param.value != ''){
          // Make sure ret is a string before scrub it
          ret = param.value + '';
        } else if (param.trackElements && param.trackElements.length > 0){
          // If track elements are defined and value isn't, concatenate all the track element
          for (i=0, L=param.trackElements.length; i<L; i++) {
            // Convert value to string if it isn't already
            ret += param.trackElements[i].value + '';
          }
        }
      }
  
      debug('Param: ' + paramName + ' Value: ' + ret);
    }
    return ret;
  }
  
  
  
  //Normalize product format
  // If list of productIds, create a list of objects, each with a productId property
  // If list of product objects, just use it
  // If single productId, create a list with a single product object and add the id to the productId property
  // If single product object, put it in an array and use it
  function normalizeProducts(productsParam){
    var normalizedProducts = [];
    var product;
    var i, L;
    if(nike.Util.isDefined(productsParam)){
      
      if(productsParam instanceof Array){
        for(i = 0, L = productsParam.length; i < L; i++){
          product = productsParam[i];
  
          if(nike.Util.isDefined(product)){
           
            //Convert numeric product ids to strings to keep everything consistent
            if(typeof product === 'number'){
              product = product + '';
            }
            
            if(typeof product === 'string'){
              if(!nike.Util.isBlank(product)){
                normalizedProducts.push({productId : product, qty : '', price : ''});
              }
              
            } else {
              normalizedProducts.push(product);
            }
          }
        }
      } else {
        return normalizeProducts([productsParam]);
      }
    }
    return normalizedProducts;
  }
  
  function getProductsFromTag(tag){
    //Create a list of tag params that should be checked for product data in the order they should be checked.  The first one found will be used.
    //This allows us to have a certona specific product param incase the requirements for certona product reporting are different from other vendors
    var tp = tag.params;
    var orderedProductVarsToCheck = [tp.certonaProducts, tp.certonaProduct, tp.certonaProductId, tp.products, tp.product, tp.productId];
    var currentProductParam;
    var i, L;
    
    var ret = [];
    
    for(i=0, L=orderedProductVarsToCheck.length; i < L; i++){
      //If we havent found any products yet, check the next param in the list as long as it's defined
      currentProductParam = orderedProductVarsToCheck[i];
      if(ret.length == 0 && nike.Util.isDefined(getParamValue(currentProductParam))){
        ret = normalizeProducts(getParamValue(currentProductParam));
      } 
    }
    
    return ret;
  }
  
}();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.CertonaMapping. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.gadget.CartCount');

nike.requireDependency('nike.Cart');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.gadget.Event');

/**
 * Change the cart count in the header
 *
 * @param {HTMLElement|jQuery} element StoreHeader gadget element
 * @param {String} [cartCount] Number to change count to. If
 *        omitted it will be loaded from cartSummary
 *
 */
nike.gadget.CartCount.setup = function(element, cartCount){
  // If the cartCount is passed in, use it to update the cartCount
	if (typeof cartCount === "number" || typeof cartCount === "string"){
    nike.gadget.CartCount.updateCartCount(element, cartCount);
	}
	else{
    nike.gadget.CartCount.updateCartCount(element, nike.Cart.getCartCount());
	}
};

nike.gadget.CartCount.updateCartCount = function(element, cartCount){
  if(cartCount > 0 && cartCount !== "0") {
    var $el = $(element);
    var $cartCount = $el.find('.cartCount');
    var $cartCountGlobalNav = $el.find('.exp-cart-count');

    $cartCount.removeClass('hidden').html(cartCount);
    if ($cartCountGlobalNav.hasClass('hidden')) {
      $cartCountGlobalNav.removeClass('hidden');
    }
    $('.exp-cart-qty').html(cartCount);
    // hack to get the css to redraw - without .hide, .height followed by .show the cartCount was not being displayed:
    $cartCountGlobalNav.hide().height();
    $cartCountGlobalNav.show();

  } else {
    nike.gadget.CartCount.hideCartCount(element);
  }
};

nike.gadget.CartCount.hideCartCount = function(element){
  var $el = $(element);
  var $cartCount = $el.find('.cartCount');
  var $cartCountGlobalNav = $el.find('[js-hook="exp-cart-count"]');

  $cartCount.addClass('hidden');
  $cartCountGlobalNav.addClass('hidden');
};

/**
 * Setup gadget when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data){
	if (data &&
		data.gadgetName == 'nike.gadget.CartCount'){
			nike.gadget.CartCount.setup(data.element);
	}
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.CartCount. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.gadget.Gadget');

nike.requireDependency('Class');

/**
 * @extends Class
 */
nike.gadget.Gadget = Class.extend(
/** @lends nike.gadget.Gadget.prototype */
{
    gadgetElement: undefined,
    nikeBindings: {},

    /**
     * @constructs
     */
    init: function(el) {
        this.gadgetElement = el;
    },

    bindListeners: function() {
        if (this.nikeBindings) {
            this.bindNikeListeners();
        }
    },

    unbindListeners: function() {
      this.gadgetElement.unbind();
          if (this.nikeBindings) {
              this.unbindNikeListeners();
          }
    },

    bindNikeListeners: function() {
        var nikeBindings = this.nikeBindings,
            nikeEvent;

        for (nikeEvent in nikeBindings) {
            if (nikeBindings.hasOwnProperty(nikeEvent)) {
                // nikeBindings[nikeEvent] = $.proxy(nikeBindings[nikeEvent], this);
                nike.listen(nikeEvent, nikeBindings[nikeEvent]);
            }
        }
    },

    unbindNikeListeners: function() {
        var nikeBindings = this.nikeBindings,
            nikeEvent;

        for (nikeEvent in nikeBindings) {
            if (nikeBindings.hasOwnProperty(nikeEvent)) {
                nike.unlisten(nikeEvent, nikeBindings[nikeEvent]);
            }
        }
    },

    destroy: function(){
    },

    show: function() {
        this.gadgetElement.show();
    },

    hide: function() {
        this.gadgetElement.hide();
    }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.Gadget. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
/**
 * The LinkRedirector listens to events that can perform navigation
 * and responds by redirecting your browser if it listens to
 * that gadget.
 *
 * NOTE: You should only have one of these per page.  If you have more
 * than one, only the first one will work correctly.
 *
 * By default the following events are configured:
 *        nike.gadget.Event.STORE_NAV_CHANGED
 *        nike.gadget.Event.SEARCH
 *        nike.Event.FOOTER_LINK_CLICK
 *
 * JAVASCRIPT USAGE:
 *        var pageSetup = new nike.gadget.LinkRedirector.PageSetup();
 *        pageSetup.setupEvent(nike.gadget.Event.STORE_NAV_CHANGED, 300);
 *        pageSetup.setupEvent(nike.gadget.Event.SEARCH, 300);
 *        pageSetup.setupEvent(nike.Event.FOOTER_LINK_CLICK, 300);
 *        nike.gadget.LinkRedirector.setupPageEvents(pageSetup);
 *
 * HTML USAGE (preferred):
 *        <div  data-gadget="nike.gadget.LinkRedirector"
 *              data-redirect-for-gadget-events="STORE_NAV_CHANGED,SEARCH"
 *              data-redirect-for-events="FOOTER_LINK_CLICK"></div>
 *
 * EVENT DATA should include the following:
 *
 *  @config {String}          query       The URL to redirect the page to
 *  @config {Element|jQuery}  [element]   The element associated with this redirect (used with nike.gadgetListensTo)
 *  @config {Number}          [delay]     The delay to add to the redirect
 *  @config {Boolean}         [newWindow] TRUE if a new window needs to be opened (will ignore delay)
 *  @config {Boolean}         [noFollow]  TRUE if the page should not redirect at all and can be used as an override
 *
 * Specifying nike.gadget.LinkRedirector.overrideFunc with a function can be used to prevent any redirect
 * from taking place by returning FALSE.  This can be used to pop up a confirmation window if the page is about to redirect.
 *
 * Each event config can also have a condition function specified to allow a function to run to determine if an event should
 * trigger a redirect or not.
 *
 * The overrideFunc and the event config function has the following prototype:
 *      function ( {String} eventName, {Object} data ) { return (Boolean) }; TRUE to follow, FALSE otherwise.
 *
 * @namespace nike.gadget.LinkRedirector
 */
nike.namespace('nike.gadget.LinkRedirector');

nike.requireDependency('Class');
nike.requireDependency('jQuery');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.gadget.Gadget');
nike.requireDependency('nike.util.StringUtil');

//noinspection MagicNumberJS
/**
 * @extends nike.gadget.Gadget
 */
nike.gadget.LinkRedirector = nike.gadget.Gadget.extend(
/** @lends nike.gadget.LinkRedirector.prototype */
{

  /**
   * @type Number
   * @constant
   */
  DEFAULT_DELAY : 300,

  /**
   * The element of the gadget
   *
   * @type Element|jQuery
   */
  gadgetElement : undefined,

  /**
   * An object whose properties are event names and values are objects
   * with the following two properties:
   *
   * {Number}     delay           The delay before the page is redirected
   * {Function}   [continueFunc]  A function to execute to determine if a redirect should occur or not
   *
   * @type Object
   */
  eventConfig : {},

  /**
   * If events are specified on the gadget level, then this will be FALSE and will not
   * allow additional setup of events
   *
   * @type Boolean
   */
  allowMerge : true,

  /**
   * Sets up the gadget for use.  Should not be instantiated outside of this file.
   * Use the static function nike.gadget.LinkRedirector.setupPageEvents() to configure page with javascript.
   *
   * @constructs
   * @private
   */
  init : function (element) {
    var count, tempSetup;
    var queue = nike.gadget.LinkRedirector.queuedPageSetup;
    var gadgetEl = $(element);
    var gadgetEvents = gadgetEl.data('redirectForGadgetEvents');
    var normalEvents = gadgetEl.data('redirectForEvents');
    var events = [];

    this._super(element);

    // Look for any events defined in data attributes on the gadget HTML
    if(gadgetEvents || normalEvents) {
      if(gadgetEvents) {
        events = events.concat(this.getEventsFromKeys(nike.gadget.Event, gadgetEvents));
      }
      if(normalEvents) {
        events = events.concat(this.getEventsFromKeys(nike.Event, normalEvents));
      }

      if(events.length) {
        tempSetup = new nike.gadget.LinkRedirector.PageSetup(false);
        for(count = events.length; count; count--) {
          tempSetup.setupEvent(events.shift());
        }
        this.setupPageEvents(tempSetup);
        this.allowMerge = false;
      }
    } else {
      this.setupDefaultEvents();
    }

    // Check for queued page setup
    if(queue.length) {
      for(count = queue.length; count; count--) {
        this.setupPageEvents(queue.shift());
      }
    }

  },

  /**
   * Retrieves event strings based on a comma delimited string of keys
   *
   * @param {Object} namespace The namespace to look for the event name in
   * @param {String} keyString Comma delimited list of strings
   *
   * @return {String[]} An array of event names referenced by the key string
   */
  getEventsFromKeys : function (namespace, keyString) {
    var keys = keyString.split(",");
    var events = [];
    var index, curEvent;

    for(index = 0; index < keys.length; index++) {
      curEvent = namespace[nike.util.StringUtil.trim(keys[index])];
      if(typeof curEvent === 'string') {
        events.push(curEvent);
      }
    }

    return events;
  },

  /**
   * Sets up a default list of events that should trigger a redirect
   */
  setupDefaultEvents : function () {
    var defaultSetup = new nike.gadget.LinkRedirector.PageSetup();

    // By default these events will be listened to if the LinkRedirector is included in the page
    defaultSetup.setupEvent(nike.gadget.Event.SEARCH);
    defaultSetup.setupEvent(nike.gadget.Event.STORE_NAV_CHANGED);
    defaultSetup.setupEvent(nike.Event.FOOTER_LINK_CLICK);

    this.setupPageEvents(defaultSetup);
  },

  /**
   * Uses a PageSetup class to setup the events that this gadget should react to
   *
   * @param {nike.gadget.LinkRedirector.PageSetup} pageEvents The PageSetup class that defines what the gadget should react to
   */
  setupPageEvents : function (pageEvents) {
    var events = this.getAllowedMergeEvents(pageEvents.eventConfig);
    var index, curEvent, prevEvent, listenerFunc;
    var instance = this;

    if(!events.length) {
      // Do nothing if there is nothing to do
      return;
    }

    // Unbind the existing listeners
    this.unbindListeners();

    // If merge is not true, we are creating a brand new set of events
    if(pageEvents.merge !== true) {
      this.nikeBindings = {};
      this.eventConfig = {};
    }

    // Walk through all the defined events
    for(index = 0; index < events.length; index++) {

      curEvent = events[index];
      prevEvent = this.eventConfig[curEvent.eventName] || {};

      // Create an immutable copy of eventName
      listenerFunc = (function(eventName) {
        return function (event, data) {
          if(instance.checkIfFollowLink(eventName, data)) {
            instance.executeRedirect(eventName, data);
          }
        }
      })(curEvent.eventName);

      this.eventConfig[curEvent.eventName] = {
        delay : (curEvent.delay || curEvent === 0) ? curEvent.delay : prevEvent.delay,
        conditionFunc : curEvent.conditionFunc || prevEvent.conditionFunc
      };

      this.nikeBindings[curEvent.eventName] = listenerFunc;
    }

    // Bind the listeners
    this.bindListeners();

  },

  /**
   * Gets the allowed events to be configured.  Will only return the event configuration for the events
   * already defined at the gadget level if this.allowMerge is equal to FALSE.  Simply returns the array
   * without filtering if this.allowMerge is equal to TRUE.
   *
   * @param {Array<Object>} eventConfig
   * @return {Array<Object>} The filtered list of event configurations allowed
   */
  getAllowedMergeEvents : function (eventConfig) {
    var allowedEvents = [];
    var length = eventConfig.length;
    var index, curEvent;

    if(this.allowMerge === false) {
      // Determine what events are attempting to configure that have not been specified on the gadget
      for(index = 0; index < length; index++) {
        curEvent = eventConfig[index];
        if(!this.eventConfig[curEvent.eventName]) {
          nike.warn("nike.gadget.LinkRedirector", "Event configuration requested without being specified on the gadget: " + curEvent.eventName, curEvent);
        } else {
          allowedEvents.push(curEvent);
        }
      }
    } else {
      allowedEvents = eventConfig;
    }

    return allowedEvents;
  },

  /**
   * Determines if the event should trigger a redirect or not by validating the data and checking conditionals
   *
   * @param {String} eventName The name of the event
   * @param {Object} data The event data to validate
   *  @config {String} query The URL to redirect the page to
   *  @config {Element|jQuery} element The element associated with this redirect
   *  @config {Number} [delay] The delay to add to the redirect
   *  @config {Boolean} [newWindow] TRUE if a new window needs to be opened (will ignore delay)
   *  @config {Boolean} [noFollow] TRUE if the page should not redirect at all and can be used as an override per event
   *
   * @return {Boolean} TRUE if the link should be followed, FALSE otherwise
   */
  checkIfFollowLink : function (eventName, data) {
    var shouldFollow = false;
    var config = this.eventConfig[eventName];
    var conditionFuncReturn = true;
    var element = (data) ? data.element : null;
    var overrideFunc = nike.gadget.LinkRedirector.overrideFunc;

    if(data.newWindow === true) {
      return true;
    }

    // Make sure the config exists for this event and the event data is validated
    if(config && this.validateEventData(data)) {
      // If there was a conditionFunc defined at setup, run it now
      if(config.conditionFunc) {
        conditionFuncReturn = config.conditionFunc(eventName, data);
      }

      // The noFollow property can override and disable the redirect
      // nike.gadgetListensTo is used to allow the gadget property data-listen to function as designed
      if(!data.noFollow && (conditionFuncReturn === true) && nike.gadgetListensTo(this.element, element)) {

        // Finally check if there is a global override function that will make the final decision
        if(overrideFunc) {
          shouldFollow = !!(overrideFunc(eventName, data) === true);
        } else {
          shouldFollow = true;
        }
      }
    }

    return shouldFollow;
  },

  /**
   * Validates that the data in the event has the required fields to handle a redirect
   *
   * @param {Object} data The event data to validate
   *  @config {String} query The URL to redirect the page to
   *  @config {Element|jQuery} element The element associated with this redirect
   *  @config {Number} [delay] The delay to add to the redirect
   *  @config {Boolean} [newWindow] TRUE if a new window needs to be opened (will ignore delay)
   *  @config {Boolean} [noFollow] TRUE if the page should not redirect at all and can be used as an override per event
   *
   * @return {Boolean} TRUE if data validates to the requirements (the above jsDoc), FALSE otherwise
   */
  validateEventData : function (data) {
    var isValid = true;

    if(!data || !data.query || typeof data.query !== 'string') {
      isValid = false;
    }

    if(data && data.delay && typeof data.delay !== 'number') {
      isValid = false;
    }

    if(data && data.element && !(data.element.nodeType || data.element instanceof jQuery )) {
      isValid = false;
    }

    if(data && data.newWindow && typeof data.newWindow !== 'boolean') {
      isValid = false;
    }

    if(data && data.noFollow && typeof data.noFollow !== 'boolean') {
      isValid = false;
    }

    return isValid;
  },

  /**
   * This will execute the redirect based on information in the event data and the page setup.
   * The validation of the data and determining if the link should be followed or not should be done
   * before executing this function.
   *
   * @param {String} eventName The name of the event being processed
   * @param {Object} data
   *  @config {String} query The URL to redirect the page to
   *  @config {Number} [delay] The delay to add to the redirect
   *  @config {Boolean} [newWindow] TRUE if a new window needs to be opened (will ignore delay)
   */
  executeRedirect : function (eventName, data) {
    var config = this.eventConfig[eventName] || {};
    var query = data.query;
    var delay = data.delay || config.delay || this.DEFAULT_DELAY;
    var isNewWindow = data.newWindow || false;

    if(isNewWindow) {
      window.open(query);
    } else {
      window.setTimeout(function () {
        window.location = query;
      }, delay);
    }
  }
});

/**
 * The singleton instance of this gadget
 *
 * @type nike.gadget.LinkRedirector
 * @public
 * @static
 */
nike.gadget.LinkRedirector.instance = undefined;

/**
 * Keeps track of waiting page setup classes
 *
 * @type {Array}
 * @static
 * @private
 */
nike.gadget.LinkRedirector.queuedPageSetup = [];

/**
 * Use this to setup page events before the gadget has been initialized or
 * when it is unknown whether the gadget has been initialized
 *
 * @public
 * @static
 *
 * @param {nike.gadget.LinkRedirector.PageSetup} pageSetup
 */
nike.gadget.LinkRedirector.setupPageEvents = function (pageSetup) {
  var instance = nike.gadget.LinkRedirector.instance;
  if(!instance) {
    nike.gadget.LinkRedirector.queuedPageSetup.push(pageSetup);
  } else {
    instance.setupPageEvents(pageSetup);
  }
};

/**
 * Legacy Support.  DON'T USE THIS
 * Included here only to prevent breaking pages not controlled by Tesla
 *
 * @param {String} query
 * @param {jQuery|Element} element
 * @static
 * @deprecated
 */
nike.gadget.LinkRedirector.followLink = function(query, element) {
  var instance = nike.gadget.LinkRedirector.instance;
  var delay = nike.gadget.LinkRedirector.prototype.DEFAULT_DELAY;

  nike.error("nike.gadget.LinkRedirector#followLink()", "DEPRECATED FUNCTION: Please configure the LinkRedirector correctly!");

  if (!instance || (instance && nike.gadgetListensTo(instance.gadgetElement, element))){
    if(typeof(query) === 'string'){
      // delaying for the analytics
      window.setTimeout(function () {
        window.location = query;
      }, delay);
    }
  }
};

/**
 * Set this function to specify a condition function that will be
 * executed for ANY redirect about to happen. Return TRUE to continue, FALSE to abort.
 *
 * function ( {String} eventName, {Object} data ) { return {Boolean} }
 *
 * @type Function
 * @public
 * @static
 */
nike.gadget.LinkRedirector.overrideFunc = undefined;

/**
 * @extends Class
 * @friend nike.gadget.LinkRedirector
 */
nike.gadget.LinkRedirector.PageSetup = Class.extend(
/** @lends nike.gadget.LinkRedirector.PageSetup.prototype */
{

  /**
   * @type Array(Object)
   * @protected
   */
  eventConfig : undefined,

  /**
   * @type Boolean
   * @default false
   * @public
   */
  merge : false,

  /**
   * Handles storing the event setup for a page.
   *
   * @constructs
   *
   * @param {Boolean} [merge=false] TRUE if the page setup should merge with the current setup, FALSE if replacing the existing setup
   */
  init: function (merge) {
    this.eventConfig = [];
    this.merge = (merge === true || merge === false) ? merge : this.merge;
  },

  /**
   * Add a new event to the page setup
   *
   * @param {String|String[]} eventNames The name of the event to listen for
   * @param {Number|Function} [delay=nike.gadget.LinkRedirector.DEFAULT_DELAY] The delay before the event follows the link
   * @param {Function} [conditionFunc] Runs this function to determine if the event should follow the link or not.
   *    prototype: function ( {String} eventName, {Object} eventData ) { return {Boolean} }
   */
  setupEvent : function (eventNames, delay, conditionFunc) {
    // Handle optional arguments
    if(typeof arguments[1] === 'function') {
      //noinspection AssignmentToFunctionParameterJS
      conditionFunc = arguments[1];
      //noinspection AssignmentToFunctionParameterJS
      delay = null
    }

    var index;
    var events = (eventNames instanceof Array) ? eventNames : [ eventNames ];
    var curEvent;

    for(index = 0; index < events.length; index++ ) {
      curEvent = events[index];

      if(!curEvent || typeof curEvent !== 'string') {
        nike.error("nike.gadget.LinkRedirector.PageSetup#setupEvent(", eventNames, delay, conditionFunc,
                    ") must have a valid event name", (events.length > 1) ? " in index: " + index : "");
      }

      var eventSetup = {
        eventName : curEvent,
        delay : delay || null,
        conditionFunc : conditionFunc || null
      };

      this.eventConfig.push(eventSetup);
    }

  }
});

/**
 * Setup the gadget element when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data){
  if (data && data.gadgetName == "nike.gadget.LinkRedirector" && !(data.element).data(nike.GADGET_INSTANCE)){
    var instance;

    // This is a singleton class so we will only instantiate the gadget once
    if(!nike.gadget.LinkRedirector.instance) {
      instance = new nike.gadget.LinkRedirector(data.element);
      nike.gadget.LinkRedirector.instance = instance;
    } else {
      instance = nike.gadget.LinkRedirector.instance;
      nike.warn("nike.gadget.LinkRedirector", "There should only be ONE LinkRedirector included on the page. " +
          "Referencing existing instance and ignoring additional element references (causes issues with data-listen).");
    }

    $(data.element).data(nike.GADGET_INSTANCE, instance);
  }
});

/**
 * This check is to setup default events if the user never even included the LinkRedirector div, but included the script asset
 */
$(document).ready(function () {
  if(!($('div[data-gadget="nike.gadget.LinkRedirector"]').length)) {
    nike.warn("nike.gaget.LinkRedirector",
            "No gadget div found.  Creating a default and appending to the body");

    var element = $('<div>', { "data-gadget" : "nike.gadget.LinkRedirector", "data-load": "preloaded" });

    $('body').append(element);

    nike.gadget.LinkRedirector.instance = new nike.gadget.LinkRedirector(element);
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.LinkRedirector. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
/**
* hoverIntent r5 // 2007.03.27 // jQuery 1.1.2+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne <brian@cherne.net>
*/
nike.requireDependency('jQuery');
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY;};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev]);}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev]);};var handleHover=function(e){var p=(e.type=="mouseover"?e.fromElement:e.toElement)||e.relatedTarget;while(p&&p!=this){try{p=p.parentNode;}catch(e){p=this;}}if(p==this){return false;}var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);}if(e.type=="mouseover"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob);},cfg.timeout);}}};return this.mouseover(handleHover).mouseout(handleHover);};})(jQuery);
jQuery.hoverIntent = $.fn.hoverIntent;
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.hoverIntent. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('jQuery.growandshow');
nike.requireDependency('jQuery');

(function ($) {

  /**
   * Creates a new GrowAndShow object.
   * @constructor
   */
  var GrowAndShow = function (settings) {

    this.settings = settings;

    return this;

  };

  GrowAndShow.prototype = {

    /**
     * Find the height of the child to be revealed.
     * param {Object} A jQuery object that references the parent of the child element to be revealed.
     * param {Object} A jQuery object that references the child element to be revealed.
     */
    getNewHeight: function( $elem, $elemToBeOpened ) {
      
      var newHeight;
      
      if ($elem.hasClass('is-active')) {

        $elemToBeOpened
        .css({position: 'absolute', left: '-9999px', width: $elem.width()})
        .removeClass('is-hidden')
        .addClass('is-active');

        newHeight = $elemToBeOpened.outerHeight();

        $elemToBeOpened
        .css({position: '', left: '', width: ''})
        .addClass('is-hidden')
        .removeClass('is-active');

      } else {

        $elem
        .removeClass('is-hidden')
        .addClass('is-active')
        .css({position: 'absolute', left: '-9999px'});

        $elemToBeOpened
        .removeClass('is-hidden')
        .addClass('is-active');

        newHeight = $elemToBeOpened.outerHeight();

        $elem
        .addClass('is-hidden')
        .removeClass('is-active')
        .css({position: '', left: ''});

        $elemToBeOpened
        .addClass('is-hidden')
        .removeClass('is-active');
      }
      
      return newHeight;
    },

    /**
     * Open the element to reveal a selected child. If selected child is already open, nothing happens.
     * param {Object} A jQuery object that references the parent of the child element to be revealed.
     */
    open : function ( $elem ) {

      var $self = this;

      var $elemToBeOpened = $elem.children( $self.settings.selector);

      if ( $elemToBeOpened.length && $elemToBeOpened.is( '.is-hidden' ) ) {
        
        var newHeight = $self.getNewHeight($elem, $elemToBeOpened),
            $elemToBeClosed = $elem.children('.is-active');

        if ( $elemToBeClosed.length ) {

          $elem.height($elem.height()); // preserve current height before child is hidden

          $elemToBeClosed.fadeTo( $self.settings.speed, 0, function () {
            $( this )
            .removeClass( 'is-active' )
            .addClass( 'is-hidden' )
            .css( {
              'display' : '',
              'opacity' : ''
            } );
          } );

          $elem.delay( $self.settings.speed );
        }

        $elem
          .removeClass('is-hidden')
          .addClass('is-active')
          .animate( {'height' : newHeight}, $self.settings.speed, function () {

            $elemToBeOpened
              .fadeTo(0,0)
              .removeClass('is-hidden')
              .addClass('is-active')
              .fadeTo( $self.settings.speed, 1, function () {
                $( this).css( {
                  'display' : '',
                  'opacity' : ''
                } );

                $self.settings.callback.apply( $elem );
              });

            $elem.removeAttr('style');
          });
      }

    },

    /**
     *  Hide a selected child and close the element. If selected child is already hidden, nothing happens.
     * param {Object} A jQuery object that references the child element to be hidden.
     */
    close: function ($elem) {

      var $self = this;

      $elem
        .height($elem.height())
        .children()
          .fadeTo($self.settings.speed, 0, function () {
            $(this)
              .removeClass('is-active')
              .addClass('is-hidden')
              .css({
                'display': '',
                'opacity': ''
              });
          })
        .end()
        .delay($self.settings.speed)
        .animate({'height': 0}, $self.settings.speed, function () {
          $(this)
            .removeClass( 'is-active' )
            .addClass('is-hidden')
            .css('height', '');

          $self.settings.callback.apply($self);
        });

    },
    /**
     * Hide or show a selected child depending on its current state.
     * param {Object} A jQuery object that references the child element to be hidden or revealed.
     */
    toggle: function ($elem) {

      var $self = this;

      $elem
        .stop()
        .children()
        .stop();

      if ($elem.children($self.settings.selector).is('.is-active')) {

        $self.close($elem);

      } else {

        $self.open($elem);

      }
    }
  };

  /**
   * JQuery plug-in that resizes a container to the size of a selected child, then reveals the child.
   * @requires jQuery
   * @param {String|{selector?:string,action?:string,speed?:number,callback?:function}} selector A string containing a selector expression to match elements against. Must be a child of 'this'.
   * @param {String} [action] The function to execute. Must be 'toggle', 'open', or 'close'.
   * @param {number} [speed] A number determining how long the animation will run.
   * @param {Function} [callback] A function to call once the animation is complete.
   * @returns {Object} the jQuery object past to the function as 'this'.
   */
  $.fn.growAndShow = function (selector, action, speed, callback) {

    var settings = {};

    if (typeof selector === 'object') {

      settings = selector;

    } else if (typeof selector === 'string') {

      if ($(this).find(selector)) {

        settings.selector = selector;

      } else {

        settings.action = selector;

      }

      if (typeof action === 'string') {

        settings.action = action;

      } else if (typeof action === 'number') {

        settings.speed = action;

      } else if (typeof action === 'function') {

        settings.callback = action;

      }

      if (typeof speed === 'number') {

        settings.speed = speed;

      } else if (typeof speed === 'function') {

        settings.callback = speed;

      }

      if (!settings.callback) {

        settings.callback = callback;

      }

    }

    settings = $.extend({}, $.fn.growAndShow.defaultSettings, settings || {});

    return this.each(function () {

      var $elem = $(this),
      $settings = $.extend(true, {}, settings),
      growAndShow = new GrowAndShow($settings);

      growAndShow[$settings.action]($elem);

    });

  };

  $.fn.growAndShow.defaultSettings = {
    selector: ':first-child',
    speed: 200,
    action: 'toggle',
    callback: function () {
    }
  };
})(jQuery);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.growandshow. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller
// fixes from Paul Irish and Tino Zijdel

(function() {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
      || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
}());
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing requestAnimationFrame. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.gadget.AccessibleNav', function (){
  var $ = nike.requireDependency('jQuery');

  return Class.extend({
    init: function(opts){

      /**
       * A map of all the keyboard keys handled by this Class.
       *
       * @type {Object}
       */
      this.keyMap = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
      };

      /**
       * A map of selectors used to reference DOM nodes.
       *
       * @type {Object}
       */
      this.selectors = {
        NAV_CONTAINER: '.js-navContainer',
        ROOT_ITEM: '.js-rootItem',
        ROOT_LIST_ITEM: '.js-rootListItem',
        SUB_ROOT_ITEM: '.js-subRootListItem',
        NAV_LIST: '.js-navList',
        IS_ROOT_NAV: '.js-isRootNav',
        SUB_NAV_LIST: '.js-subNavList',
        SUB_NAV_CONTAINER: '.js-subNavContainer',
        LIST_ITEM: '.js-listItem',
        SUB_LIST_ITEM: '.js-subListItem',
        NAV_ITEM: '.js-navItem',
        COLUMN_ITEM: '.js-columnItem',
        NAV_ITEM_WITH_SUB_NAV: '.js-navItemWithSubNav',
        ARIA_NOT_HIDDEN: '[aria-hidden="false"]'
      };

      /**
       * A map of selectors used to reference DOM nodes (css classes).
       *
       * @type {Object}
       */
      this.cssClasses = {
        COLUMN_ITEM: this.selectors.COLUMN_ITEM.replace('.', ''),
        NAV_ITEM: this.selectors.NAV_ITEM.replace('.', ''),
        NAV_ITEM_WITH_SUB_NAV: this.selectors.NAV_ITEM_WITH_SUB_NAV.replace('.', ''),
        ROOT_ITEM: this.selectors.ROOT_ITEM.replace('.', ''),
        SUB_ROOT_ITEM: this.selectors.SUB_ROOT_ITEM.replace('.', ''),
        SUB_NAV_LIST: this.selectors.SUB_NAV_LIST.replace('.', ''),
        SUB_NAV_CONTAINER: this.selectors.SUB_NAV_CONTAINER.replace('.', ''),
        LIST_ITEM: this.selectors.LIST_ITEM.replace('.', ''),
        SUB_LIST_ITEM: this.selectors.SUB_LIST_ITEM.replace('.', ''),
        IS_ROOT_NAV: this.selectors.IS_ROOT_NAV.replace('.',''),
        ROOT_LIST_ITEM: this.selectors.ROOT_LIST_ITEM.replace('.', '')
      };

      /**
       * A map of CSS classes used to modifiy the state of a DOM node.
       *
       * @type {Object}
       */
      this.cssModifiers = {
        IS_CLOSED: 'is--closed',
        IS_OPEN: 'is--open',
        HAS_OPEN_SUB: 'is-active',
        IS_FOCUSED: 'has--focus'
      };

      this.eventNamespace = '.accessibleNav';

      /**
       * A map of Event types handled by this Class.
       *
       * @type {Object}
       */
      this.events = {
        CLICK: 'click '+this.eventNamespace,
        MOUSE_OVER: 'mouseover '+this.eventNamespace,
        KEY_UP: 'keyup '+this.eventNamespace,
        KEY_DOWN: 'keydown '+this.eventNamespace
      };

      /**
       * A map of ARIA attributes handled by this Class.
       *
       * @type {Object}
       */
      this.ariaAttributes = {
        HIDDEN: 'aria-hidden',
        EXPANDED: 'aria-expanded'
      };

      /**
       * Whether or not the user is interacting with the nav via the keyboard.
       *
       * @type {Boolean}
       */
      this.triggeredByKeyboard = false;

      /**
       * A map of the types of navs this Class supports.
       *
       * @type {Object}
       */
      this.navTypes = {
        COLUMN: 'column',
        DROP_DOWN: 'dropDown'
      };

      /**
       * The type of nav that will be set up.
       *
       * @type {String}
       */
      this.navType = opts.navType || this.navTypes.DROP_DOWN;

      /**
       * A unique identifier used for event delegation and styling.
       *
       * @type {String|null}
       */
      this.navClass = 'is-for--' + opts.navClass || null;
      this.contSelector = this.selectors.NAV_CONTAINER;
      if (this.navClass) {
        this.contSelector += '.' + this.navClass;
      }
      this.$navs = $(this.contSelector);
      this.addListeners(this.$navs);
    },

    /**
     * focus on an element
     *
     * @param {HTMLElement} $element - The element that will be focused on
     */
    focusItem : function($element, $menu){
      var $element = $($element);
      var $menu = $($menu);

      // add / remove  IS_FOCUSED class which is specific to COLUMN navs
      if ( this.navType === this.navTypes.COLUMN ){
        $menu.children().removeClass(this.cssModifiers.IS_FOCUSED);
        if ( $element.hasClass(this.cssClasses.ROOT_LIST_ITEM) ){
          $element.addClass(this.cssModifiers.IS_FOCUSED);
        }
      }

      $element.find(this.selectors.NAV_ITEM).first().focus();
    },

    /**
     * Selects the next item in nav. If there isn't one it'll bounce back to the first item in the list. If it's at the end
     * of a sub nav that belongs to a root item, it'll close the nav and refocus the root item.
     *
     * @param {HTMLElement} el - The element the user is on.
     * @param {Boolean} [openSub] - Whether or not to open a sub nav.
     * @param {Number} [direction] - The keyboard key code of the direction the user chose.
     */
    selectNextNavItem : function ($el, openSub, direction) {
      var _self = this;
      var $menu = $el.closest(this.selectors.NAV_LIST);
      var $nextEl = $el.parent().next();
      var $columns = null;
      var $nextMenu = null;

      if ($nextEl.is('.hidden, ' + this.selectors.ROOT_ITEM + ', ' + this.selectors.NAV_ITEM)){
        $nextEl = $nextEl.next();
      }

      // it element is SUB_ROOT_ITEM, finds the SUB_NAV_LIST and selects the first element
      if ($el.parent().hasClass(this.cssClasses.SUB_ROOT_ITEM)) {
        $nextEl = $el.next(this.selectors.SUB_NAV_LIST).find(this.selectors.LIST_ITEM).eq(0);
      }

      // goes back to the js-subRootListItem list item once it reaches the last item in SUB_NAV_LIST
      if ($el.parent().hasClass(this.cssClasses.SUB_LIST_ITEM) && !$nextEl.length) {
        $nextEl = $el.closest(this.selectors.SUB_ROOT_ITEM);
      }

      // if there is no next item, go to the first item in the menu
      if (!$nextEl.length || !$nextEl.hasClass(this.cssClasses.LIST_ITEM)) {
        $nextEl = $menu.find(this.selectors.LIST_ITEM+':not(.hidden)').eq(0);
      }

      if (!openSub && $el.hasClass(this.cssClasses.COLUMN_ITEM) && direction) {
        $nextMenu = $menu.nextAll(this.selectors.NAV_LIST).first();

        if ($nextMenu.length) {
          // set menu to next menu and increment the columnIndex
          $menu = $nextMenu;
          this.columnIndex++;
        } else {
          // if no next menu, go to first menu
          $menu = $menu.parent().children().eq(0);
          this.columnIndex = 0;
        }

        // go to first element
        $nextEl = $menu.find(this.selectors.LIST_ITEM).eq(0);

      } else if (!openSub && direction) {
        this.columnIndex = 0;
      }

      // if openSub is true,  open the sub nav for that root nav item
      if (openSub) {
        if (this.navType == this.navTypes.COLUMN) {

          // dispatch event to nike.gadget.OneNikeNav to make sub nav visible
          nike.dispatchEvent(nike.gadget.Event.SUB_NAV_VISIBLE, {
            'hook': $el.closest(this.selectors.ROOT_LIST_ITEM).attr('js-hook'),
            'ariaInfo': {
               rootListItemSelector:  this.selectors.ROOT_LIST_ITEM,
               parentItemAria: this.ariaAttributes.EXPANDED,
               subNavContainerSelector: this.selectors.SUB_NAV_CONTAINER,
               subNavAriaHidden: this.ariaAttributes.HIDDEN,
               subNavAriaExpanded: this.ariaAttributes.EXPANDED
            }
          });

          $columns = $el.next().find(this.selectors.NAV_LIST);

          if (!this.columnIndex) {
            this.columnIndex = 0;
          }

          $nextEl = $columns.eq(this.columnIndex);
        } else {
          $nextEl = $el.parent().find(this.selectors.NAV_LIST).first();

          // set aria attribute for root nav list item
          $el.attr(this.ariaAttributes.EXPANDED, true);

          // set aria attributes for sub nav
          $nextEl
            .attr(this.ariaAttributes.HIDDEN, false)
            .attr(this.ariaAttributes.EXPANDED, true);
        }
          $el.parent().addClass(this.cssModifiers.HAS_OPEN_SUB);
      }
      // call focusItem method to focus on the next element
      _self.focusItem($nextEl[0], $menu[0]);
    },

    /**
     * Selects the previous item in nav. If there isn't one it'll bounce to the last item in the list. If it's at the start
     * of a sub nav that belongs to a root item, it'll close the nav and refocus the root item.
     *
     * @param {HTMLElement} el - The element the user is on.
     * @param {Boolean} [closeSub] - Whether or not to close a sub nav.
     * @param {Number} [direction] - The keyboard key code of the direction the user chose.
     */
    selectPreviousNavItem : function ($el, closeSub, direction) {
      var _self = this;
      var $menu = $el.closest(this.selectors.NAV_LIST);
      var hasRootParent = !$el.hasClass(this.cssClasses.ROOT_ITEM);
      var $prevEl = $el.parent().prev();
      var $prevElItem = null;
      var $columns = null;
      var $prevMenu = null;

      // if there is a hidden root nav item-- go to the next nav item
      if ($prevEl.is('.hidden, ' + this.selectors.ROOT_ITEM + ', ' + this.selectors.NAV_ITEM)){
        $prevEl = $prevEl.prev();
      }

      // returns to parent js-subListItem element -- only applies to COLUMN navtypes
      if ($el.parent().hasClass(this.cssClasses.SUB_LIST_ITEM) && !$prevEl.length) {
        $prevEl = $el.closest(this.selectors.SUB_ROOT_ITEM);
      }

      // if there is no previous element-- go to the last element in the menu
      if (!$prevEl.length || !$prevEl.hasClass(this.cssClasses.LIST_ITEM)) {
        $prevEl = $menu.find(this.selectors.LIST_ITEM+this.selectors.ROOT_LIST_ITEM+':not(.hidden)').eq($menu.find(this.selectors.LIST_ITEM+this.selectors.ROOT_LIST_ITEM+':not(.hidden)').length - 1);
        if (hasRootParent && closeSub === undefined) {
          closeSub = true;
        }
      }

      if (!closeSub && $el.hasClass(this.cssClasses.COLUMN_ITEM) && direction) {
        $prevMenu = $menu.prevAll(this.selectors.NAV_LIST).first();

        if ($prevMenu.length) {
          // set menu to previous menu and decrement columnIndex
          $menu = $prevMenu;
          this.columnIndex--;
        } else {
          // if no previous menu, go to the last menu
          this.columnIndex = $menu.parent().children().length - 1;
          $menu = $menu.parent().children().eq(this.columnIndex);
        }

        // go to first list element element in menu
        $prevEl = $menu.find(this.selectors.LIST_ITEM).eq(0);

        closeSub = false;
      } else if (!closeSub && direction) {
        this.columnIndex = 0;
      }

      if (closeSub) {
        if (this.navType === this.navTypes.COLUMN) {

          $columns = $menu.parent().find(this.selectors.NAV_LIST);
          // dispatch event to nike.gadget.OneNikeNav to close sub nav
          _self.closeColumnNav();
          // set prevEl to the root list item
          $prevEl = $menu.closest(this.selectors.ROOT_LIST_ITEM);
          $prevElItem = $prevEl.find(this.selectors.NAV_ITEM);

        } else if (!$menu.hasClass(this.cssClasses.IS_ROOT_NAV)) {

          $prevEl = $menu.closest(this.selectors.ROOT_LIST_ITEM);

          $prevElItem = $prevEl.find(this.selectors.NAV_ITEM);
          // change aria attribute of root nav item
          $prevElItem.attr(this.ariaAttributes.EXPANDED, false);
          // change aria attribute of sub nav menu
          $menu
          .attr(this.ariaAttributes.HIDDEN, true)
          .attr(this.ariaAttributes.EXPANDED, false);
        }
          $prevEl.removeClass(this.cssModifiers.HAS_OPEN_SUB);
      }
      // call focusItem method to focus on the previous element
      _self.focusItem($prevEl[0], $menu[0]);
    },

    /**
     * Remove any visual indicators used to display an open sub nav.
     *
     * @param {HTMLElement} parentEl - All child elements with CSS class will be reset.
     */
    removeOpenSubState : function ($parentEl) {
      var _self = this;
      var $elsWithClass = $parentEl.find('.' + this.cssModifiers.HAS_OPEN_SUB);

      $elsWithClass.each(function () {
        $(this).removeClass(_self.cssModifiers.HAS_OPEN_SUB);
      });
    },

    /**
     * dispatches an event listend to by OneNikeNav to close column nav types
     * OneNikeNav also handles setting aria-hidden and aria-expanded
     */
    closeColumnNav : function () {
      nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {
        'ariaInfo': {
          rootListItemSelector:  this.selectors.ROOT_LIST_ITEM,
          parentItemAria: this.ariaAttributes.EXPANDED,
          subNavContainerSelector: this.selectors.SUB_NAV_CONTAINER,
          subNavAriaHidden: this.ariaAttributes.HIDDEN,
          subNavAriaExpanded: this.ariaAttributes.EXPANDED
        }
      });
    },

    /**
     * Closes all open sub navs and will return focus to the root item.
     *
     * @param {Event} ev - Normally a keyboard event with ESC or TAB. Could also be triggered if the user starts
     * using a mouse (mouseover) after they've been using the keyboard.
     */
    closeOpenNavs : function (ev) {
      var _self = this;
      var $cont = $(ev.delegateTarget);
      var $item = $(ev.target);
      var isTab = ev.keyCode == this.keyMap.TAB;
      var $visibleNavs = null;

      if (this.triggeredByKeyboard) {
        if (isTab) {
          if (ev.shiftKey && $item.parent().prev().length) {
            return;
          }
          if (!ev.shiftKey && $item.parent().next().length) {
            return;
          }
        }

        // finds navs with aria-hidden= false
        $visibleNavs = $cont.find(this.selectors.ARIA_NOT_HIDDEN);

        // if there are are navs with aria-hidden = false
        if ($visibleNavs.length) {

          // for COLUMN navType dispatch event to hide open sub navs and then return focus to root nav item
          if (_self.navType === _self.navTypes.COLUMN){

            // dispatch event to nike.gadget.OneNikeNav to close sub nav
            // this also sets aria attributes
            _self.closeColumnNav();

            // remove IS_FOCUSED from all root nav list items
            $visibleNavs.closest(this.selectors.NAV_LIST+this.selectors.IS_ROOT_NAV).children().removeClass(this.cssModifiers.IS_FOCUSED);

            // add IS_FOCUSED to root nav item parent
            $visibleNavs.siblings(this.selectors.ROOT_ITEM).parent().addClass(this.cssModifiers.IS_FOCUSED);
            // return focus to root nav item
            $visibleNavs.siblings(this.selectors.ROOT_ITEM).focus();

            ev.preventDefault();

            // for DROPDOWN navType dispatch event to hide open sub navs and then return focus to root nav item
          } else if (_self.navType === _self.navTypes.DROP_DOWN) {
            // removes open sub navs
            _self.removeOpenSubState($cont);
            // set aria-hidden on nav item
            $visibleNavs.attr(_self.ariaAttributes.EXPANDED, false);
            $visibleNavs.attr(_self.ariaAttributes.HIDDEN, true);
            // set aria-expended to false on root item
            $visibleNavs.parent().siblings(this.selectors.ROOT_ITEM).attr(_self.ariaAttributes.EXPANDED, false);
            // return focus to root item
            $visibleNavs.parent().siblings(this.selectors.ROOT_ITEM).focus();
            ev.preventDefault();
          }
        }
        this.triggeredByKeyboard = false;
      }
    },

    /**
     * Handles navigation via keyboard events.
     *
     * @param {Event} ev - Keyboard events.
     */
    handleKeyUp : function (ev) {
      var $el = $(ev.target);
      this.triggeredByKeyboard = true;
      var $rootItemSiblings = null;

      switch (ev.keyCode) {
        case this.keyMap.LEFT:
          if ($el.hasClass(this.cssClasses.ROOT_ITEM) || $el.hasClass(this.cssClasses.COLUMN_ITEM)) {
            this.selectPreviousNavItem($el, false, this.keyMap.LEFT);
          } else if ($el.hasClass(this.cssClasses.NAV_ITEM_WITH_SUB_NAV)) {
            this.selectPreviousNavItem($el, true);
          }
          break;

        case this.keyMap.UP:
          this.selectPreviousNavItem($el);
          break;

        case this.keyMap.RIGHT:
          if ($el.hasClass(this.cssClasses.ROOT_ITEM) || $el.hasClass(this.cssClasses.COLUMN_ITEM)) {
            this.selectNextNavItem($el, false, this.keyMap.RIGHT);
          } else if ($el.hasClass(this.cssClasses.NAV_ITEM_WITH_SUB_NAV)) {
            this.selectNextNavItem($el, true);
          }
          break;

        case this.keyMap.DOWN:
          if ($el.hasClass(this.cssClasses.ROOT_ITEM) && $el.hasClass(this.cssClasses.NAV_ITEM_WITH_SUB_NAV)) {
            this.selectNextNavItem($el, true);
          } else {
            this.selectNextNavItem($el);
          }
          break;

        case this.keyMap.SPACE:
          if ( $el.hasClass(this.cssClasses.ROOT_ITEM) && !$el.hasClass(this.cssClasses.NAV_ITEM_WITH_SUB_NAV)
               || $el.hasClass(this.cssClasses.NAV_ITEM) && !$el.hasClass(this.cssClasses.ROOT_ITEM) ) {
            $el.click();
          } else if ($el.hasClass(this.cssClasses.NAV_ITEM_WITH_SUB_NAV)) {
            this.selectNextNavItem($el, true);
          }
          break;

        case this.keyMap.ESC:
          this.closeOpenNavs(ev);
          break;

        // keyDown does not fire when entering an element
        // this makes sure to add IS_FOCUSED is added to first item in the nav for COLUMN type menus
        case this.keyMap.TAB:
          $rootItemSiblings = $el.closest(this.selectors.NAV_LIST+this.selectors.IS_ROOT_NAV).children();

          // adds css focus class if the tab key press lands you on the last root item in a column nav
          if (this.navType === this.navTypes.COLUMN && $rootItemSiblings[$rootItemSiblings.length -1] === $el.parent()[0]) {
            $el.parent().addClass(this.cssModifiers.IS_FOCUSED);
            // adds css focus class if the tab key press lands you on the first root item in a column nav
          } else if (this.navType === this.navTypes.COLUMN && $rootItemSiblings[0] === $el.parent()[0]) {
            $el.parent().addClass(this.cssModifiers.IS_FOCUSED);
          }
          break;
      }
    },

    /**
     * Handles navigation via keyboard events. Some keys need to be captured on down otherwise we can't intercept them.
     *
     * @param {Event} ev - Keyboard events.
     */
    handleKeyDown : function (ev) {
      var $el = $(ev.target);
      var dontScrollThese = [
        this.keyMap.UP,
        this.keyMap.DOWN,
        this.keyMap.LEFT,
        this.keyMap.RIGHT,
        this.keyMap.SPACE
      ].join('|');

      if (new RegExp(dontScrollThese).test(ev.keyCode)) {
        ev.preventDefault();
      }

      if (ev.keyCode == this.keyMap.TAB ){
        // uses selectPreviousNavItem or selectNextNavItem so that IS_VISIBLE gets added to the correct element
        if ($el.hasClass(this.cssClasses.ROOT_ITEM) && this.navType === this.navTypes.COLUMN && $el.parent().prev()[0] && ev.shiftKey) {
          this.selectPreviousNavItem($el, false, this.keyMap.LEFT);
          ev.preventDefault();
        } else if ($el.hasClass(this.cssClasses.ROOT_ITEM) && this.navType === this.navTypes.COLUMN && $el.parent().next()[0] && !ev.shiftKey) {
          this.selectNextNavItem($el, false, this.keyMap.RIGHT);
          ev.preventDefault();
        }
        // remove IS_FOCUSED
        $el.parent().removeClass(this.cssModifiers.IS_FOCUSED);
        this.closeOpenNavs(ev);
      }
    },

    /**
     * Adds all event bindings for the nav.
     *
     * @param {HTMLElements} $navs - html navigation elements that will have event listeners bound
     */
    addListeners : function ($navs) {
      var _self = this;

      $navs.each(function () {
        var $nav = $(this);

        if (!$nav.data('hasListeners')) {
          $(document).on(_self.events.MOUSE_OVER, _self.selectors.NAV_ITEM, _self.closeOpenNavs.bind(_self));
          $nav.on(_self.events.KEY_DOWN, _self.selectors.NAV_ITEM, _self.handleKeyDown.bind(_self));
          $nav.on(_self.events.KEY_UP, _self.selectors.NAV_ITEM, _self.handleKeyUp.bind(_self));
          $nav.on(_self.events.CLICK, _self.selectors.NAV_ITEM, _self.closeOpenNavs.bind(_self));
        }
      });
    }
  });
});


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.AccessibleNav. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace('nike.exp.global.LocalValueUtil');
nike.requireDependency('lib.lodash');

nike.exp.global.LocalValueUtil = _.extend(nike.exp.global.LocalValueUtil, {

  getLocal : function(localValueKey){
    var ret;
    if(nike.objectDefined('nike.exp.dynamic.LocalValues')){
      ret = nike.exp.dynamic.LocalValues[localValueKey];
    }
    return ret;
  }

});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.LocalValueUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * User: BPYL
 * @namespace nike.exp.global.validation
 */
nike.namespace("nike.exp.global.validation");

nike.exp.global.validation = {

  /**
   * Event that will be fired whenever an element is validated.
   * This will only be fired if the state is something other than
   * {@link nike.exp.global.validation.STATE.NOT_VALIDATED}
   *
   * @type String
   * @public
   * @constant
   */
  VALIDATION_EVENT : 'validationEvent.nikeExpGlobalValidation',

  /**
   * Indicates the data attribute to use when the current state of validation is too specific
   *
   * @type {String}
   * @public
   * @constant
   */
  DEFAULT_ERROR : 'error',

  /**
   * Indicates the validation state of an element.  This value is obtainable
   * by listening to the {@link nike.exp.global.validation.VALIDATION_EVENT}.
   * The data of this event will be an instance of the class
   * {@link nike.exp.global.validation.ValidationEvent} and will contain the
   * state.
   *
   * @constant
   * @public
   * @enum {String}
   */
  STATE : {
    /**
     * Indicates that this field was not validated because it was empty and not required.
     *
     * @type nike.exp.global.validation.STATE
     */
    NOT_VALIDATED : 'notValidated',

    /**
     * Indicates that this field has passed validation
     *
     * @type nike.exp.global.validation.STATE
     */
    VALID : 'valid',

    /**
     * Indicates that validation has failed because a required field is not completed
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_NOT_COMPLETE : 'errorNotComplete',

    /**
     * Indicates that validation has failed because a confirm field does not match
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_NO_MATCH : 'errorNotMatch',

    /**
     * Indicates that validation has failed because the field has the regular expression
     * in the pattern attribute of the field
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_PATTERN : 'errorPattern',

    /**
     * Indicates that the field has an invalid format and is used by the DateField to
     * indicate an error
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_INVALID_FORMAT : 'errorInvalidFormat',

    /**
     * Indicates that this field has invalid characters in it
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_RESTRICTED_CHARACTERS : 'errorRestrictedCharacters',

    /**
     * Indicates that this field has failed because of a age verification failure
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_MINIMUM_AGE : 'errorMinimumAge',

    /**
     * Indicates that this field has failed because of a age verification failure
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_MINIMUM_AGE_WARNING : 'errorMinimumAgeWarning',

    /**
     * @type nike.exp.global.validation.STATE
     */
    ERROR_MINIMUM_AMOUNT : 'errorMinimumAmount',

    /**
     * @type nike.exp.global.validation.STATE
     */
    ERROR_MAXIMUM_AMOUNT : 'errorMaximumAmount',

    /**
     * Indicates that validation has failed because of a complex reason.  The value of
     * this state should be an object that describes the failure in more detail.
     * For instance, this would be used for a password field to indicate the reasons
     * why a field has failed.
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR_COMPLEX : {},

    /**
     * Indicates that validation has failed because of an unknown reason.
     *
     * @type nike.exp.global.validation.STATE
     */
    ERROR : 'error'
  },

  /**
   * Children's Advertising Review Unit
   * @type String
   * @constant
   * @private
   */
  INVALID_AGE_COOKIE : 'nike_caru',

  /**
   * Sets the invalid age cookie
   */
  setInvalidAge : function() {
    var date = new Date();
    date.setDate(date.getDate() + 1);
    document.cookie = this.INVALID_AGE_COOKIE + "=invalid; domain="+nike.ROOT_DOMAIN+"; expires=" + date.toUTCString() + "; path=/";
  },

  /**
   * Determines if age validation has already failed
   *
   * @returns {boolean} TRUE if age validation has already failed, FALSE if it has not
   */
  ageMinFailed : function() {
    var check = false;
    if (document.cookie.indexOf(this.INVALID_AGE_COOKIE) > -1) {
      check = true;
    }
    return check;
  }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.Validation');
nike.requireDependency("nike.exp.global.LocalValueUtil");
nike.requireDependency("nike.exp.global.validation");

// Depracted!  Use nike.exp.global.Form and nike.exp.global.validation to handle forms and validation.
/**
 * @depracted
 */
nike.Validation = {

  /**
   * Map of all invalid character codes.
   * These are all characters codes rather than actual unicode to avoid relying on UTF-8 encoding working reliably
   * in all of our supported devices and handling maps of unicode characters.
   *
   * This is to support this deprected class
   *
   * ©«¬®»¼½¾¿ʬπφ–—‘’“”…‹›€℃℉№℗℡™ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ↔↵⇄⇅⇆⇇⇈⇉⇊⇐⇑⇒⇓⇔⇤⇥⇦⇧⇨⇩⇪⇱⇲⇳⇵∅∆∇∈∉∋∑√∝∞∟∠∩∪∫∮∵≒≠≡≤≥⊗⊘⊙⊚⊥⊿⋘⋙⏏␈␍␚␛␡␣①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⓪⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴⓵⓶⓷⓸⓹⓺⓻⓼⓽⓾⓿▢▣▤▥▰▱▲△▴▵▶▷▸▹▻▾▿◅◈◉◍◎◧◨◩◪◫☀☁☂☃★☆☉☎☏☑☒☚☛☜☝☞☟☠☢☣☤☥☪☭☮☯☹☺☻☼☽☾♀♂♔♕♖♘♚♛♞♟♠♡♢♣♤♥♦♧♨♩♪♫♬♭♮♯✁✂✃✄✆✇✈✉✌✍✎✏✐✑✒✓✔✖✘✝✡✦✧✩✳✵✺✽✿❀❁❐❑❒❖❤❥❦❧❶❷❸❹❺❻❼❽❾❿➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➷➸➹⤴⤵⤶⤷⤹〄〝〟〠・・㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩㈪㈫㈬㈭㈮㈯㈰㈱㈲㈳㈴㈵㈶㈷㈸㈹㈺㈻㈼㈽㈾㈿㉀㉁㉂㉃㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㊊㊋㊌㊍㊎㊏㊐㊑㊒㊓㊔㊕㊖㊗㊘㊙㊚㊛㊜㊝㊞㊟㊠㊡㊢㊣㊤㊥㊦㊧㊨㊩㊪㊫㊬㊭㊮㊯㊰㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㋐㋑㋒㋓㋔㋕㋖㋗㋘㋙㋚㋛㋜㋝㋞㋟㋠㋡㋢㋣㋤㋥㋦㋧㋨㋩㋪㋫㋬㋭㋮㋯㋰㋱㋲㋳㋴㋵㋶㋷㋸㋹㋺㋻㋼㋽㋾㌃㌍㌔㌘㌢㌣㌦㌧㌫㌶㌻㍉㍊㍍㍑㍗㍻㍼㍽㍾㎎㎏㎜㎝㎞㎡㏄㏍丨仡仼伀伃伹佖侊侒侔侚俉俍俿倞倢偀偂偆偰傔僘僴兊兤冝冾凬刕劜劦劯勀勛匀匇匤卲厓厲叝咊咜咩哿喆坙坥垬埇埈增墲夋奓奛奝奣妤妺孖寀寘寬尞岦岺峵崧嵂嵓嵭嶸嶹巐弡弴彅彧德忞恝悅悊惕惞惲愑愠愰愷憘戓抦揵摠撝擎敎昀昉昕昞昤昮昱昻晗晙晥晳暙暠暲暿曺曻朎杦枻柀栁桄桒棈棏楨榘槢樰橆橫橳橾櫢櫤毖氿汜汯沆泚洄浯涇涖涬淏淲淸淼渧渹渼湜溿澈澵濵瀅瀇瀨炅炫炻焄焏煆煇煜燁燾犱犾猤獷玽珉珒珖珣珵琇琦琩琪琮瑢璉璟甁甯畯皂皛皜皞皦睆砡硎硤硺礰禔禛竑竧竫箞絈絜綠綷緖繒纊罇羡茁荢荿菇菶葈蒴蓜蕓蕙蕫薰蠇裵褜訒訷詹誧誾諟諶譓譿賰賴贒赶軏遧郞鄕鄧釗釚釞釤釥釭釮鈆鈊鈐鈹鈺鈼鉀鉎鉑鉙鉧鉷鉸銈銧鋐鋓鋕鋗鋙鋠鋧鋹鋻鋿錂錝錞錡錥鍈鍗鍰鎤鏆鏞鏸鐱鑅鑈閒隝隯霳霻靃靍靏靑靕顗顥餧馞驎髙髜魲魵鮏鮱鮻鰀鵫鵰鸙黑朗隆﨎﨏塚﨑晴﨓﨔凞猪益礼神祥福靖精羽﨟蘒﨡諸﨣﨤逸都﨧﨨﨩飯飼館鶴＂＇＊￤
   *
   * @type Object.<string,number>
   * @static
   * @public
   * @constant
   */
  RESTRICTED_CHARACTER_MAP : {c169:1,c171:1,c172:1,c174:1,c187:1,c188:1,c189:1,c190:1,c191:1,c684:1,c960:1,c966:1,c8211:1,c8212:1,c8216:1,c8217:1,c8220:1,c8221:1,c8230:1,c8249:1,c8250:1,c8364:1,c8451:1,c8457:1,c8470:1,c8471:1,c8481:1,c8482:1,c8544:1,c8545:1,c8546:1,c8547:1,c8548:1,c8549:1,c8550:1,c8551:1,c8552:1,c8553:1,c8560:1,c8561:1,c8562:1,c8563:1,c8564:1,c8565:1,c8566:1,c8567:1,c8568:1,c8569:1,c8596:1,c8629:1,c8644:1,c8645:1,c8646:1,c8647:1,c8648:1,c8649:1,c8650:1,c8656:1,c8657:1,c8658:1,c8659:1,c8660:1,c8676:1,c8677:1,c8678:1,c8679:1,c8680:1,c8681:1,c8682:1,c8689:1,c8690:1,c8691:1,c8693:1,c8709:1,c8710:1,c8711:1,c8712:1,c8713:1,c8715:1,c8721:1,c8730:1,c8733:1,c8734:1,c8735:1,c8736:1,c8745:1,c8746:1,c8747:1,c8750:1,c8757:1,c8786:1,c8800:1,c8801:1,c8804:1,c8805:1,c8855:1,c8856:1,c8857:1,c8858:1,c8869:1,c8895:1,c8920:1,c8921:1,c9167:1,c9224:1,c9229:1,c9242:1,c9243:1,c9249:1,c9251:1,c9312:1,c9313:1,c9314:1,c9315:1,c9316:1,c9317:1,c9318:1,c9319:1,c9320:1,c9321:1,c9322:1,c9323:1,c9324:1,c9325:1,c9326:1,c9327:1,c9328:1,c9329:1,c9330:1,c9331:1,c9332:1,c9333:1,c9334:1,c9335:1,c9336:1,c9337:1,c9338:1,c9339:1,c9340:1,c9341:1,c9342:1,c9343:1,c9344:1,c9345:1,c9346:1,c9347:1,c9348:1,c9349:1,c9350:1,c9351:1,c9352:1,c9353:1,c9354:1,c9355:1,c9356:1,c9357:1,c9358:1,c9359:1,c9360:1,c9361:1,c9362:1,c9363:1,c9364:1,c9365:1,c9366:1,c9367:1,c9368:1,c9369:1,c9370:1,c9371:1,c9372:1,c9373:1,c9374:1,c9375:1,c9376:1,c9377:1,c9378:1,c9379:1,c9380:1,c9381:1,c9382:1,c9383:1,c9384:1,c9385:1,c9386:1,c9387:1,c9388:1,c9389:1,c9390:1,c9391:1,c9392:1,c9393:1,c9394:1,c9395:1,c9396:1,c9397:1,c9398:1,c9399:1,c9400:1,c9401:1,c9402:1,c9403:1,c9404:1,c9405:1,c9406:1,c9407:1,c9408:1,c9409:1,c9410:1,c9411:1,c9412:1,c9413:1,c9414:1,c9415:1,c9416:1,c9417:1,c9418:1,c9419:1,c9420:1,c9421:1,c9422:1,c9423:1,c9424:1,c9425:1,c9426:1,c9427:1,c9428:1,c9429:1,c9430:1,c9431:1,c9432:1,c9433:1,c9434:1,c9435:1,c9436:1,c9437:1,c9438:1,c9439:1,c9440:1,c9441:1,c9442:1,c9443:1,c9444:1,c9445:1,c9446:1,c9447:1,c9448:1,c9449:1,c9450:1,c9451:1,c9452:1,c9453:1,c9454:1,c9455:1,c9456:1,c9457:1,c9458:1,c9459:1,c9460:1,c9461:1,c9462:1,c9463:1,c9464:1,c9465:1,c9466:1,c9467:1,c9468:1,c9469:1,c9470:1,c9471:1,c9634:1,c9635:1,c9636:1,c9637:1,c9648:1,c9649:1,c9650:1,c9651:1,c9652:1,c9653:1,c9654:1,c9655:1,c9656:1,c9657:1,c9659:1,c9662:1,c9663:1,c9669:1,c9672:1,c9673:1,c9677:1,c9678:1,c9703:1,c9704:1,c9705:1,c9706:1,c9707:1,c9728:1,c9729:1,c9730:1,c9731:1,c9733:1,c9734:1,c9737:1,c9742:1,c9743:1,c9745:1,c9746:1,c9754:1,c9755:1,c9756:1,c9757:1,c9758:1,c9759:1,c9760:1,c9762:1,c9763:1,c9764:1,c9765:1,c9770:1,c9773:1,c9774:1,c9775:1,c9785:1,c9786:1,c9787:1,c9788:1,c9789:1,c9790:1,c9792:1,c9794:1,c9812:1,c9813:1,c9814:1,c9816:1,c9818:1,c9819:1,c9822:1,c9823:1,c9824:1,c9825:1,c9826:1,c9827:1,c9828:1,c9829:1,c9830:1,c9831:1,c9832:1,c9833:1,c9834:1,c9835:1,c9836:1,c9837:1,c9838:1,c9839:1,c9985:1,c9986:1,c9987:1,c9988:1,c9990:1,c9991:1,c9992:1,c9993:1,c9996:1,c9997:1,c9998:1,c9999:1,c10000:1,c10001:1,c10002:1,c10003:1,c10004:1,c10006:1,c10008:1,c10013:1,c10017:1,c10022:1,c10023:1,c10025:1,c10035:1,c10037:1,c10042:1,c10045:1,c10047:1,c10048:1,c10049:1,c10064:1,c10065:1,c10066:1,c10070:1,c10084:1,c10085:1,c10086:1,c10087:1,c10102:1,c10103:1,c10104:1,c10105:1,c10106:1,c10107:1,c10108:1,c10109:1,c10110:1,c10111:1,c10112:1,c10113:1,c10114:1,c10115:1,c10116:1,c10117:1,c10118:1,c10119:1,c10120:1,c10121:1,c10122:1,c10123:1,c10124:1,c10125:1,c10126:1,c10127:1,c10128:1,c10129:1,c10130:1,c10131:1,c10136:1,c10137:1,c10138:1,c10139:1,c10140:1,c10141:1,c10142:1,c10143:1,c10144:1,c10145:1,c10146:1,c10147:1,c10148:1,c10149:1,c10150:1,c10167:1,c10168:1,c10169:1,c10548:1,c10549:1,c10550:1,c10551:1,c10553:1,c12292:1,c12317:1,c12319:1,c12320:1,c12539:1,c12539:1,c12832:1,c12833:1,c12834:1,c12835:1,c12836:1,c12837:1,c12838:1,c12839:1,c12840:1,c12841:1,c12842:1,c12843:1,c12844:1,c12845:1,c12846:1,c12847:1,c12848:1,c12849:1,c12850:1,c12851:1,c12852:1,c12853:1,c12854:1,c12855:1,c12856:1,c12857:1,c12858:1,c12859:1,c12860:1,c12861:1,c12862:1,c12863:1,c12864:1,c12865:1,c12866:1,c12867:1,c12881:1,c12882:1,c12883:1,c12884:1,c12885:1,c12886:1,c12887:1,c12888:1,c12889:1,c12890:1,c12891:1,c12892:1,c12893:1,c12894:1,c12895:1,c12928:1,c12929:1,c12930:1,c12931:1,c12932:1,c12933:1,c12934:1,c12935:1,c12936:1,c12937:1,c12938:1,c12939:1,c12940:1,c12941:1,c12942:1,c12943:1,c12944:1,c12945:1,c12946:1,c12947:1,c12948:1,c12949:1,c12950:1,c12951:1,c12952:1,c12953:1,c12954:1,c12955:1,c12956:1,c12957:1,c12958:1,c12959:1,c12960:1,c12961:1,c12962:1,c12963:1,c12964:1,c12965:1,c12966:1,c12967:1,c12968:1,c12969:1,c12970:1,c12971:1,c12972:1,c12973:1,c12974:1,c12975:1,c12976:1,c12977:1,c12978:1,c12979:1,c12980:1,c12981:1,c12982:1,c12983:1,c12984:1,c12985:1,c12986:1,c12987:1,c12988:1,c12989:1,c12990:1,c12991:1,c12992:1,c12993:1,c12994:1,c12995:1,c12996:1,c12997:1,c12998:1,c12999:1,c13000:1,c13001:1,c13002:1,c13003:1,c13008:1,c13009:1,c13010:1,c13011:1,c13012:1,c13013:1,c13014:1,c13015:1,c13016:1,c13017:1,c13018:1,c13019:1,c13020:1,c13021:1,c13022:1,c13023:1,c13024:1,c13025:1,c13026:1,c13027:1,c13028:1,c13029:1,c13030:1,c13031:1,c13032:1,c13033:1,c13034:1,c13035:1,c13036:1,c13037:1,c13038:1,c13039:1,c13040:1,c13041:1,c13042:1,c13043:1,c13044:1,c13045:1,c13046:1,c13047:1,c13048:1,c13049:1,c13050:1,c13051:1,c13052:1,c13053:1,c13054:1,c13059:1,c13069:1,c13076:1,c13080:1,c13090:1,c13091:1,c13094:1,c13095:1,c13099:1,c13110:1,c13115:1,c13129:1,c13130:1,c13133:1,c13137:1,c13143:1,c13179:1,c13180:1,c13181:1,c13182:1,c13198:1,c13199:1,c13212:1,c13213:1,c13214:1,c13217:1,c13252:1,c13261:1,c20008:1,c20193:1,c20220:1,c20224:1,c20227:1,c20281:1,c20310:1,c20362:1,c20370:1,c20372:1,c20378:1,c20425:1,c20429:1,c20479:1,c20510:1,c20514:1,c20544:1,c20546:1,c20550:1,c20592:1,c20628:1,c20696:1,c20724:1,c20810:1,c20836:1,c20893:1,c20926:1,c20972:1,c21013:1,c21148:1,c21158:1,c21167:1,c21184:1,c21211:1,c21248:1,c21255:1,c21284:1,c21362:1,c21395:1,c21426:1,c21469:1,c21642:1,c21660:1,c21673:1,c21759:1,c21894:1,c22361:1,c22373:1,c22444:1,c22471:1,c22472:1,c22686:1,c22706:1,c22795:1,c22867:1,c22875:1,c22877:1,c22883:1,c22948:1,c22970:1,c23382:1,c23488:1,c23512:1,c23532:1,c23582:1,c23718:1,c23738:1,c23797:1,c23847:1,c23874:1,c23891:1,c23917:1,c23992:1,c23993:1,c24016:1,c24353:1,c24372:1,c24389:1,c24423:1,c24503:1,c24542:1,c24669:1,c24709:1,c24714:1,c24789:1,c24798:1,c24818:1,c24849:1,c24864:1,c24880:1,c24887:1,c24984:1,c25107:1,c25254:1,c25589:1,c25696:1,c25757:1,c25806:1,c25934:1,c26112:1,c26121:1,c26133:1,c26142:1,c26148:1,c26158:1,c26161:1,c26171:1,c26199:1,c26201:1,c26213:1,c26227:1,c26265:1,c26272:1,c26290:1,c26303:1,c26362:1,c26363:1,c26382:1,c26470:1,c26555:1,c26560:1,c26625:1,c26692:1,c26706:1,c26824:1,c26831:1,c26984:1,c27032:1,c27106:1,c27184:1,c27206:1,c27243:1,c27251:1,c27262:1,c27362:1,c27364:1,c27606:1,c27711:1,c27740:1,c27759:1,c27782:1,c27866:1,c27908:1,c28015:1,c28039:1,c28054:1,c28076:1,c28111:1,c28146:1,c28152:1,c28156:1,c28199:1,c28217:1,c28220:1,c28252:1,c28351:1,c28552:1,c28597:1,c28661:1,c28677:1,c28679:1,c28712:1,c28805:1,c28843:1,c28859:1,c28932:1,c28943:1,c28998:1,c28999:1,c29020:1,c29121:1,c29182:1,c29361:1,c29374:1,c29476:1,c29559:1,c29629:1,c29641:1,c29650:1,c29654:1,c29667:1,c29685:1,c29703:1,c29734:1,c29737:1,c29738:1,c29742:1,c29794:1,c29833:1,c29855:1,c29953:1,c29999:1,c30063:1,c30338:1,c30363:1,c30364:1,c30366:1,c30374:1,c30534:1,c30753:1,c30798:1,c30820:1,c30842:1,c31024:1,c31124:1,c31131:1,c31441:1,c31463:1,c31467:1,c31646:1,c32072:1,c32092:1,c32160:1,c32183:1,c32214:1,c32338:1,c32394:1,c32583:1,c32673:1,c33537:1,c33634:1,c33663:1,c33735:1,c33782:1,c33864:1,c33972:1,c34012:1,c34131:1,c34137:1,c34155:1,c34224:1,c34823:1,c35061:1,c35100:1,c35346:1,c35383:1,c35449:1,c35495:1,c35518:1,c35551:1,c35574:1,c35667:1,c35711:1,c36080:1,c36084:1,c36114:1,c36214:1,c36559:1,c36967:1,c37086:1,c37141:1,c37159:1,c37335:1,c37338:1,c37342:1,c37348:1,c37349:1,c37357:1,c37358:1,c37382:1,c37386:1,c37392:1,c37433:1,c37434:1,c37436:1,c37440:1,c37454:1,c37457:1,c37465:1,c37479:1,c37495:1,c37496:1,c37512:1,c37543:1,c37584:1,c37587:1,c37589:1,c37591:1,c37593:1,c37600:1,c37607:1,c37625:1,c37627:1,c37631:1,c37634:1,c37661:1,c37662:1,c37665:1,c37669:1,c37704:1,c37719:1,c37744:1,c37796:1,c37830:1,c37854:1,c37880:1,c37937:1,c37957:1,c37960:1,c38290:1,c38557:1,c38575:1,c38707:1,c38715:1,c38723:1,c38733:1,c38735:1,c38737:1,c38741:1,c38999:1,c39013:1,c39207:1,c39326:1,c39502:1,c39641:1,c39644:1,c39794:1,c39797:1,c39823:1,c39857:1,c39867:1,c39936:1,c40299:1,c40304:1,c40473:1,c40657:1,c63785:1,c63964:1,c64014:1,c64015:1,c64016:1,c64017:1,c64018:1,c64019:1,c64020:1,c64021:1,c64022:1,c64023:1,c64024:1,c64025:1,c64026:1,c64027:1,c64028:1,c64029:1,c64030:1,c64031:1,c64032:1,c64033:1,c64034:1,c64035:1,c64036:1,c64037:1,c64038:1,c64039:1,c64040:1,c64041:1,c64042:1,c64043:1,c64044:1,c64045:1,c65282:1,c65287:1,c65290:1,c65508:1},

  regex : {
		homeAddress: {
			postalCodeUS: new RegExp(/(^\d{5}$)|(^\d{5}-\d{4}$)/),
			postalCodeCA: new RegExp(/^([ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1} *\d{1}[A-Z]{1}\d{1}$)/)
		},
		shippingAddress: {//currently being used by gift cards
			postalCodeUS: new RegExp(/(^\d{5}$)|(^\d{5}-\d{4}$)/),
			postalCodeAT: new RegExp(/(a|A)?(\s|-)?\d{4}/i),
			postalCodeBE: new RegExp(/(b|B)?(\s|-)?\d{4}/i),
			postalCodeCA: new RegExp(/^([ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1} *\d{1}[A-Z]{1}\d{1}$)/),
			postalCodeCH: new RegExp(/\d{4}/i),
			postalCodeCZ: new RegExp(/\d{5}/i),
			postalCodeDE: new RegExp(/(d|D)?(\s|-)?\d{5}/i),
			postalCodeDK: new RegExp(/(dk|DK)?(\s|-)?\d{3,4}/i),
			postalCodeFI: new RegExp(/(fin|FIN)?(\s|-)?\d{5}/i),
			postalCodeFR: new RegExp(/(fr|FR)?(\s|-)?\d{5}/i),
			postalCodeGB: new RegExp(/(GIR 0AA)|(BFPO|bfpo) (\d{1,4}$)|(((A[BL]|B[ABDHLNRSTX]?|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]?|F[KY]|G[LUY]?|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]?|M[EKL]?|N[EGNPRW]?|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKLMNOPRSTY]?|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)[1-9]?[0-9]|((E|N|NW|SE|SW|W)1|EC[1-4]|WC[12])[A-HJKMNPR-Y]|(SW|W)([2-9]|[1-9][0-9])|EC[1-9][0-9])[\ ]{0,1}[0-9][ABD-HJLNP-UW-Z]{2})/),
			postalCodeGR: new RegExp(/\d{5}/i),
			postalCodeHU: new RegExp(/\d{4}/i),
			postalCodeIT: new RegExp(/\d{5}/i),
			postalCodeLU: new RegExp(/(l)?(\s|-)?\d{4}/i),
			postalCodeNL: new RegExp(/\d{4} ?[a-zA-Z]{2}/),
			postalCodeNO: new RegExp(/(no|NO)?(\s|-)?\d{4}/i),
			postalCodePL: new RegExp(/\d{5}/i),
			postalCodePT: new RegExp(/\d{5,7}/i),
			postalCodeSI: new RegExp(/\d{4}/i),
			postalCodeES: new RegExp(/\d{5}/i),
			postalCodeSE: new RegExp(/^(se|SE)?\d{5}/i)
		},
		email: new RegExp(/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/i),
		commaSeparatedEmails: new RegExp(/^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}(\s*,\s*[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4})*$/i),
		register: {
			hasNum: new RegExp(/([0-9])/),
			hasUppercase: new RegExp(/([A-Z])/),
			hasLowercase: new RegExp(/[a-z]/)
		},
		name: new RegExp('^((?!["<>$@*!#%^&+=_,?\\t/\\\\|<>(){}[\\]]{1,}).)*$'),//uses negative look ahead to make sure all characters are not in the test string
		phoneNum: new RegExp(/^((\+\(?\d{1,3}\)?(-| |\s|\.)?\(?\d\)?(-| |\.)?\d{1,5})|(\d?\(?\d{1,6}\)?)|(\d{1}?(\.| |-)?\d{1,6})|(\d{1,6})|(\+\(\d{3}\))|(\d{1,3})?)(-| |\.)?(\d{3,4})(-| |\.)?(\d{4})(( )?(ext|extn|x)(:| |_|-)?(\d{1,4}))?$/i),
    chinaPhoneNum: new RegExp(/^(1)+\d{10}$/),
		screenname: new RegExp('^((?!["\'<>$@*!#%^&+=,?\\s/\\\\|<>(){}[\\]]{1,}).)*$'),//uses negative look ahead to make sure all characters are not in the test string
    city: new RegExp(/([0-9])/) //city cannot contain numbers
	},

  cssModifiers : {
    IS_INVALID : 'is-invalid'
  },


  shippingPostalCodePreProcessor : (function(){
    var removeSpacesAndDashesFn = function(value){
      return value.replace(/(\s|-)?/gi, "");
    };
    return {
      "CZ" : removeSpacesAndDashesFn,
      "PL" : removeSpacesAndDashesFn,
      "PT" : removeSpacesAndDashesFn,
      "SE" : removeSpacesAndDashesFn,
      "GB" : function(value){
        return removeSpacesAndDashesFn(value).toUpperCase();
      }
    };
  }()),
	formElement: undefined,
	invalidElSelector : undefined,

	/**
	 * Validate an input that requires a value. Add the this.cssModifiers.IS_INVALID
	 * class to the input if it does not have a value.
	 *
	 * @param input A form input element
	 *
	 * @return true if the input has a value
	 */
	validateRequired : function (input){
		if ($(input).val() === ''){
			$(input).addClass(this.cssModifiers.IS_INVALID);
			return false;
		}
		$(input).removeClass(this.cssModifiers.IS_INVALID);
		return true;
	},
	/**
	 * Validate that a form's required fields have been entered
   *
   * @param {jQuery} formElement
   * @param {Function} [invalidElSelector]
   * @deprecated Use nike.exp.global.Form and nike.exp.global.validation.Validator to handle form validation
	 */
	validateForm : function(formElement, invalidElSelector){
		var valid = true;
		var fields = formElement.find("input[required]").add(formElement.find("select[required]"));
		var self = nike.Validation;
		self.formElement = formElement;
		self.invalidElSelector = invalidElSelector?invalidElSelector:undefined;

		fields.each(function(i,el) {
			var $el = $(el);
			var val = $el.val();
			var form = ($el.context.form === null) ? formElement : $el.context.form;

      if(!self.validateCharacters($el)) {
        self.notifyState($el, nike.exp.global.LocalValueUtil.getLocal("profile.validation.restrictedchar.message"));
        self._invalid($el);
        valid = false;
      } else {
        if ($el.is("input[name=password]")) { // check for password complexity only in register/password-reset form (while other pages are still in dev)
          if(form && (form.name == "register-form" || form.name == "passwordUpdater-form" || form.name =="swoosh-profile-form")){
            // check password complexity
            var passwordEval = self.validatePassword($el.val(), formElement.closest('form').find('input[name=screenName]').val());
            if (!passwordEval.allReqMet) {
              self._invalid($el);
              valid = false;
            } else {
              self._valid($el);
            }
          }
          else if($el.parents(".change_password_form").length > 0){
            // check password complexity
            var passwordEval = self.validatePassword($el.val(), formElement.closest('form').find('input[name=screenName]').val());
            if (!passwordEval.allReqMet) {
              self._invalid($el);
              valid = false;
            } else {
              self._valid($el);
            }
          } else {
            //validate password
            if ($el.val() == '') {
              self._invalid($el);
              valid = false;
            } else {
              self._valid($el);
            }
          }
        } else if ($el.is("input[name=passwordConfirm]") || $el.is("input[name=confirmPassword]") || $el.is("input[name=confirmpassword]")) {
          //validate password
          var password = (formElement.closest('form').find("input[name=password]").length > 0) ? formElement.closest('form').find("input[name=password]") : formElement.find("input[name=password]"),
           confirmpassword = formElement.find("input[name=passwordConfirm], input[name=confirmPassword], input[name=confirmpassword]");
          if(confirmpassword.val() == ""){
            self.notifyState($el, $($el).data('error-empty'));
            $($el).addClass(this.cssModifiers.IS_INVALID);
            valid = false;
          }else{
            if (password.val() !== confirmpassword.val()){
              self.notifyState($el, $($el).data('error-match'));
              $($el).addClass(this.cssModifiers.IS_INVALID);
              valid = false;
            }else if(password.val() == '') {
              self._invalid($el);
              valid = false;
            } else {
              self._valid($el);
            }
          }
        } else if ($el.is("input[name=firstName]")||$el.is("input[name=lastName]")||$el.is('input[name=jpFirstNameKana]')||$el.is('input[name=jpLastNameKana]')) {
          //validate firstname
          var firstname = formElement.find($el);
          if (firstname.val() == '') {
            self._invalid($el);
            valid = false;
          }else if (!self.validateName(firstname.val())) {
            var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;
            valid = false;
            target.addClass("is-invalid");
            if($el.attr("data-error-specialCharacters")) {
              self.notifyState(target, $el.attr("data-error-specialCharacters"));
            }
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[name=city]")) {
          //validate city
          var city = formElement.find($el);
          if (city.val() == '') {
            self._invalid($el);
            valid = false;
          }else if (!self.validateCity(city.val())) {
            var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;
            valid = false;
            target.addClass("is-invalid");
            if($el.attr("data-error-hasnumbers")) {
              self.notifyState(target, $el.attr("data-error-hasnumbers"));
            }
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[name=screenName]")) {
          //validate screenName
          var screenName = formElement.find("input[name=screenName]");
          var screenNameVal = $.trim(screenName.val());
          var spaceReg = /\s/;
          if (screenNameVal == '') {
            self._invalid($el);
            valid = false;
          } else if (!self.validateScreenName(screenNameVal)) {
            var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;
            valid = false;
            target.addClass("is-invalid");
            if ($el.attr("data-error-space") && spaceReg.test(screenNameVal)) {
              self.notifyState(target, $el.attr("data-error-space"));
            } else if($el.attr("data-error-specialcharacters")){
              self.notifyState(target, $el.attr("data-error-specialcharacters"));
            }
          } else {
            self._valid($el);
          }
        }else if ($el.is("input[name=phoneNumber]") || $el.is("input[name=additionalPhoneNumber]") || $el.is("input[name=mobileNumber")){
          //validate phonenumber
          if ($el.val() == '' || !self.validatePhoneNumber($el.val())) {
            self._invalid($el);
            valid = false;
          } else {
            //validate phone number in basic info for CN
            if ($el.hasClass('chinaMobileNumber')) {
              var phoneText = self.regex.chinaPhoneNum;
              if (phoneText.test($el.val()) === false) {
                self._invalid($el);
                valid = false;
              } else {
                self._valid($el);
              }
            }else {
              self._valid($el);
            }
          }
        } else if ( $el.is("input[name=email]") || $el.is("input[name=login]") ) {
          if (!self.validateEmail($el.val()) ){
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[name=emailConfirm]")) {
          //validate if emails match
          var email = formElement.closest('form').find("input[name=email]");
          if (email.val() !== $el.val()) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[name=postalCode]")) {
          var type = $(form).find('[name=type]').val();
          if (!self.validatePostalCode(val, form, type)) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[name=shippingPostalCode]") || $el.is("input[name=emeaPostCode]")) {
          if (!self.validatePostalCode(val, form, "shipping")) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is("input[type=email]")) {
          if (!self.validateEmail($el.val())) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is('input[type=radio]') || $el.is('input[type=checkbox]')) {
          if (!formElement.closest('form').find("input[name=" + $el.attr("name") + "]:checked").exists()) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.attr("pattern")) {
          var regex = new RegExp($el.attr("pattern"), $el.attr("data-patternFlag"));
          if (regex.test(val) === false) {
            self._invalid($el);
            valid = false;
          } else {
            self._valid($el);
          }
        } else if ($el.is("select.dob-dropdown")) {
          var dob = self.getDOB($(form));

          if(dob.isCompleted && (self.validateDate(dob.year, dob.month, dob.day) || nike.COUNTRY == 'JP')) {
            self._valid($el);
          } else {
            self._invalid($el);
            valid = false;
          }
        } else if (val == "") {
          self._invalid($el);
          valid = false;
        } else {
          self._valid($el);
        }
      }
		});

    // Handle validation of non required fields that require some type of pattern validation if they are filled in
    fields = formElement.find('input[pattern]:not([required]):visible');

    fields.each(function (i,el) {
      var $el = $(el);
      var val = $el.val();
      var self = nike.Validation;
      var regex = new RegExp($el.attr("pattern"), $el.attr("data-patternFlag"));

      if(!self.validateCharacters($el)) {
        self.notifyState($el, nike.exp.global.LocalValueUtil.getLocal("profile.validation.restrictedchar.message"));
        self._invalid($el);
        valid = false;
      } else {
        if ($el.is("input[name=city]")) {
          //validate city
          var city = formElement.find($el);
          if (city.val() != '' && !self.validateCity(city.val())) {
            var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;
            valid = false;
            target.addClass("is-invalid");
            if($el.attr("data-error-hasnumbers")) {
              self.notifyState(target, $el.attr("data-error-hasnumbers"));
            }
          } else {
            self._valid($el);
          }
        } else if (val && regex.test(val) === false) {
          self._invalid($el);
          valid = false;
        } else {
          self._valid($el);
        }
      }
    });

		return valid;
	},

	_valid:function($el) {
	var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;

    target.removeClass("is-invalid");
		var self = nike.Validation;

	if ($el.is("input")){
    if($el.parent().find(".error").length > 0){
      nike.dispatchEvent(nike.Event.ERROR_NOTIFIER_REMOVED,{element:$el});
      $el.parent().find(".error").hide();
    }
  }

	if ($el.is(':radio')) {
		if (self.formElement.is("label")) {
			self.formElement = self.formElement.parent();
		}
		self.formElement.find("input[name=" + $el.attr("name") + "]").removeClass("is-invalid");
	}
},

	_invalid:function($el) {
	var target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;
	var self = nike.Validation;

	self.notifyState(target, $el.attr("data-error"));

	if(self.invalidElSelector) {
		target = self.invalidElSelector(target);
	}

	target.addClass("is-invalid");
  if ($el.is(':radio')) {
    self.formElement.closest('form').find("input[name=" + $el.attr("name") + "]").addClass("is-invalid");
  }

  },
	validatePostalCode: function(postalCode, form, type){
		//validate the postal code if we have a regex for it
		var isValid = false;
		var self = nike.Validation;
    var country;
    if(type != undefined) {
		  country = (null != $(form).find('.required-'+type +' [name=country]').val())? $(form).find('.required-'+type +' [name=country]').val():nike.COUNTRY;
    }else{
      country = (null != $(form).find('[name=country]').val())? $(form).find('[name=country]').val():nike.COUNTRY;
    }
    if (type==="shipping") {
      country = $(form).find('[name="postalCountry"]').val() || country;
      if(self.shippingPostalCodePreProcessor[country]) {
        postalCode = self.shippingPostalCodePreProcessor[country](postalCode);
      }
    }
		var postalCodeTest = type === "shipping" ? nike.Validation.regex.shippingAddress["postalCode" + country.toUpperCase()] : nike.Validation.regex.homeAddress["postalCode" + country.toUpperCase()];
		if ((postalCodeTest && (postalCodeTest.test(postalCode) === false)) || postalCodeTest && postalCode == "" || postalCode == "") {
			isValid = false;
		} else {
			isValid = true;
		}
		return isValid;
	},

  /**
   * Called when validation should be made against a specific age limit.
   *
   * @param {jQuery} form The form element to get the DOB from
   * @param {String|Number} ageMin The minimum age that should be allowed to pass validation, if omitted, just checks for completion
   * @return {Boolean} TRUE if DOB is completed and age is above ageMin, FALSE if form is not complete or below the minimum age
   */
  validateDOBAge : function (form, ageMin) {
    var dob = this.getDOB(form);
    var formEls = form.find('select[name="dobDay"], select[name="dobMonth"], select[name="dobYear"]');
    var valid = true;

    if (dob.isCompleted && this.validateAge(dob.year, dob.month, dob.day, ageMin)) {
      this._valid(formEls);
    } else {
      this._invalid(formEls);
      valid = false;
    }

    return valid;
  },

  /**
   * Validates a DOB date.  Will return TRUE if incomplete or a valid date, FALSE if complete and invalid.
   *
   * @param {jQuery} form The form to look for DOB elements in
   * @return {Boolean} TRUE if valid or incomplete, FALSE otherwise
   */
  validateDOBChange : function (form) {
    var dob = this.getDOB(form);
    var formEls = form.find('select[name="dobDay"], select[name="dobMonth"], select[name="dobYear"]');
    var valid = true;

    if (dob.isCompleted && !this.validateDate(dob.year, dob.month, dob.day)) {
      this._invalid(formEls);
      valid = false;
    } else {
      this._valid(formEls);
    }

    return valid;
  },

  validateAge : function(yr,mo,dt,agemin) {
		var dobdiff;
		if( isNaN( yr ) || isNaN( mo ) || isNaN( dt )) {
			return false;
		}

		//all dates are valid if agemin is zero...
		if (agemin == "0") {
			return true;
		}

		var threshold = agemin && agemin !== "" ? parseInt(agemin) : 18;//default is eighteen
		var now = new Date();
		var agecheck = new Date();
		var dob = new Date(yr,mo-1,dt);
		var agediff = dobdiff = 0;
		var valid = true;
		dob.setFullYear(yr,mo-1,dt);
		agecheck.setFullYear(now.getFullYear() - threshold, now.getMonth(), now.getDate());
		agediff = now.getTime() - agecheck.getTime();
		dobdiff = now.getTime() - dob.getTime();
		if ((agediff - dobdiff) > 0) {
			valid = false;
		}
		return valid;
	},
	setInvalidAge : function() {
    nike.exp.global.validation.setInvalidAge();
	},
	ageMinFailed : function() {
		return nike.exp.global.validation.ageMinFailed();
	},
	disableFields : function($fields, enable) {
		$fields.each(function() {
			var $el = $(this),
			 target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;

			if (enable) {
				target.removeAttr("disabled")
			} else {
				target.attr("disabled", "disabled");
			}
		});
	},
	notifyState : function($el, notifyMsg, type) {
		if (!notifyMsg) {
			return false;
		}
		var notifyType = type ? type : "error";
		var msg = $('<div class="' +  notifyType + ' notifier"><p class="msg">' + notifyMsg + '</p></div>');
		if($el.parent().find('.error.notifier').size() == 0){
			$el.parent().append(msg);
			nike.dispatchEvent(nike.Event.ERROR_NOTIFIER_ATTACHED,{element:$el});
		}
	},
  /** @param [screenName] */
	validatePassword : function(password, screenName) {
		var minChar = false,
		 maxChar = false,
		 hasNum = false,
		 hasUppercase = false,
		 hasLowercase = false,
		 isNotInScreenName = true,
		 allReqMet = false,
		 hasReqCharLength = false,
		 hasMixedChars = false;

		// check if password length is too short
		if (password.length > 7){ minChar = true;}

		// check if password length is too long
		if (password.length < 37) {maxChar = true;}

		// check if screen name is not blank and if screen name matches password
		// if ((screenName != '') && (password.indexOf(screenName) != -1)) isNotInScreenName = false; // checks if SN is substring of PW
		if ((screenName != '') && (password == screenName)){ isNotInScreenName = false;}  // checks if SN equals PW

		// check if password contains an uppercase character
		if (password.match(nike.Validation.regex.register["hasUppercase"])){ hasUppercase = true;}

		// check if password contains a lowercase character
		if (password.match(nike.Validation.regex.register["hasLowercase"])) {hasLowercase = true;}

		// check if password has numbers
		if (password.match(nike.Validation.regex.register["hasNum"])) {hasNum = true;}

		// rules
		if (minChar && maxChar && hasUppercase && hasLowercase && hasNum && isNotInScreenName) {allReqMet = true;}
		if (minChar && maxChar){ hasReqCharLength = true;}
		if (hasUppercase && hasLowercase){ hasMixedChars = true;}

    return {allReqMet : allReqMet, hasNum : hasNum, isNotInScreenName : isNotInScreenName, hasReqCharLength : hasReqCharLength, hasMixedChars : hasMixedChars};
	},
	passwordStrength: function(password, screenName) {
		var self = nike.Validation;
		var strength = self.validatePassword(password, screenName);

		$.each(strength, function(index, value){
			if (value) {
				$("."+index).addClass("is--good");
			} else {$("."+index).removeClass("is--good");}
		});

    return strength;
	},
	validateEmail : function(email) {
		var self = nike.Validation;
		var isValid = false;
		isValid = (self.regex.email.test(email)&& email != "");
		return isValid;
	},
	validateName : function(name){
		var self = nike.Validation;
		var isValid = false;
		isValid = self.regex.name.test(name);
		return isValid;
	},
  validateCity : function(city){
    var self = nike.Validation;
    var isValid = false;
    isValid = !self.regex.city.test(city);
		return isValid;
	},
	validateScreenName : function (screenName) {
		var self = nike.Validation;
		var isValid = false;
		isValid = self.regex.screenname.test(screenName);
		return isValid;
	},
	validatePhoneNumber : function(phoneNumber){
		var self = nike.Validation;
		var isValid = false;
		if(phoneNumber.length >= 8){
			isValid = self.regex.phoneNum.test(phoneNumber);
		}
		return isValid;
	},
	validateDate : function(yr,mo,dy) {

		if( isNaN( yr ) || isNaN( mo ) || isNaN( dy )){
			return false;
		}

		var valid = true;
		//April, June, September and November does not have 31 days
		if((mo === 4 || mo === 6 || mo === 9 || mo === 11) && dy === 31){
			valid = false;
		}
		else if(mo === 2){
			// check for february 29th
			var isLeap = (yr % 4 === 0 && (yr %100 !== 0 || yr % 400 === 0));
			if(dy >29 || (dy === 29 && !isLeap)){
				//February of leap years does not have 29 days
				valid = false;
			}
		}

		return valid;
	},

  /**
   * Retrieves the DOB select box values.  Returns an object with the year, month and day values as well as
   * a helper value of isCompleted that is TRUE when all fields have values.
   *
   * @param {jQuery} form The element to find the DOB select's in
   * @return {Object} contains "day", "month" and "year" with "isCompleted" TRUE if all fields have been entered
   * */
  getDOB : function (form) {
    var day = form.find('select[name="dobDay"]').val();
    var month = form.find('select[name="dobMonth"]').val();
    var year = form.find('select[name="dobYear"]').val();

    try {
      month = month ? parseInt(month, 10) : "";
      day = day ? parseInt(day, 10) : "";
      year = year ? parseInt(year) : "";
    } catch (e) {
      nike.error("Unable to parse integers from DOB elements", e, month, day, year);
    }

    return {
      day : day,
      month : month,
      year : year,
      isCompleted : day && month && year
    };
  },

  validateCustomAmountField : function ($el, min , max) {
    var testObj = {
      valid : true
    };

    var value = $el.val();

    if(!value) {
      testObj.noValue = true;
      testObj.valid = false;
    } else if (!(/^[0-9]+$/).test(value)) {
      testObj.notInteger = true;
      testObj.valid = false;
    } else if (value > max) {
      testObj.overMax = true;
      testObj.valid = false;
    } else if (value < min) {
      testObj.underMin = true;
      testObj.valid = false;
    }

    return testObj;
  },

  validateCharacters : function (element) {
    var valid = true;
    var value = element.val() || "";
    var charCode;

    for(var index = 0; index < value.length; index++ ) {
      charCode = value.charCodeAt(index);
      if((charCode < 32 && charCode !== 10 && charCode !== 13) || (nike.COUNTRY == 'JP' && this.RESTRICTED_CHARACTER_MAP["c" + charCode])) {
        valid = false;
        break;
      }
    }

    return valid;
  },

  /**
   * formats error response from nike.profile or SwooshService and dispatches methods to display the error
   *
   * @param {object} form - a form object:  i.e. form = new nike.exp.util.form.desktop.Form
   * @param {object} event - an event object
   * @param {object} response - response from nike.profile.api.user or nike.exp.util.shared.base.SwooshService
   */
  handleAddressValidationResponse : function (form, event, response) {
    var self = nike.Validation;
    var errorMapping = {
      'city': 'town'
    };
    var fieldName = null;
    var err = null;
    var errorMsg = null;
    var $el = null;

    if(response && response.exceptions && response.exceptions[0] && response.exceptions[0].message) {  //handle error message from swoosh response
      form.globalMessage(response.exceptions[0].message);
    } else {
      // Profile's error response has the object we want in the second position, Identity's has it first
      // Also, we need to modify the response Identity sends; hence passing it into formatErrorResponse()
      response = response.responseText ? response : self.formatErrorResponse(event);
      err = JSON.parse(response.responseText);
      errorMsg = err[0].errorMessage;

      for(var i = 0; i < err.length; i++){
        // if the field name exists in the error map,  change it to the mapped value
        fieldName = errorMapping[err[i].fieldName] || err[i].fieldName;
        $el = form.$form.find('[name="' + fieldName + '"]').addClass(self.cssModifiers.IS_INVALID).one('keypress', function(){
          $(this).removeClass(self.cssModifiers.IS_INVALID);
        });

        if ($el && $el.length > 0) {
          form.handleError($el, err[i].errorMessage);
        }
      }
      form.globalMessage(errorMsg);
    }
    $('body').animate({ scrollTop: 0 }, "slow");
  },

  /**
   * Formats the responses expected by this service into a digestible object for our legacy error-handling
   * @param  {Object}  resp  Object with a "responseText" prop expected
   * @return {Object}        Object with its "responseText" JSON string correctly formatted
   */
  formatErrorResponse: function (resp) {

    var responseObj = resp.responseText ? JSON.parse(resp.responseText) : {};
    var formatted = {};
    var responses = [];

    // Translate the response received into the format our error handlers expect
    if (responseObj.fault) {
      responses[0] = { 'errorMessage': responseObj.fault.faultstring };
    } else if (responseObj.error_id) {
      responses[0] = { 'errorMessage': responseObj.errors[0].message };
    } else {
      // If it's not in a format that we expect from the service, send it back
      return resp;
    }

    // Now stringify
    formatted.responseText = JSON.stringify(responses);

    return formatted;
  }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Validation. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * A utility class which contains tools for navigation.
 * This class can was made instantiable in order to more easily handle the use cases where we transition from one
 * country/locale combination to another. For instance, when a user switches from the French-Canadian site to
 * the English-Canadian site.
 * @author Geoff M. Granum
 *          Sept 26, 2011
 */
nike.NavigationUtil = Class.extend({

    /**
     * The two character country code, such as 'US' (United States) or 'GB' (Great Britain).
     * @type String
     */
    country : undefined,

    /**
     * The locale, such as 'en_US'.
     * @Type String
     */
    locale : undefined,

    /**
     * Create a new instance of this utility in a specific locale. See configuration options.
     * @param {Object} config The configuration parameters.
     * @config {String} locale The locale, such as 'en_US'.
     * @config {String} country The two character country code, such as 'US' (United States) or 'GB' (Great Britain).
     */
    init : function(config) {
        $.extend(this, config)
    },

    /**
     * Redirects the current window the the home page for the region. For example,
     * http://www.store.nike.com/US/en_US/
     */
    redirectToRegionalHomepage : function() {
        var loc = window.location;
        window.location = nike.getServiceUrl('baseBrandURL') + this.country + "/" + this.locale;
    },

    getUnsecuredRegionalHomepageUrl : function(){
        var loc = window.location;
        return 'http://' + loc.host + "/" + this.country + "/" + this.locale;
    },

    redirectToUniteStandALoneLogin : function() {
      window.location = nike.getServiceUrl('baseStoreURL') + this.country + "/" + this.locale + "/?l=shop,login_register";
    },

    /**
     * This function redirects a link to a new page either by opening a new window or updating the current window.
     * It will delay by 200ms by default and use the target attribute to determine how to open the link
     *
     * @deprecated
     *
     * @param {Event} event The click event that is going to navigate
     * @param {Number} [delay=200] The number of milliseconds before the navigation happens
     *
     * !!DEPRECATED FUNCTION!!
     * Should be using nike.gadget.LinkRedirector for all redirects
     * Use {@link nike.NavigationUtil.getLinkEventProperties} to get the properties of the link
     * to use with the event that triggers the redirect
     */
    delayLink : function (event, delay) {
        var target = $(event.currentTarget);

        if(!target.attr('href')) {
            target = target.find("[href]");
        }

        var newPage = target.attr('href');

        // Do nothing if the link in empty or not a valid URL
        if(!newPage || (newPage === "#") || (newPage.indexOf("javascript:") >= 0)) {
            return;
        }

        event.preventDefault();

        var isBlankTarget = !!target.attr('target') && (target.attr('target').toLowerCase() === '_blank');

        if(isBlankTarget) {
            window.open(newPage);
        } else {
            window.setTimeout(function () {
                window.location = newPage;
            }, delay || 200);
        }
    },

    /**
     * Determines the query and the target of an event.  It will dig through the
     * event.currentTarget until it finds an element with a href attribute
     *
     * @param {Event} event The event associated with the browser action
     * @return {Object}
     * @config {String} query The href that was found
     * @config {Boolean} newWindow What the target of the link is
     * @config {Boolean} noFollow Will set to TRUE if the link is invalid or should not be followed ('#', etc.)
     */
    getLinkEventProperties : function (event) {
      var target = $(event.currentTarget);
      var newPage;
      var isBlankTarget = false;
      var noFollow = false;

      if(!target.attr('href')) {
        target = target.find("[href]");
      }

      newPage = target.attr('href');

      // Do nothing if the link in empty or not a valid URL
      if(!newPage || (newPage === "#") || (newPage.indexOf("javascript:") >= 0)) {
        noFollow = true;
      }

      isBlankTarget = !!target.attr('target') && (target.attr('target').toLowerCase() === '_blank');

      return {
        query : newPage,
        newWindow : isBlankTarget,
        noFollow : noFollow
      }
    }
});

/**
 * @type {nike.NavigationUtil}
 */
nike.navUtil = new nike.NavigationUtil({
    country : nike.COUNTRY,
    locale : nike.LOCALE
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.NavigationUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};

/*********************************************************************************************************************
** DEPRECATED: Please use Hammer.js for all future touch related functionality
*********************************************************************************************************************/

/**
 * Input-specific interaction events.
 * @namespace interactionType
 *
 * @example $(div).on(nike.interactionType, doThing);
 */
nike.namespace("nike.interactionType");

nike.interactionType = {
    click:(Modernizr.touch)?'touchstart':'click',
    down:(Modernizr.touch)?'touchstart':'mousedown',
    up:(Modernizr.touch)?'touchend':'mouseup',
    enter:(Modernizr.touch)?'touchstart':'mouseenter',
    leave:(Modernizr.touch)?'touchend':'mouseleave',
    over:(Modernizr.touch)?'touchstart':'mouseover',
    out:(Modernizr.touch)?'touchend':'mouseout',
    move:(Modernizr.touch)?'touchmove':'mousemove'
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.interactionType. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}




try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.AbstractState
 */
nike.namespace('nike.exp.global.AbstractState');

nike.requireDependency('Class');

/**
 * @extends Class
 */
nike.exp.global.AbstractState = Class.extend(
/** @lends nike.exp.global.AbstractState.prototype */
{
  /**
   * @constructs
   *
   * @param {String} state The name of this state as defined in the constants.  Only used for developer reference.
   *
   * @see {@link nike.exp.global.AbstractState#compare}
   */
  init: function (state) {
    //noinspection JSValidateTypes
    if(this.constructor === nike.exp.global.AbstractState.prototype.constructor) {
      var msg = "Attempt to instantiate an abstract class! The nike.exp.global.AbstractState class MUST be extended to use.";
      nike.error(msg);
      throw new TypeError(msg);
    }
    this.state = state;
  },

  /**
   * Called when the state is changed to this class.  This should return a deferred object and resolve when all
   * setup for the state is finished.  The default is to resolve immediately.
   *
   * @param {nike.exp.global.StateController} context The controller context that is handling this class.
   * @param {...*} var_args Additional data to send to the state
   * @returns {jQuery.Deferred} When this state has finished entering, it will resolve or reject this deferred object.
   *
   * @see {@link jQuery.Deferred}
   * @see {@link nike.exp.global.StateController}
   *
   * @public
   */
  enter : function (context, var_args) {
    return $.Deferred().resolve();
  },

  /**
   * Called when the state should verify that it is still valid.  By default it will simply return resolve immediately.
   *
   * @param {nike.exp.global.StateController} context The controller context that is handling this class.
   * @returns {jQuery.Deferred} When this state has finished verifying, it will resolve or reject this deferred object.
   *
   * @see {@link jQuery.Deferred}
   * @see {@link nike.exp.global.StateController}
   */
  verify : function (context) {
    return $.Deferred().resolve();
  },

  /**
   * Used to compare this state with another one.  If the state is equivalent to the current one, it will return
   * the name of this state.  If it is not, but could be changed to the compared state, then it will return the
   * next state required to get there.
   *
   * @example
   * CPC_STATE.NOT_LOADED compared to CPC_STATE.BASIC_READY returns CPC_STATE.BASIC_LOADED as the next state required
   * to obtain BASIC_READY.
   *
   * CPC_STATE.COMPLETE_READY compared to CPC_STATE.BASIC_READY returns CPC_STATE.COMPLETE_READY as the return
   * since COMPLETE_READY already handles everything BASIC_READY needs.
   *
   * @param {String} state The name of the state that you want to compare to this one.  This should be the value
   *                       of the constant used to reference this state.
   * @returns {String} The name of the state that the state should be changed to for the state to obtain the compared
   *                   state.  ERROR if the current state cannot be changed to the compared one.
   *
   * @public
   */
  compare : function (state) {
    return state;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.AbstractState. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.StateController
 */
nike.namespace('nike.exp.global.StateController');

nike.requireDependency('Class');
nike.requireDependency('nike.exp.global.AbstractState');
nike.requireDependency('jQuery');

/**
 * @extends Class
 */
nike.exp.global.StateController = Class.extend(
/** @lends nike.exp.global.StateController.prototype */
{
  /**
   * Used to store all instantiated state classes
   *
   * @type Object<nike.exp.global.AbstractState>
   * @private
   */
  states : undefined,

  /**
   * The current state that this controller is in.
   *
   * @type String
   * @protected
   */
  curState : undefined,

  /**
   * The deferred object representing the progress of the current state.  It will
   * be 'pending' if the state has not been fully entered yet. 'rejected' if there
   * has been an error that can't be recovered from.
   *
   * @type jQuery.Deferred
   * @protected
   */
  curDeferred : undefined,

  /**
   * The state that this controller is trying to get to.  This will be used to guide a call
   * from {@link nike.exp.global.StateController#requireState}.
   *
   * @type String
   * @protected
   */
  goalState : undefined,

  /**
   * The deferred object representing the progress of obtaining goal state.  Will be 'rejected' if
   * there is no possibility of obtaining the goal.
   *
   * @type jQuery.Deferred
   * @protected
   */
  goalDeferred : undefined,

  /**
   * Used to store registered state change callbacks.
   *
   * @type jQuery.Callbacks
   * @private
   */
  stateCallbacks : undefined,

  /**
   * Helps resolve circular state rejection
   *
   * @type Object<String>
   * @private
   */
  previousStates : undefined,

  previousRequiredStates : undefined,

  /**
   * Create a new state controller using the namespace and the state constants passed.  The namespace will be
   * used to find the state classes in.  The states object should contain a set of constants that should be equal
   * to the camel cased names of proper cased classes.
   *
   * @example
   * <pre>new nike.exp.global.StateController(
   *   {
   *     NotLoaded : AbstractState.extend({}),
   *     BasicLoaded : AbstractState.extend({}),
   *     Error : AbstractState.extend({})
   *   },{
   *     NOT_LOADED : 'notLoaded',
   *     BASIC_LOADED : 'basicLoaded',
   *     ERROR : 'error'
   *   });</pre>
   *
   * CPC Profile States use the following parameters: (nike.exp.profile.state, nike.exp.profile.CPC_STATE)
   * The states are referred to by the rest of the codebase using the CPC_STATE constants and the controller
   * uses the state classes to do the work.
   *
   * @constructs
   * @param {Object<nike.exp.global.AbstractState>} namespace The namespace that will contain the extensions of
   *                                                          {@link nike.exp.global.AbstractState}
   * @param {Object<string>} states The object of state constants that will be used to find the class names
   *
   * @param {string} initialState The state that this class should initialize to
   * @public
   */
  init : function (namespace, states, initialState) {
    // Do some syntax checking to ensure valid use
    //noinspection JSValidateTypes
    if(typeof namespace !== 'object') {
      nike.error("WTF!");
      throw new SyntaxError("wth?!");
    } else if(typeof states !== 'object') {
      nike.error("HEY!");
      throw new SyntaxError("Why you gotta be like that?!");
    } else if (!initialState) {
      nike.error("WHY?!");
      throw new SyntaxError("oh man!");
    } else {
      this.createStates(namespace, states);
    }

    this.stateCallbacks = $.Callbacks('unique memory');

    this.changeState(initialState);
  },

  /**
   * Used to require that this controller obtain some state.  The return will be deferred object that will be
   * notified of the success or failure of the attempt.  If the object is 'resolved' the controller has
   * reach the required state.
   *
   * @example
   * this.requireState(CPC_STATE.COMPLETE_READY);
   *
   * @param {String} state The state that you want this controller to obtain using the state constant as reference.
   *
   * @returns {jQuery.Deferred} The deferred object that will report the success or failure of the request.
   * @see {@link jQuery.Deferred}
   *
   * @public
   */
  requireState : function (state) {
    var deferred;
    var hasGoalState = !!this.goalState;

    if(hasGoalState) {
      deferred = this.requireStateWithExistingGoal(state);
    } else {
      deferred = this.requireStateWithoutExistingGoal(state);
    }

    return deferred.promise();
  },

  /**
   * Used to call a function whenever the state is resolved to the request state
   *
   * @param {string} state The state constant that you want to register a callback for
   * @param {function} callback The function you want to execute when the state has been resolved
   * @returns {function} The function that needs to be used if you want to remove this listener later.
   * @public
   */
  listenForState : function (state, callback) {
    var listener = function (firedState) {
      if(firedState === state) {
        try {
          callback.apply(this, $.makeArray(arguments));
        } catch (exp) {
          nike.error("State callback threw an exception.  To prevent jQuery from breaking for everyone we are logging the error and not propogating it further up the stack.", exp);
        }
      }
    };

    this.stateCallbacks.add(listener);
    return listener;
  },

  /**
   * Used to call a function whenever the state is resolved to a state compatible with the requested state
   *
   * @param {string} state The state constant that you want to register a callback for
   * @param {function} callback The function you want to execute when the state has been resolved
   * @returns {function} The function that needs to be passed to removeListener.
   * @public
   */
  listenForCompatibleState : function (state, callback) {
    var self = this;
    var listener = function (firedState) {
      if(self.states[firedState].compare(state) === firedState) {
        try {
          callback.apply(this, $.makeArray(arguments));
        } catch (exp) {
          nike.error("State callback threw an exception.  To prevent jQuery from breaking for everyone we are logging the error and not propogating it further up the stack.", exp);
        }
      }
    };

    this.stateCallbacks.add(listener);
    return listener;
  },

  /**
   * Removes a listener from the controller.  The passed in function MUST be the function returned
   * by the listenFor method.   Otherwise it won't work.
   *
   * TODO: Make it work using a function array for the referencing.
   *
   * @param {function} func The function that was returned by the listenFor method
   */
  removeListener : function (func) {
    this.stateCallbacks.remove(func);
  },

  /**
   * Tests the current state for equality.
   *
   * @param {string} state The requested state to test
   * @returns {boolean} TRUE if the state is EQUAL to the current one, FALSE otherwise
   * @public
   */
  isStateEqualTo : function (state) {
    return this.curDeferred.isResolved() && this.curState === state;
  },

  /**
   * Tests the current state for a compatible state
   *
   * @param {string} state The requested state to test for compatibility
   * @returns {boolean} TRUE if the state is compatible to the current one, FALSE otherwise
   * @public
   */
  isStateComparableTo : function (state) {
    return this.curDeferred.isResolved() && this.states[this.curState].compare(state) === this.curState;
  },

  /**
   * Handles a requireState when another goal has already been specified.  It will
   * first compare the requirement to the current goal state and resolve or reject
   * based on the goal states compatibility to this new one.
   *
   * @param {String} state The requested state that should be obtained
   * @returns {jQuery.Deferred} The deferred object that will be notified of the success or failure
   *
   * @private
   */
  requireStateWithExistingGoal : function (state) {
    var deferred;
    var compareResult;

    compareResult = this.states[this.goalState].compare(state);

    // TODO: What if goalState is compatible to state.  Then we should be able to update the goalState.
    // TODO: Like if we have a LOGGED_IN goal and we are requesting USER_LOADED, that should be supported.
    // TODO: However, it may be that we are no longer compatible to the original goal if we do this
    // TODO: more than once.

    if(compareResult === this.goalState) {
      // Our current goal is compatible with the requested one
      deferred = this.goalDeferred;
    } else {
      // We cannot get to this state from the current goal
      deferred = $.Deferred().reject();
    }

    return deferred;
  },

  /**
   * Handles a requireState when a goal state has not already been set.  It will attempt to find
   * a way to get to the requested state through however many steps are necessary.  The returned
   * deferred object will be notified of the success or failure of the attempt.  It will also
   * notify whenever the state has been changed if tracking the states is needed.
   *
   * TODO: The notify events should also provide a way to handle when a state can't be obtained until
   * something happens, like a login modal displayed or multiple paths exist to the same goal.
   * Maybe something like deferred.notify(decisionFunc(deferred (wait for this) | state (this must be compared to current) ) )
   * Not calling the decision function will trigger default behavior, that might mean failure.
   *
   * @param {String} state The request state that should be obtained
   * @returns {jQuery.Deferred} The deferred object that will be notified of the success or failure
   *
   * @private
   */
  requireStateWithoutExistingGoal : function (state) {
    var deferred;
    var compareResult;
    var self = this;
    var handleGoalStepComplete = $.proxy(this.handleGoalStepComplete, this);
    var handleGoalStepFailed = $.proxy(this.handleGoalStepFailed, this);
    var curDeferred = this.curDeferred;

    this.previousRequiredStates = {};

    compareResult = this.states[this.curState].compare(state);

    if(compareResult === this.curState && this.curDeferred.isResolved()) {
      // We are at the required state AND resolved, so we can just return the deferred object
      deferred = this.curDeferred;
    } else if (compareResult !== 'error') {
      // We need to get to another state to satisfy this requirement or the current
      // state has not yet resolved.
      this.goalState = state;

      // We might need several steps to get to the goal
      this.goalDeferred = $.Deferred();
      deferred = this.goalDeferred;

      // Move to the first step of the goal
      curDeferred.done(handleGoalStepComplete);
      // If the state can't change, then the request should fail, but may change to another state
      curDeferred.fail(handleGoalStepFailed);

      // Once the goal is satisfied, we can remove the goal
      this.goalDeferred.always(
          function () {
            self.goalState = null;
            self.goalDeferred = null;
          });
    } else {
      // We can never get to this state, so return an error immediately.
      deferred = $.Deferred().reject();
    }

    return deferred;
  },

  /**
   * Handles each step of the processing towards a goal.  Whenever the current step
   * has finished, it will start the next one until the goal is resolved or fails.
   *
   * @recursive
   * @protected
   */
  handleGoalStepComplete : function () {
    var compareResult = this.states[this.curState].compare(this.goalState);
    var handleGoalStepComplete = $.proxy(this.handleGoalStepComplete, this);
    var handleGoalStepFailed = $.proxy(this.handleGoalStepFailed, this);
    var curDeferred;

    if(compareResult === this.curState) {
      // All done, report the success
      this.goalDeferred.resolve();
    } else if (compareResult !== 'error' && !this.previousRequiredStates[compareResult]) {
      this.previousRequiredStates[compareResult] = true;
      // Change the state and handle the change with the next step to complete
      this.changeState(compareResult);
      curDeferred = this.curDeferred;

      curDeferred.done(handleGoalStepComplete);
      // If the state can't change, then the request should fail
      curDeferred.fail(handleGoalStepFailed);
    } else {
      // There is no way to satisfy the goal, so we should reject the request.
      this.goalDeferred.reject();
    }
  },

  /**
   * Handles a failed attempt to obtain a goal.  A state change will report a failure
   * if the state was changed to another one.  So we should follow that change and
   * see if it is still compatible with our goal.
   *
   * @param {String} [curState]
   * @param {String} [newState] The state that this controller changed to instead of the requested one
   *
   * @private
   */
  handleGoalStepFailed : function (curState, newState) {
    // If we are failing because we have been forced into another
    // state, then we should follow it and see if we can
    // still obtain our goal from the new state
    if(newState && newState !== 'error') {
      this.curDeferred.done($.proxy(this.handleGoalStepComplete, this));
      this.curDeferred.fail($.proxy(this.handleGoalStepFailed, this));
    } else {
      this.goalDeferred.reject();
    }
  },

  /**
   * This is called to make a state change to another one.  The state will only actually
   * change if we aren't in an error state or are not still resolving another one.  In
   * all cases the deferred object will be returned of the current state loaded.
   *
   * DO NOT CALL THIS METHOD DIRECTLY.
   * USE: {@link nike.exp.global.StateController#requireState}
   *
   * @param {String} state The state that you want to change to
   * @param {...*} var_args All additional arguments are passed to the state instance enter method
   * @returns {jQuery.Deferred} A deferred object of the current state (regardless of whether it was changed or not)
   * @protected
   */
  changeState : function (state, var_args) {
    var controller = this;
    var argArray = $.makeArray(arguments);
    var stateInstance;

    // This will handle a state requiring a new state, like OUT_OF_SYNC state changing to LOGGED_OUT.
    var changeToAnotherState = function (curState, newState, ignoreCircular) {
      var argArray = $.makeArray(arguments);
      var stateInstance;
      // We are now going to change to a new state
      if(newState && controller.states[newState] && curState === controller.curState) {
        if(ignoreCircular || !controller.previousStates[newState]) {
          nike.debug("Leaving state: " + curState + ", Entering state: " + newState);
          // prevent circular states
          controller.previousStates[newState] = true;
          controller.curState = newState;
          stateInstance = controller.states[newState];
          argArray.splice(0, 3, controller);
          // Enter the new state
          // TODO: It might be needed to jump some of this execution out of the call stack
          // This could be possible by using another deferred object for the curDeferred and calling the enter(...)
          // of the state in a setTimeout(..., 1);
          controller.curDeferred = stateInstance.enter.apply(stateInstance, argArray);
          // Just in case we change another time
          controller.curDeferred.fail(changeToAnotherState);
          controller.curDeferred.done(
              function () {
                nike.debug("Resolved state: " + controller.curState);
                controller.stateCallbacks.fire(controller.curState);
              });
        } else {
          nike.error("Circular states detected.  Requested state '" + newState + "' has already failed to resolve once before.");
          // Enter the error state (which MUST exist for any state controller to function correctly)
          controller.curState = 'error';
          controller.curDeferred = controller.states.error.enter();
        }
      }
    };

    // If we can safely change the state, then do so, otherwise we will just return the current states deferred object.
    // TODO: If we aren't currently resolved on our current state, then the deferred will be the PREVIOUS state,
    // not the requested state.  This may cause usage errors.
    if(!this.curState || this.curState !== 'error' && this.curState !== state && this.curDeferred.isResolved()) {
      nike.debug("Leaving state: " + this.curState + ", Entering state: " + state);
      // prevent circular states
      controller.previousStates = {};
      controller.previousStates[state] = true;
      this.curState = state;
      stateInstance = this.states[this.curState];
      argArray.splice(0, 1, this);
      this.curDeferred = stateInstance.enter.apply(stateInstance, argArray);
      this.curDeferred.fail(changeToAnotherState);
      this.curDeferred.done(
          function () {
            nike.debug("Resolved state: " + controller.curState);
            controller.stateCallbacks.fire(controller.curState);
          });
    }

    return this.curDeferred;
  },

  /**
   * Initializes the states object with instantiated states.  These will be used to handle all
   * of the controllers operations and depend on sane inputs that resolve correctly.
   * Each of the defined states must find a match in namespace to work.
   *
   * @param {Object<nike.exp.global.AbstractState>} namespace The namespace that all states are in that should be
   *                                                          the proper case of their constant reference.
   * @param {Object<string>} states The constant values of each state in camel case form.
   *
   * @private
   */
  createStates : function (namespace, states) {
    var stateClasses = {};
    var stateKey, state, stateClassName, stateClass;

    for(stateKey in states) {
      if(states.hasOwnProperty(stateKey)) {
        state = states[stateKey];
        // Convert from camel case to proper case (notLoggedIn -> NotLoggedIn)
        stateClassName = state.slice(0,1).toUpperCase().concat(state.slice(1));
        stateClass = namespace[stateClassName];
        if(stateClass) {
          var newState = new stateClass();
          if(newState instanceof nike.exp.global.AbstractState) {
            stateClasses[state] = new stateClass();
          } else {
            nike.error("Unable to match state constant to a state class: " + state)
          }
        }
      }
    }

    this.states = stateClasses;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.StateController. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile
 */
nike.namespace("nike.exp.profile");

// Using extend to guarantee that I am not overwriting an existing profile class
$.extend(nike.exp.profile,
/** @lends nike.exp.profile */
{

  /**
   * Represents the state of the user and their profile.  Can be used
   * to obtain user data and handles the login and logout.
   *
   * @enum {string}
   * @constant
   */
  PROFILE_STATE : {
    /**
     * Indicates that the state of the user has not yet been deteremined.
     * @constant
     */
    NOT_KNOWN : 'notKnown',

    /**
     * The user is not logged in
     * @constant
     */
    NOT_LOGGED_IN : 'notLoggedIn',

    /**
     * The user logged in, but not in this session
     * @constant
     */
    REMEMBERED_LOG_IN : 'rememberedLogIn',

    /**
     * The user has logged in this session
     * @constant
     */
    LOGGED_IN : 'loggedIn',

    /**
     * Partial user data has been loaded of a remembered user
     * @constant
     */
    PARTIAL_USER_LOADED : 'partialUserLoaded',

    /**
     * Full user data has been loaded of a logged in user
     * @constant
     */
    USER_LOADED : 'userLoaded',

    /**
     * The state of the user is out of sync with the service calls.
     * @constant
     */
    OUT_OF_SYNC : 'outOfSync',

    /**
     * Something has gone wrong that we can't recover from
     * @constant
     */
    ERROR : 'error'
  },

  /**
   * Represents the state of the CPC Profile JSAPI and indicates
   * the type of load performed for the page.
   *
   * @enum {string}
   * @constant
   */
  CPC_STATE : {
    /**
     * Nothing has been loaded
     * @constant
     */
    NOT_LOADED : 'notLoaded',

    /**
     * The basic profile has been loaded, but not initialized
     * @constant
     */
    BASIC_LOADED : 'basicLoaded',

    /**
     * The basic profile has been initialized
     * @constant
     */
    BASIC_READY : 'basicReady',

    /**
     * The complete profile app has been loaded, but not initialized
     * @constant
     */
    COMPLETE_LOADED : 'completeLoaded',

    /**
     * The complete profile app has been initialized
     * @constant
     */
    COMPLETE_READY : 'completeReady',

    /**
     * Something has gone wrong that we can't recover from
     * @constant
     */
    ERROR : 'error'
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.NotLoaded
 */
nike.namespace('nike.exp.profile.state.NotLoaded');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.NotLoaded = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.NotLoaded.prototype */
{

  /**
   * The CPC Profile JSAPI is NOT currently loaded.
   *
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.CPC_STATE.NOT_LOADED);
  },

  /**
   * Provides the next step to reach a ready state based on the requested state.
   * The only way to receive an error state is to ask for one or to provide invalid states.
   *
   * @param {nike.exp.profile.CPC_STATE} goalState The goal state that you need to achieve.
   * @returns {nike.exp.profile.CPC_STATE}
   *          The next step required to achieve a goal. Will return itself if we are already there
   */
  compare : function (goalState) {
    var CPC_STATE = nike.exp.profile.CPC_STATE;
    var result = CPC_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(goalState) {
      case CPC_STATE.NOT_LOADED:
        result = CPC_STATE.NOT_LOADED;
        break;
      case CPC_STATE.BASIC_LOADED:
      case CPC_STATE.BASIC_READY:
        result = CPC_STATE.BASIC_LOADED;
        break;
      case CPC_STATE.COMPLETE_LOADED:
      case CPC_STATE.COMPLETE_READY:
        result = CPC_STATE.COMPLETE_LOADED;
        break;
      default:
        result = CPC_STATE.ERROR;
        break;
    }

    return result;
  }

});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.NotLoaded. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
 /**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.BasicLoaded
 */
nike.namespace('nike.exp.profile.state.BasicLoaded');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.BasicLoaded = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.BasicLoaded.prototype */
{

  /**
   * A list of dependencies that need to be externally loaded for a basic profile load.
   *
   * @type Array<string>
   * @constant
   * @private
   */
  DEPENDENCIES : [
    nike.getRootUrl() + "common/scripts/NikeProfileGlobal.js",
    nike.getRootUrl() + "common/scripts/backbone-0.9.2.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/jsapi/nike-profile.min.js"
  ],

  /**
   * Firefox and Internet Explorer have a tendency to jump the gun and execute a callback
   * before the requested code has finished executing.  To prevent this, we will poll for
   * the required namespaces, but only so many times before failing.  This is the maximum
   * number of attempts to poll for the namespaces.
   *
   * @type number
   * @constant
   * @private
   */
  MAX_ATTEMPTS : 50,

  /**
   * The delay between each poll.
   *
   * @type number
   * @constant
   * @private
   */
  ATTEMPT_DELAY : 10,

  /**
   * The CPC Profile JSAPI has been loaded but NOT yet initialized.
   *
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.CPC_STATE.BASIC_LOADED);
  },

  /**
   * Requests the {@link nike.exp.profile.state.BasicLoaded.DEPENDENCIES} defined and checks
   * for the required namespaces before resolving.
   *
   * @param {nike.exp.global.StateController} context The current state controller that is handling this state
   * @returns {jQuery.Deferred} Will indicate the success or failure of the state.
   */
  enter : function (context) {
    var deferred = $.Deferred();
    var attempts = 0;
    var MAX_ATTEMPTS = this.MAX_ATTEMPTS;
    var ATTEMPT_DELAY = this.ATTEMPT_DELAY;

    // Occassionally Firefox and IE will execute the callback BEFORE it executes the javascript for the loaded files
    var resourcesLoaded = function () {
      //noinspection JSUnresolvedVariable
      if(nike.profile && nike.profile.Application && _ && Backbone) {
        // We did it!
        deferred.resolve();
      } else if (attempts < MAX_ATTEMPTS) {
        // Must be Internet Explorer or Android, the execution of the scripts hasn't happened yet.
        //noinspection DynamicallyGeneratedCodeJS
        setTimeout(resourcesLoaded, ATTEMPT_DELAY);
        attempts++;
      } else {
        // We can't wait around forever, likely something loaded in the wrong order
        deferred.reject();
      }
    };

    // Only request the dependencies if we have to
    //noinspection JSUnresolvedVariable
    if(!nike || !nike.profile || !nike.profile.Application) {
      this.syncLoadScripts(this.DEPENDENCIES, resourcesLoaded, function () {deferred.reject();});
    } else {
      deferred.resolve();
    }

    return deferred;
  },
  /**
   * <p>Will load an array of scripts in the order they are entered into the array.</p>
   * @param {String[]} scripts    An array of urls to be used for loading the scripts.
   * @param {Function} success    A callback function to execute once the last script has finished loading.
   * @param {Function} fail       A callback function to execute if any of the scripts calls their onerror handler.
   */
  syncLoadScripts : function (scripts, success, fail) {
    var self = this,
        _scripts = scripts.concat([]), //since modification of the array is needed, creating a copy
        head = document.getElementsByTagName('head')[0] || document.documentElement,
        script = document.createElement('script'),
        onComplete = function () {
          //prevent double firing
          script.onreadystatechange = null;
          script.onload = null;
          script.onerror = null;

          if (_scripts.length === 0) {
            success();
          } else {
            self.syncLoadScripts(_scripts, success, fail);
          }
        },
        onFail = function () {
          script.onreadystatechange = null;
          script.onload = null;
          script.onerror = null;

          nike.error(script.src + ' : failed to load.');

          fail();
        };

    //add attributes
    script.type = 'text/javascript';
    script.src = _scripts.shift();

    //callback functions
    //for IE8 and less
    script.onreadystatechange = function () {
      if (script.readyState === 'complete' || script.readyState === 'loaded') {
        onComplete();
      }
    };
    //for all other browsers
    script.onload = onComplete;

    //for all browsers in case script fails, not very accurate but will
    // be good to know for responsible browsers.
    script.onerror = onFail;

    //add in execution order to the head.
    head.appendChild(script);
  },

  /**
   * Used to determine if this state is valid by checking for the namespaces this state
   * loads.
   *
   * @param {nike.exp.global.StateController} context The controller that is handling this state
   * @returns {jQuery.Deferred} Indicates if this state is valid or not
   */
  verify : function (context) {
    //noinspection JSUnresolvedVariable,OverlyComplexBooleanExpressionJS
    var valid = nike.profile && nike.profile.Application && _ && Backbone;

    var deferred = $.Deferred();

    if(valid) {
      deferred.resolve();
    } else {
      deferred.reject();
    }

    return deferred;
  },

  /**
   * The only valid state for basic loaded to achieve is itself and basic ready.  We
   * can't unload the javascript to complete load for instance.  CPC state is pretty
   * much a one way street.
   *
   * @param {nike.exp.profile.CPC_STATE} goalState The goal state that you need to achieve.
   * @returns {nike.exp.profile.CPC_STATE}
   *          The next step required to achieve a goal. Will return itself if we are already there
   */
  compare : function (goalState) {
    var CPC_STATE = nike.exp.profile.CPC_STATE;
    var result = CPC_STATE.ERROR;

    switch(goalState) {
      case CPC_STATE.BASIC_LOADED:
        result = CPC_STATE.BASIC_LOADED;
        break;
      case CPC_STATE.BASIC_READY:
        result = CPC_STATE.BASIC_READY;
        break;
      default:
        result = CPC_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.BasicLoaded. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.BasicReady
 */
nike.namespace('nike.exp.profile.state.BasicReady');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.BasicReady = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.BasicReady.prototype */
{
  /**
   * @constructs
   */
  init : function () {
    this._super(nike.exp.profile.state.BASIC_READY);
  },

  enter : function (context) {
    var deferred = $.Deferred();
    // Bootstrap XDM Settings for usage by the plugin
    //noinspection JSUnresolvedVariable
    nike.profile.settings.profile.xdm.urls.PROVIDER_HTML = nike.getServiceUrl('profileBaseService') + 'assets/jsapi/provider.html';

    //noinspection JSUnresolvedVariable
    nike.profile.main = nike.profile.Application.create(
    {
      urls : {
        profile: [ nike.getServiceUrl('profileBaseService') ]
      }
    },{
      success : function () {
        nike.info('nike.profile.Application init complete');
        nike.dispatchEvent(nike.Event.ONENIKE_PROFILE_API_READY, {});
        deferred.resolve();
      },
      fail : function () {
        nike.error('nike.profile.Application failed to initialize');
        nike.dispatchEvent(nike.Event.ONENIKE_PROFILE_API_FAILED, {});
        deferred.reject();
      }
    });
    deferred.done(function() {
      if (nike.profile.main) {
        nike.profile.main.setLocale(nike.LOCALE);
      }
    })

    return deferred;
  },

  verify : function () {
    var valid = nike.profile && nike.profile.main;

    var deferred = $.Deferred();

    if(valid) {
      deferred.resolve();
    } else {
      deferred.reject();
    }

    return deferred;
  },

  compare : function (goalState) {
    var CPC_STATE = nike.exp.profile.CPC_STATE;
    var result = CPC_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(goalState) {
      case CPC_STATE.BASIC_LOADED:
      case CPC_STATE.BASIC_READY:
        result = CPC_STATE.BASIC_READY;
        break;
      default:
        result = CPC_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.BasicReady. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.CompleteLoaded
 */
nike.namespace('nike.exp.profile.state.CompleteLoaded');

nike.requireDependency('nike.exp.profile.state.BasicLoaded');


/**
 * @extends nike.exp.profile.state.BasicLoaded
 */
nike.exp.profile.state.CompleteLoaded = nike.exp.profile.state.BasicLoaded.extend(
/** @lends nike.exp.profile.state.CompleteLoaded.prototype */
{
  DEPENDENCIES : [
    nike.getRootUrl() + "common/scripts/NikeProfileGlobal.js",
    nike.getRootUrl() + "common/scripts/backbone-0.9.2.min.js",
    nike.getRootUrl() + "common/scripts/jquery.Jcrop.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/libs/bootstrap.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/libs/bootbox.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/jsapi/nike-profile-app.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/libs/avatar-js.min.js",
    nike.getServiceUrl('profileBaseService') + "assets/libs/i18next-1.5.7.min.js"
  ],

  /** @constructs */
  init : function () {
    this._super(nike.exp.profile.CPC_STATE.COMPLETE_LOADED);
  },

  compare : function (goalState) {
    var CPC_STATE = nike.exp.profile.CPC_STATE;
    var result = CPC_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(goalState) {
      case CPC_STATE.BASIC_LOADED:
      case CPC_STATE.COMPLETE_LOADED:
        result = CPC_STATE.COMPLETE_LOADED;
      case CPC_STATE.BASIC_READY:
      case CPC_STATE.COMPLETE_READY:
        result = CPC_STATE.COMPLETE_READY;
        break;
      default:
        result = CPC_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.CompleteLoaded. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.CompleteReady
 */
nike.namespace('nike.exp.profile.state.CompleteReady');

nike.requireDependency('nike.exp.profile.state.BasicReady');

/**
 * @extends nike.exp.profile.state.BasicReady
 */
nike.exp.profile.state.CompleteReady = nike.exp.profile.state.BasicReady.extend(
/** @lends nike.exp.profile.state.CompleteReady.prototype */
{
  /** @constructs */
  init : function () {
    this._super(nike.exp.profile.CPC_STATE.COMPLETE_READY);
  },

  enter : function (context) {
    var stateDeferred = $.Deferred();
    var appDeferred;

    // Avatar Profile Settings
    // The CPC JSApplication Framework has built-in Notifications for various aspects. One of which are the service requests.
    // This setting allows enabling or disabling the notifications.
    nike.profile.settings.profile.notifications.services.isEnabled = false;
    nike.profile.settings.profile.routing.isEnabled       = false;
    nike.profile.settings.profile.validation.isEnabled    = true;
    nike.profile.settings.profile.i18n.isEnabled          = true;
    nike.profile.settings.profile.i18n.i18next            = {
      fallbackLng: "global",
      //lng: nike.LOCALE.split("_")[0],
      lng: 'global',
      ns: 'nike.profile',
      //resGetPath: 'scripts/widget/locales/nike.profile.'+nike.LOCALE.split("_")[0]+'.json',
      resStore: {
        global: {
          "nike.profile": {
            "verb": {
              "cancel": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-cancel"),
              "save": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-save")
            },
            "adj": {
              "loading": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-loading")
            },
            "widget-settings-avatar": {
              "title": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-title"),
              "delete-photo": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-delete-photo"),
              "upload-photo": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-upload-photo"),
              "be-valid-err": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-be-valid-err"),
              "restrictions": nike.exp.global.LocalValueUtil.getLocal("widget-settings-avatar-restrictions")
            }
          }
        }
      }


    };

    appDeferred = this._super(context);

    appDeferred.done( function () {
      nike.profile.main.start(); //start app for use by the avatar widgets
      stateDeferred.resolve();
    });

    appDeferred.fail(function () {
      stateDeferred.reject();
    });

    return stateDeferred;
  },

  compare : function (goalState) {
    var CPC_STATE = nike.exp.profile.CPC_STATE;
    var result = CPC_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(goalState) {
      case CPC_STATE.BASIC_LOADED:
      case CPC_STATE.BASIC_READY:
      case CPC_STATE.COMPLETE_LOADED:
      case CPC_STATE.COMPLETE_READY:
        result = CPC_STATE.COMPLETE_READY;
        break;
      default:
        result = CPC_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.CompleteReady. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.Error
 */
nike.namespace('nike.exp.profile.state.Error');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.Error = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.Error.prototype */
{
  /** @constructs */
  init : function () {
    this._super(nike.exp.profile.CPC_STATE.ERROR);
  },

  enter : function (context) {
    return $.Deferred().reject();
  },

  verify : function (context) {
    return $.Deferred().reject();
  },

  compare : function (state) {
    return nike.exp.profile.CPC_STATE.ERROR;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.Error. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.CpcStateController
 */
nike.namespace('nike.exp.profile.CpcStateController');

nike.requireDependency('nike.exp.global.StateController');
nike.requireDependency('nike.exp.profile');
nike.requireDependency('nike.exp.profile.state.NotLoaded');
nike.requireDependency('nike.exp.profile.state.BasicLoaded');
nike.requireDependency('nike.exp.profile.state.BasicReady');
nike.requireDependency('nike.exp.profile.state.CompleteLoaded');
nike.requireDependency('nike.exp.profile.state.CompleteReady');
nike.requireDependency('nike.exp.profile.state.Error');

nike.exp.profile.CpcStateController =
    new nike.exp.global.StateController(nike.exp.profile.state, nike.exp.profile.CPC_STATE, nike.exp.profile.CPC_STATE.NOT_LOADED);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.CpcStateController. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}



try{
var nike = nike || {};
nike.namespace("jQuery.base64");
nike.requireDependency("jQuery");
jQuery.extend({base64:{encode:function(b){var d="",g,c,f,a,e,h,j=0;b=b.replace(/\x0d\x0a/g,"\n");c="";for(f=0;f<b.length;f++)a=b.charCodeAt(f),128>a?c+=String.fromCharCode(a):(127<a&&2048>a?c+=String.fromCharCode(a>>6|192):(c+=String.fromCharCode(a>>12|224),c+=String.fromCharCode(a>>6&63|128)),c+=String.fromCharCode(a&63|128));for(b=c;j<b.length;)g=b.charCodeAt(j++),c=b.charCodeAt(j++),f=b.charCodeAt(j++),a=g>>2,g=(g&3)<<4|c>>4,e=(c&15)<<2|f>>6,h=f&63,isNaN(c)?e=h=64:isNaN(f)&&(h=64),d=d+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)+ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(g)+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(e)+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(h);return d},decode:function(b){var d="",g,c,f,a,e,h=0;for(b=b.replace(/[^A-Za-z0-9\+\/\=]/g,"");h<b.length;)g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(h++)),c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(h++)), a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(h++)),e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(h++)),g=g<<2|c>>4,c=(c&15)<<4|a>>2,f=(a&3)<<6|e,d+=String.fromCharCode(g),64!=a&&(d+=String.fromCharCode(c)),64!=e&&(d+=String.fromCharCode(f));b=d;d="";for(e=c1=c2=a=0;a<b.length;)e=b.charCodeAt(a),128>e?(d+=String.fromCharCode(e),a++):191<e&&224>e?(c2=b.charCodeAt(a+1),d+=String.fromCharCode((e&31)<<6|c2&63),a+=2):(c2= b.charCodeAt(a+1),c3=b.charCodeAt(a+2),d+=String.fromCharCode((e&15)<<12|(c2&63)<<6|c3&63),a+=3);return d}}});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.base64. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace("jQuery.base64url");

nike.requireDependency('jQuery.base64');

jQuery.base64url = (function ( $ ) {
  var _VERSION = "1.0";

  function _encode ( string ) {
    return string ? _base64toUrl($.base64.encode(string)) : string;
  }

  function _decode ( string ) {
    return string ? $.base64.decode(_urlToBase64(string)) : string;
  }

  function _urlToBase64 (string) {
    return string ? string.replace(/-/g, "+").replace(/_/g, "/").replace(/\./g,"=") : string;
  }

  function _base64toUrl (string) {
    return string ? string.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, ".") : string;
  }

  return {
    encode : _encode,
    decode : _decode,
    urlToBase64 : _urlToBase64,
    base64toUrl : _base64toUrl,
    VERSION : _VERSION
  }
})(jQuery);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.base64url. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.UserState
 */
nike.namespace('nike.exp.profile.state.UserState');

nike.requireDependency('Class');
nike.requireDependency('jQuery.base64url');
nike.requireDependency('JSON'); // This will augment the Date type with .toJSON() if it doesn't exist.

/**
 * @extends Class
 */
nike.exp.profile.state.UserState = Class.extend(
/** @lends nike.exp.profile.state.UserState.prototype */
{
  /**
   * Indicates if user has been logged in or not
   *
   * @type Boolean
   * @private
   */
  loggedIn : false,

  /**
   * Indicates that a user is only remembered and has not logged in
   * during the current session.
   *
   * @type Boolean
   * @private
   */
  shallow : true,

  /**
   * Indicates if the user is a swoosh employee or not
   *
   * @type Boolean
   * @private
   */
  isSwoosh : false,

  /**
   * The current display name of the user
   *
   * @type String
   * @private
   */
  displayName : undefined,

  /**
   * The current screen name of the user
   *
   * @type String
   * @private
   */
  screenName : undefined,

  /**
   * The suffix of the url of the avatar for this user
   *
   * @type String
   * @private
   */
  avatarURL : undefined,

  /**
   * When the user has selected the remember me option in the log in, this will
   * record the expiration date so we can correctly update the state cookie without
   * changing the expiration.
   *
   * @type Date
   * @private
   */
  exp : undefined,

  /**
   * The current profileId of the user
   *
   * @type String
   * @private
   */
  profileId : undefined,

  /**
   * The current mobile phone number of the user
   *
   * @type String
   * @private
   */
  mobileNumber : undefined,

  /**
   * Creates an instance of the user state.  There will likely only be one of these that will be handled
   * in the {@link nike.exp.profile.ProfileStateController}.
   *
   * @param {Object|String} [state] Optionally initialize this user state to something specific
   */
  init : function (state) {
    if(typeof state === 'object') {
      this.setState(state);
    } else if (state && typeof state === 'string') {
      this.fromCookieString(state);
    }
  },

  /**
   * Converts the state of the user into a string that can be stored in a cookie.  This can later
   * be used to restore this state.  The "shallow" property of this state will not be handled by this
   * string and needs to be handled outside of this class.
   *
   * @returns {string} The cookie safe string representing the state of the user.  This will be base64 encoded
   *                   using a url safe string. {@link jQuery.base64url}
   * @public
   */
  toCookieString : function () {
    var loginState = this.loggedIn ? 1 : 0;
    loginState += this.isSwoosh ? 2 : 0;

    var expires = this.exp && this.exp instanceof Date ? this.exp.toJSON() : "";

    var displayName = this.displayName || "";
    var avatarUrl = this.avatarURL || "";
    var profileId = this.profileId || "";
    var screenName = this.screenName || "";

    if(this.loggedIn) {
      // We are ending the string with another $$ because of bugs in Firefox that will add the "REPLACEMENT CHARACTER" \uFFFD
      // to the end of our string (sometimes) which will get fed into the Date constructor and break.  This is likely an artifact of
      // doing base64 encoding on UTF-8 character sets.
      return $.base64url.encode("" + loginState + "$$" + displayName + "$$" + avatarUrl + "$$" + expires + "$$" + profileId + "$$" + screenName + "$$");
    } else {
      return "0";
    }
  },

  /**
   * Converts a cookie string into the state of the user.  This should always be the cookie string created using
   * {@link #toCookieString}.  It can support the old style cookie as well that
   * was used before July2013.  Shallow log in will always be set and must be explicitly turned off outside
   * of this class using {@link #setState}
   *
   * @param {string} cookie The cookie string stored in the PROFILE_DATA_COOKIE
   * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, avatarURL: string, exp: Date, profileId: string, screenName: string}}
   * @public
   */
  fromCookieString : function (cookie) {
    if(cookie === "0") {
      this.setState({
        loggedIn : false,
        shallow : true,
        isSwoosh : false,
        displayName : null,
        avatarURL : null,
        exp : null,
        profileId : null,
        mobileNumber : null,
        screenName: null
      });

      return this.getState();
    }

    var data;
    var parts = [];

    // DEPRECATED COOKIE TEST //
    if(/^\{/.test(cookie)) {
      // OLD style cookie that should be parsed as a JSON string
      try {
        data = $.parseJSON(cookie);
        // Convert data
        parts[0] = data.loggedIn ? 1 : 0;
        parts[0] += data.isSwoosh ? 2 : 0;
        //noinspection JSUnresolvedVariable
        parts[1] = data.displayFullName || data.displayName;
        parts[2] = data.avatarURL;
        parts[3] = data.exp;
      } catch (exp) {
        parts[0] = 0;
      }
    } else {
      data = $.base64url.decode(cookie);
      parts = data.split("$$");
    }

    var expireString = parts[3];
    var expires = expireString ? new Date(expireString) : null;

    // IE can't create date from YYYY-MM-DDThh:mm:ssZ string. We'll convert it to YYYY/MM/DDThh:mm:ss string.
    //noinspection JSValidateTypes
    if (isNaN(expires)) {
      expires = new Date(Date.parse(expireString.replace(/\-/ig, '/').split('Z')[0].split('.')[0]));
    }

    //noinspection JSBitwiseOperatorUsage,NonShortCircuitBooleanExpressionJS
    this.setState({
      loggedIn : parts[0] & 1 ? true : false,
      shallow : true,
      isSwoosh : parts[0] & 2 ? true : false,
      displayName : parts[1],
      avatarURL : parts[2],
      exp : expires,
      profileId : parts[4],
      mobileNumber : parts[6],
      screenName : parts[5]
    });

    return this.getState();
  },

  /**
   * Consumes a cart summary response and sets all the relevant user state from it. Returns the current state
   * of the user after update.  Returns the updated state of the user with a valid shallow state set.
   *
   * @param cartSummary The response from the cart summary request.
   * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, avatarURL: string, exp: Date, profileId: string, screenName: string}}
   * @public
   */
  fromCartSummary : function (cartSummary) {
    var emailName = cartSummary.email ? cartSummary.email.substring(0, cartSummary.email.indexOf('@')) : '';

    this.setState({
      loggedIn : cartSummary.securityStatus >= 1,
      shallow : cartSummary.securityStatus >= 1 && cartSummary.securityStatus < 3,
      isSwoosh : !!(cartSummary.userType === nike.Cart.UserType.EMPLOYEE),
      // The displayName should use firstName lastName from the profile data if possible.
      // We will only use the cart summary displayName if we don't already have one defined.
      displayName : this.displayName || cartSummary.screenName || cartSummary.firstName || emailName,
      profileId: cartSummary.profileId,
      screenName: cartSummary.screenName
    });

    return this.getState();
  },

  /**
   * Consumes the user data from a profile service load() call.  If user is null, then the state will be changed
   * to a logged out user, otherwise it will set all relevant data in the user state.  Shallow will be set
   * to false.  Returns the updated state of the user.
   *
   * @param user The current user model from the profile services
   * @param account The current account model from the profile services (derived from the user object)
   * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, avatarURL: string, exp: Date, profileId: string, screenName: string}}
   * @public
   */
  fromUserData : function (user, account) {
    var displayName;

    if (user) {
      displayName = this.getDisplayName(user, account);
      this.setState({
        loggedIn : true,
        shallow : false,
        displayName : displayName,
        avatarURL : nike.objectDefined('avatar.base', user) ? user.avatar.base : this.avatarURL,
        profileId: user.id,
        screenName: account ? account.screenName : null
      })
    } else {
      this.setState({
        loggedIn : false
      })
    }

    return this.getState();
  },

  /**
   * Get user's display name and display appropriately. Account for any necessary fallbacks and locale-specific display logic.
   *
   * @param user The current user model from the profile services
   * @param account The current account model from the profile services (derived from the user object)
   * @returns {string}
   * @public
   */
  getDisplayName : function(user, account) {
    var displayName;

    displayName = (user.firstName && user.lastName) ? user.firstName + ' ' + user.lastName : "";
    displayName = displayName || user.firstName || "";
    if (account) {
      displayName = displayName || account.screenName;
      displayName = !displayName && account.email ? account.email.substring(0, account.email.indexOf('@')) : displayName;
    }
    // if user is in ja_JP locale, switch order of first & last if they exist. Add honorific no matter what is being used for displayName.
    if (nike.LOCALE == "ja_JP") {
      displayName = (user.firstName && user.lastName) ? user.lastName + ' ' + user.firstName + " さん" : displayName + " さん";
    } else if (nike.LOCALE == "zh_CN" || nike.LOCALE == "zh_TW") {
      displayName = (user.firstName && user.lastName) ? user.lastName + user.firstName : displayName;
    }

    return displayName;
  },

  /**
   * Returns the current state of the user.  The object returned is NOT a reference to the class and changes made
   * to it will not affect the running state of the user.
   *
   * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, avatarURL: string, exp: Date, profileId: string, screenName: string }}
   * @public
   */
  getState : function () {
    return {
      loggedIn : this.loggedIn,
      shallow : this.shallow,
      isSwoosh : this.isSwoosh,
      displayName : this.displayName,
      avatarURL : this.avatarURL,
      exp : this.exp,
      profileId : this.profileId,
      mobileNumber : this.mobileNumber,
      screenName : this.screenName
    }
  },

  /**
   * Set the state of the user.  Anything not specified will not be changed, however if loggedIn is false, then all
   * other fields are set to default.
   *
   * @param {{loggedIn?: boolean,shallow?: boolean,isSwoosh?: boolean, isNikePlus?: boolean, displayName?: string, avatarURL?: string, exp?: Date }} state
   * @public
   */
  setState : function (state) {
    this.loggedIn = typeof state.loggedIn === 'boolean' ? state.loggedIn : this.loggedIn;

    if(this.loggedIn) {
      this.shallow = typeof state.shallow === 'boolean' ? state.shallow : this.shallow;
      this.isSwoosh = typeof state.isSwoosh === 'boolean' ? state.isSwoosh : this.isSwoosh;
      this.displayName = typeof state.displayName === 'string' ? state.displayName : this.displayName;
      this.avatarURL = typeof state.avatarURL === 'string' ? state.avatarURL : this.avatarURL;
      this.exp = state.exp instanceof Date ? state.exp : this.exp;
      this.profileId = typeof state.profileId === 'string' ? state.profileId : this.profileId;
      this.mobileNumber = typeof state.mobileNumber === 'string' ? state.mobileNumber : this.mobileNumber;
      this.screenName = typeof state.screenName === 'string' ? state.screenName : this.screenName;
    } else {
      this.shallow = true;
      this.isSwoosh = false;
      this.displayName = "";
      this.avatarURL = "";
      this.exp = null;
      this.profileId = "";
      this.mobileNumber = "";
      this.screenName = "";
    }
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.UserState. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.NotKnown
 */
nike.namespace('nike.exp.profile.state.NotKnown');

nike.requireDependency('nike.exp.global.AbstractState');
nike.requireDependency('nike.Cart');
nike.requireDependency('nike.DomReady');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.NotKnown = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.NotKnown.prototype */
{

  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.NOT_KNOWN);
  },

  /**
   * This state will never resolve.  It's purpose is to determine the current state
   * of the user.   If the profile cookies exist, then it will use those to determine
   * the state of the user.  If they do not, then it will wait for a cart summary
   * response. If the cookies did not exist and if possible, the user will be loaded
   * to obtain additional name and avatar information.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile state controller to handle
   *                                                          updating the user state.
   * @returns {jQuery.Deferred} This deferred object will be rejected with the state of the user.
   */
  enter : function (context) {
    // cookie references here are left for ada
    var deferred = $.Deferred();
    //var profileData = $.CookieUtil(context.PROFILE_DATA_COOKIE);
    //var profileId = $.CookieUtil(context.PROFILE_ID_COOKIE);
    var self = this;
    //var state = null;
    var uniteDeferred = context.uniteDeferred;
    $.when(uniteDeferred).then(
      function (data, userType) {
        var userState = nike.exp.profile.ProfileStateController.updateUserData(data, null, userType);
        if (userState.loggedIn) {
          deferred.reject(self.state, nike.exp.profile.PROFILE_STATE.USER_LOADED); // Reject NotKnown because we got the whole user from cartsummary
        } else {
          deferred.reject(self.state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN); // Reject NotKnown because we're not logged in.
        }
    }.bind(self));
    // TODO: Delete these commented lines with final Unite implementation
    // // Try the cookie first
    // if(profileData) { // If we have cookie data.  Will always eval to false once we remove var.
    //   state = context.updateUserStateFromCookie(profileData, profileId); // Get state from cookie.

    //   if(state.loggedIn && !state.shallow) { // hit this block if user is fully logged in
    //     deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.LOGGED_IN); // Reject the NotKnown because user is logged in
    //   } else if (state.loggedIn && state.shallow) { // hit this block if user is logged in but shallowly
    //     deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN); // reject NotKnown because user is logged in via being remembered
    //   } else { // Hit this block if user is not logged in
    //     deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN); // Reject NotKnown because user it not logged in
    //   }
    // } else { // Hit this block if there is no profile data
      // Wait for the cart summary if there is no cookie
    nike.DomReady(
      // We need to wait until all the scripts in the head have executed to ensure
      // any request for a cpc state can be satisfied
      function waitForAllScriptToExecute () {
        // TODO: is this good enough to determine that unite never loaded?
        //if (!nike.unite) {
        //  var state = context.updateUserStateFromCartSummary(nike.Cart.getCartSummaryFromCookie());  // Update the state from the cart summary
        //  if(state.loggedIn) { // Hit this block if cart summary says we're logged in
        //    // We want to go all the way to USER_LOADED to retrieve all the user data we need in the cookie
        //    if (state.shallow) { // Hit this block if cart summary says we're only partially logged in
        //      deferred.reject(self.state, nike.exp.profile.PROFILE_STATE.PARTIAL_USER_LOADED); // Reject NotKnown because user is partially loaded
        //    } else { // Hit this block if user is not shallowly logged in
        //      deferred.reject(self.state, nike.exp.profile.PROFILE_STATE.USER_LOADED); // Reject NotKnown because we got the whole user from cartsummary
        //    }
        //  } else { // Hit this block if cart summary says we're not logged in
        //    deferred.reject(self.state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN); // Reject NotKnown because we're not logged in.
        //  }
        //
        //}
      });
    // }

    return deferred; // Return the deferred object to StateController
  },

  /**
   * This is the initial state of the profile, however this state will never
   * actually resolve.  It will ALWAYS reject to another state.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state
   * @returns {nike.exp.profile.PROFILE_STATE}
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(state) {
      case PROFILE_STATE.NOT_LOGGED_IN:
      case PROFILE_STATE.REMEMBERED_LOG_IN:
      case PROFILE_STATE.LOGGED_IN:
      case PROFILE_STATE.PARTIAL_USER_LOADED:
      case PROFILE_STATE.USER_LOADED:
        result = state;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.NotKnown. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.NotLoggedIn
 */
nike.namespace('nike.exp.profile.state.NotLoggedIn');

nike.requireDependency('nike.exp.global.AbstractState');
nike.requireDependency('nike.Cart');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.NotLoggedIn = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.NotLoggedIn.prototype */
{
  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN);
  },

  /**
   * This state resolves when the user state indicates that the user is not logged in.  It will
   * attempt to reject to a the correct state if the user state does not match this state.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile controller that each state has
   * @returns {jQuery.Deferred} Will resolve if the user state is not logged in, rejects with a new state otherwise
   */
  enter : function (context) {
    var deferred = $.Deferred();
    var userState = context.getUserState();

    if(!userState.loggedIn) {
      nike.dispatchEvent(nike.Event.LOGIN_STATE_UPDATED, userState);
      deferred.resolve();
    } else if(userState.loggedIn && !userState.shallow) {
      deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.USER_LOADED);
    }

    return deferred;
  },

  /**
   * The only valid state, for NOT_LOGGED_IN to validate against, is itself.  All other
   * states need to be explicitly obtained and are not valid in a requiredState() request
   * if we are in a NOT_LOGGED_IN state.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state The state that to compare to this one
   * @returns {nike.exp.profile.PROFILE_STATE} The state that should be obtained to achieve the requested state
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    switch(state) {
      case PROFILE_STATE.NOT_LOGGED_IN:
        result = PROFILE_STATE.NOT_LOGGED_IN;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.NotLoggedIn. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.RememberedLogIn
 */
nike.namespace('nike.exp.profile.state.RememberedLogIn');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.
RememberedLogIn = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.RememberedLogIn.prototype */
{
  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN);
  },

  /**
   * This state resolves when the user has logged in with the remember me option selected,
   * but not in this session.  If the user was logged in this session or not logged in at all,
   * then the state will reject to the appropriate state.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile controller
   * @returns {jQuery.Deferred} Will resolve if the user state is in sync, rejected otherwise.
   */
  enter : function (context) {
    var deferred = $.Deferred();
    var userState = context.getUserState();

    if(userState.loggedIn && userState.shallow) {
      nike.dispatchEvent(nike.Event.LOGIN_STATE_UPDATED, userState);
      deferred.resolve();
    } else if (userState.loggedIn && !userState.shallow) {
      deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.LOGGED_IN);
    } else {
      deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN);
    }

    return deferred;
  },

  /**
   * This state can only be compared to itself and allows a partial user loaded state to compare successfully.
   * Otherwise this state will return an error for all other states since they all require some user action
   * to obtain them.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state The state requested
   * @returns {nike.exp.profile.PROFILE_STATE} The next state to obtain, itself or an error
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    switch (state) {
      case PROFILE_STATE.REMEMBERED_LOG_IN:
        result = PROFILE_STATE.REMEMBERED_LOG_IN;
        break;
      case PROFILE_STATE.PARTIAL_USER_LOADED:
        result = PROFILE_STATE.PARTIAL_USER_LOADED;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.RememberedLogIn. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.LoggedIn
 */
nike.namespace('nike.exp.profile.state.LoggedIn');

nike.requireDependency('nike.exp.global.AbstractState');
nike.requireDependency('nike.Cart');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.LoggedIn = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.LoggedIn.prototype */
{
  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.LOGGED_IN);
  },

  /**
   * This state resolves when a user has logged in during the current browser session.  If the
   * user state does not match this state, then it will reject with the current state of the user.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile state controller
   * @returns {jQuery.Deferred} Indicates the success or failure to resolve this state.
   */
  enter : function (context) {
    var deferred = $.Deferred();
    var userState = context.getUserState();

    if(userState.loggedIn && !userState.shallow) {
      nike.dispatchEvent(nike.Event.LOGIN_STATE_UPDATED, userState);
      deferred.resolve();
    } else if (userState.loggedIn && userState.shallow) {
      deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN);
    } else {
      deferred.reject(this.state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN);
    }

    return deferred;
  },

  /**
   * This state will compare equivalently to itself and REMEMBERED_LOG_IN and will
   * return USER_LOADED for each of the user loaded states. All other states
   * will return an error.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state The state requested
   * @returns {nike.exp.profile.PROFILE_STATE} The next state needed to obtain the requested state.  Itself if equivalent.
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(state) {
      case PROFILE_STATE.REMEMBERED_LOG_IN:
      case PROFILE_STATE.LOGGED_IN:
        result = PROFILE_STATE.LOGGED_IN;
        break;
      case PROFILE_STATE.PARTIAL_USER_LOADED:
      case PROFILE_STATE.USER_LOADED:
        result = PROFILE_STATE.USER_LOADED;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.LoggedIn. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.PartialUserLoaded
 */
nike.namespace('nike.exp.profile.state.PartialUserLoaded');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.PartialUserLoaded = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.PartialUserLoaded.prototype */
{
  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.PARTIAL_USER_LOADED);
  },

  /**
   * This state resolves when a user has logged in with the remember me option selected, but not in
   * this session and we need to obtain some information about the user.  This state will perform a
   * user load while the user is in a remembered log in state.  The data received is only a small
   * subset of the total data, but is typically enough for the user state to use.
   *
   * Swoosh users should never attempt to obtain this state since it won't work for them.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile controller to update the user
   *                                                          state with the information about the user.
   * @param {boolean} [preventDataLoad=false] Used to trigger a switch the PARTIAL_USER_LOADED state without actually
   *                                          making any service calls.  This is an internal parameter.
   * @returns {jQuery.Deferred} Indicates the success or failure of the attempt.
   */
  enter : function (context, preventDataLoad) {
    var deferred = $.Deferred();
    var state = this.state;

    if(!preventDataLoad) {
      // Get the CPC Profile JSAPI ready to go
      var cpc = nike.exp.profile.CpcStateController.requireState(nike.exp.profile.CPC_STATE.BASIC_READY);

      cpc.done(
          function cpcServicesLoaded () {
            var userLoad;

            // We want to avoid throwing exceptions since they will orphan the deferred objects in a pending state.
            if(nike.objectDefined('nike.profile.api.user.load')) {
              userLoad = nike.profile.api.user.load(null, {
                // We need to use this depracted usage as per their own documentation to capture
                // a partial user state.
                partial : function (model, response) {
                  var userState = context.updateUserData(response.entity, true);
                  // If anything doesn't make sense with the return, then we should go out of sync to find out
                  // what is wrong.
                  if(!userState || !userState.loggedIn) {
                    deferred.reject(state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN);
                  } else {
                    // If everything is happy, resolve the state
                    deferred.resolve();
                    nike.dispatchEvent(nike.Event.LOGIN_STATE_UPDATED, userState);
                  }
                }
              });
              userLoad.done(
                  function fullUserLoaded (model, response) {
                    // The user actually resolved to a fully loaded user and not a partial.
                    context.updateUserData(response.entity);
                    deferred.reject(state, nike.exp.profile.PROFILE_STATE.USER_LOADED, true, true);
                  });
              userLoad.fail(
                  function userLoadFailed () {
                    // Unable to obtain user data
                    // We have no idea why that is, so we will just fallback to whatever it already is
                    // and ignore this request for user data
                    var userState = context.getUserState();
                    if(userState && userState.loggedIn) {
                      deferred.reject(state, nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN, true);
                    } else {
                      deferred.reject(state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN, true);
                    }
                  });
            } else {
              // The profile api did not successfully load even though it said it did
              deferred.reject(state, nike.exp.profile.PROFILE_STATE.ERROR);
            }
          });

      cpc.fail(
          function cpcServicesLoadFailed () {
            // We were unable to load the profile api
            deferred.reject(state, nike.exp.profile.PROFILE_STATE.ERROR);
          });
    } else {
      // Just resolve the state and do nothing else
      deferred.resolve();
    }

    return deferred;
  },

  /**
   * This state will compare equivalent to any remember login state.  However,
   * all other states will not compare since they all require user action to
   * obtain.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state The requested state
   * @returns {nike.exp.profile.PROFILE_STATE} The result of the comparision to this state
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch (state) {
      case PROFILE_STATE.REMEMBERED_LOG_IN:
      case PROFILE_STATE.PARTIAL_USER_LOADED:
        result = PROFILE_STATE.PARTIAL_USER_LOADED;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.PartialUserLoaded. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.UserLoaded
 */
nike.namespace('nike.exp.profile.state.UserLoaded');

nike.requireDependency('nike.exp.global.AbstractState');

/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.UserLoaded = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.UserLoaded.prototype */
{

  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.USER_LOADED);
  },

  /**
   * This state will resolve when the user data has been completely loaded from the profile services.  It
   * should never be entered by a swoosh user.
   *
   * @param {nike.exp.profile.ProfileStateController} context The controller context that is handling this class.
   * @returns {jQuery.Deferred} When this state has finished entering, it will resolve or reject this deferred object.
   *
   * @public
   */
  enter : function (context, preventDataLoad) {
    var deferred = $.Deferred();
    var state = this.state;

    nike.dispatchEvent(nike.Event.LOGIN_STATE_UPDATED, context.userState);
    deferred.resolve();
    return deferred;
  },

  /**
   * Used to compare this state with another one.  If the state is equivalent to the current one, it will return
   * the name of this state.  If it is not, but could be changed to the compared state, then it will return the
   * next state required to get there.
   *
   * @param {String} state The name of the state that you want to compare to this one.  This should be the value
   *                       of the constant used to reference this state.
   * @returns {String} The name of the state that the state should be changed to for the state to obtain the compared
   *                   state.  ERROR if the current state cannot be changed to the compared one.
   *
   * @public
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(state) {
      case PROFILE_STATE.REMEMBERED_LOG_IN:
      case PROFILE_STATE.LOGGED_IN:
      case PROFILE_STATE.PARTIAL_USER_LOADED:
      case PROFILE_STATE.USER_LOADED:
        result = PROFILE_STATE.USER_LOADED;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.UserLoaded. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.state.OutOfSync
 */
nike.namespace('nike.exp.profile.state.OutOfSync');

nike.requireDependency('nike.exp.global.AbstractState');

//noinspection MagicNumberJS
/**
 * @extends nike.exp.global.AbstractState
 */
nike.exp.profile.state.OutOfSync = nike.exp.global.AbstractState.extend(
/** @lends nike.exp.profile.state.OutOfSync.prototype */
{

  /**
   * Indicates the number of milliseconds to wait before retesting if a user
   * is really logged out or not before FORCING a logout of the user.
   *
   * @type number
   * @constant
   * @private
   */
  OUT_OF_SYNC_DELAY : 500,

  FORCED_LOGOUT_RETRIES : 2,

  /**
   * @constructs
   */
  init: function () {
    this._super(nike.exp.profile.PROFILE_STATE.OUT_OF_SYNC);
  },

  /**
   * This state will never resolve.  It's purpose it to determine the state of the user if it has changed
   * from what we assumed it was.  This could happen when the user logs off in another Nike site and the cart summary
   * reports a logged out user, when our cookies show a logged in user.  We can get to this state whenever
   * the cart summary, the profile services or the cookies are not consistent.
   *
   * If we were a logged out user and now we are a logged in user, then we will simply set the state
   * to what the user state is now reporting, updating the user data as we need to.
   *
   * However, if the user was logged in, but is now reporting logged out, then we will use the cart summary
   * as the trusted source of the user state.   If the user is still logged out after checking a second time, then we
   * will force a log out of the user.
   *
   * @param {nike.exp.profile.ProfileStateController} context A reference to the profile controller to update the user state
   * @returns {jQuery.Deferred} Will be rejected with the determined state of the user.
   */
  enter : function (context) {
    var state = this.state;
    var deferred = $.Deferred();
    var delay = this.OUT_OF_SYNC_DELAY;
    var logoutRetries = this.FORCED_LOGOUT_RETRIES;
    var logoutChecks = 0;

    // We want to wait a bit before we check the state again.  There is a HIGH probability that
    // that we got to this state because the CPC Profile services and the ATG Services are not communicating
    setTimeout(
        function outOfSyncTimeout () {
          nike.Cart.loadCartSummary("nikestore",
              function cartSummarySuccess (data) {
                var userState;
                if(data && data.response) {
                  userState = context.updateUserStateFromCartSummary(data.response);
                  if(userState.loggedIn && !userState.shallow) {
                    // At this point, we should load all the user data so we can update the cookie
                    deferred.reject(state, nike.exp.profile.PROFILE_STATE.USER_LOADED);
                  } else if (userState.loggedIn && userState.shallow) {
                    // We are a remembered user, but we need to get the name of the user
                    deferred.reject(state, nike.exp.profile.PROFILE_STATE.PARTIAL_USER_LOADED);
                  } else {
                    if(logoutChecks < logoutRetries) {
                      nike.warn("Logged out state reported by the cart summary services, we will retry before forcing the logout of the CPC Services");
                      setTimeout(outOfSyncTimeout, delay);
                      logoutChecks++;
                    } else {
                      // We are now going to FORCE the logout of the user
                      nike.warn("A logged out state has been reported by the cart summary services after multiple retries.  We are now going to FORCE a log out of the user.");
                      //noinspection JSAccessibilityCheck
                      context.submitLogout().always(
                          function () {
                            deferred.reject(state, nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN, true);
                          });
                    }
                  }
                } else {
                  // Invalid response from the cart summary
                  deferred.reject(state, nike.exp.profile.PROFILE_STATE.ERROR);
                }
              },
              function cartSummaryFailed () {
                // Failed cart summary request
                deferred.reject(state, nike.exp.profile.PROFILE_STATE.ERROR);
              },
            true);
        }, delay);

    return deferred;
  },

  /**
   * Since this state will never resolve, then any valid state that is compared will
   * return the state requested to allow any requireState() to succeed correctly.
   *
   * @param {nike.exp.profile.PROFILE_STATE} state The desired state to obtain from this state
   * @returns {nike.exp.profile.PROFILE_STATE} The next state in the sequence that should be obtained to reach the desired state
   */
  compare : function (state) {
    var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
    var result = PROFILE_STATE.ERROR;

    //noinspection FallthroughInSwitchStatementJS
    switch(state) {
      case PROFILE_STATE.NOT_LOGGED_IN:
      case PROFILE_STATE.REMEMBERED_LOG_IN:
      case PROFILE_STATE.LOGGED_IN:
      case PROFILE_STATE.PARTIAL_USER_LOADED:
      case PROFILE_STATE.USER_LOADED:
        result = state;
        break;
      default:
        result = PROFILE_STATE.ERROR;
        break;
    }

    return result;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.state.OutOfSync. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * If you need to reference a function here for a test, stub it in ProfileStateController.mock.js
 */
nike.namespace('nike.exp.profile.ProfileStateController');

nike.requireDependency('nike.exp.global.StateController');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.exp.profile.CpcStateController');
nike.requireDependency('nike.exp.profile');
nike.requireDependency('nike.exp.profile.state.UserState');
nike.requireDependency('nike.exp.profile.state.NotKnown');
nike.requireDependency('nike.exp.profile.state.NotLoggedIn');
nike.requireDependency('nike.exp.profile.state.RememberedLogIn');
nike.requireDependency('nike.exp.profile.state.LoggedIn');
nike.requireDependency('nike.exp.profile.state.PartialUserLoaded');
nike.requireDependency('nike.exp.profile.state.UserLoaded');
nike.requireDependency('nike.exp.profile.state.OutOfSync');
nike.requireDependency('nike.exp.profile.state.Error');

/**
 * Singleton instance of ProfileStateController
 */
nike.exp.profile.ProfileStateController = ( function createSingletonForProfileStateController () {
  /**
   * @class nike.exp.profile.ProfileStateController
   * @extends nike.exp.global.StateController
   */
  var ProfileClass = nike.exp.global.StateController.extend(
  /** @lends nike.exp.profile.ProfileStateController.prototype */
  {

    /**
     * The profile data cookie is used to store the current state of a login to minimize the reasons
     * to load the full profile API and load up the complete user.
     *
     * @type String
     * @public
     * @constant
     */
    PROFILE_DATA_COOKIE : "pr_data",

    /**
     * The profile ID cookie is currently the only way to tell if a user was logged in
     * with the profile API from the store during the current session.
     *
     * @type String
     * @public
     * @constant
     */
    PROFILE_ID_COOKIE : "pr_id",

    /**
     * All the cookies that must be removed on logout.
     *
     * @type array<string>
     * @private
     * @constant
     */
    LOGOUT_COOKIES : [ "pr_id", "pr_data" ],

    /**
     * The current state of the user.  Should be accessed via
     * {@link ProfileClass#getUserState}
     *
     * @type nike.exp.profile.UserState
     *
     * @private
     * @constant
     */
    userState : new nike.exp.profile.state.UserState(),

    /**
     * Use getUserData() and NEVER this variable directly.  It could be out of state.
     * If you MUST have user account data, then make sure you requireState(USER_LOADED) first.
     *
     * @type object
     * @private
     */
    User : undefined,

    /**
     * Use getUserAccount() and NEVER this variable.  It could be out of state.
     * If you MUST have user account data, then make sure you requireState(USER_LOADED) first.
     *
     * @type object
     * @private
     */
    UserAccount : undefined,

    /**
     * This is the deferred object surrounding the initial cart summary request.  This will be
     * waited for before a requireState() is satisfied to allow the controller to shift
     * if the cookies are out of sync.
     *
     * @type jQuery.Deferred
     * @private
     */
    initialCartRequest : undefined,

    /**
     * This is the deferred object for the initial Unite getUserProfile() call.
     *
     * @type jQuery.Deferred
     * @private
     */
    uniteDeferred: $.Deferred(),
    /**
     * This class handles the state of the user.  It keeps in sync as cart summary calls are made and should be
     * the point of reference whenever the following functions are needed with the profile service that might
     * affect the state of the user:
     *
     *  - {@link nike.exp.profile.ProfileStateController#login}
     *  - {@link nike.exp.profile.ProfileStateController#logout}
     *  - {@link nike.exp.profile.ProfileStateController#register}
     *
     *  This class should also be used to obtain user and account data and the current state of the user.
     *  User state can be viewed at any time, however user and account data require that you be in
     *  the {@link nike.exp.profile.PROFILE_STATE.USER_LOADED} state before accessing.
     *
     *  - {@link nike.exp.profile.ProfileStateController#getUserState}
     *  - {@link nike.exp.global.StateController#requireState}
     *  - {@link nike.exp.profile.ProfileStateController#getUserData}
     *  - {@link nike.exp.profile.ProfileStateController#getAccountData}
     *
     *  You can respond to state changes by using the inherited methods from StateController for the purpose:
     *
     *  - {@link nike.exp.global.StateController#listenForState}
     *  - {@link nike.exp.global.StateController#listenForCompatibleState}
     *  - {@link nike.exp.global.StateController#isStateEqualTo}
     *  - {@link nike.exp.global.StateController#isStateComparableTo}
     *
     * @see Examples: {@link nike.exp.global.StateController}
     * @see States: {@link nike.exp.profile.PROFILE_STATE}
     *
     * @constructor
     * @param {Object<nike.exp.global.AbstractState>} namespace The namespace that will contain the extensions of
     *                                                          {@link nike.exp.global.AbstractState}
     * @param {Object<string>} states The object of state constants that will be used to find the class names
     * @param {string} initialState The state that this class should initialize to
     *
     * @override
     */
    init : function (namespace, states, initialState) {
      var self = this;
      this.initUnite();
      this._super(namespace, states, initialState);
      this.initialCartRequest = $.Deferred();

      this.initialCartRequest.done($.proxy(this.handleCartSummaryRequest, this));

      /*
       * Refactor of the way we are loading Cart Summary info:
       * remove the local call to self.loadCartSummary, we will load
       * from nike.Cart.getCartSummaryFromCookie and pass it to the success handler (failure is not an option,
       * since we will always have a default user data object returned from getCartSummaryFromCookie)
       */

      var data = {};
      //the current flow expects data to be in the response param; can we refactor downstream?
      data.response = nike.Cart.getCartSummaryFromCookie();

      //Resolve the deferred self.initialCartRequest object immediately, which will fire the handleCartSummaryRequest.
      //However, this seems inefficient and would benefit for a refactoring of the deferred object, since we are not waiting on data any longer.
      self.initialCartRequest.resolve(data);

    },

    initUnite : function () {
      var self = this;
      var storedUniteInit = window.nikeUniteInit;

      window.nikeUniteInit = (function() {
        return function(str) {
          //Once Unite is loaded, check to user's state and update the UI
          nike.unite.session.getUserProfile(
            function success(userProfile, userType){
              if (!userProfile) {
                self.uniteDeferred.resolve(null);
                return null;
              }

              self.uniteDeferred.resolve(userProfile.entity, userType);
            },
            function failure(error){
              self.uniteDeferred.resolve(error);
              //the user is not logged in
              return null;
            }
          );
          if (typeof storedUniteInit === "function") {
            // call whatever nikeUniteInit was previously if it was a function
            storedUniteInit.apply(this, arguments);
          }
        };
      }());
    },

    fetchUserData: function () {
      var self = this;
      var deferred = $.Deferred();
      nike.unite.session.getUserProfile(
        function success (userProfile, userType) {
          var user = userProfile.entity;

          var state = self.convertUniteUserToState(user, userType);
          self.updateUserData(user, null, userType);
          nike.dispatchEvent(nike.Event.SHOW_MEMBER_SECTION, state);
          deferred.resolve();
        }.bind(self), function failure (error) {
          nike.error('Failed to get user data from Unite: ' + error);
          deferred.reject();
        }.bind(self));
      return deferred;
    },

    convertUniteUserToState: function(user, userType){
      var state = {
        loggedIn : false,
        shallow : true,
        isSwoosh : false,
        displayName : "",
        avatarURL : "",
        profileId : "",
        screenName : ""
      };

      /**
       * Get user's display name and display appropriately. Account for any necessary fallbacks and locale-specific display logic.
       *
       * @param user The current user model from the profile services
       * @param account The current account model from the profile services (derived from the user object)
       * @returns {string}
       * @public
       */
      var getDisplayName  = function(user, account) {
        var displayName;

        displayName = (user.firstName && user.lastName) ? user.firstName + ' ' + user.lastName : "";
        displayName = displayName || user.firstName || "";
        if (account) {
          displayName = displayName || account.screenName;
          displayName = !displayName && account.email ? account.email.substring(0, account.email.indexOf('@')) : displayName;
        }
        // if user is in ja_JP locale, switch order of first & last if they exist. Add honorific no matter what is being used for displayName.
        if (nike.LOCALE == "ja_JP") {
          displayName = (user.firstName && user.lastName) ? user.lastName + ' ' + user.firstName + " さん" : displayName + " さん";
        } else if (nike.LOCALE == "zh_CN" || nike.LOCALE == "zh_TW") {
          displayName = (user.firstName && user.lastName) ? user.lastName + user.firstName : displayName;
        }

        return displayName;
      }

      if (user) {
        state.loggedIn = true;
        state.shallow = false;
        state.isSwoosh = (userType == "EMPLOYEE");
        state.displayName = getDisplayName(user, user.account);
        state.avatarURL = nike.objectDefined('avatar.base', user) ? user.avatar.base : "";
        state.profileId = user.id;
        state.screenName = user.account.screenName;
      }

      return state;
    },

    /**
     * This loads the cartsummary data if not already loaded by initial jcartservice call.
     * After user hits the submit review button, and successfully logs in we refresh the cartsummary data.
     * @param refresh
     */
    loadCartSummary: function(refresh, overrideProtector, callback) {
      var self = this;
      // Kick off a cart summary request.
      nike.Cart.loadCartSummary("nikestore",
      function handleSuccessfulCartSummary (data) {
        self.initialCartRequest.resolve(data);
        if(callback){
          callback();
        }
        // Listen for the future cartSummary updates to verify and possibly update the state
        nike.listen(nike.Event.CART_SUMMARY_REQUEST_SUCCESS,
        function (event, data) {
          self.handleCartSummaryRequest(data);
        });
      },
      function handleFailedCartSummary () {
        self.initialCartRequest.reject();
        self.changeState(nike.exp.profile.PROFILE_STATE.ERROR);
      },
      refresh,
      overrideProtector
      );
    },

    /**
     * Used to require that this controller obtain some state.  The return will be deferred object that will be
     * notified of the success or failure of the attempt.  If the object is 'resolved' the controller has
     * reached the required state or a state that is equivalent.
     *
     * @example
     * this.requireState(PROFILE_STATE.USER_LOADED);
     *
     * @param {nike.exp.profile.PROFILE_STATE} state The state that you want this controller to obtain
     *                                               using the state constant as reference.
     * @returns {jQuery.Deferred} The deferred object that will report the success or failure of the request.
     * @see {@link jQuery.Deferred}
     * @see {@link nike.exp.profile.PROFILE_STATE}
     *
     * @override
     * @public
     */
    requireState : function (state) {
      var deferred = $.Deferred();
      var self = this;
      var __super = this._super;
      // Since we are requiring this state, we have to make sure that the cart summary has
      // completed and made changes to the state BEFORE we verify it.
      this.initialCartRequest.done(
          function handleInitialCartRequest () {
            // Handles the actual required state calls
            var goal = __super.call(self, state);

            goal.done(function () {
              deferred.resolve();
            });

            goal.fail(function () {
              deferred.reject();
            });
          });

      this.initialCartRequest.fail(
          function handleFailedCartRequest () {
            deferred.reject();
          });

      return deferred.promise();
    },


    loginFromUnite: function(user, account){
      /// SUCCESS START ///

      var self = this;

      nike.Cart.clearCartSummary();
      //self.setProfileCookies(account);
      // self.changeState(nike.exp.profile.PROFILE_STATE.LOGGED_IN);

      $.proxy(self.loadCartSummary(true, true, function(){
        //Set the user state, since we have all the info we need at this step
        self.updateUserData(user);

        // Change the state to load additional user data
        self.changeState(nike.exp.profile.PROFILE_STATE.USER_LOADED);
      }), self);
    },

    /**
     * Handles logging into the CPC Profile Services using provided credentials.  A failed attempt
     * will reject the deferred with both the message and the response.  The message could be the
     * message object returned from the service call or a simple string detailing why the service call
     * failed.  This function will not fire any login events except for the deprecated LOGIN_STATE_UPDATED
     * to indicate that the user state has changed.
     *
     * @param {object} data The form data that should contain the user credentials
     * @param {string} data.email The email of the user
     * @param {string} data.password The plain text password of the user
     * @param {boolean} data.rememberMe Indicates whether the user wants to be remembered or not
     *
     * @return {jQuery.Deferred} Used to indicate the success or failure of the attempt
     * @public
     */
    login : function (data) {
      // Wait for both the current state to be resolved and the CPC state to be BASIC_READY
      var cpcDeferred = $.when(this.curDeferred,
                            nike.exp.profile.CpcStateController.requireState(nike.exp.profile.CPC_STATE.BASIC_READY));

      // This will be our returned deferred object
      var deferred = $.Deferred();

      var self = this;

      cpcDeferred.done(
          function cpcServicesLoaded () {
            if(nike.objectDefined('nike.profile.api.account.login')) {
              // Log the user in using the CPC Profile JSAPI
              var loginDeferred = nike.profile.api.account.login(data);

              loginDeferred.done(
                  function loginSuccessful (model) {
                    var account;

                    try {
                      account = model.toJSON();
                    } catch (exp) {
                      nike.error("Exception while accessing user model", exp);
                      deferred.reject("Unable to access user model", model);
                    }

                    if (!account || !account.id) {
                      deferred.reject("account model is invalid", account);
                    }

                    /// SUCCESS START ///

                    nike.Cart.clearCartSummary();
                    //self.setProfileCookies(account, data.rememberMe);

                   $.proxy(self.loadCartSummary(true, true, function(){
                      // Change the state to load additional user data

                      var stateDeferred = self.changeState(nike.exp.profile.PROFILE_STATE.USER_LOADED);
                      stateDeferred.always(
                      function stateChanged () {
                        deferred.resolve(account);
                      });

                      stateDeferred.fail(
                      function userLoadFailed () {
                        nike.warn("Unable to load full user data.  However, we are logged in, so ignoring");
                      });
                   }), self);

                  });

              loginDeferred.fail(
                  function loginFailed (model, response) {
                    var message, user, parsedResponse;

                    try {
                      parsedResponse = typeof response === 'object' && typeof response.responseText === 'string' ? $.parseJSON(response.responseText) : "";
                      message = parsedResponse && parsedResponse.length ? parsedResponse[0] : "Unable to parse error message";
                      message = typeof message === 'object' && message.errorMessage ? message : "Unable to parse error message";
                      user = model.toJSON();
                    } catch (exp) {
                      nike.error("Exception was thrown trying to parse login error", exp);
                    } finally {
                      message = message || "Unable to parse response";
                      user = user || model;
                    }

                    // We are going to reject with a simple string UNLESS it is an error
                    // directly from the CPC Profile service.  Then we can return that object.
                    deferred.reject(message, user);
                  });
            } else {
              deferred.reject("Unable to find profile account login services", nike.profile);
            }
          });

      cpcDeferred.fail(
          function cpcServicesFailed () {
            deferred.reject("Unable to login user");
          });

      deferred.fail(
          function loginRequestFailed (message, response) {
            nike.error(message, response);
          });

      return deferred.promise();
    },

    /**
     * Used to logout a user.   The deferred object returned will indicate the success or failure of the
     * attempt.  However, most of the time you will want to use .always() since it doesn't matter how
     * successful the logout actually was, you just want to know when it's done.
     *
     * @returns {jQuery.Deferred} Used to indicate the success or failure of the attempt
     * @public
     */
    logout : function () {
      var deferred = $.Deferred();
      var self = this;

      this.curDeferred.done(
        function currentStateResolved () {
          // Make the actual logout call.  This is done to separate out the explicit log outs caused by
          // user interaction from the forced log outs.
          var logout = self.submitLogout();

          logout.done(
            function logoutSuccessful () {
              // Reload if on product wall or PDP
              var reload = (location.href.match(/\/pd|pw|product\//) || (nike.exp && nike.exp.gridwall)) ? true : false;

              if (reload) {
                window.location.reload();
              } else {
                // Change the state
                nike.Cart.clearCartSummary();
                nike.gadget.CartCount.setup($('[data-gadget="nike.gadget.OneNikeNav"]'));
                self.changeState(nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN).done(
                  function stateChangedForLogout() {
                    deferred.resolve();
                  });
              }
            });

          logout.fail(
            function logoutFailed () {
              deferred.reject();
            });
        });

      this.curDeferred.fail(
        function currentStateRejected () {
          deferred.reject();
        });

      return deferred.promise();
    },

    /**
     *
     * @param {object} formData
     * @returns {jQuery.Deferred}
     * @public
     */
    register : function (formData) {
      var deferred = $.Deferred();
      var self = this;

      var apiReady = $.when(this.curDeferred,
                            nike.exp.profile.CpcStateController.requireState(nike.exp.profile.CPC_STATE.BASIC_READY),
                            this.submitLogout());
      apiReady.done(
          function serviceLoadSuccessful () {
            if(nike.objectDefined("nike.profile.api.user.create")) {
              var registerDeferred = nike.profile.api.user.create(formData);

              registerDeferred.done(
                  function registerSuccessful (model) {
                    try {
                      var user = model.toJSON();
                      var state = self.updateUserData(user);

                      if(state.loggedIn) {

                        // Clear the existing cart summary
                        nike.Cart.clearCartSummary();

                        // Change the state to USER_LOADED without actually making any additional calls
                        var stateDeferred = self.changeState(nike.exp.profile.PROFILE_STATE.USER_LOADED, true);

                        // We already have the user data, although possibly without MSP data.
                        stateDeferred.always(function waitForState () {
                          deferred.resolve(user);
                        });

                        stateDeferred.fail(function failedUserLoad () {
                          nike.warn("Unable to load full user data, but we have most of it already, so ignoring");
                        });

                      } else {
                        deferred.reject("User data is not valid and user is not logged in");
                      }

                    } catch (exp) {
                      nike.error("Returned model is not valid", exp, model);
                      deferred.reject("Returned model is not valid");
                    }
                  });

              registerDeferred.fail(
                  function registerFailed (message, response) {
                    deferred.reject(response);
                  });
            } else {
              deferred.reject("Cannot find profile api user create");
            }
          });

      apiReady.fail(
          function serviceLoadFailed () {
            deferred.reject("Unable to load profile api");
          });

      return deferred;
    },

    serviceLoadSuccessful: function (formData) {

    },

    /**
     * Retrieves the current state of the user.
     *
     * {@link nike.exp.profile.state.UserState#loggedIn} - Whether the user is logged in or not (security status 1 or higher)
     * {@link nike.exp.profile.state.UserState#shallow} - Indicates if the user is only remembered from a previous session (security status less than 3)
     * {@link nike.exp.profile.state.UserState#isSwoosh} - Indicates if the user is an employee or not
     * {@link nike.exp.profile.state.UserState#displayName} - The name that should be displayed to the user
     * {@link nike.exp.profile.state.UserState#avatarURL} - The URL of this users avatar
     *
     * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, email: string, avatarURL: string}}
     * @public
     */
    getUserState : function () {
      return this.userState.getState();
    },

    /**
     * The user data for the current user.  Only valid if the state is in USER_LOADED.  Will return null if the state
     * is not USER_LOADED (or PARTIAL_USER_LOADED).
     *
     * @returns {object} The user from the profile services or NULL if the state is invalid.
     * @public
     */
    getUserData : function () {
      return this.isStateComparableTo(nike.exp.profile.PROFILE_STATE.PARTIAL_USER_LOADED) ? this.User : null;
    },

    /**
     * The account data for the current user.  Only valid if the state is in USER_LOADED. Will return null if the
     * state is not USER_LOADED (or PARTIAL_USER_LOADED).
     *
     * @returns {object} The account from the profile services or NULL if the state is invalid
     * @public
     */
    getAccountData : function () {
      return this.isStateComparableTo(nike.exp.profile.PROFILE_STATE.PARTIAL_USER_LOADED) ? this.UserAccount : null;
    },

    /**
     * ONLY USED DURING AN AVATAR CHANGE IN ACCOUNT SETTINGS
     *
     * @param avatarURL
     * @returns {{loggedIn: boolean, shallow: boolean, isSwoosh: boolean, displayName: string, avatarURL: string, exp: Date}|Object}
     */
    updateAvatarURL : function (avatarURL) {
      this.userState.setState({
        avatarURL : avatarURL
      });

      // this.updateUserStateCookie();  // Removed due to reference to state cookie
      return this.userState.getState();
    },

    /**
     * Updates the user state from a swoosh profile.
     *
     * ONLY CALLED DURING LOGIN OR REGISTER FOR SWOOSH
     *
     * @todo Maybe we need to gather swoosh login/logout/register so the state can be maintained
     * @todo Not needed as long as the swoosh pages are separate pages and redirect as soon as it's done
     *
     * @param {object} profile
     */
    updateUserStateFromSwooshProfile : function (profile) {
      var displayName, isSwoosh;
      if(typeof profile === 'object' && profile.id) {
        isSwoosh = profile.userType === 'swooshUser';
        if(isSwoosh) {
          displayName = profile.firstName + (profile.lastName ? ' ' + profile.lastName : "");
        }
        // setup the user state
        this.userState.setState({
          loggedIn : true,
          isSwoosh : isSwoosh,
          shallow : false,
          displayName : displayName,
          profileId : profile.id,
          screenName: profile.screenName
        });
        //this.updateProfileIdCookie(profile.id);
      } else {
        this.userState.setState({
          loggedIn : false
        });
      }

      // this.updateUserStateCookie(); // removed due to reference to state cookie
      this.userState.getState();
    },

    /**
     * Updates the user state from a cart summary response.  The states themselves will make this call
     * and it should not be used outside of this class or it's states.  Doing so would force the user state
     * out of sync with the current state of the controller.
     *
     * USED INTERNALLY BY STATES
     *
     * @param {object} cartSummary
     * @returns {object} The current user state after processing
     */
    updateUserStateFromCartSummary : function (cartSummary) {
      var state = this.userState.fromCartSummary(cartSummary);
      // this.updateUserStateCookie(); // removed due to reference to state cookie
      return state;
    },

    /**
     * Updates the user state from profile state cookies.  The states themselves will make this call
     * and it should not be used outside of this class or it's states.  Doing so would force the user state
     * out of sync with the current state of the controller.
     *
     * USED INTERNALLY BY STATES
     *
     * @param {string} stateCookie The PROFILE_DATA_COOKIE
     * @param {string} [sessionCookie] The PROFILE_ID_COOKIE
     * @returns {object} The current user state after processing
     */
     // TODO: Keep this around until ADA is confirmed working w/o it.
    updateUserStateFromCookie : function (stateCookie, sessionCookie) {
      this.userState.fromCookieString(stateCookie);
      if(sessionCookie) {
        this.userState.setState({shallow : false})
      }
      return this.userState.getState();
    },

    updateUserDataFromUnite: function(){
      this.userState.fromUserData(this.User, this.UserAccount);
      return this.userState.getState();
    },
    /**
     * Updates the user state from loaded user data.  The states themselves will make this call
     * and it should not be used outside of this class or it's states.  Doing so would force the user state
     * out of sync with the current state of the controller.
     *
     * USED INTERNALLY BY STATES
     *
     * @param {object} user The user data from the Profile services.
     * @param {boolean} [shallow=false] TRUE if this is the result of a partial user load, FALSE otherwise
     * @returns {boolean|object} The current state if successful, FALSE otherwise
     */
    updateUserData : function (user, shallow, userType) {
      try {
        if (!user.account.id) { // Check to make sure the user is a user.  Might be an error from Unite.
          throw "No account ID";
        }
        this.User = user;
        this.UserAccount = user.account;
      } catch (exp) {
        nike.error("Unable to retrieve user and account data", exp);
        this.User = null;
        this.UserAccount = null;
      }

      var userState = this.userState.fromUserData(this.User, this.UserAccount);

      if(shallow) {
        this.userState.setState({
          shallow : true
        });
      }

      if(userType == "EMPLOYEE"){
        this.userState.setState({isSwoosh: true})
      }

      return this.userState.getState();
    },

    /**
     * Submits a logout request to the profile services.  Does not handle state changes, but does
     * fire the MEMBER_LOGGED_OUT event.
     *
     * @returns {jQuery.Deferred} Indicates the successful or failure of the attempt
     * @private
     */
    submitLogout : function () {
      var deferred = $.Deferred();
      var apiReady = nike.exp.profile.CpcStateController.requireState(nike.exp.profile.CPC_STATE.BASIC_READY);
      var self = this;

      apiReady.done(
         function cpcServicesLoaded () {
           if(nike.objectDefined("nike.profile.api.account.logout")) {
             nike.profile.api.account.logout().always(
                 function logoutAlways () {
                   // Change the user state
                    self.userState.setState({
                      loggedIn: false
                    });

                   var deleteOptions = {
                     expires: -1,
                     path:'/',
                     domain: nike.ROOT_DOMAIN,
                     secure: false
                   };

                   // Delete all the cookies defined in LOGOUT_COOKIES
                   // for(var cookieIndex = 0; cookieIndex < self.LOGOUT_COOKIES.length; cookieIndex++ ) {
                   //   var cookieName = self.LOGOUT_COOKIES[cookieIndex];
                   //   if($.CookieUtil(cookieName)){
                   //     $.CookieUtil(cookieName, null, deleteOptions);
                   //   }
                   // }

                  // Invalidate the cart summary
                  nike.Cart.clearCartSummary();

                  nike.dispatchEvent(nike.Event.MEMBER_LOGGED_OUT,{});

                  this.User = null;
                  this.UserAccount = null;

                  deferred.resolve();
                 });
           } else {
             deferred.reject("Unable to find profile account logout services", nike.profile);
           }
         });

      apiReady.fail(
         function logoutFailed () {
           deferred.reject("Unable to logout user");
         });

      return deferred;
    },

    /**
     * Sets the profile cookies after a successful login.  The data cookie will be kept based
     * on the rememberMe indication.  The id cookie is a simple session cookie to help determine
     * the type of login in future visits.
     *
     * @param {object} account The user from the profile services
     * @param {boolean} rememberMe TRUE to keep the data around for 30 days, FALSE otherwise
     * @private
     */
    //setProfileCookies : function (account, rememberMe) {
      ////noinspection MagicNumberJS
      //var MILLISECONDS_IN_30_DAYS = 2592000000;
      //var expires;
      //
      //if(rememberMe) {
      //  var expiresTime = new Date();
      //  expiresTime.setTime(expiresTime.getTime() + MILLISECONDS_IN_30_DAYS);
      //  expires = expiresTime;
      //}
      //
      //// We are calling this with account in both parameters to avoid extra headaches writing a handlers
      //// for every situation. This will fake it just fine.
      //this.userState.fromUserData(account, account);
      //this.userState.setState({
      //  exp : expires
      //});

      //$.CookieUtil(this.PROFILE_DATA_COOKIE, this.userState.toCookieString(),
      //             { path : '/', domain : nike.ROOT_DOMAIN, secure : false, expires : expires });
      //
      //$.CookieUtil(this.PROFILE_ID_COOKIE, account.id,
      //             { path : '/', domain : nike.ROOT_DOMAIN, secure : false });
    //},

    /**
     * Updates the profile data cookie with the most recent data from this.userState
     *
     * @private
     */
    // updateUserStateCookie : function () {
    //   console.log("THIS SHOULD NOT BE FIRING ANYMORE");
    //   //var cookieOptions = {
    //   //  path : '/',
    //   //  domain : nike.ROOT_DOMAIN,
    //   //  secure : false,
    //   //  expires : this.userState.getState().exp || null
    //   //};
    //   //
    //   //$.CookieUtil(this.PROFILE_DATA_COOKIE, this.userState.toCookieString(), cookieOptions);
    // },

    /**
     * Updates the profile id cookie with the most recent data from this.userState
     *
     * @param {string} [id=this.User.id]
     * @private
     */
    //updateProfileIdCookie : function (id) {
    //  var cookieOptions = {
    //    path : '/',
    //    domain : nike.ROOT_DOMAIN,
    //    secure : false
    //  };
    //
    //  $.CookieUtil(this.PROFILE_ID_COOKIE, id || this.User.id, cookieOptions);
    //},

    /**
     * Processes a request from the cart summary.  It's purpose is to determine if the state returned is
     * different than the current state of the profile controller.  If it is different, then it will
     * change the state to OutOfSync to try and determine why the controller is not in sync with the
     * cart summary.
     *
     * @param {object} data The cartSummary response.
     * @private
     */
    handleCartSummaryRequest : function (data) {
      var PROFILE_STATE = nike.exp.profile.PROFILE_STATE;
      var curState = this.curState;
      var userState, inShallowState, inLoggedInState, inNotLoggedInState, shallowTest, loggedInTest, notLoggedInTest, curProfileId, profileIdTest;

      if (data && data.response && this.curDeferred.isResolved() && curState !== PROFILE_STATE.ERROR) {

        curProfileId = this.userState.profileId;
        userState = this.updateUserStateFromCartSummary(data.response);

        inShallowState = curState === PROFILE_STATE.REMEMBERED_LOG_IN || curState === PROFILE_STATE.PARTIAL_USER_LOADED;
        inLoggedInState = curState === PROFILE_STATE.LOGGED_IN || curState === PROFILE_STATE.USER_LOADED;
        inNotLoggedInState = curState === PROFILE_STATE.NOT_LOGGED_IN;


        shallowTest = inShallowState && !(userState.loggedIn && userState.shallow);
        loggedInTest = inLoggedInState && !(userState.loggedIn && !userState.shallow);
        notLoggedInTest = inNotLoggedInState && userState.loggedIn;
        profileIdTest = inLoggedInState && !(curProfileId === userState.profileId);

        // If the cart response is not consistent with the current state, then we should verify before
        // changing it in case we are just out of sync (could be up to a couple of seconds).
        if(shallowTest || loggedInTest || notLoggedInTest ||profileIdTest) {
          this.changeState(PROFILE_STATE.OUT_OF_SYNC);
        }
      }
    }
  });
  // Creates our singleton instance
  return new ProfileClass(nike.exp.profile.state, nike.exp.profile.PROFILE_STATE, nike.exp.profile.PROFILE_STATE.NOT_KNOWN);
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.ProfileStateController. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.gadget.desktop.GlobalNavNotifier', function(){
  nike.requireDependency('nike.Event');
  nike.requireDependency('nike.gadget.Event');
  nike.requireDependency('nike.exp.profile.ProfileStateController');
  var $ = nike.requireDependency('jQuery');
  nike.requireDependency('jQuery.CookieUtil');

  /**
   * All logging should be prefixed with this.
   * @type {string}
   */
  var logPrefix = '[ GlobalNavNotifier ] -';

  return Class.extend({
    /**
     * The initializer.
     */
    init: function(){
      /**
       * The key used to store a user's action.
       * @type {string}
       */
      this.cookieName = 'nike_notification';
      /**
       * Will resolve once the notifier first appears on the page.
       * @type {jQuery.Deferred}
       */
      this.initialResizeDefer = new $.Deferred();
      /**
       * Other components can use this to adjust themselves once the
       * notifier has initially loaded.
       * @type {Promise}
       */
      this.initialResizePromise = this.initialResizeDefer.promise();
      /**
       * A map of selectors used to access DOM elements.
       * @type {object}
       */
      this.selectors = {
        NOTIFIER: '#globalNavNotifier',
        NOTIFIER_MESSAGE: '#globalNavNotifierMessage',
        NOTIFIER_CLOSE_BTN: '#globalNavNotifierCloseBtn',
        BODY_CONTENT: '#content'
      };
      /**
       * A map of events used by this Class.
       * @type {object}
       */
      this.events = {
        CLICK: 'click'
      };
      /**
       * A map of CSS modifiers used to change element states.
       * @type {object}
       */
      this.cssModifiers = {
        HIDDEN: 'hidden'
      };
      /**
       * A map of cached elements used by this Class.
       * @type {object}
       */
      this.els = {};
      /**
       * The initial CSS offset for the body content.
       * @type {undefined|string}
       */
      this.bodyOffset;

      this.els.$notifier = $(this.selectors.NOTIFIER);

      if( this.els.$notifier.length ){
        this.els.$notifierCloseBtn = this.els.$notifier.find( this.selectors.NOTIFIER_CLOSE_BTN );
        this.els.$bodyContent = $( this.selectors.BODY_CONTENT );

        this.addListeners();

        // only show the banner if the user hasn't already closed it for the session.
        // and is logged in.
        if(
          !$.CookieUtil(this.cookieName)
          && !(nike.exp.profile.ProfileStateController.getUserState()).loggedIn
        ){
          this.els.$notifier.removeClass( this.cssModifiers.HIDDEN );
          this.dispatchResizeEvent();
        }
      }
    },

    /**
     * Adds listeners to handle the close click or any other functionality
     * that will be needed in the future.
     */
    addListeners: function(){
      var _self = this;

      this.els.$notifierCloseBtn
        .off(_self.events.CLICK)
        .on(_self.events.CLICK, function(ev){
          $.CookieUtil(_self.cookieName, 'closed', {
            path: '/'
          });

          _self.els.$notifier.remove();
          _self.dispatchResizeEvent();
          nike.dispatchEvent(nike.gadget.Event.NOTIFIER_CLOSE_CLICK);
        });

      nike.unlisten(nike.Event.LOGIN_SUCCESS);
      nike.listen(nike.Event.LOGIN_SUCCESS, function(ev){
        _self.els.$notifier.remove();
        _self.dispatchResizeEvent();
      });

      nike.unlisten(nike.gadget.Event.NOTIFIER_RESIZED);
      nike.listen(nike.gadget.Event.NOTIFIER_RESIZED, function(ev){
        if( _self.els.$bodyContent.length ){
          if( !_self.bodyOffset ){
            _self.bodyOffset = _self.els.$bodyContent.css('padding-top');
          }

          // if the start value is a number, add to it
          if( parseInt(_self.bodyOffset) != NaN ){
            _self.els.$bodyContent.css('padding-top', parseInt(_self.bodyOffset) + _self.els.$notifier.outerHeight());
          }
          // else, add the offset
          else{
            _self.els.$bodyContent.css('padding-top',  _self.els.$notifier.outerHeight());
          }

          nike.log(logPrefix, 'Update the body content offset');
        }else{
          nike.error(logPrefix, 'Body content not found, offset not adjusted');
        }
      });

      this.els.$notifier.find(this.selectors.NOTIFIER_MESSAGE).on('click', function(ev){
        ev.preventDefault();

        // delegation doesn't work with middle-click so got old-school
        if( ev.target.nodeName == 'A' ){
          nike.dispatchEvent(nike.gadget.Event.NOTIFIER_LINK_CLICK);

          var linkLocation = _self.transformLink( ev.target.getAttribute('href') );

          // give time for the event to fire and handle left/middle click
          setTimeout(function(){
            if( ev.target.href ){
              switch( ev.which ){
                case 1 :
                  window.location = linkLocation;
                  break;
                case 2 :
                  window.open(linkLocation);
                  break;
              }
            }
          }, 100);
        }
      });
    },

    /**
     * Rewrites relative URL's so they point to the correct pages regardless of `www` or `store`.
     *
     * @param {string} url - The URL of an anchor a user clicked.
     * @returns {string}
     */
    transformLink: function(url){
      // Only try to transform if the URL is relative
      if( !/^(?:http|\/\/)/.test(url) ){
        // handle `register` links
        if( url.indexOf('register') > -1 ){
          url = this.els.$notifier.data('registerLink');
          nike.log( this.logPrefix, 'Rewriting link URL to `'+ url +'`' );
        }
      }

      return url;
    },

    /**
     * Resolves the initial Promise, and dispatches an event for any further
     * notifier resizing that occurs.
     */
    dispatchResizeEvent: function(){
      var data = {
        newHeight: this.els.$notifier.outerHeight()
      };

      if( !this.initialResizeDefer.isResolved() ){
        this.initialResizeDefer.resolve(data);
      }

      nike.dispatchEvent(nike.gadget.Event.NOTIFIER_RESIZED, data);
    }

  });
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.desktop.GlobalNavNotifier. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.store.ui.widgets.ModalDialog');

nike.requireDependency('Class');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.exp.global.Orientation');

/**
 * @extends Class
 */
nike.store.ui.widgets.ModalDialog = Class.extend(
/** @lends nike.store.ui.widgets.ModalDialog.prototype */
{

    /**
     * The content element for this dialog.
     *
     * @type jQuery|Element
     * @public
     */
    contentEl : undefined,

    /**
     * An array of events that this dialog should fire via the nike.dispatchEvent method
     *
     * @type Object[]
     * @public
     */
    onCloseDispatchEvents : undefined,

    /**
     * The action to take when displaying a modal.
     *
     * @type String
     * @default "show"
     * @public
     */
    showAction : "show",

    /**
     * Toggles between "remove" or "hide", depending on if noDestroy is set to "true" or "false", respectively.
     *
     * @type String
     * @default "remove"
     * @public
     */
    hideAction : "remove",

    /**
     * TRUE to bind events to the contentEl for closing the dialog.  FALSE otherwise
     *
     * @type Boolean
     * @default true
     * @public
     */
    bindEvents: true,

    /**
     * TRUE to create a blocker behind the dialog window to prevent clicks
     *
     * @type Boolean
     * @default true
     * @public
     */
    blockContent: true,

    /**
     * TRUE to close all other dialogs when this one is showing.
     *
     * @type Boolean
     * @default true
     * @public
     */
    hideOthers: true,

    /**
     * TRUE to listen to the resize event to make adjustments to the size of position of the modal dialog
     *
     * @type Boolean
     * @default false
     * @public
     */
    listenToResize: false,

    /**
     * Flag to indicate if ModalDialog caller will handle dialog close click, for example if
     * caller wants to display a dialog box to warn user of consequence of closing out.
     *
     * @type Boolean
     * @default true
     * @public
     */
    naturalClose: true,

    /**
     * If the dialog should be shown as soon as it is created.
     *
     * @type Boolean
     * @default true
     * @public
     */
    autoShow: true,

    /**
     * If the dialog should be hidden on close, instead of destroyed.
     *
     * @type Boolean
     * @default false
     * @public
     */
    noDestroy: false,

    /**
     * If the dialog needs to remain in a fixed position on the page change this value to
     * true. Otherwise by default the dialog will stay centered in the browser window.
     *
     * @type Boolean
     * @default false
     * @public
     */
    positionAbsolute: false,

    /**
     * If the dialog container should stretch to fit the full browser window width, change this value to
     * true. Otherwise by default the dialog will stay centered in the browser window at the width of its content.
     *
     * @type Boolean
     * @default false
     * @public
     */
    fullWidth: false,

    /**
     * If the dialog should show a built-in close button, set this value to true.
     * Otherwise, no default close button will be shown.
     *
     * @type Boolean
     * @default false
     * @public
     */
    closeButton: false,

    /**
     * If the modal is being used in mobile, set this value to true.
     * Otherwise, desktop glyph will be used for close button.
     *
     * @type Boolean
     * @default false
     * @public
     */
    useMobileGlyph: false,

    /** @private */
    blockerBaseClass: "modalBlock",

    /** @private */
    blockerExtClass: "",

    /** @private */
    modalBaseClass: "modal",

    /** @private */
    modalExtClass: "",

    /** @private */
    modalCloserClass: "modalClose",

    /** @private */
    offscreenClass: "offscreen",

    /** @private */
    blockerClickCloses: true,

    /** @private */
    escKeyCloses: true,

    /** @private */
    insertionPoint: undefined,

    /** @private */
    maskEl : undefined,

    /**
     * Indicates whether the modal is current showing or not
     *
     * @type Boolean
     * @private
     */
    showing : false,

    /**
     * @constructs
     * @param {Object} config
     * @config {Element} contentEl The content element for this dialog.
     * @config {Object[]} [onCloseDispatchEvents] An array of events that this dialog should fire via the
     * nike.dispatchEvent method
     * @config {String} [showAction="show"] the action to take when displaying a modal.
     * @config {String} [hideAction="remove"] toggles between "remove" or "hide", depending on if noDestroy is set to "true" or "false", respectively.
     * @config {Boolean} [bindEvents=true] TRUE to bind events to the contentEl for closing the dialog.  FALSE otherwise
     * @config {Boolean} [blockContent=true] TRUE to create a blocker behind the dialog window to prevent clicks
     * @config {Boolean} [hideOthers=true] TRUE to close all other dialogs when this one is showing.
     * @config {Boolean} [listenToResize=false] TRUE to listen to the resize event to make adjustments to the size of position of the modal dialog
     * @config {boolean} [naturalClose=true] Flag to indicate if ModalDialog caller will handle dialog close click, for example if
     *                   caller wants to display a dialog box to warn user of consequence of closing out.
     * @config {boolean} [autoShow=true] If the dialog should be shown as soon as it is created. Defaults to true.
     * @config {boolean} [noDestroy=false] If the dialog should be hidden on close, instead of destroyed.
     * Defaults to false (dialog will be destroyed on close).
     * @config {boolean} [positionAbsolute=false] If the dialog needs to remain in a fixed position on the page change this value to
     * true. Otherwise by default the dialog will stay centered in the browser window.
     * @config {boolean} [fullWidth=false] If the dialog container should stretch to fit the full browser window width, change this value to
     * true. Otherwise by default the dialog will stay centered in the browser window at the width of its content.
     * @config {boolean} [closeButton=false] If the dialog should show a built-in close button, set this value to true.
     * Otherwise, no default close button will be shown.
     * @config {boolean} [useMobileGlyph=false] If the modal is being used in mobile, set this value to true.
     * Otherwise, desktop glyph will be used for close button.
     */
    init : function(config) {
      var maskClasses,
          containerClasses;
      var self = this;

      self.insertionPoint = $("body");

      $.extend(self, config);

      self.hideAction = self.noDestroy ? "hide" : "remove";

      maskClasses = [self.blockerBaseClass, self.blockerExtClass];
      self.maskEl = $('<div class="' + maskClasses.join(' ') + '" />');

      containerClasses = [self.modalBaseClass, self.modalExtClass];
      if(self.positionAbsolute) {
        containerClasses.push('positionAbsolute');
      }

      if(self.fullWidth) {
        containerClasses.push('flex');
      }

      self.containerEl = $('<div class="' + containerClasses.join(' ') + '" />');
      self.containerEl.data("class", self);

      if (this.closeButton) {
        self.containerEl.append('<div class="modal-close-button-container">' +
            '<a href="#" class="' + this.modalCloserClass + ' nsg-glyph--x" data-qa="modal.close"></a>' +
            '</div>');
      }

      if (self.blockContent) {
          self.mask();
      }
      self.insertionPoint.prepend(self.containerEl);
      self.setContent(self.containerEl);
      if (self.bindEvents) {
          self.doBindEvents();
      }

      if (self.autoShow) {
          self.show();
      }

      nike.listen(nike.Event.PAGE_LAYOUT, function(event, data) {
          self.center();
      });

      if(self.listenToResize) {
        this.resizeListen();
      }

      self.orientationChange = function () {
        self.center();
      };
      self.resizeChange = function () {
        self.center();
        self.onResize();
      };

      if (window.addEventListener) {
        window.addEventListener("orientationchange", self.orientationChange);
      } else {
        window.attachEvent("orientationchange", self.orientationChange);
      }

      if (Modernizr.touch) {
        this.inputFocusHandler();
      }
    },

    setContent: function(dialogContainer){
      dialogContainer.append(this.contentEl);
    },

    onBeforeShow: function () {},

    onShow: function () {},

    onBeforeClose: function () {},

    onModalCloseClicked: function () {},

    onResize: function () {},


    onClose: function(){
      if(this.onCloseDispatchEvents){
        for(var i = 0, L = this.onCloseDispatchEvents.length; i < L; i++){
            nike.dispatchEvent.apply(nike, this.onCloseDispatchEvents[i]);
        }
      }
    },

    mask : function() {
        this.insertionPoint.prepend(this.maskEl);
    },

    unmask : function() {
        this.maskEl.remove();
    },

    /**
     *  Sets the top and left margin of the modal based on the modal's height and width so they are aligned to the middle
     */
    center : function() {
      var topOffset,
          leftOffset,
          modalWidth;

      if (!this.positionAbsolute) {

        //Checks if the modal has been centered yet or not
        //This should only run if it has been centered so that the height of the element is more accurate
        if(this.containerEl.css('margin-left') != 0) {

          this.containerEl.css('left','0');

          //Handles oversized modals
          if (this.containerEl.outerHeight() > $(window).height()) {

            this.containerEl.css('left','');

            // If a modal gets bigger due to changed content which causes it to become larger than the screen height,
            // This aligns it so that the top of the modal stays the same
            if (parseInt(this.containerEl.css('margin-top'), 10) != 0) {
              var oversizedModalTopOffset = this.containerEl.position().top + parseInt(this.containerEl.css('margin-top'), 10);
              this.containerEl.css('top',oversizedModalTopOffset);
            } else {
              this.containerEl.css('top',$(window).scrollTop());
            }
            this.containerEl.addClass('positionAbsolute');
          } else {
            this.containerEl.removeClass('positionAbsolute').css('position','').css('top','').css('left','');
          }
        }
      }

      if (this.containerEl.hasClass('positionAbsolute') || this.containerEl.css('position') == 'absolute') {

        //Sets a the topOffset to 0 since absolute positioned elements are vertically aligned differently
        if (this.containerEl.hasClass('positionAbsolute')) {
          topOffset = 0;
        }

        /**
         *  Adding inline style left and position static and then removing them to force
         *  iOS to reset the screen width when the virtual keyboard is open
         */
        this.containerEl.css(
          {
            'left' : 0,
            'position' : 'static'
          }
        );
        this.containerEl.css(
          {
            'position' : 'absolute',
            'left' : ''
          }
        );

      }

      /**
       *  Sets the element's top and left margin offsets and retries until the results are consistent (generally only run once
       *  except in mobile screens where changing the margin can also alter width of the element
       */
      do {
        modalWidth = this.containerEl.outerWidth();

        //Prevent topOffset on absolute positioned modals from being overridden
        if (this.containerEl.css('position') != 'absolute') {
          topOffset = -(this.containerEl.outerHeight() / 2);
        }
        leftOffset = this.fullWidth ? 0 : -(this.containerEl.outerWidth() / 2);

        this.containerEl.css(
          {
            'margin-top' : topOffset,
            'margin-left' : leftOffset
          }
        );
      } while (Math.abs(modalWidth - this.containerEl.outerWidth()) > 1); //Prevents instances where the rounding caused the values to alternate between two values one pixel apart
    },

    show : function() {
      this.onBeforeShow();

      if (this.hideOthers) {
        $(".modal").not(this.containerEl).each(function(i, modal) {
          if ($(modal).data("class")) {
            $(modal).data("class").close();
          }
        });
      }

      // Defaults positionAbsolute enabled modals to initialize where the window position is rather than at the top of the page
      if (this.positionAbsolute) {
        var verticalPosition = $(window).scrollTop();
        this.containerEl.css('top', verticalPosition);
      }

      if (this.escKeyCloses) {
        this.bindEscEvent();
      }

      this.maskEl[this.showAction]();
      this.containerEl[this.showAction]();
      this.center();
      this.showing = true;
      this.onShow();
    },

    resizeListen: function () {
      nike.Util.windowResizeListen(this.resizeChange);
    },

    close : function() {
      if (this.showing === false) {
          return false;
      } else {
        this.onBeforeClose();

        if (this.escKeyCloses) {
            this.unbindEscEvent();
        }

        this.maskEl.add(this.containerEl)[this.hideAction]();
        this.showing = false;
        nike.unlisten(nike.Event.WINDOW_RESIZE, this.resizeChange);
        $(window).off('orientationchange',this.orientationChange);
        this.onClose();
        return true;
      }
    },

    doBindEvents : function() {
      var self = this;
      this.containerEl.on('click', "." + this.modalCloserClass, function(e) {
        e.preventDefault();
        self.onModalCloseClicked();
        if(self.naturalClose){
          self.close(this);
        }
      });

      if (this.blockerClickCloses) {
        this.maskEl.on('click', function(e) {
          e.preventDefault();
          if(self.blockerClickCloses) {
            self.close(this);
          }
        });
      }
    },

    /**
     *  This function forces position absolute on focus on iOS to deal with the fixed positioning bug that occurs with virtual keyboards on
     */
    inputFocusHandler : function() {
      if (this.containerEl.css('position') == 'fixed') {
        var position = this.containerEl.position();
        var initialTop;

        this.containerEl.on(
            'focusin',
            'input',
            $.proxy(function(){
              initialTop = $(window).scrollTop();
              position = this.containerEl.position();

              // Positions the element in the same spot it was before absolute positioning was applied
              this.containerEl.css({
                'position' : 'absolute',
                'top' : position.top,
                'left' : position.left
              });
            },this)).on(
            'focusout',
            'input',
            $.proxy(function(){

              //Scrolls back to the spot the window was at before the virtual keyboard scrolled it down then reverts the positioning back to fixed
              $('html,body').animate({scrollTop: initialTop}).promise().done(
                $.proxy(function(){
                  this.containerEl.css({
                    'position' : '',
                    'top' : '',
                    'left' : ''
                  })
                },this)
              );
              this.center();
            },this)
        );
      }
    },

    bindEscEvent : function() {
      var self = this;
      $(document).on('keyup', function (e) {
        self.escHandler(e);
      });
    },

    unbindEscEvent : function() {
      var self = this;
        $(document).on('keyup', function (e) {
          self.escHandler(e);
        });
    },

    escHandler : function(e) {
      var self = this;

      if (e.which === 27) {
          self.close(this);
      }
    }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.store.ui.widgets.ModalDialog. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.page.OneNikePageLayout');


nike.requireDependency('Modernizr');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.exp.global.Orientation');

/** OneNikePageLayout is used to set breakpoints and add listeners to set/change classes in the HTML element accordingly
 *  The HTML element will gain classes according to the breakpoint and orientation rules set in this script.
 *  The set breakpoints are essentially minimum display widths that the layout is designed for.
 *  Example: If the breakpoints are set at 768 and 1024, if the window display width is above 1024, the HTML element will gain "l1024" as a class.
 *           Between 768 and 1024, the class will be l768.
 *
 *  Orientation is also added as a class in HTML.
 */
nike.page.OneNikePageLayout = {
  // Default breakpoint list (can be reset using setBreakpoints())
  layoutBreakpoints: [768, 1024, 1260, 1600],
  currentPageBreakpoint : undefined,
  classes : {
      layout: 'l',
      greaterThan: 'gt',
      lessThan: 'lt'
  },
  allowGreaterThan: false,
  $html : $('html'),

  init: function() {
    var _self = this;
    nike.Util.windowResizeListen($.proxy(_self.resizeHandler, _self));
    nike.exp.global.Orientation.listen($.proxy(_self.orientationUpdate, _self));

    _self.$html.data('greaterThanClass', '');

    //trigger initial calculation
    nike.dispatchEvent(nike.Event.WINDOW_RESIZE, {});
    nike.exp.global.Orientation.trigger();
  },
  /**
   * Will listen to the orientation change event in order to update the html element with the appropriate classes.
   * @param event
   * @param data
   */
  orientationUpdate : function (event, data) {
    var _self = this;
    var isLandscape = data.orientation === nike.exp.global.Orientation.LANDSCAPE;

    _self.$html.toggleClass(nike.exp.global.Orientation.LANDSCAPE, isLandscape).toggleClass(nike.exp.global.Orientation.PORTRAIT, !isLandscape);
  },
  /**
   * Call back function for listening for window resize
   * @param event
   */
  resizeHandler : function (forceUpdate) {
    var _self = this;
    var layoutBreakpoint = _self.getLayout();

    if (_self.currentPageBreakpoint != layoutBreakpoint || forceUpdate === true) {
      _self.currentPageBreakpoint = layoutBreakpoint;
      _self.setLayout(layoutBreakpoint);
    }

    if(_self.winWidth > layoutBreakpoint && _self.allowGreaterThan){
      _self.setGreaterThan();
    }

    // if less than the lowest breakpoint at a class so we can target those styling instances
    if(_self.winWidth < _self.layoutBreakpoints[0]){
      _self.setLessThan();
    }else if( _self.winWidth > _self.layoutBreakpoints[0] && _self.$html.data('lessThanClass') ){
      _self.$html.removeClass(_self.$html.data('lessThanClass'));
    }
  },

  /**
   * Since our layout classes encompass the current breakpoint width and everything proceeding it,
   * adding a 'greater than' class allows us to add refinement to what's included within each breakpoint.
   */
  setGreaterThan: function(){
    var _self = this;

    _self.$html.removeClass(_self.$html.data('greaterThanClass'))
      .data('greaterThanClass', _self.classes.greaterThan + _self.currentPageBreakpoint)
      .addClass(_self.$html.data('greaterThanClass'));
    _self.allowGreaterThan = false;
  },

  /**
   * The 'less than' class will only be added once the window
   */
  setLessThan: function(){
    var _self = this;

    if( _self.$html.data('lessThanClass') ){
      _self.$html.removeClass(_self.$html.data('lessThanClass'));
    }
    _self.$html.data('lessThanClass', _self.classes.lessThan + _self.currentPageBreakpoint)
      .addClass(_self.$html.data('lessThanClass'));
  },

  setLayout: function(width) {
    var _self = this;

    // remove any old layout class
    _self.$html.removeClass(_self.classes.layout + _self.$html.data('layout'))
      .removeClass(_self.$html.data('greaterThanClass'))
      .data('layout', width)
      .addClass(_self.classes.layout + width);

    _self.allowGreaterThan = true;

    nike.dispatchEvent(nike.Event.PAGE_LAYOUT, {width: width});
  },

  getLayout: function() {
    var _self = this;
    var breakpoints = _self.layoutBreakpoints;
    var layout = breakpoints[0];
    _self.winWidth = $(window).width();

    for (var i=0; i<breakpoints.length; i++) {
      if (_self.winWidth >= breakpoints[i]) {
          layout = breakpoints[i];
      } else {
          break;
      }
    }

    return layout;
  },

  /**
   * Set the page breakpoints using this function.
   * Example: nike.page.OneNikePageLayout.setBreakpoints([768, 980, 1140]);
   * @param breakpoints
   */
  setBreakpoints: function(breakpoints) {
    var _self = this;
    _self.layoutBreakpoints = breakpoints;
    _self.resizeHandler(true);
  }
};

nike.page.OneNikePageLayout.init();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.page.OneNikePageLayout. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('iOS-quirks-fix');

(function(w){

// This fix addresses an iOS bug, so return early if the UA claims it's something else.
  var ua = navigator.userAgent;

  //iOS5 back button fix
  if (/iPhone|iPad|iPod/.test( navigator.platform ) && /OS [5-6]_[0-9_]* like Mac OS X/i.test(ua)) {
    window.onpageshow = function(evt) {
      // If persisted then it is in the page cache, force a reload of the page.
      if (evt.persisted) {
        document.body.style.display = "none";
        location.reload();
      }
    };
  }

  /*! A fix for the iOS orientationchange zoom bug.
   Script by @scottjehl, rebound by @wilto.
   MIT / GPLv2 License.
   */
  if( !( /iPhone|iPad|iPod/.test( navigator.platform ) && /OS [1-5]_[0-9_]* like Mac OS X/i.test(ua) && ua.indexOf( "AppleWebKit" ) > -1 ) ){
    return;
  }

  var doc = w.document;

  if( !doc.querySelector ){ return; }

  var meta = doc.querySelector( "meta[name=viewport]" ),
  initialContent = meta && meta.getAttribute( "content" ),
  disabledZoom = initialContent + ",maximum-scale=1",
  enabledZoom = initialContent + ",maximum-scale=10",
  enabled = true,
  x, y, z, aig;

  if( !meta ){ return; }

  function restoreZoom(){
    meta.setAttribute( "content", enabledZoom );
    enabled = true;
  }

  function disableZoom(){
    meta.setAttribute( "content", disabledZoom );
    enabled = false;
  }

  function checkTilt( e ){
    aig = e.accelerationIncludingGravity;
    x = Math.abs( aig.x );
    y = Math.abs( aig.y );
    z = Math.abs( aig.z );

// If portrait orientation and in one of the danger zones
    if( (!w.orientation || w.orientation === 180) && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ){
      if( enabled ){
        disableZoom();
      }
    }
    else if( !enabled ){
      restoreZoom();
    }
  }

  w.addEventListener( "orientationchange", restoreZoom, false );
  w.addEventListener( "devicemotion", checkTilt, false );


})( this );
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing iOS-quirks-fix. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
/*!

 handlebars v4.0.5

Copyright (C) 2011-2015 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/

var nike = nike || {};
if(nike.namespace){
nike.namespace('HandlebarsRuntime');
}


(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Handlebars"] = factory();
	else
		root["Handlebars"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(1)['default'];

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _handlebarsBase = __webpack_require__(3);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(17);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(5);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(4);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(18);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(19);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};

	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }

	    newObj["default"] = obj;
	    return newObj;
	  }
	};

	exports.__esModule = true;

/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(6);

	var _decorators = __webpack_require__(14);

	var _logger = __webpack_require__(16);

	var _logger2 = _interopRequireDefault(_logger);

	var VERSION = '4.0.5';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  if (loc) {
	    this.lineNumber = line;
	    this.column = column;
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;

	var _helpersBlockHelperMissing = __webpack_require__(7);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(8);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(9);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(10);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(11);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(12);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(13);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;

	var _decoratorsInline = __webpack_require__(15);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(4);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ },
/* 17 */
/***/ function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(1)['default'];

	var _interopRequireDefault = __webpack_require__(2)['default'];

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _utils = __webpack_require__(4);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(5);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(3);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context !== depths[0]) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    options.data = _base.createFrame(options.data);
	    partialBlock = options.data['partial-block'] = options.fn;

	    if (partialBlock.partials) {
	      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
	    }
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }
/******/ ])
});
;
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing HandlebarsRuntime. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace('nike.style.nsg.Classes');

/**
 * <p>This is a map of styleguide control classes that need to be used when the state of a style guide element needs to change.</p>
 * <p><b>***IMPORTANT***</b></p>
 * <p>This map must remain in sync with the styleguide.  If the styleguide changes, then this must be updated to match.</p>
 *
 * @type {Object}
 * @author adam.kaplan@nike.com
 * @version August 2013
 */
nike.style.nsg.Classes = {
  /**
   * @constant
   * @type {String}
   */
  ACTIVE : 'is-active',
  /**
   * @constant
   * @type {String}
   */
  OPEN : 'is-open',
  /**
   * @constant
   * @type {String}
   */
  HOVER : 'is-hover',
  /**
   * @constant
   * @type {String}
   */
  VISITED : 'is-visited',
  /**
   * @constant
   * @type {String}
   */
  SELECTED : 'is-selected',
  /**
   * @constant
   * @type {String}
   */
  VALID : 'is-valid',
  /**
   * @constant
   * @type {String}
   */
  INVALID : 'is-invalid',
  /**
   * @constant
   * @type {String}
   */
  DISABLED : 'is-disabled',
  /**
   * @constant
   * @type {String}
   */
  PORTRAIT : 'is-portrait',
  /**
   * @constant
   * @type {String}
   */
  LANDSCAPE : 'is-landscape',
  /**
   * @constant
   * @type {String}
   */
  SMALL_SCREEN : 'is-small-screen',
  /**
   * Class used to define the background slider.
   * @constant
   * @type {String}
   */
  TOGGLE_BUTTON_BACKGROUND_SLIDER : 'toggleBg'
};


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.style.nsg.Classes. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace("nike.ExposeClosureForTest");

nike.ExposeClosureForTest = function (key, anything) { };

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.ExposeClosureForTest. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/** @namespace nike.exp.global.templatehelpers.FormRenderHelpers */
nike.namespace("nike.exp.global.templatehelpers.FormRenderHelpers");

nike.requireDependency("HandlebarsRuntime");
nike.requireDependency("lib.lodash");
nike.requireDependency("nike.ExposeClosureForTest");

(function (nike, Handlebars, _) {

  /**
   * Contains all of the form components organized into 'families'.  This will allow a set of default components to be
   * defined, while also allowing custom components to be used for specific forms that need it (like dealing with the password meter).
   * The minimal form components have been set to a noop function.
   *
   * Define components using {@link registerFormComponent}:
   * <code>{{registerFormComponent name [family="default"]}}</code>
   * Element types will be used to decide which component to use. A select element will use a component named 'SelectElement'.
   * Input elements have additional granularity that can optionally be defined.  ie. 'InputRadioElement'
   *
   * A component can be rendered inside of any block (including other components) using the following syntax. {@link renderFormComponent}:
   * <code>{{renderFormComponent name [family="default"] [context=this] [attributes=data.attributes]}}</code>
   *
   * @type {Object}
   */
  var BASE_FORM_COMPONENTS = {
    "default" : {
      /** Used to render the form element */
      "FormOpen" : Handlebars.VM.noop,
      /** Closes the form element */
      "FormClose" : Handlebars.VM.noop,
      /** Used to render the form error */
      "FormError" : Handlebars.VM.noop,
      /** Used to start any field.  This will surround any elements inside of a field. */
      "FieldOpen" : Handlebars.VM.noop,
      /** Closes a field */
      "FieldClose" : Handlebars.VM.noop
    }
  };

  /**
   * Generators are used to easily define select options that are programmic in nature.  The options of a date
   * picker are the most common.  In fact, that is the only generator currently defined.
   *
   * They are defined in the select element like this:
   * <pre> elements : {
   *    select : {
   *      options : {
   *        func : "dobGenerator",
   *        args : [ "DAY" ]
   *      }
   *    }
   *  }</pre>
   *
   * @type {Object}
   */
  var OPTION_GENERATORS = { };

  /**
   * <code>{{renderAttributeMap map:object [excludes:string]}}</code>
   *
   * Renders an attribute map for including in a HTML element.
   * <code>{ key1 : value1, key2 : value2 } => 'key1="value1" key2="value2"'</code>
   *
   * The values are escaped.
   * The attribute data-qa is excluded if: <code>nike.ENV_CONFIG.renderDataQA != "true"</code>
   *
   * To exclude a set of keys, set excludes equal to a comma separated list of keys to exclude.
   *
   * <b>No Block</b>
   * @param {object} map An object map of key/value pairs for the attributes of an HTML element.
   * @config {string} [excludes] A comma separated list of keys to exclude from the output
   */
  var renderAttributeMap = function (map) {
    var options = arguments[arguments.length - 1];
    var excludes = (options.hash && options.hash.excludes && options.hash.excludes.split(",")) || [];
    var mapOutput = [];
    var excludeMap = {};
    var key, index;

    // Exclude the data-qa variable if appropriate
    if(!nike.ENV_CONFIG || nike.ENV_CONFIG.renderDataQA != "true") {
      excludes.push("data-qa");
    }

    if(map && typeof map === 'object') {
      // Build exclude map
      for(index = 0; index < excludes.length; index++) {
        excludeMap[excludes[index]] = true;
      }

      // Build key value pairs
      for(key in map) {
        //noinspection OverlyComplexBooleanExpressionJS,JSUnfilteredForInLoop
        if(map.hasOwnProperty(key) && !excludeMap[key]) {
          mapOutput.push(key + "=\"" + Handlebars.Utils.escapeExpression(map[key]) + "\"");
        }
      }
    }

    return new Handlebars.SafeString(mapOutput.join(" "));
  };

  /**
   * <pre> {{#registerFormComponent name:string [componentFamily:string="default"]}}
   *   @attributes:object @id:string @name:string @indicateRequired:boolean [@parentField:string]
   * {{/registerFormComponent}}</pre>
   *
   * Registers a form component for use by renderForm and renderField.  A name and block must be defined.
   *
   * <b>Block Required</b> | <b>Else Ignored</b>
   * <b>Context: </b> The current element as defined in the field object
   * <b>Private Variables:</b>
   * <ul>
   *   [ <code>object</code> ] attributes - Will be used to store a map of all the attributes that should be applied to the current element.
   *   [ <code>string</code> ] id - The current ID that was generated for this field.
   *   [ <code>string</code> ] name - The name of the field
   *   [ <code>boolean</code> ] indicateRequired - Indicates whether the field should be indicate that it's a required field.
   *   [ <code>string, optional</code> ] parentField - In the case of field containers, this will be the name of the parent field.
   *   TODO: Added attributes
   *   TODO: Added parent field
   * </ul>
   * A basic component block will look like the following:
   * <pre> {{#registerFormComponent "InputElement"}}
   *   &lt;input {{renderAttributeMap @attributes}}/>
   * {{/registerFormComponent}}</pre>
   *
   * A more useful example:
   * <code>&lt;input class="nsg-form--input {{@id}}--input {{class}}" {{renderAttributeMap @attributes excludes="class"}}/></code>
   *
   * A component can be rendered inside of any block (including other components) using the following syntax:
   * <code>{{renderFormComponent name [componentFamily="default"] [context=this] [attributes=data.attributes]}}</code>
   *
   * @param {!string} componentName The name of this component.  Examples can be found here {@link BASE_FORM_COMPONENTS}
   * @config {string} [family="default"] The family to define this component in.  If the family does not exist, the "default" family will be cloned.
   */
  var registerFormComponent = function (componentName) {
    var options = arguments[arguments.length - 1];
    var family = options.hash && options.hash.family || "default";

    if(!BASE_FORM_COMPONENTS[family]) {
      BASE_FORM_COMPONENTS[family] = _.clone(BASE_FORM_COMPONENTS["default"]);
    }

    if(componentName && options.fn) {
      BASE_FORM_COMPONENTS[family][componentName] = options.fn;
    } else {
      nike.warn("Handlebars:registerFormComponent", "Form component is not registered because either the name or the block does not exist.");
    }
  };

  /**
   * <code>{{renderFormComponent name:object [componentFamily:string=data.family||"default"] [context:object=this] [attributes:object=data.attributes]}}</code>
   *
   * Renders a form component using the attributes and context from the containing block.   The context and attributes can be
   * overridden with hash parameters, however, the context should always be the element object being rendered.  The attributes
   * should always be the attributes for the element that needs to be rendered.  The componentFamily will be whatever default
   * has already been set, but can be overridden if desired.
   *
   * <b>No Block</b>
   * @example
   * {{renderFormComponent "InputElement" context=elements.input attributes=@inputAttributes}}
   *
   * @param {string} componentName The name of the component to render.
   * @config {string} [family=data.family||"default"] The family to use to find the component name.
   * @config {object} [context=this] The context to use for the component.  This should always be the element object.
   * @config {object} [attributes=data.attributes] The attribute map to use for this component.
   *
   * @returns {Handlebars.SafeString} The HTML that describes the form component specified.
   */
  var renderFormComponent = function (componentName) {
    var options = arguments[arguments.length - 1];
    //noinspection OverlyComplexBooleanExpressionJS
    var family = (options.hash && options.hash.family) || (options.data && options.data.componentFamily) || "default";
    var context = (options.hash && options.hash.context) || this;

    var data = options.data ? Handlebars.createFrame(options.data) : { attributes : {}};
    data.componentFamily = family;
    if(options.hash && options.hash.attributes) {
      data.attributes = options.hash.attributes;
    }


    return new Handlebars.SafeString(BASE_FORM_COMPONENTS[family][componentName](context, {data: data}));
  };

  /**
   * <pre> {{[#]renderForm form:object [displayFormError:boolean=true] [displayHiddenAutomatically:boolean=true]
   *                             [classPrefix:string="exp-"] [prefix:string=""] [suffix:string=""] [fieldPrefix:string=""]
   *                             [fieldSuffix:string=""] [componentFamily:string="default"] [indicateRequired:boolean] }}
   *   @name:string @fieldPrefix:string @fieldSuffix:string  @classPrefix:string
   *   @displayHiddenAutomatically:boolean @fields:array @componentFamily:string
   * {{/renderForm}}</pre>
   * Render a form using the description of the form as described by: "<code>http://www.nike.com/nike/schema/form#/properties/form</code>".
   * For the most part, most uses should be able to just use renderForm without specifying a block, however, if the positioning
   * of fields is more complex or additional structure needs to exist around individual fields, then it will be necessary to
   * specify the block.
   *
   * Inside the block you will be given a map of all the field names and their objects that describe them. Using
   * {@link renderField} you will be able to render out each of the fields however, you like.
   *
   * The hidden fields will, by default, be after the FormError component is rendered.  When using {@link renderField}
   * to render a field that is hidden and has already been rendered, that field will not rendered again.
   *
   * The component family used to assist rendering is "default" unless specified.
   *
   * <b>Block Helper</b> | <b>Else Supported</b> | <b>Block Optional</b>
   * <b>Else:</b> Else is executed when the field object does not exist.
   * <b>Context:</b> Set to form.fields as a map.  Keys are the field name.
   * <b>Private Variables:</b>
   * <ul>
   * [ string ] name - The name of the field
   * [ string ] fieldPrefix - The prefix that should be applied before every field
   * [ string ] fieldSuffix - The suffix that should be applied after every field
   * [ string ] classPrefix - The prefix that is used before any class or ID generation
   * [ boolean ] displayHiddenAutomatically - Indicates whether the hidden fields have already been rendered
   * [ string ] componentFamily - The component family that will be used to render this form
   * [ array ] fields - The fields for the form as an array.  This preserves the order of the fields.
   * </ul>
   * @param {{name:string,attributes?:object,fields:Array}} form The form object as describes by the schema at URI: "<code>http://www.nike.com/nike/schema/form#/properties/form</code>".
   * @config {boolean} [displayFormError=true] When TRUE will render the component "FormError" at the top of the form.
   * @config {boolean} [displayHiddenAutomatically=true] When TRUE will render all fields that have an element 'input' with a type of 'hidden'.
   * @config {string} [classPrefix="exp-"] Prefixes any derived class names.
   * @config {string} [prefix] Prefixes the component "FormOpen".
   * @config {string} [suffix] Suffixes the component "FormClose".
   * @config {string} [fieldPrefix] Prefixes the component "FieldOpen".
   * @config {string} [fieldSuffix] Suffixes the component "FieldClose".
   * @config {string} [componentFamily="default"] Specifies a component family to use for rendering form components
   * @config {boolean} [indicateRequired] Indicates whether required fields should be indicated as required or not (TODO: This might make it into the model)
   *
   * @returns {Handlebars.SafeString} The HTML that was described by the form object.
   */
  var renderForm = function (form) {
    var options = arguments[arguments.length - 1] || {};
    var hash = options.hash || {};
    var attributes = form.attributes || {};
    var componentData = options.data ? Handlebars.createFrame(options.data || {}) : {};
    var data = options.data ? Handlebars.createFrame(options.data || {}) : {};
    var finalString;
    var componentFamily = hash.componentFamily || "default";
    var FORM_COMPONENTS = BASE_FORM_COMPONENTS[componentFamily];

    // Process the else block (if one exists) if there is no form object passed
    if(typeof form !== 'object') {
      return options.inverse ? options.inverse(this) : new Handlebars.SafeString("");
    }

    var displayFormError = (typeof hash.displayFormError === 'boolean') ? hash.displayFormError : true;
    var displayHiddenAutomatically = (typeof hash.displayHiddenAutomatically === 'boolean') ? hash.displayHiddenAutomatically : true;
    var classPrefix = hash.classPrefix || "exp-" + form.name + "-";
    var prefix = hash.prefix || "";
    var suffix = hash.suffix || "";
    var fieldPrefix = hash.fieldPrefix || "";
    var fieldSuffix = hash.fieldSuffix || "";

    var formName = classPrefix + "form";
    var name = form.name;
    var defaultAttributeMap = {
      "class" : classPrefix + "-form" + (attributes["classNames"] ? " " + attributes["classNames"] : ""),
      "name" : attributes.name || formName,
      "action" : attributes.action || "javascript:void(0)",
      "onsubmit" : attributes.onsubmit || "void(0);"
    };

    finalString = "";

    // Setup the private data for the form components
    componentData.formName = formName;
    componentData.attributes = createAttributeMap(attributes, defaultAttributeMap);

    // Render out the start of the HTML
    finalString += prefix;
    finalString += FORM_COMPONENTS.FormOpen(attributes, {data : componentData});

    if(displayFormError) {
      finalString += FORM_COMPONENTS.FormError(form);
    }

    // All the hidden fields will be rendered at the top, after the form error
    if(displayHiddenAutomatically) {
      for(var index=0; index < form.fields.length; index++) {
        var field = form.fields[index];
        if(field.elements && field.elements.input && field.elements.input.type === 'hidden') {
          // WARNING: The logic to generate a field ID is duplicated here
          finalString += renderHiddenField(classPrefix + field.name, field, componentFamily);
        }
      }
    }

    // Setup the private variables for the block and the fields
    data.formName = name;
    data.fieldPrefix = fieldPrefix;
    data.fieldSuffix = fieldSuffix;
    data.classPrefix = classPrefix;
    data.displayHiddenAutomatically = displayHiddenAutomatically;
    data.componentFamily = componentFamily;
    data.indicateRequired = hash.indicateRequired;
    data.indicateComplete = hash.indicateComplete;
    data.fields = form.fields;

    // Are we rendering the default form, or a custom build?
    if(options.fn) {
      // Render the form using a specific block that will control placement
      finalString += options.fn(convertArrayToMap(form.fields),{data : data});
    } else {
      // Render each form field using defaults and their defined order
      finalString += renderDefaultForm(form, data);
    }

    // Render out the end of the HTML
    finalString += FORM_COMPONENTS.FormClose(form);
    finalString += suffix;

    return new Handlebars.SafeString(finalString);
  };


  /**
   * <pre> {{[#]renderField field:object [prefix:string=data.fieldPrefix] [suffix:string=data.fieldSuffix]
   *                               [classPrefix:string=data.classPrefix] [componentFamily:string=data.componentFamily||"default"]
   *                               [outputContainer:boolean=true] [displayHidden:boolean=!data.displayHiddenAutomatically]
   *                               [indicateRequired:boolean=data.indicateRequired] [excludes:string] }}
   *   @id:string @name:string @indicateRequired:boolean @componentFamily:string
   *   @{elementType}Attributes:object @{elementType}Text:string
   *   [@parent:string] [@options:array] [@optionsString:string]
   * {{/renderField}}</pre>
   * Renders a field in a form.  Uses some of the settings from the renderForm block to make decisions unless overridden.
   * Without a block, several config options can conifgure how the field should be rendered.  With a block, it will
   * be necessary to write all of the HTML in the container.  However, even the container can be specified if required.
   *
   * The field object will be given as the context and each element will have at least one attribute variable.
   * Input elements will have an <b>@inputAttribute</b>, label elements will have a <b>@labelAttributes</b> and a <b>@labelText</b>.
   * To ensure that we are not duplicating more code than necessary, use the renderFormComponent for any element
   * that you didn't need direct control of.  So if you only need to modify the input, but not the label:
   * <pre><code>{{renderFormComponent "LabelElement" context=elements.label attributes=<b>@labelAttributes</b>}}</code></pre>
   * <b>Block Helper</b> | <b>Else Supported</b> | <b>Block Optional</b> | <b>Recursive</b>
   * <b>Else:</b> Executes else if field does not exist or will not render because it is a hidden field and displayHidden=false
   * <b>Context:</b> The field that was passed as the first parameter
   * <b>Important:</b> This helper must be called within a {{#renderForm}} block or it will not function correctly
   * <b>Private Variables:</b>
   * <ul>
   *   [ string ] id - The generated ID for this field.  Normally classPrefix + name
   *   [ string ] name - The name of this field.  This will be used in the name attribute of input elements
   *   [ boolean ] indicateRequired - Always set to whether or not required fields should be indicated as required.  Useful for labels
   *   [ string ] componentFamily - The component family that should be used to render this field.
   *   [ object ] <elementType>Attributes - The attributes that should be applied to an element.  ie. <b>@inputAttributes</b> or <b>@labelAttributes</b>
   *   [ string ] [<elementType>Text] - If an element has text, this would contain that text.  ie. <b>@labelText</b>
   *   [ string ] [parent] - If this field is inside a container (like radio button), this will be the name of the parent
   *   [ Array.&lt;{Object, value:string, test:string}> ] [options] - If there is a select element present, this will be an array of value/text objects
   *   [ string ] [optionsString] - If there is a select element present, this will be the string of all <option> elements in the select
   * </ul>
   * @param {{name:string,elements:object,attributes?:object,required?:boolean,fields?:Array}} field A field object as described by "<code>http://www.nike.com/nike/schema/form#/properties/field</code>".
   * @config {string} [prefix=data.fieldPrefix] The HTML to prefix the field, if it is rendered
   * @config {string} [suffix=data.fieldSuffix] The HTML to suffix the field, it it is rendered
   * @config {string} [classPrefix=data.classPrefix] The prefix used for any class or ID generated for this field.
   * @config {string} [componentFamily=data.componentFamily||"default"] The component family to use to assist rendering.
   * @config {boolean} [outputContainer=true] If the container of this field should not be rendered at all, set this to FALSE
   * @config {boolean} [displayHidden=!data.displayHiddenAutomatically] If you really want to display the field, even if it has already been rendered hidden, set this.
   * @config {boolean} [indicateRequired=data.indicateRequired] This will override any automatic decisions about whether the field should indicate if it's required or not
   * @config {string} [excludes] A comma separated list of elements to exclude from the output.
   *
   * @returns {Handlebars.SafeString} The HTML that describes the field
   */
  var renderField = function (field) {
    var options = arguments[arguments.length - 1];
    var hash = options.hash || {};
    var privateData = options.data || {};
    var formName = privateData.formName || "";
    var prefix = hash.prefix || privateData.fieldPrefix || "";
    var suffix = hash.suffix || privateData.fieldSuffix || "";
    var outputContainer = (typeof hash.outputContainer === 'boolean') ? hash.outputContainer : true;
    var config = {
      classPrefix : hash.classPrefix || privateData.classPrefix || "exp-" + ((formName && formName + "-") || ""),
      indicateRequired : hash.indicateRequired || privateData.indicateRequired,
      indicateComplete : hash.indicateComplete || privateData.indicateComplete || false,
      displayHidden : (typeof hash.displayHidden === 'boolean') ? hash.displayHidden : !!(privateData.displayHiddenAutomatically === false),
      excludes : hash.excludes,
      parentField : privateData.isFieldContainer ? privateData.name : undefined,
      componentFamily : hash.componentFamily || privateData.componentFamily || "default"
    };
    var FORM_COMPONENTS = BASE_FORM_COMPONENTS[config.componentFamily];
    var blockContext;

    // Protect the method
    if(typeof field !== 'object') {
      return options.inverse ? options.inverse(this) : new Handlebars.SafeString("");
    }

    var id = config.classPrefix + field.name;

    // Handle hidden fields immediately, no need for any type of rendering (default or the block)
    if(field.elements && field.elements.input && field.elements.input.type === 'hidden' && !_.contains(config.excludes, "input")) {
      if(config.displayHidden) {
        return new Handlebars.SafeString(renderHiddenField(id, field, config.componentFamily));
      } else {
        return options.inverse ? options.inverse(this) : new Handlebars.SafeString("");
      }
    }

    var finalString = "";

    // Data to pass to the form components
    var componentData = {
      id : id,
      formName : formName,
      name : field.name,
      indicateRequired : field.required || false,
      indicateComplete : config.indicateComplete,
      parent : config.parentField,
      attributes : createAttributeMap(field.attributes || {}, { "class" : id + "--container" })
    };

    // Setup our private data object using the previous private data from the containing block as a base.
    var data = _.extend(
                  Handlebars.createFrame(privateData),
                  getBaseDataObject(id, field, config.parentField, config.indicateRequired, config.indicateComplete)
               );

    data.componentFamily = config.componentFamily;

    // Check for a container
    if(field.fields && field.fields.length) {
      data.isFieldContainer = true;
      componentData.isFieldContainer = true;
    }

    if(outputContainer) {
      finalString += prefix;
      finalString += FORM_COMPONENTS.FieldOpen(field, {data: componentData});
    }

    var elements = field.elements;

    // Check for a block
    if(options.fn) {
      // Loop through and get each of the attributes for the elements.
      // @inputAttributes, @selectAttributes, etc.
      for(var fieldKey in elements) {
        if(elements.hasOwnProperty(fieldKey)) {
          data[fieldKey + "Attributes"] = getElementAttributes(id, field, fieldKey, config.parentField);
          if(elements[fieldKey].text) {
            data[fieldKey + "Text"] = elements[fieldKey].text;
          }
        }
      }

      // Grab the properties for a select element
      if(field.elements.select) {
        data = _.extend(data, getSelectOptions(field.elements.select))
      }

      // Modify the context of the block without actual modifying the model outside of the block
      if(field.fields) {
        blockContext = _.clone(field);
        blockContext.fields = convertArrayToMap(field.fields);
        data.fields = field.fields;
      } else {
        blockContext = field;
      }

      finalString += options.fn(blockContext, {data : data});
    } else {
      finalString += renderDefaultField(id, field, config);

      // If we are a container, then render out each of the contained fields too
      if(field.fields && field.fields.length) {
        // Now render out the field container open component, if one exists
        if(FORM_COMPONENTS.FieldContainerOpen) {
          finalString += FORM_COMPONENTS.FieldContainerOpen(field, {data : componentData});
        }

        // Loop through each of the fields and call this function recursively
        for(var index = 0; index < field.fields.length; index++) {
          var containedField = field.fields[index];
          finalString += renderField(containedField, {data : data, hash : { classPrefix : id + "-" }}).toString();
        }

        // Render out the field container close component
        if(FORM_COMPONENTS.FieldContainerClose) {
          finalString += FORM_COMPONENTS.FieldContainerClose(field, {data : componentData});
        }
      }

    }

    if(outputContainer) {
      finalString += FORM_COMPONENTS.FieldClose(field, {data: componentData});
      finalString += suffix;
    }

    return new Handlebars.SafeString(finalString);
  };

  /**
   * <code>{{#addClassNamesToComponent name:string}}{{/registerFormComponent}}</code>
   *
   * Modifies the classNames of the current context and adds in more classes.  This will be done in a non
   * permanent way to prevent dirtying up the context after execution.
   *
   * @param {string} classNames The class names to add to the component
   * @returns {string|Handlebars.SafeString} The block after execution using the modified class names
   */
  var addClassNamesToComponent = function (classNames) {
    var options = arguments[arguments.length - 1];
    var hash = options.hash;
    var context = _.clone(this);
    var base = context;

    if(hash.base && context[hash.base]) {
      context[hash.base] = _.clone(context[hash.base]);
      base = context[hash.base];
    }

    if(typeof base == "object" && typeof base.classNames == "string") {
      base.classNames += " " + classNames;
    } else if (typeof base == "object") {
      base.classNames = classNames;
    }

    return options.fn ? options.fn(context) : "";
  };

  /**
   * Returns an object attributes collapsed into a single layer.  baseAttributes can be passed as default values
   * if attributes doesn't specify a key.
   * @example
   * attributes : { maxlength : 40, data : { error : "error", validator : "name" } }
   * baseAttributes : { name : "lastName", class : "exp-test-lastName", maxlength : 30 }
   *
   * output : { name : "lastName", class : "exp-test-lastName", maxlength : 40, data-error : "error", data-validator : "name" }
   *
   * @param {object} attributes These should be the attributes from the element object.
   * @param {object} [baseAttributes] These are the default attributes that will be set unless overridden by the attributes.
   * @returns {object} The compiled attributes using the baseAttributes as the default
   */
  var createAttributeMap = function (attributes, baseAttributes) {
    var compiledAttributes = {};
    var eachAttribute = function (value, key) {
      var keyName = (key === 'classNames') ? 'class' : key;

      if(typeof value === 'object') {
        //noinspection JSValidateTypes
        _.each(value, eachAttribute, {prefix: this.prefix + key + "-"})
      } else {
        compiledAttributes[this.prefix + keyName] = value;
      }
    };

    //noinspection JSValidateTypes
    _.each(baseAttributes || {}, eachAttribute, {prefix: ""});
    //noinspection JSValidateTypes
    _.each(attributes, eachAttribute, {prefix: ""});

    return compiledAttributes;
  };

  /**
   * When given a string, returns the first character upper cased.  If no string is passed, returns
   * an empty string.
   *
   * @param {string} string The string to replace the first letter with an uppercase.
   * @returns {string} The string passed with the first letter upper cased, or an empty string if a invalid string passed.
   */
  var properCase = function (string) {
    return (typeof string === 'string') ? string.charAt(0).toUpperCase() + string.slice(1) : "";
  };

  /**
   * Converts an array of objects that contain a 'name' property into a map of key/value pairs.
   * [ { name: 'foo' }, { name: 'bar' } ] => { foo: { name: 'foo' }, bar: { name: 'bar' } }
   *
   * @param {Array.<{name:string}>} array The array of objects that contain at least a 'name' property
   * @returns {object} The new map with each key the name in each item in the array.
   */
  var convertArrayToMap = function (array) {
    var map = {};
    var entry;

    try {
      for(var index = 0; index < array.length; index++) {
        entry = array[index];
        map[entry.name] = entry;
      }
    } catch (exp) {
      nike.error("Array does not contain valid entries to convert into a map", array, exp);
    }

    return map;
  };

  /**
   * Handles running a generator to get data for several <option> elements.  If no generator is found
   * given the 'func' name, then an array with only a single default option will be returned.
   *
   * TODO: This needs work to handle "additionalOptions" in the form schema correctly.
   *
   * @param {{func:string,args:*}} options The options object should specify the name of the generator as 'func'and the arguments to pass as 'args'.
   * @returns {Array.<{value:string,text:string}>} An array of value/text pairs to create <option> elements with.
   */
  var processOptionFunc = function (options) {
    var processedOptions = [];
    var additionalOptions = [];
    var funcName = options.func;
    var funcArgs = options.args || [];

    // Add the default option
    processedOptions.push({
      value : "",
      displayText : options["defaultText"]
    });

    if(OPTION_GENERATORS[funcName]) {
      additionalOptions = OPTION_GENERATORS[funcName].apply(this, funcArgs);
    }

    return processedOptions.concat(additionalOptions);
  };

  /**
   * A helper to return a base set of private data for a field block.
   *
   * @param {string} id The ID of the field
   * @param {object} field The field object for this element
   * @param {string} parentField The parent container of this field
   * @param {boolean} indicateRequired Whether this field should be indicate it's required
   * @param {boolean} [indicateComplete=false] Whether to indicate when the field is valid
   * @returns {{id: string, name: string, parent: string, indicateRequired: boolean}} The compiled data object that should be used as private data
   */
  var getBaseDataObject = function (id, field, parentField, indicateRequired, indicateComplete) {
    return {
      id : id,
      name : field.name,
      parent : parentField,
      indicateRequired : !!(indicateRequired !== false && !parentField && field.required),
      indicateComplete : indicateComplete || false
    }
  };

  /**
   * Creates an attribute map for any element based on the provided fields.
   *
   * @param {string} id The generated ID for this field.
   * @param {object} field The field object for this element
   * @param {string} elementType The type of element that needs attributes
   * @param {string} parentField The parent container of this field
   * @returns {Object} The attribute map for this element description
   */
  var getElementAttributes = function (id, field, elementType, parentField) {
    var element = field.elements[elementType];
    var baseAttributes = {};

    baseAttributes["class"] = id + "--" + elementType;

    if(elementType === 'label') {
      baseAttributes["for"] = id;
    } else {
      baseAttributes["id"] = id;

      if(elementType === 'input' && element.type === 'radio') {
        // Handle radio inputs a bit differently
        baseAttributes["name"] = parentField;
        baseAttributes["value"] = element["value"] || field.name;
      } else if (elementType === 'select' && parentField) {
        // Handle contained select elements a bit differently
        baseAttributes["name"] = parentField + properCase(field.name);
      } else {
        baseAttributes["name"] = field.name;
      }
      // Add the required attribute if this field is required
      if(field.required) {
        baseAttributes.required = "required";
      }
    }

    var elementData = _.extend({}, element);
    // We don't want the options property to show up in the attributes
    delete elementData.options;
    // We don't want the text property to show up in the attributes
    delete elementData.text;

    return createAttributeMap(elementData, baseAttributes);
  };

  /**
   * Get the select options for a select field.  Returns an array of option objects and a rendered option string.
   *
   * @param {object} element The select element that needs the options processed.
   * @returns {{options: [{value:string,text:string}], optionsString: string}} An options array and the option string for this element.
   */
  var getSelectOptions = function (element) {
    var data = {
      options : (element.options instanceof Array) ? element.options : processOptionFunc(element.options),
      optionsString : ""
    };

    for(var index = 0; index < data.options.length; index++) {
      var option = data.options[index];
      var attributeMap = {
        value : option.value
      };

      if(option.selected) {
        attributeMap.selected = "selected"
      }

      if(option.additionalProperties) {
        attributeMap = createAttributeMap(option.additionalProperties, attributeMap);
      }

      var attributesString = renderAttributeMap(attributeMap).toString();

      data.optionsString += "<option " + attributesString + ">" + (option.displayText || "") + "<\/option>";
    }

    return data;
  };

  /**
   * Renders a hidden input element. It will use the component InputHiddenElement, if found,
   * otherwise it will render the input string directly and NOT use the InputElement component.
   *
   * @param {string} id The generated ID of this hidden input element
   * @param {object} field The field object that contains the hidden element
   * @param {string} [componentFamily="default"] The component family to use to render this element.
   * @returns {string} The HTML for this hidden input element
   */
  var renderHiddenField = function (id, field, componentFamily) {
    var FORM_COMPONENTS = BASE_FORM_COMPONENTS[componentFamily || "default"];
    var baseAttributes = {
      name : field.name
    };

    var data = {
      attributes : createAttributeMap(field.elements.input, baseAttributes),
      id : id
    };

    // We are returning DIRECTLY without applying anything else to this hidden field
    if(FORM_COMPONENTS.InputHiddenElement) {
      return FORM_COMPONENTS.InputHiddenElement(field.elements.input, {data : data});
    } else {
      return "<input " + renderAttributeMap(data.attributes, {}) + "/>";
    }
  };

  /**
   * Renders a default form block.  It will iterate over the field objects and render them in order
   * using the default passed to <code>{{renderForm}}</code>.
   *
   * @param {Object} form The form object that is being rendered.
   * @param {Object} data The private data that has been setup to render this form with.
   * @returns {string} The HTML that represents the form object passed using the configuration in the data object.
   */
  var renderDefaultForm = function (form, data) {
    var finalString = "";
    for(var index = 0; index < form.fields.length; index++) {
      var field = form.fields[index];
      finalString += renderField(field, {data: data}).toString();
    }

    return finalString;
  };

  /**
   * Renders a single field in a form using the layouts detailed in the components.  The rendering is highly
   * configurable.
   *
   * @param {string} id The generated ID for this field.
   * @param {object} field The field object that describes this field.
   * @param {object} config The configuration object that describes how to render this field.
   * @param {boolean} [config.labelFirst] When TRUE, will render the label first, FALSE otherwise.
   *                                      When not specified, it will be TRUE for most types,
   *                                      FALSE when a radio and checkbox input type.
   * @param {boolean} [config.indicateRequired] When NOT FALSE and does NOT have a parent field and
   *                                            a required field, tells the component that it should
   *                                            indicate a required field.
   * @param {boolean} [config.indicateComplete] When NOT FALSE will signal the component to display
   *                                            indication that a field is successfully valid.
   * @param {string} [config.parentField] When the parent field exists, it indicates that we are
   *                                      rendering inside a container and affects the generated
   *                                      names and whether the field should indicate a required field.
   * @param {Array.<string>} [config.excludes] A comma separated list of elements to exclude from the rendering.
   * @param {string} [config.componentFamily="default"] Which component family to use to render this field with.
   * @returns {string} The HTML for this field object using the provided configuration
   */
  var renderDefaultField =  function (id, field, config) {
    var data = {};
    var result = [];
    var label = "";
    var isRadioOrCheckbox = false;
    var excludes = config.excludes || [];
    var FORM_COMPONENTS = BASE_FORM_COMPONENTS[config.componentFamily || "default"];
    var element, markup;

    for(var elementType in field.elements) {
      if(field.elements.hasOwnProperty(elementType)) {
        element = field.elements[elementType];

        // Enforce the exlude list
        if(_.contains(excludes, elementType)) {
          continue;
        }

        data = getBaseDataObject(id, field, config.parentField, config.indicateRequired, config.indicateComplete);
        data.attributes = getElementAttributes(id, field, elementType, config.parentField);

        // Handle the element
        switch(elementType) {
          case "input":
            if(element.type === 'radio' || element.type === 'checkbox') {
              isRadioOrCheckbox = true;
            }

            // Use a form component (fine tuned if exists) or just make something up
            if(FORM_COMPONENTS["Input" + properCase(element.type) + "Element"]) {
              result.push(FORM_COMPONENTS["Input" + properCase(element.type) + "Element"](element, {data : data}));
            } else if(FORM_COMPONENTS.InputElement) {
              result.push(FORM_COMPONENTS.InputElement(element, {data : data}));
            } else {
              result.push("<input " + renderAttributeMap(data.attributes, {}) + "/>");
            }
            break;
          case "select":
            data = _.extend(data, getSelectOptions(element));

            if(FORM_COMPONENTS.SelectElement) {
              result.push(FORM_COMPONENTS.SelectElement(element, {data : data}));
            } else {
              result.push("<select " + renderAttributeMap(data.attributes, {}) + ">" + data.optionsString + "<\/select>");
            }
            break;
          default:
            data.text = element.text;

            if(FORM_COMPONENTS[properCase(elementType) + "Element"]) {
              markup = FORM_COMPONENTS[properCase(elementType) + "Element"](element, {data : data});
            } else {
              markup = "<" + elementType + " " + renderAttributeMap(data.attributes, {}) + ">" + (element.text || "") + "<\/" + elementType + ">";
            }

            if(elementType === 'label') {
              label = markup;
            } else {
              result.push(markup);
            }

            break;
        }
      }
    }

    if(typeof config.labelFirst === 'boolean') {
      if(config.labelFirst) {
        result.unshift(label);
      } else {
        result.push(label);
      }
    } else if (isRadioOrCheckbox) {
      result.push(label);
    } else {
      result.unshift(label);
    }

    return result.join("");
  };

  // Register all of our exposed helpers to Handlebars
  Handlebars.registerHelper("registerFormComponent", registerFormComponent);
  Handlebars.registerHelper("renderForm", renderForm);
  Handlebars.registerHelper("renderFormComponent", renderFormComponent);
  Handlebars.registerHelper("renderAttributeMap", renderAttributeMap);
  Handlebars.registerHelper("renderField", renderField);
  Handlebars.registerHelper("addClassNamesToComponent", addClassNamesToComponent);

  // Expose all of our closures when in a testing environment
  nike.ExposeClosureForTest("FormRenderHelpers", {
    FORM_COMPONENTS : BASE_FORM_COMPONENTS,
    OPTION_GENERATORS : OPTION_GENERATORS,
    createAttributeMap : createAttributeMap,
    properCase : properCase,
    convertArrayToMap : convertArrayToMap,
    processOptionFunc : processOptionFunc,
    renderDefaultField : renderDefaultField,
    renderDefaultForm : renderDefaultForm,
    renderFormComponent : renderFormComponent,
    registerFormComponent : registerFormComponent,
    renderAttributeMap : renderAttributeMap,
    renderForm : renderForm,
    renderField : renderField,
    addClassNamesToComponent : addClassNamesToComponent
  });

  nike.exp.global.templatehelpers.FormRenderHelpers.registerFormGenerator = function (name, func) {
    OPTION_GENERATORS[name] = func;
  };

})(nike, Handlebars, _);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templatehelpers.FormRenderHelpers. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace("nike.exp.global.templatehelpers.generator.StateGenerator");

nike.requireDependency('nike.exp.global.templatehelpers.FormRenderHelpers');

nike.exp.global.templatehelpers.generator.StateGenerator = {
  STATE_MAP: {
    US: [
      {value: "AL", displayText: "AL"},
      {value: "AK", displayText: "AK"},
      {value: "AZ", displayText: "AZ"},
      {value: "AR", displayText: "AR"},
      {value: "CA", displayText: "CA"},
      {value: "CO", displayText: "CO"},
      {value: "CT", displayText: "CT"},
      {value: "DE", displayText: "DE"},
      {value: "DC", displayText: "DC"},
      {value: "FL", displayText: "FL"},
      {value: "GA", displayText: "GA"},
      {value: "HI", displayText: "HI"},
      {value: "ID", displayText: "ID"},
      {value: "IL", displayText: "IL"},
      {value: "IN", displayText: "IN"},
      {value: "IA", displayText: "IA"},
      {value: "KS", displayText: "KS"},
      {value: "KY", displayText: "KY"},
      {value: "LA", displayText: "LA"},
      {value: "ME", displayText: "ME"},
      {value: "MD", displayText: "MD"},
      {value: "MA", displayText: "MA"},
      {value: "MI", displayText: "MI"},
      {value: "MN", displayText: "MN"},
      {value: "MS", displayText: "MS"},
      {value: "MO", displayText: "MO"},
      {value: "MT", displayText: "MT"},
      {value: "NE", displayText: "NE"},
      {value: "NV", displayText: "NV"},
      {value: "NH", displayText: "NH"},
      {value: "NJ", displayText: "NJ"},
      {value: "NM", displayText: "NM"},
      {value: "NY", displayText: "NY"},
      {value: "NC", displayText: "NC"},
      {value: "ND", displayText: "ND"},
      {value: "OH", displayText: "OH"},
      {value: "OK", displayText: "OK"},
      {value: "OR", displayText: "OR"},
      {value: "PA", displayText: "PA"},
      {value: "RI", displayText: "RI"},
      {value: "SC", displayText: "SC"},
      {value: "SD", displayText: "SD"},
      {value: "TN", displayText: "TN"},
      {value: "TX", displayText: "TX"},
      {value: "UT", displayText: "UT"},
      {value: "VT", displayText: "VT"},
      {value: "VA", displayText: "VA"},
      {value: "WA", displayText: "WA"},
      {value: "WV", displayText: "WV"},
      {value: "WI", displayText: "WI"},
      {value: "WY", displayText: "WY"}
    ],

    JP: [
      {value: "JP-01", displayText: "prefecture.Hokkaido"},
      {value: "JP-02", displayText: "prefecture.Aomori"},
      {value: "JP-03", displayText: "prefecture.Iwate"},
      {value: "JP-04", displayText: "prefecture.Miyagi"},
      {value: "JP-05", displayText: "prefecture.Akita"},
      {value: "JP-06", displayText: "prefecture.Yamagata"},
      {value: "JP-07", displayText: "prefecture.Fukushima"},
      {value: "JP-08", displayText: "prefecture.Ibaraki"},
      {value: "JP-09", displayText: "prefecture.Tochigi"},
      {value: "JP-10", displayText: "prefecture.Gunma"},
      {value: "JP-11", displayText: "prefecture.Saitama"},
      {value: "JP-12", displayText: "prefecture.Chiba"},
      {value: "JP-13", displayText: "prefecture.Tokyo"},
      {value: "JP-14", displayText: "prefecture.Kanagawa"},
      {value: "JP-15", displayText: "prefecture.Niigata"},
      {value: "JP-16", displayText: "prefecture.Toyama"},
      {value: "JP-17", displayText: "prefecture.Ishikawa"},
      {value: "JP-18", displayText: "prefecture.Fukui"},
      {value: "JP-19", displayText: "prefecture.Yamanashi"},
      {value: "JP-20", displayText: "prefecture.Nagano"},
      {value: "JP-21", displayText: "prefecture.Gifu"},
      {value: "JP-22", displayText: "prefecture.Shizuoka"},
      {value: "JP-23", displayText: "prefecture.Aichi"},
      {value: "JP-24", displayText: "prefecture.Mie"},
      {value: "JP-25", displayText: "prefecture.Shiga"},
      {value: "JP-26", displayText: "prefecture.Kyoto"},
      {value: "JP-27", displayText: "prefecture.Osaka"},
      {value: "JP-28", displayText: "prefecture.Hyogo"},
      {value: "JP-29", displayText: "prefecture.Nara"},
      {value: "JP-30", displayText: "prefecture.Wakayama"},
      {value: "JP-31", displayText: "prefecture.Tottori"},
      {value: "JP-32", displayText: "prefecture.Shimane"},
      {value: "JP-33", displayText: "prefecture.Okayama"},
      {value: "JP-34", displayText: "prefecture.Hiroshima"},
      {value: "JP-35", displayText: "prefecture.Yamaguchi"},
      {value: "JP-36", displayText: "prefecture.Tokushima"},
      {value: "JP-37", displayText: "prefecture.Kagawa"},
      {value: "JP-38", displayText: "prefecture.Ehime"},
      {value: "JP-39", displayText: "prefecture.Kochi"},
      {value: "JP-40", displayText: "prefecture.Fukuoka"},
      {value: "JP-41", displayText: "prefecture.Saga"},
      {value: "JP-42", displayText: "prefecture.Nagasaki"},
      {value: "JP-43", displayText: "prefecture.Kumamoto"},
      {value: "JP-44", displayText: "prefecture.Oita"},
      {value: "JP-45", displayText: "prefecture.Miyazaki"},
      {value: "JP-46", displayText: "prefecture.Kagoshima"},
      {value: "JP-47", displayText: "prefecture.Okinawa"}
    ],

    CN : [
      {value: "CN-92", displayText: "profile.china.province.92"},
      {value: "CN-23", displayText: "profile.china.province.23"},
      {value: "CN-50", displayText: "profile.china.province.50"},
      {value: "CN-22", displayText: "profile.china.province.22"},
      {value: "CN-21", displayText: "profile.china.province.21"},
      {value: "CN-52", displayText: "profile.china.province.52"},
      {value: "CN-51", displayText: "profile.china.province.51"},
      {value: "CN-42", displayText: "profile.china.province.42"},
      {value: "CN-43", displayText: "profile.china.province.43"},
      {value: "CN-44", displayText: "profile.china.province.44"},
      {value: "CN-45", displayText: "profile.china.province.45"},
      {value: "CN-64", displayText: "profile.china.province.64"},
      {value: "CN-46", displayText: "profile.china.province.46"},
      {value: "CN-65", displayText: "profile.china.province.65"},
      {value: "CN-63", displayText: "profile.china.province.63"},
      {value: "CN-14", displayText: "profile.china.province.14"},
      {value: "CN-13", displayText: "profile.china.province.13"},
      {value: "CN-62", displayText: "profile.china.province.62"},
      {value: "CN-61", displayText: "profile.china.province.61"},
      {value: "CN-15", displayText: "profile.china.province.15"},
      {value: "CN-41", displayText: "profile.china.province.41"},
      {value: "CN-12", displayText: "profile.china.province.12"},
      {value: "CN-11", displayText: "profile.china.province.11"},
      {value: "CN-33", displayText: "profile.china.province.33"},
      {value: "CN-34", displayText: "profile.china.province.34"},
      {value: "CN-31", displayText: "profile.china.province.31"},
      {value: "CN-32", displayText: "profile.china.province.32"},
      {value: "CN-37", displayText: "profile.china.province.37"},
      {value: "CN-53", displayText: "profile.china.province.53"},
      {value: "CN-35", displayText: "profile.china.province.35"},
      {value: "CN-54", displayText: "profile.china.province.54"},
      {value: "CN-36", displayText: "profile.china.province.36"}
    ]
  },

  generateStateMap: function(commerceRegion) {
    var siteMap = null;
    if(typeof commerceRegion === 'string') {
      var upperCaseCommerceRegion = commerceRegion.toUpperCase();
      siteMap = this.STATE_MAP[upperCaseCommerceRegion];
      if("JP" === upperCaseCommerceRegion || "CN" === upperCaseCommerceRegion) {
        var localValueUtil = nike.exp.global.LocalValueUtil;
        for(var index in siteMap) {
          var mapElement = siteMap[index];
          mapElement.displayText = localValueUtil.getLocal(mapElement.displayText);
        }
      }
    }
    return siteMap? siteMap : [];
  }
};

nike.exp.global.templatehelpers.FormRenderHelpers.registerFormGenerator("stateGenerator",

/**
 * Generates selects with states or provinces based on locale
 *
 * <b>Example:</b>
 * <pre> options : {
               *    func : "stateGenerator"
               *    args : [ "US" ]
               * }</pre>
 *
 * @param {string} type Should be one of: US, JP, EU
 * @returns {[{value:string,displayText:string}]} An array of option objects for the given locale.
 */
function (commerceRegion) {

  /**
   * Used internally by the dobGenerator
   */
    return nike.exp.global.templatehelpers.generator.StateGenerator.generateStateMap(commerceRegion);
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templatehelpers.generator.StateGenerator. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.TemplateHelpers');

nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('nike.style.nsg.Classes');
nike.requireDependency('nike.exp.global.templatehelpers.generator.StateGenerator');
nike.requireDependency('nike.exp.global.LocalValueUtil');
nike.requireDependency('nike.geo.Util');
nike.requireDependency('HandlebarsRuntime');

!function(){

  // Do nothing helpers.  This will be read by the ScriptManager to assemble dependencies
  // but they are defined for unit test execution, so don't overwrite them.
  if (!_(Handlebars.helpers).has('requirePartial')){
    Handlebars.registerHelper('requirePartial', Handlebars.VM.noop);
  }
  if (!_(Handlebars.helpers).has('requireDependency')){
    Handlebars.registerHelper('requireDependency', Handlebars.VM.noop);
  }

  /**
   * With block helpers, the 'markup' or 'options' argument will always be the last
   * argument. In order to make more dynamic helpers you can utilize this method to
   * verify a property is not markup/options, and then proceed to set data.
   * @param {*} x - Could be any argument passed in
   * @param {Object} obj - The Object that will be updated
   * @param {String} prop - The property of the Object the data will be set to
   * @returns {Boolean}
   */
  Handlebars.registerHelper("blockHelperMarkupCheck", function(x, obj, prop){
    if(x && x.fn){
      obj[prop] = new Handlebars.SafeString( x.fn(this) );
      return true;

      // handles instances where the user calls the helper via {{helper arg1 arg2 ...}}
      // instead of {{#helper arg1 arg2 ...}}{{/helper}}
    }else if(x && x.data && x.hash){
      return true;
    }

    return false;
  });

  Handlebars.registerHelper("buildSocialTool", function(obj){
  	var markup= "";

    if(Handlebars.templates.Social){
			obj.lang = nike.LANGUAGE;
      markup = Handlebars.templates.Social(obj);
    }

    return new Handlebars.SafeString(markup);

  });

  /** Helper to setup the email share link with the proper url and params.
   *
   * @param {Object} context - data passed in to be manipulated, the mail link in this case
   * @param {String} markup - used with the return value
   */
  Handlebars.registerHelper("buildEmailButton", function(context, markup){
    if( context && context.dataAttributes && context.dataAttributes.url ){
      context.dataAttributes.url = nike.geo.Util.parseUnicodeText(String(context.dataAttributes.url)).replace(/\\/g, '');
      return markup.fn(context);
    }else{
      return '[ ERROR ] - buildEmailButton: `context.dataAttributes.url` not defined.'
    }
  });

    Handlebars.registerHelper("getStateMap", function(country, options) {
      var data = Handlebars.createFrame(options.data || {});
      var stateMap = nike.exp.global.templatehelpers.generator.StateGenerator.generateStateMap(country);
      var finalResult = '';
      if(stateMap.length > 0) {
        var mapElement = stateMap[0];
        data.value = mapElement.value;
        data.displayText = mapElement.displayText;
        finalResult = options.fn(this, {data: data});
        for (var index = 1; index < stateMap.length; index++) {
          mapElement = stateMap[index];
          data.value = mapElement.value;
          data.displayText = mapElement.displayText;
          finalResult += options.fn(this, {data: data});
        }
      } else {
        finalResult = options.inverse(this);
      }
      return finalResult;
  });

  /**
   * Takes a variable number of arguments and assembles a QA name.  It outputs
   * data-qa="{{assembled name}}"
   */
  Handlebars.registerHelper('addQaAttribute', function() {
    var attribute;
    var args = _.toArray(arguments);
    // Pop off the handlebars object
    args.pop();

    if (nike.ENV_CONFIG && nike.ENV_CONFIG.renderDataQA == "true") {
      attribute = nike.DATA_QA + "=\"" + args.join("").toLowerCase() + "\"";
    } else {
      attribute = "";
    }
    return new Handlebars.SafeString(attribute);
  });

  /**
   * Outputs the string 'true' or 'false' if the argument passed is truthy or not.
   */
  Handlebars.registerHelper('boolean', function (context) {
    return context ? 'true' : 'false';
  });

  /**
   * Lower cases a string
   */
  Handlebars.registerHelper('toLowerCase', function (str) {
    return typeof str === 'string' ? str.toLocaleLowerCase() : str;
  });

  Handlebars.registerHelper('toUpperCase', function (str) {
    return typeof str === 'string' ? str.toLocaleUpperCase() : str;
  });

  /**
   * This acts as a for loop in Handlebars.  The block variable is whatever is
   * contained between the opening and closing tags (e.g. {{#for 1 10}}block{{/for}})
   */
  Handlebars.registerHelper("for", function(from, to, block) {
    var accum = '';
    for(var i = from; i <= to; i++) {
      accum += block.fn(i);
    }
    return accum;
  });


  Handlebars.registerHelper("foreach",function(arr,options) {
    if(options.inverse && !arr.length){
      return options.inverse(this);
    }

    return _.map(arr, function(item,index) {
      item.$index = index;
      item.$first = index === 0;
      item.$second = index === 1;
      item.$last = index === arr.length-1;
      return options.fn(item);
    }).join('');
  });


  Handlebars.registerHelper("splitBySlash", function(value){
    if(value.length > 10){
      return value.split("/").join(' /');
    }
    return value;
  });


  /**
   * Find a specific local value object in the global dynamic localValues map
   */
  Handlebars.registerHelper("getLocal", function(localValueKey){
    return nike.exp.global.LocalValueUtil.getLocal(localValueKey);
  });

  Handlebars.registerHelper("displayPayNowCTA", function(orderContext, options) {
    var displayCTA = options.inverse(this);
    if('CN' == nike.COUNTRY && nike.objectDefined("paymentGroups", orderContext)) {
      var paymentMethods = orderContext.paymentGroups;
      for(var index = 0; index < paymentMethods.length; index++) {
        if(nike.objectDefined("paymentUrl", paymentMethods[index])) {
          var data = options.data || {};
          data.paymentUrl = paymentMethods[index].paymentUrl;
          displayCTA = options.fn(this, {data: data});
          break;
        }
      }
    }
    return displayCTA;
  });

  Handlebars.registerHelper("isOddRow", function(rawValue, options){
    var rawValue = rawValue +1; //index starts with 0, so making it start with 1
    if (+rawValue % 2) {
      return options.fn(this);
    } else {
      return options.inverse(this);
    }
  });

  /**
   * Feature Flag Helper
   */
  Handlebars.registerHelper("featureFlag", function(feature, options){
    var featureFlag = nike.FEATURE_LIST[feature];
    if(featureFlag){
      return options.fn(this);
    } else {
      return options.inverse(this);
    }
  });

  /**
   * Checks if page's BRAND matches the approved domain for displaying content
   * @param {string} domains - All caps domain names separated by commas such as "NIKE", "NIKE,CONVERSE" or "HURLEY,NIKE"
   */
  Handlebars.registerHelper("allowedDomains", function(domains, options){
    domains = domains.split(',');

    return (domains.indexOf(nike.BRAND) > -1)
      ? options.fn(this)
      : options.inverse(this);
  });

  /**
   * <p>Will add the appropriate NSG class from the Classes object.  If a class is requested but not listed, then an error message will be returned.</p>
   * @see nike.style.nsg.Classes
   */
  Handlebars.registerHelper('NSGClass', function (sClass) {
    if (nike.style.nsg.Classes[sClass.toUpperCase()]) {
      return nike.style.nsg.Classes[sClass.toUpperCase()];
    } else {
      return "The_state_name__"+sClass+"__does_not_exist.";
    }
  });

  /**
   * Replaces $hashKey{someText} with whatever is defined in the block,
   * with "hashKey" as a hash variable passed to the helper.
   *
   * Replaces this input:
   * By clicking REGISTER, you are agreeing to the $policy{Nike Policy} and $terms{Terms & Conditions}.
   *
   * with this:
   * By clicking REGISTER, you are agreeing to the
   * <a href="privacyUrl" class="policy" target="_blank" data-qa="user_registration.privacy">Nike Policy</a>
   * and
   * <a href="termsUrl" class="terms" target="_blank" data-qa="user_registration.terms_conditions">Terms and Conditions</a>.
   *
   * This allows languages to determine where and when each of the URLs are present without trying break
   * up the local value into several separate strings.
   *
   * @private disclaimer The text to parse
   * @hash All variables in the hash are used to replace text in the disclaimer
   * @context Not changed
   * @block
   * @ignoresElse
   *
   */
  Handlebars.registerHelper("renderLinkReplacement",
  function renderLinkReplacement (link) {
    var options = arguments[arguments.length - 1] || {};
    var hash = options.hash || {};
    var data = Handlebars.createFrame(options.data || {});
    var ret = link || "";
    var key, regexp, matches;

    // Replace only the values that are defined in the hash
    for(key in hash) {
      if(hash.hasOwnProperty(key)) {
        regexp = new RegExp("\\$" + key + "\\{([^\\}]+)\\}");
        matches = regexp.exec(ret);

        // Ensure that we have this key in the text
        if(matches && matches.length > 1) {
          data.name = key;
          data.url = hash[key];
          data.displayText = matches[1];

          // Replace the value in the text with the return of the block rendering
          ret = ret.replace(matches[0], options.fn(this, {data : data}));
        }
      }
    }

    return new Handlebars.SafeString(ret);
  });

  Handlebars.registerHelper("extendedEach",
      /**
       *
       * @param {Object|Array} context
       * @config {string} [excludes] A comma separated list of excluded properties.
       *                             For an object, this will exclude properties of that object.
       *                             For an array, this will exclude by the array value (which must be a string).
       * @config {string} [excludeByProperty] Will specify a property to use for the excludes list to look at.
       *                                      For an object, each property will be looked at, and if it is an object,
       *                                      and that object has the property specified, then the value of that
       *                                      property will be matched to the exclude list.
       *                                      For an array, each item in the array will be looked at, and if it is an object,
       *                                      and that object has the property specified, then the value of that
       *                                      property will be matched to the exclude list.
       */
      function extendedEach (context) {
        var options = arguments[arguments.length - 1];
        var hash = options.hash || {};

        var excludes = hash.excludes;
        var excludeByProperty = hash.excludeByProperty;
        var excludeMap = (function (excludes) {
          var excludeArray = excludes ? excludes.split(",") : [];
          var excludeMap = {};
          for(var i=0;i<excludeArray.length;i++) {
            excludeMap[excludeArray[i]] = true;
          }
          return excludeMap;
        })(excludes);

        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;

        var isExcluded = function (value) {
            //noinspection OverlyComplexBooleanExpressionJS
          return (excludeByProperty && typeof value === 'object' && typeof value[excludeByProperty] === 'string'
                      && excludeMap[value[excludeByProperty]])
                 || (excludeMap[value]);
        };

        if (options.data) {
          data = Handlebars.createFrame(options.data);
        }

        if(context && typeof context === 'object') {
          if(context instanceof Array){
            for(var j = context.length; i<j; i++) {
              if(isExcluded(context[i])) { continue; }
              if (data) { data.index = i; }
              ret += fn(context[i], { data: data });
            }
          } else {
            for(var key in context) {
              if(context.hasOwnProperty(key)) {
                if(isExcluded(context[key])) { continue; }
                if(data) { data.key = key; }
                ret += fn(context[key], {data: data});
                i++;
              }
            }
          }
        }

        if(i === 0){
          ret = inverse(this);
        }

        return ret;
      });

  Handlebars.registerHelper("importModel", function(ns) {
    // This is a top-level helper and certain data should only be added once
    if( !Handlebars.nike ) Handlebars.nike = {};

    var name, i, id;
    var nsArr = ns.split(',');
    var html  = '';
    var globalData = '';
    var encodeScript = function(data) {
      return data.replace(/script/g, 'scr-ipt');
    };

    for (i = 0; i < nsArr.length; i++) {
      name = nsArr[i] = nsArr[i].trim();
      id   = 'tmpData-' + name;
      if (this[name]) {
        html+=
        '<script id="' + id + '" type="importModelTempData" data-name="'+ name +'">\n'+
           encodeScript(JSON.stringify(this[name])) + '\n' +
        '</script>\n';
      }
    }

    // only load the execution code once
    if( !Handlebars.nike.modelImported ){
      html+=
      '<script id="tmpData-parse" type="text/javascript">\n'+
      '  var testNike = function() {\n'+
      '    if (!nike || !nike.namespace || typeof $ === "undefined") {\n'+
      '      setTimeout(testNike, 30);\n'+
      '    }else {\n'+
      '      nike.namespace("nike.globalData");\n'+
      '      function unencodeScript($script) {\n'+
      '        var rawData = $script.html();\n'+
      '        var data = JSON.parse(rawData.replace(/scr-ipt/g, "script"));\n'+
      '        nike.globalData[$script.data("name")] = data;\n'+
      '        $script.remove();\n'+
      '      }\n'+
      '      try {\n'+
      '        var modelItems = $("script[type=\\"importModelTempData\\"]");\n'+
      '        for(var i=modelItems.length-1; i>=0; i--){\n'+
      '          unencodeScript($(modelItems[i]));\n'+
      '        }\n'+
      '      } catch (ex) {\n'+
      '        nike.error("Error loading data via import model. Exception:", ex);\n'+
      '      }\n'+
      '      $("#tmpData-parse").remove();\n'+
      '    }\n'+
      '  }\n'+
      '  testNike();\n'+
      '</script>\n';
    }

    Handlebars.nike.modelImported = true;

    return new Handlebars.SafeString(html);
  });

  Handlebars.registerHelper("giftCardCharged", function (formattedGiftCardVaucherAmount, options) {
    var result = false;

    if (!$.isEmptyObject(formattedGiftCardVaucherAmount)) {
      if(!isNaN(formattedGiftCardVaucherAmount)) {
        result = formattedGiftCardVaucherAmount != 0;
      } else {
        result = formattedGiftCardVaucherAmount.substring(1) != '0.00';
      }
    }

    if (result) {
      return options.fn(this);
    } else {
      return options.inverse(this);
    }
  });

  /**
   * Register a partial inline, useful for small partials that you don't want to
   * register in JS or a separate .handlebars file.
   * <!-- Define a micro-partial -->
   * {{#microPartial "MicroReviews"}}
   *   <div>Avg. Rating: {{averageRatingPercentage}}</div>
   * {{/microPartial}}
   * <!-- Use it like a partial -->
   * {{>MicroReviews reviews}}
   *
   * @param {string} name - The name to register the partial with.
   * @param {object} options - standard options object passed to registerHelper function.
   */
  Handlebars.registerHelper("microPartial", function(name, options){
    // Register the partial with the supplied name and the compiled template.
    Handlebars.registerPartial(name, options.fn);
    return '';
  });

  /**
   * There are some instance where you have to replace keys in values.
   * This method will allow an inline replacement, or replacing a needle with
   * a block of markup.
   *
   * @param haystack The string in which to replace the needle with the replacement value.
   * @param needle The needle to replace in the haystack with a replacement value.
   * @param replacement The value that replaces the needle.
   * @param type The type of the replacement value. i.e. number, etc.
   * @returns The haystack with the needle replaced by the replacement value as a string.
   */
  function replaceHaystack(haystack, needle, replacement, type){
    var result = "";
    if(haystack) {
      if (type && typeof replacement == type) {
        replacement = replacement.toString();
      }
      result = (typeof replacement == 'string')
        ? haystack.replace(needle, replacement)
        : haystack.replace(needle, replacement.fn());
    }
    return result;
  };

  /**
   * There are some instance where you have to replace keys in values.
   * This method will allow an inline replacement, or replacing a needle with
   * a block of markup.
   *
   * @param haystack The string in which to replace the needle with the replacement value.
   * @param needle The needle to replace in the haystack with a replacement value.
   * @param replacment The value that replaces the needle.
   * @param type The type of the replacement value. i.e. number, etc.
   * @returns The haystack with the needle replaced by the replacement value as a string.
   */
  Handlebars.registerHelper("replace", function(haystack, needle, replacement, type) {
    return replaceHaystack(haystack, needle, replacement, type);
  });

  /**
   * There are some instance where you have to replace keys in local values.
   * This method will allow an inline replacement, or replacing a needle with
   * a block of markup.
   *
   * @param keyName The local value key to look up, this will be the haystack.
   * @param needle The needle to replace in the haystack with a replacement value.
   * @param replacement The value that replaces the needle.
   * @param type The type of the replacement value. i.e. number, etc.
   * @returns The haystack with the needle replaced by the replacement value as a string.
   */
  Handlebars.registerHelper("replaceTokenInSFKeyWithValue", function(keyName, needle, replacement, type) {
    var haystack = nike.exp.global.LocalValueUtil.getLocal(keyName);
    return replaceHaystack(haystack, needle, replacement, type);
  });

  /**
   * There are some instance where you have to replace keys in local values.
   * This method will allow an inline replacement, or replacing a needle with
   * a block of markup.
   *
   * @param keyName The local value key to look up, this will be the haystack.
   * @param needle The needle to replace in the haystack with a replacement value.
   * @param replacementKey The local value key to look up, this will be the value that replaces the needle.
   * @returns The haystack with the needle replaced by the replacement value as a string.
   */
  Handlebars.registerHelper("replaceTokenInSFKeyWithSFKey", function(keyName, needle, replacementKey) {
    var haystack = nike.exp.global.LocalValueUtil.getLocal(keyName);
    var replacement = nike.exp.global.LocalValueUtil.getLocal(replacementKey);
    return replaceHaystack(haystack, needle, replacement);
  });

  /**
   * Return an element from an array.  This version of Handlebars
   * does not allow .[i] access within a .each loop.  Use this
   * helper to solve that problem until we upgrade.
   *
   * @param {array} obj - the array to extract element from.
   * @param {int} field - index of the element to fetch
   */
  Handlebars.registerHelper('arrayLookup', function(obj, field) {
    if(obj) {
      return obj[field];
    } else {
      return null;
    }
  });

  Handlebars.registerHelper("compare", function (lvalue, operator, rvalue, options) {
    var operators, result;

    if (arguments.length < 3) {
      throw new Error("Handlerbars Helper 'compare' needs 3 parameters");
    }

    if (options === undefined) {
      options  = rvalue;
      rvalue   = operator;
      operator = "===";
    }

    operators = {
      '=='    : function (l, r) { return l ==  r; },
      '==='   : function (l, r) { return l === r; },
      '&&'    : function (l, r) { return l &&  r; },
      '||': function (l, r) { return l || r; },
      '!='    : function (l, r) { return l !=  r; },
      '!=='   : function (l, r) { return l !== r; },
      '<'     : function (l, r) { return l <   r; },
      '>'     : function (l, r) { return l >   r; },
      '<='    : function (l, r) { return l <=  r; },
      '>='    : function (l, r) { return l >=  r; },
      'typeof': function (l, r) { return typeof l == r; },
      'match' : function (l, r) { return (new RegExp(r)).test(l)}
    };

    if (!operators[operator]) {
      throw new Error("Handlerbars Helper 'compare' doesn't know the operator " + operator);
    }

    result = operators[operator](lvalue, rvalue);

    if (result) {
      return options.fn(this);
    } else {
      return options.inverse(this);
    }
  });

  /**
   * Returns a nike url with country + lang_locale with further arguments
   * @param  [arguments...] - any string passed in as an argument
   * @param {Handlebars@Options} - default last argument from Handlebars
   * @return {String}
   */
  Handlebars.registerHelper('createFullNikeURL', function () {
    var path = _(arguments).filter(function (term) {
      return (typeof term === "string" && term != "");
    }).join('/');
    return nike.getServiceUrl('oneStoreHost') + nike.COUNTRY.toLowerCase() + '/' + nike.LOCALE.toLowerCase() + '/' + path + '/';
  });

  /**
   * Returns the secure commerce domain url.
   */
  Handlebars.registerHelper("createSecureCommerceDomainUrl", function() {
    return nike.getServiceUrl("secureCommerceDomain");
  });

  /**
   * Returns a nike url with country + lang_locale with further arguments.
   * If the slug starts with 'http', 'www', or '//' we simply return the slug because we need to
   * allow rendering of links from the NavLink cartridge which could either be a gridwall hash or full url.
   *
   * @param {String} slug
   * @parma {String} hash
   * @param {String} [searchTerm]
   * @return {String}
   */
  Handlebars.registerHelper('createGridwallUrl', function (slug, hash, searchTerm) {
    var baseUrl = nike.getServiceUrl('oneStoreHost') + nike.COUNTRY.toLowerCase() + '/' + nike.LOCALE.toLowerCase() + '/pw/' + slug + '/' + hash;
    var regexp = new RegExp('^(http|www|\/\/)');

    // if sortOrder is defined, add it to the query string
    if (
      typeof window !== "undefined"
      && nike.objectDefined('nike.exp.gridwall.Gridwall')
      && nike.exp.gridwall.Gridwall.sortOrder
    ) {
      baseUrl = nike.util.UrlUtil.addParameter(baseUrl, 'sortOrder', nike.exp.gridwall.Gridwall.sortOrder);
    }

    if (regexp.test(slug)) {
      return slug;
    } else {
      return searchTerm ? nike.util.UrlUtil.addParameter(baseUrl, 'sl', searchTerm) : baseUrl;
    }
  });

  /**
   * Looks up a value in the specified array at the specified index and returns it.
   *
   * @param array The array in which to look up a value.
   * @param index The index of the value to look up.
   * @return The value in the array at the specified index.
   */
  Handlebars.registerHelper('lookup', function(array, index) {
    return array[index];
  });
}();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.TemplateHelpers. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
if(nike.namespace){nike.namespace('nike.exp.global.templates.BrowserCheck');}
   (function() { 
     var template = Handlebars.template, 
         templates = Handlebars.templates = Handlebars.templates || {}; 
     templates['BrowserCheck'] = template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "    <div class=\"exp--compatibility--message-container\">\r\n        <span class=\"nsg-text--grey nsg-font-family--base\">"
    + ((stack1 = (helpers.getLocal || (depth0 && depth0.getLocal) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"compatibility.view.ie",{"name":"getLocal","hash":{},"data":data})) != null ? stack1 : "")
    + "</span>\r\n    </div>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression;

  return "    <div class=\"exp--browser-check--content\">\r\n        <h1 class=\"nsg-font-family--platform exp--browser-check--title edf-font-size--xlarge \">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.header",{"name":"getLocal","hash":{},"data":data}))
    + "</h1>\r\n        <span class=\"nsg-keyline--horizontal exp--browser-check--keyline\"/>\r\n        <div class=\"exp--browser-check--logo-container\">\r\n            <a href=\""
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.CTA.link.ie",{"name":"getLocal","hash":{},"data":data}))
    + "\" target=\"_blank\">\r\n              <img src=\"/nikestore/html/img/browsers/Internet_Explorer.png\">\r\n            </a>\r\n        </div>\r\n        <div class=\"nsg-text--grey nsg-font-family--base exp--browser-check--message\">"
    + ((stack1 = (helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.messageText",{"name":"getLocal","hash":{},"data":data})) != null ? stack1 : "")
    + "</div>\r\n        <div class=\"exp--browser-check--cta-container\">\r\n            <button class=\"nsg-button nsg-grad--nike-orange exp--browser-check--button\" data-query=\""
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.CTA.link.ie",{"name":"getLocal","hash":{},"data":data}))
    + "\">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.CTA.label",{"name":"getLocal","hash":{},"data":data}))
    + "</button>\r\n            <div class=\"exp--browser-check--link-container\">\r\n                <a href=\""
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.help.link",{"name":"getLocal","hash":{},"data":data}))
    + "\"\r\n                   class=\"nsg-text--grey nsg-font-family--base exp--browser-check--link\">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"browserDeprecator.help.label",{"name":"getLocal","hash":{},"data":data}))
    + "</a>\r\n            </div>\r\n        </div>\r\n    </div>\r\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return container.escapeExpression((helpers.requireDependency || (depth0 && depth0.requireDependency) || helpers.helperMissing).call(alias1,"nike.exp.global.TemplateHelpers",{"name":"requireDependency","hash":{},"data":data}))
    + "\r\n\r\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isCompatMode : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
    + "\r\n";
},"useData":true}); 
   })();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templates.BrowserCheck. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.base.BrowserCheck');

nike.requireDependency('HandlebarsRuntime');
nike.requireDependency('Class');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.exp.global.templates.BrowserCheck');
nike.requireDependency('nike.exp.global.TemplateHelpers');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.Event');

/**
 * An object to test if the browser is deprecated or using compatibility mode
 * @type {*}
 */
nike.exp.global.base.BrowserCheck = Class.extend({
  /**
   * Holds the cookie object
   */
  browserCheckCookie: undefined,

  /**
   * The String name of the cookie
   */
  BROWSER_CHECK_COOKIE: 'BrowserCheck',


  init: function () {
    this.getBrowserCheckCookie();
  },

  /**
   * Retrieves the cookie from the DOM and stores it in this.getBrowserCheckCookie
   */
  getBrowserCheckCookie: function () {
    this.browserCheckCookie = $.CookieUtil(this.BROWSER_CHECK_COOKIE);
  },

  /**
   * Creates or modifies the browserCheckCookie in the DOM.  The cookie is a session cookie.
   */
  setBrowserCheckCookie: function () {
    $.CookieUtil(this.BROWSER_CHECK_COOKIE, 'userAcknowledged');
    this.getBrowserCheckCookie();
  },

  /**
   * Notify the user if they are using a deprecated or unsupported browser mode and set a session cookie,
   *      so it won't repeatedly show the notify modal
   *      'Trident/7' -> rv:11 = MSIE11
   *        COMPAT MODE: contains Trident/7 and NOT rv:11
   *      'Trident/6' -> MSIE 10
   *        COMPAT MODE: contains Trident/6 and NOT MSIE 10
   *      'Trident/5' -> MSIE 9
   *        COMPAT MODE: contains Trident/5 and NOT MSIE 9
   *      'Trident/4' -> MSIE 8
   *        DEPRECATED: contains Trident/4 OR contains MSIE 8, with no Trident
   */
  checkForDeprecatedBrowser: function () {
    if (!this.browserCheckCookie) {
      var userAgentString = navigator.userAgent;

      if ((userAgentString.indexOf('Trident/4') != -1) || (userAgentString.indexOf('MSIE 8') != -1 && userAgentString.indexOf('Trident') == -1)) {
        this.notifyUpgradeBrowser();
        this.setBrowserCheckCookie();
      }
      if (userAgentString.indexOf('Safari') != -1) {
        this.handleNoLocalStorage();
      } else if ((userAgentString.indexOf('Trident/7') != -1 && userAgentString.indexOf('rv:11') == -1) ||
                 (userAgentString.indexOf('Trident/6') != -1 && userAgentString.indexOf('MSIE 10') == -1) ||
                 (userAgentString.indexOf('Trident/5') != -1 && userAgentString.indexOf('MSIE 9') == -1)) {
        this.notifyCompatiblityMode();
        this.setBrowserCheckCookie();
      }
    }
  },

  /**
   * Notifies the user that they are using IE compatibility mode
   */
  notifyCompatiblityMode: function () {
    var modelContent = Handlebars.templates.BrowserCheck({isCompatMode: true});
    var modalObject = new nike.exp.global.Modal({
      $content: $(modelContent),
      blockerClickCloses: false,
      autoDestroy: true
    });

    modalObject.open();
  },

  /**
   * Notifies the user that they are using a deprecated browser
   */
  notifyUpgradeBrowser: function () {
    var modalContent = Handlebars.templates.BrowserCheck({isCompatMode: false});
    var modalObject = new nike.exp.global.Modal({
      $content: $(modalContent),
      blockerClickCloses: false,
      autoDestroy: true,
      onClose: function () {nike.dispatchEvent(nike.Event.BROWSER_UPGRADE_EXIT);}
    });

    this.handleButtonClick();
    modalObject.open();
    nike.listen(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, function () {
      nike.dispatchEvent(nike.Event.BROWSER_UPGRADE_MODAL_DISPLAY);
    });
  },

  /**
   * If the user's browser does not support LocalStorage, swallow the error
   */
  handleNoLocalStorage: function () {
    if (typeof localStorage === 'object') {
      try {
        localStorage.setItem('localStorage', 1);
        localStorage.removeItem('localStorage');
      } catch (e) {
        Storage.prototype._setItem = Storage.prototype.setItem;
        Storage.prototype.setItem = function() {};
      }
    }
  },

  /**
   * Redirect to external download page
   */
  handleButtonClick: function () {
    $('.exp--browser-check--button').on('click', function () {
      nike.dispatchEvent(nike.Event.BROWSER_UPGRADE_NOW_CLICK);
      window.open($(this).data('query'));
    });

    $('.exp--browser-check--link').on('click', function () {
      nike.dispatchEvent(nike.Event.BROWSER_UPGRADE_HELP_CLICK);
    });
  }

});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.base.BrowserCheck. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.BrowserCheckNotifier');

nike.requireDependency('nike.exp.global.base.BrowserCheck');

/**
 * Runs a check for deprecated browsers and unsupported browser modes.
 *      Alerts the user if they are using an unsupported browser or mode.
 */
nike.exp.global.BrowserCheckNotifier = function(){
  $(document).ready(function(){
    var notifier = new nike.exp.global.base.BrowserCheck();
    notifier.checkForDeprecatedBrowser();
  });
};

nike.exp.global.BrowserCheckNotifier();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.BrowserCheckNotifier. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * A plugin to invoke nsgDropDown as selectBox()
 * @namespace nike.exp.global.SelectBox
 */
nike.namespace('nike.exp.global.SelectBox');
nike.requireDependency('jQuery');

nike.exp.global.SelectBox = {};

(function ($) {


  /**
   * Initializes the NSG DropDown plugin, and adds the old QA attributes that were originally required.
   * @param {Object|String} [confOrMethod] - If an Object is passed it will act as the configuration for the dropdown. If a String, and the String matches a method belonging to the dropdown plugin, it will be executed.
   * @param {*} [methodData] - If a method is passed in the first arg, you can pass the data needed for the method here.
   * @param {jQuery} [$currEl] - The current select element.
   */
  function executePlugin(confOrMethod, methodData, $currEl){

    $currEl.nsgDropDown(confOrMethod, methodData);
    if( $currEl.attr('data-qa') ){
      var dataQaPrefix = $currEl.attr('data-qa');
      var $par = $currEl.parent();
      $par.find('a').attr('data-qa', dataQaPrefix + ".control");
      $par.find('ul').attr('data-qa', dataQaPrefix + ".values");
    }
  }

  /**
   * This is a polyfill until we have the time to convert all areas of the site that are still utilizing the original selectBox plugin.
   * @param {Object|String} [confOrMethod] - If an Object is passed it will act as the configuration for the dropdown. If a String, and the String matches a method belonging to the dropdown plugin, it will be executed.
   * @param {*} [methodData] - If a method is passed in the first arg, you can pass the data needed for the method here.
   * @returns {Object}
   */
  $.fn.selectBox = function(confOrMethod, methodData){
    this.each(function(){
      var $currEl = $(this);
      if(nsg && nsg.isReady){
        executePlugin(confOrMethod, methodData, $currEl);
      } else {
        $(document).one('nsgReady', function(e){
          executePlugin(confOrMethod, methodData, $currEl);
        });
      }
    });

    return this;
  };

})(jQuery);

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.SelectBox. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}




try{
var nike = nike || {};
/**
 * User: BPYL
 * @namespace nike.exp.global.validation.ValidationEvent
 */
nike.namespace("nike.exp.global.validation.ValidationEvent");

/**
 * @extends Class
 */
nike.exp.global.validation.ValidationEvent = Class.extend(
/** @lends nike.exp.global.validation.ValidationEvent.prototype */
{

  /**
   * @type {jQuery}
   */
  element : undefined,

  /**
   * @type {nike.exp.global.validation.STATE}
   */
  state : undefined,

  /**
   * @type {String}
   */
  message : undefined,

  /**
   * @constructs
   *
   * @param {jQuery} element
   * @param {nike.exp.global.validation.STATE} state
   * @param {String} message
   */
  init:function (element, state, message) {
    this.element = element;
    this.state = state;
    this.message = message;
  },

  /**
   * @public
   * @return {Boolean} TRUE if the state is in error, FALSE otherwise
   */
  isError : function () {
    return !(this.state === nike.exp.global.validation.STATE.NOT_VALIDATED ||
             this.state === nike.exp.global.validation.STATE.VALID);
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.ValidationEvent. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * User: bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.Field
 */
nike.namespace("nike.exp.global.validation.field.Field");

/**
 * @extends Class
 */
nike.exp.global.validation.field.Field = Class.extend(
/** @lends nike.exp.global.validation.field.Field.prototype */
{
  /**
   * Map of all invalid character codes.
   * These are all characters codes rather than actual unicode to avoid relying on UTF-8 encoding working reliably
   * in all of our supported devices and handling maps of unicode characters. I've used the NCR decimal code just
   * in case something might puke from a weird unicode character in a javascript field.
   *
   * ©«¬®»¼½¾¿ʬπφ–—‘’“”…‹›€℃℉№℗℡™ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ↔↵⇄⇅⇆⇇⇈⇉⇊⇐⇑⇒⇓⇔⇤⇥⇦⇧⇨⇩⇪⇱⇲⇳⇵∅∆∇∈∉∋∑√∝∞∟∠∩∪∫∮∵≒≠≡≤≥⊗⊘⊙⊚⊥⊿⋘⋙⏏␈␍␚␛␡␣①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⓪⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴⓵⓶⓷⓸⓹⓺⓻⓼⓽⓾⓿▢▣▤▥▰▱▲△▴▵▶▷▸▹▻▾▿◅◈◉◍◎◧◨◩◪◫☀☁☂☃★☆☉☎☏☑☒☚☛☜☝☞☟☠☢☣☤☥☪☭☮☯☹☺☻☼☽☾♀♂♔♕♖♘♚♛♞♟♠♡♢♣♤♥♦♧♨♩♪♫♬♭♮♯✁✂✃✄✆✇✈✉✌✍✎✏✐✑✒✓✔✖✘✝✡✦✧✩✳✵✺✽✿❀❁❐❑❒❖❤❥❦❧❶❷❸❹❺❻❼❽❾❿➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➷➸➹⤴⤵⤶⤷⤹〄〝〟〠・・㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩㈪㈫㈬㈭㈮㈯㈰㈱㈲㈳㈴㈵㈶㈷㈸㈹㈺㈻㈼㈽㈾㈿㉀㉁㉂㉃㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㊊㊋㊌㊍㊎㊏㊐㊑㊒㊓㊔㊕㊖㊗㊘㊙㊚㊛㊜㊝㊞㊟㊠㊡㊢㊣㊤㊥㊦㊧㊨㊩㊪㊫㊬㊭㊮㊯㊰㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㋐㋑㋒㋓㋔㋕㋖㋗㋘㋙㋚㋛㋜㋝㋞㋟㋠㋡㋢㋣㋤㋥㋦㋧㋨㋩㋪㋫㋬㋭㋮㋯㋰㋱㋲㋳㋴㋵㋶㋷㋸㋹㋺㋻㋼㋽㋾㌃㌍㌔㌘㌢㌣㌦㌧㌫㌶㌻㍉㍊㍍㍑㍗㍻㍼㍽㍾㎎㎏㎜㎝㎞㎡㏄㏍丨仡仼伀伃伹佖侊侒侔侚俉俍俿倞倢偀偂偆偰傔僘僴兊兤冝冾凬刕劜劦劯勀勛匀匇匤卲厓厲叝咊咜咩哿喆坙坥垬埇埈增墲夋奓奛奝奣妤妺孖寀寘寬尞岦岺峵崧嵂嵓嵭嶸嶹巐弡弴彅彧德忞恝悅悊惕惞惲愑愠愰愷憘戓抦揵摠撝擎敎昀昉昕昞昤昮昱昻晗晙晥晳暙暠暲暿曺曻朎杦枻柀栁桄桒棈棏楨榘槢樰橆橫橳橾櫢櫤毖氿汜汯沆泚洄浯涇涖涬淏淲淸淼渧渹渼湜溿澈澵濵瀅瀇瀨炅炫炻焄焏煆煇煜燁燾犱犾猤獷玽珉珒珖珣珵琇琦琩琪琮瑢璉璟甁甯畯皂皛皜皞皦睆砡硎硤硺礰禔禛竑竧竫箞絈絜綠綷緖繒纊罇羡茁荢荿菇菶葈蒴蓜蕓蕙蕫薰蠇裵褜訒訷詹誧誾諟諶譓譿賰賴贒赶軏遧郞鄕鄧釗釚釞釤釥釭釮鈆鈊鈐鈹鈺鈼鉀鉎鉑鉙鉧鉷鉸銈銧鋐鋓鋕鋗鋙鋠鋧鋹鋻鋿錂錝錞錡錥鍈鍗鍰鎤鏆鏞鏸鐱鑅鑈閒隝隯霳霻靃靍靏靑靕顗顥餧馞驎髙髜魲魵鮏鮱鮻鰀鵫鵰鸙黑朗隆﨎﨏塚﨑晴﨓﨔凞猪益礼神祥福靖精羽﨟蘒﨡諸﨣﨤逸都﨧﨨﨩飯飼館鶴＂＇＊￤
   *
   * @type Object.<string,number>
   * @static
   * @public
   * @constant
   */
  RESTRICTED_CHARACTER_MAP : {c169:1,c171:1,c172:1,c174:1,c187:1,c188:1,c189:1,c190:1,c191:1,c684:1,c960:1,c966:1,c8211:1,c8212:1,c8216:1,c8217:1,c8220:1,c8221:1,c8230:1,c8249:1,c8250:1,c8364:1,c8451:1,c8457:1,c8470:1,c8471:1,c8481:1,c8482:1,c8544:1,c8545:1,c8546:1,c8547:1,c8548:1,c8549:1,c8550:1,c8551:1,c8552:1,c8553:1,c8560:1,c8561:1,c8562:1,c8563:1,c8564:1,c8565:1,c8566:1,c8567:1,c8568:1,c8569:1,c8596:1,c8629:1,c8644:1,c8645:1,c8646:1,c8647:1,c8648:1,c8649:1,c8650:1,c8656:1,c8657:1,c8658:1,c8659:1,c8660:1,c8676:1,c8677:1,c8678:1,c8679:1,c8680:1,c8681:1,c8682:1,c8689:1,c8690:1,c8691:1,c8693:1,c8709:1,c8710:1,c8711:1,c8712:1,c8713:1,c8715:1,c8721:1,c8730:1,c8733:1,c8734:1,c8735:1,c8736:1,c8745:1,c8746:1,c8747:1,c8750:1,c8757:1,c8786:1,c8800:1,c8801:1,c8804:1,c8805:1,c8855:1,c8856:1,c8857:1,c8858:1,c8869:1,c8895:1,c8920:1,c8921:1,c9167:1,c9224:1,c9229:1,c9242:1,c9243:1,c9249:1,c9251:1,c9312:1,c9313:1,c9314:1,c9315:1,c9316:1,c9317:1,c9318:1,c9319:1,c9320:1,c9321:1,c9322:1,c9323:1,c9324:1,c9325:1,c9326:1,c9327:1,c9328:1,c9329:1,c9330:1,c9331:1,c9332:1,c9333:1,c9334:1,c9335:1,c9336:1,c9337:1,c9338:1,c9339:1,c9340:1,c9341:1,c9342:1,c9343:1,c9344:1,c9345:1,c9346:1,c9347:1,c9348:1,c9349:1,c9350:1,c9351:1,c9352:1,c9353:1,c9354:1,c9355:1,c9356:1,c9357:1,c9358:1,c9359:1,c9360:1,c9361:1,c9362:1,c9363:1,c9364:1,c9365:1,c9366:1,c9367:1,c9368:1,c9369:1,c9370:1,c9371:1,c9372:1,c9373:1,c9374:1,c9375:1,c9376:1,c9377:1,c9378:1,c9379:1,c9380:1,c9381:1,c9382:1,c9383:1,c9384:1,c9385:1,c9386:1,c9387:1,c9388:1,c9389:1,c9390:1,c9391:1,c9392:1,c9393:1,c9394:1,c9395:1,c9396:1,c9397:1,c9398:1,c9399:1,c9400:1,c9401:1,c9402:1,c9403:1,c9404:1,c9405:1,c9406:1,c9407:1,c9408:1,c9409:1,c9410:1,c9411:1,c9412:1,c9413:1,c9414:1,c9415:1,c9416:1,c9417:1,c9418:1,c9419:1,c9420:1,c9421:1,c9422:1,c9423:1,c9424:1,c9425:1,c9426:1,c9427:1,c9428:1,c9429:1,c9430:1,c9431:1,c9432:1,c9433:1,c9434:1,c9435:1,c9436:1,c9437:1,c9438:1,c9439:1,c9440:1,c9441:1,c9442:1,c9443:1,c9444:1,c9445:1,c9446:1,c9447:1,c9448:1,c9449:1,c9450:1,c9451:1,c9452:1,c9453:1,c9454:1,c9455:1,c9456:1,c9457:1,c9458:1,c9459:1,c9460:1,c9461:1,c9462:1,c9463:1,c9464:1,c9465:1,c9466:1,c9467:1,c9468:1,c9469:1,c9470:1,c9471:1,c9634:1,c9635:1,c9636:1,c9637:1,c9648:1,c9649:1,c9650:1,c9651:1,c9652:1,c9653:1,c9654:1,c9655:1,c9656:1,c9657:1,c9659:1,c9662:1,c9663:1,c9669:1,c9672:1,c9673:1,c9677:1,c9678:1,c9703:1,c9704:1,c9705:1,c9706:1,c9707:1,c9728:1,c9729:1,c9730:1,c9731:1,c9733:1,c9734:1,c9737:1,c9742:1,c9743:1,c9745:1,c9746:1,c9754:1,c9755:1,c9756:1,c9757:1,c9758:1,c9759:1,c9760:1,c9762:1,c9763:1,c9764:1,c9765:1,c9770:1,c9773:1,c9774:1,c9775:1,c9785:1,c9786:1,c9787:1,c9788:1,c9789:1,c9790:1,c9792:1,c9794:1,c9812:1,c9813:1,c9814:1,c9816:1,c9818:1,c9819:1,c9822:1,c9823:1,c9824:1,c9825:1,c9826:1,c9827:1,c9828:1,c9829:1,c9830:1,c9831:1,c9832:1,c9833:1,c9834:1,c9835:1,c9836:1,c9837:1,c9838:1,c9839:1,c9985:1,c9986:1,c9987:1,c9988:1,c9990:1,c9991:1,c9992:1,c9993:1,c9996:1,c9997:1,c9998:1,c9999:1,c10000:1,c10001:1,c10002:1,c10003:1,c10004:1,c10006:1,c10008:1,c10013:1,c10017:1,c10022:1,c10023:1,c10025:1,c10035:1,c10037:1,c10042:1,c10045:1,c10047:1,c10048:1,c10049:1,c10064:1,c10065:1,c10066:1,c10070:1,c10084:1,c10085:1,c10086:1,c10087:1,c10102:1,c10103:1,c10104:1,c10105:1,c10106:1,c10107:1,c10108:1,c10109:1,c10110:1,c10111:1,c10112:1,c10113:1,c10114:1,c10115:1,c10116:1,c10117:1,c10118:1,c10119:1,c10120:1,c10121:1,c10122:1,c10123:1,c10124:1,c10125:1,c10126:1,c10127:1,c10128:1,c10129:1,c10130:1,c10131:1,c10136:1,c10137:1,c10138:1,c10139:1,c10140:1,c10141:1,c10142:1,c10143:1,c10144:1,c10145:1,c10146:1,c10147:1,c10148:1,c10149:1,c10150:1,c10167:1,c10168:1,c10169:1,c10548:1,c10549:1,c10550:1,c10551:1,c10553:1,c12292:1,c12317:1,c12319:1,c12320:1,c12539:1,c12539:1,c12832:1,c12833:1,c12834:1,c12835:1,c12836:1,c12837:1,c12838:1,c12839:1,c12840:1,c12841:1,c12842:1,c12843:1,c12844:1,c12845:1,c12846:1,c12847:1,c12848:1,c12849:1,c12850:1,c12851:1,c12852:1,c12853:1,c12854:1,c12855:1,c12856:1,c12857:1,c12858:1,c12859:1,c12860:1,c12861:1,c12862:1,c12863:1,c12864:1,c12865:1,c12866:1,c12867:1,c12881:1,c12882:1,c12883:1,c12884:1,c12885:1,c12886:1,c12887:1,c12888:1,c12889:1,c12890:1,c12891:1,c12892:1,c12893:1,c12894:1,c12895:1,c12928:1,c12929:1,c12930:1,c12931:1,c12932:1,c12933:1,c12934:1,c12935:1,c12936:1,c12937:1,c12938:1,c12939:1,c12940:1,c12941:1,c12942:1,c12943:1,c12944:1,c12945:1,c12946:1,c12947:1,c12948:1,c12949:1,c12950:1,c12951:1,c12952:1,c12953:1,c12954:1,c12955:1,c12956:1,c12957:1,c12958:1,c12959:1,c12960:1,c12961:1,c12962:1,c12963:1,c12964:1,c12965:1,c12966:1,c12967:1,c12968:1,c12969:1,c12970:1,c12971:1,c12972:1,c12973:1,c12974:1,c12975:1,c12976:1,c12977:1,c12978:1,c12979:1,c12980:1,c12981:1,c12982:1,c12983:1,c12984:1,c12985:1,c12986:1,c12987:1,c12988:1,c12989:1,c12990:1,c12991:1,c12992:1,c12993:1,c12994:1,c12995:1,c12996:1,c12997:1,c12998:1,c12999:1,c13000:1,c13001:1,c13002:1,c13003:1,c13008:1,c13009:1,c13010:1,c13011:1,c13012:1,c13013:1,c13014:1,c13015:1,c13016:1,c13017:1,c13018:1,c13019:1,c13020:1,c13021:1,c13022:1,c13023:1,c13024:1,c13025:1,c13026:1,c13027:1,c13028:1,c13029:1,c13030:1,c13031:1,c13032:1,c13033:1,c13034:1,c13035:1,c13036:1,c13037:1,c13038:1,c13039:1,c13040:1,c13041:1,c13042:1,c13043:1,c13044:1,c13045:1,c13046:1,c13047:1,c13048:1,c13049:1,c13050:1,c13051:1,c13052:1,c13053:1,c13054:1,c13059:1,c13069:1,c13076:1,c13080:1,c13090:1,c13091:1,c13094:1,c13095:1,c13099:1,c13110:1,c13115:1,c13129:1,c13130:1,c13133:1,c13137:1,c13143:1,c13179:1,c13180:1,c13181:1,c13182:1,c13198:1,c13199:1,c13212:1,c13213:1,c13214:1,c13217:1,c13252:1,c13261:1,c20008:1,c20193:1,c20220:1,c20224:1,c20227:1,c20281:1,c20310:1,c20362:1,c20370:1,c20372:1,c20378:1,c20425:1,c20429:1,c20479:1,c20510:1,c20514:1,c20544:1,c20546:1,c20550:1,c20592:1,c20628:1,c20696:1,c20724:1,c20810:1,c20836:1,c20893:1,c20926:1,c20972:1,c21013:1,c21148:1,c21158:1,c21167:1,c21184:1,c21211:1,c21248:1,c21255:1,c21284:1,c21362:1,c21395:1,c21426:1,c21469:1,c21642:1,c21660:1,c21673:1,c21759:1,c21894:1,c22361:1,c22373:1,c22444:1,c22471:1,c22472:1,c22686:1,c22706:1,c22795:1,c22867:1,c22875:1,c22877:1,c22883:1,c22948:1,c22970:1,c23382:1,c23488:1,c23512:1,c23532:1,c23582:1,c23718:1,c23738:1,c23797:1,c23847:1,c23874:1,c23891:1,c23917:1,c23992:1,c23993:1,c24016:1,c24353:1,c24372:1,c24389:1,c24423:1,c24503:1,c24542:1,c24669:1,c24709:1,c24714:1,c24789:1,c24798:1,c24818:1,c24849:1,c24864:1,c24880:1,c24887:1,c24984:1,c25107:1,c25254:1,c25589:1,c25696:1,c25757:1,c25806:1,c25934:1,c26112:1,c26121:1,c26133:1,c26142:1,c26148:1,c26158:1,c26161:1,c26171:1,c26199:1,c26201:1,c26213:1,c26227:1,c26265:1,c26272:1,c26290:1,c26303:1,c26362:1,c26363:1,c26382:1,c26470:1,c26555:1,c26560:1,c26625:1,c26692:1,c26706:1,c26824:1,c26831:1,c26984:1,c27032:1,c27106:1,c27184:1,c27206:1,c27243:1,c27251:1,c27262:1,c27362:1,c27364:1,c27606:1,c27711:1,c27740:1,c27759:1,c27782:1,c27866:1,c27908:1,c28015:1,c28039:1,c28054:1,c28076:1,c28111:1,c28146:1,c28152:1,c28156:1,c28199:1,c28217:1,c28220:1,c28252:1,c28351:1,c28552:1,c28597:1,c28661:1,c28677:1,c28679:1,c28712:1,c28805:1,c28843:1,c28859:1,c28932:1,c28943:1,c28998:1,c28999:1,c29020:1,c29121:1,c29182:1,c29361:1,c29374:1,c29476:1,c29559:1,c29629:1,c29641:1,c29650:1,c29654:1,c29667:1,c29685:1,c29703:1,c29734:1,c29737:1,c29738:1,c29742:1,c29794:1,c29833:1,c29855:1,c29953:1,c29999:1,c30063:1,c30338:1,c30363:1,c30364:1,c30366:1,c30374:1,c30534:1,c30753:1,c30798:1,c30820:1,c30842:1,c31024:1,c31124:1,c31131:1,c31441:1,c31463:1,c31467:1,c31646:1,c32072:1,c32092:1,c32160:1,c32183:1,c32214:1,c32338:1,c32394:1,c32583:1,c32673:1,c33537:1,c33634:1,c33663:1,c33735:1,c33782:1,c33864:1,c33972:1,c34012:1,c34131:1,c34137:1,c34155:1,c34224:1,c34823:1,c35061:1,c35100:1,c35346:1,c35383:1,c35449:1,c35495:1,c35518:1,c35551:1,c35574:1,c35667:1,c35711:1,c36080:1,c36084:1,c36114:1,c36214:1,c36559:1,c36967:1,c37086:1,c37141:1,c37159:1,c37335:1,c37338:1,c37342:1,c37348:1,c37349:1,c37357:1,c37358:1,c37382:1,c37386:1,c37392:1,c37433:1,c37434:1,c37436:1,c37440:1,c37454:1,c37457:1,c37465:1,c37479:1,c37495:1,c37496:1,c37512:1,c37543:1,c37584:1,c37587:1,c37589:1,c37591:1,c37593:1,c37600:1,c37607:1,c37625:1,c37627:1,c37631:1,c37634:1,c37661:1,c37662:1,c37665:1,c37669:1,c37704:1,c37719:1,c37744:1,c37796:1,c37830:1,c37854:1,c37880:1,c37937:1,c37957:1,c37960:1,c38290:1,c38557:1,c38575:1,c38707:1,c38715:1,c38723:1,c38733:1,c38735:1,c38737:1,c38741:1,c38999:1,c39013:1,c39207:1,c39326:1,c39502:1,c39641:1,c39644:1,c39794:1,c39797:1,c39823:1,c39857:1,c39867:1,c39936:1,c40299:1,c40304:1,c40473:1,c40657:1,c63785:1,c63964:1,c64014:1,c64015:1,c64016:1,c64017:1,c64018:1,c64019:1,c64020:1,c64021:1,c64022:1,c64023:1,c64024:1,c64025:1,c64026:1,c64027:1,c64028:1,c64029:1,c64030:1,c64031:1,c64032:1,c64033:1,c64034:1,c64035:1,c64036:1,c64037:1,c64038:1,c64039:1,c64040:1,c64041:1,c64042:1,c64043:1,c64044:1,c64045:1,c65282:1,c65287:1,c65290:1,c65508:1},

  /**
   * The form that this class is being associated with
   *
   * @type {jQuery}
   * @protected
   */
  formEl : null,

  /**
   * If this is set to TRUE, then all fields will be
   * considered required and will be invalid if there is no value
   *
   * @type {Boolean}
   * @default false
   * @protected
   */
  forceRequired : false,

  /**
   * @constructs
   *
   * @param {Object} options The field options for this class to use
   * @param {jQuery} options.formEl The form element that this class will be associated with
   * @param {Boolean} [options.forceRequired=false] IF TRUE, will force all fields to be required,
   *                                                regardless of the "required" attribute on the element
   */
  init : function (options) {
    this.formEl = options.formEl;
    this.forceRequired = options.forceRequired || false;
  },

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   */
  validate : function (element) {
    var value = element.val();
    var required = element.attr('required') || this.forceRequired;
    var state = nike.exp.global.validation.STATE.VALID;
    var pattern = element.attr('pattern');
    var regex = pattern ? new RegExp(pattern, element.data('patternFlag')) : null;

    // First check if a value is required and not there
    if(!value) {
      if(!required) {
        state = nike.exp.global.validation.STATE.NOT_VALIDATED;
      } else if (required) {
        state = nike.exp.global.validation.STATE.ERROR_NOT_COMPLETE;
      }
    // Now check to see if there is a value and it matches the pattern, if one exists
    } else if (value) {
      if(!this.validateCharacters(element)) {
        state = nike.exp.global.validation.STATE.ERROR_RESTRICTED_CHARACTERS;
      } else if (regex && regex.test(value) === false) {
        state = nike.exp.global.validation.STATE.ERROR_PATTERN;
      } else if (required && !value.trim()){
        state = nike.exp.global.validation.STATE.ERROR_NOT_COMPLETE;
      }
    }

    return state;
  },

  /**
   * Checks each character in an input for invalid character codes.
   *
   * @param {jQuery} element The element to test for restricted characters in the value
   * @returns {boolean} FALSE if restricted characters found in the input box, TRUE otherwise
   * @private
   */
  validateCharacters : function (element) {
    var valid = true;
    var value = element.val() || "";
    var charCode;

    for(var index = 0; index < value.length; index++ ) {
      charCode = value.charCodeAt(index);
      if((charCode < 32 && charCode !== 10 && charCode !== 13) || (nike.COUNTRY == 'JP' && this.RESTRICTED_CHARACTER_MAP["c" + charCode])) {
        valid = false;
        break;
      }
    }

    return valid;
  }

});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.Field. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * User: BPYL
 * @namespace nike.exp.global.validation.field.FieldFactory
 */
nike.namespace("nike.exp.global.validation.field.FieldFactory");

nike.requireDependency("nike.exp.global.validation.field.Field");

nike.exp.global.validation.field.FieldFactory = {

  /**
   *
   * @param {RegExp} regexp
   * @param {nike.exp.global.validation.STATE} [errorState=nike.exp.global.validation.STATE.ERROR_PATTERN]
   * @return {nike.exp.global.validation.field.Field}
   */
  createRegExpFieldClass : function (regexp, errorState) {
    return nike.exp.global.validation.field.Field.extend({

      /**
       * Tests for valid characters in a field using a regular expression
       *
       * Uses negative look ahead to make sure all characters are not in the test string
       *
       * @type RegExp
       * @constant
       * @private
       */
      REGEX : regexp,

      /**
       *
       * @param {jQuery} element
       * @param {Boolean} [incompleteAllowed=false]
       *
       * @return {nike.exp.global.validation.STATE}
       * @override
       */
      validate : function (element, incompleteAllowed) {
        var state = this._super(element, incompleteAllowed);
        var value = element.val();

        // If the basic validation passed, let's add the additional constraints
        if(value &&
           state === nike.exp.global.validation.STATE.VALID &&
           this.REGEX.test(value) === false) {

          // No spaces are allowed
          state = errorState || nike.exp.global.validation.STATE.ERROR_PATTERN;
        }

        return state;
      }
    });
  },

  /**
   *
   * @param {String} confirmValidator
   * @return {nike.exp.global.validation.field.Field}
   */
  createConfirmFieldClass : function(confirmValidator) {
    return nike.exp.global.validation.field.Field.extend({

      /**
       *
       * @param {jQuery} element
       * @param {Boolean} [incompleteAllowed=false]
       *
       * @return {nike.exp.global.validation.STATE}
       * @override
       */
      validate : function (element, incompleteAllowed) {
        var state = this._super(element, incompleteAllowed);
        var value = element.val();
        var confirmValue = this.formEl.find('[data-validator="' + confirmValidator + '"]').val();

        // If the basic validation passed, let's add the additional constraints
        if(value &&
           (state === nike.exp.global.validation.STATE.VALID ||
            state === nike.exp.global.validation.STATE.ERROR_PATTERN) && // ERROR_NO_MATCH should trump ERROR_PATTERN
           confirmValue !== value) {
          state = nike.exp.global.validation.STATE.ERROR_NO_MATCH;
        }

        return state;
      }
    });
  }
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.FieldFactory. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.PasswordField
 */
nike.namespace('nike.exp.global.validation.field.PasswordField');

nike.requireDependency('nike.exp.global.validation.field.Field');

//noinspection MagicNumberJS
/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.PasswordField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.PasswordField.prototype */
{
  /**
   * @type number
   * @private
   * @constant
   */
  MINIMUM_PASSWORD_SIZE : 8,

  /**
   * @type number
   * @private
   * @constant
   */
  MAXIMUM_PASSWORD_SIZE : 36,

  /**
   * @type nike.exp.global.validation.STATE
   */
  PASSWORD_STATE : {
    /** @type Boolean */
    allRegMet : false,
    /** @type Boolean */
    hasNum : false,
    /** @type Boolean */
    isNotScreenName : false,
    /** @type Boolean */
    hasReqCharLength : false,
    /** @type Boolean */
    hasMixedChars : false
  },

  REG_EXP_MAP : {
    hasNum: /([0-9])/,
    hasUppercase: /([A-Z])/,
    hasLowercase: /[a-z]/
  },

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @param {Boolean} [incompleteAllowed=false] If TRUE, then an incomplete field is allowed during this validation
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @override
   */
  validate : function (element, incompleteAllowed) {
    var state = this._super(element, incompleteAllowed);
    var password = element.val();
    var screenName = this.formEl.find('[data-validator=screenName]').val();
    var complexState = this.validatePassword(password, screenName);

    // If the password should be validated at all, then validate it.
    // Ignore errors that aren't restricted characters since the password validation should cover them.
    if(state !== nike.exp.global.validation.STATE.ERROR_RESTRICTED_CHARACTERS &&
       state !== nike.exp.global.validation.STATE.NOT_VALIDATED) {
      state = complexState.allRegMet ? nike.exp.global.validation.STATE.VALID : complexState;
    }

    return state;
  },

  /**
   * Assembles the complex state for the password field.  This will allow
   *
   * @param password
   * @param screenName
   * @private
   * @returns nike.exp.global.validation.STATE
   */
  validatePassword : function(password, screenName) {
    var minChar = false;
    var maxChar = false;
    var hasNum = false;
    var hasUppercase = false;
    var hasLowercase = false;
    var isNotScreenName = true;
    var allReqMet = false;
    var hasReqCharLength = false;
    var hasMixedChars = false;
    var state = $.extend({}, this.PASSWORD_STATE);

    // check if password length is too short
    if (password.length >= this.MINIMUM_PASSWORD_SIZE) {
      minChar = true;
    }

    // check if password length is too long
    if (password.length <= this.MAXIMUM_PASSWORD_SIZE) {
      maxChar = true;
    }

    // check if screen name is not blank and if screen name matches password
    if (screenName && (password == screenName)) {
      isNotScreenName = false;
    }  // checks if SN equals PW

    // check if password contains an uppercase character
    if (password.match(this.REG_EXP_MAP.hasUppercase)) {
      hasUppercase = true;
    }

    // check if password contains a lowercase character
    if (password.match(this.REG_EXP_MAP.hasLowercase)) {
      hasLowercase = true;
    }

    // check if password has numbers
    if (password.match(this.REG_EXP_MAP.hasNum)) {
      hasNum = true;
    }

    // rules
    //noinspection OverlyComplexBooleanExpressionJS
    if (minChar && maxChar && hasUppercase && hasLowercase && hasNum && isNotScreenName) {
      allReqMet = true;
    }
    if (minChar && maxChar) {
      hasReqCharLength = true;
    }
    if (hasUppercase && hasLowercase) {
      hasMixedChars = true;
    }

    state.allRegMet = allReqMet;
    state.hasNum = hasNum;
    state.isNotScreenName = isNotScreenName;
    state.hasReqCharLength = hasReqCharLength;
    state.hasMixedChars = hasMixedChars;

    return state;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.PasswordField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.ToggleField
 */
nike.namespace('nike.exp.global.validation.field.ToggleField');

nike.requireDependency('nike.exp.global.validation.field.Field');

/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.ToggleField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.ToggleField.prototype */
{

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @param {Boolean} [incompleteAllowed=false] If TRUE, then an incomplete field is allowed during this validation
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @override
   */
  validate : function (element, incompleteAllowed) {
    var name = element.attr('name');
    var hasChecked = this.formEl.find('[name=' + name + ']:checked').length > 0;
    var required = element.attr('required') || this.forceRequired;
    var state = nike.exp.global.validation.STATE.VALID;

    // Checkbox test
    if(!hasChecked && required && !incompleteAllowed) {
      state = nike.exp.global.validation.STATE.ERROR_NOT_COMPLETE;
    }

    return state;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.ToggleField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.PostalCodeEmeaField
 */
nike.namespace('nike.exp.global.validation.field.PostalCodeEmeaField');

nike.requireDependency('nike.exp.global.validation.field.Field');

/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.PostalCodeEmeaField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.PostalCodeEmeaField.prototype */
{
  countryFieldName : "country",
  /**
   * @type Object<String,RegExp>
   * @private
   */
  REG_EXP_MAP : {
    US : /(^\d{5}$)|(^\d{5}-\d{4}$)/,
    AT : /(a|A)?(\s|-)?\d{4}/i,
    BE : /(b|B)?(\s|-)?\d{4}/i,
    CA : /^([ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1} *\d{1}[A-Z]{1}\d{1}$)/,
    CH : /^\d{4}$/i,
    CZ : /\d{5}/i,
    DE : /(d|D)?(\s|-)?\d{5}/i,
    DK : /(dk|DK)?(\s|-)?\d{3,4}/i,
    FI : /(fin|FIN)?(\s|-)?\d{5}/i,
    FR : /(fr|FR)?(\s|-)?\d{5}/i,
    GB : /(GIR 0AA)|(BFPO|bfpo) (\d{1,4}$)|(((A[BL]|B[ABDHLNRSTX]?|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]?|F[KY]|G[LUY]?|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]?|M[EKL]?|N[EGNPRW]?|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKLMNOPRSTY]?|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)[1-9]?[0-9]|((E|N|NW|SE|SW|W)1|EC[1-4]|WC[12])[A-HJKMNPR-Y]|(SW|W)([2-9]|[1-9][0-9])|EC[1-9][0-9])[ ]{0,1}[0-9][ABD-HJLNP-UW-Z]{2})/,
    GR : /\d{5}/i,
    HU : /\d{4}/i,
    IT : /\d{5}/i,
    LU : /(l)?(\s|-)?\d{4}/i,
    NL : /\d{4} ?[a-zA-Z]{2}/,
    NO : /(no|NO)?(\s|-)?\d{4}/i,
    PL : /\d{5}/i,
    PT : /\d{4}/i,
    SI : /\d{4}/i,
    ES : /\d{5}/i,
    SE : /^(se|SE)?\d{5}/i,
    CN : /^\d{6}$/
  },

  /**
   * @type Object<String,Function>
   * @private
   */
  PRE_PROCESSORS : (function(){
    var removeSpacesAndDashesFn = function(value){
      return value.replace(/(\s|-)?/gi, "");
    };
    return {
      "CZ" : removeSpacesAndDashesFn,
      "PL" : removeSpacesAndDashesFn,
      "PT" : removeSpacesAndDashesFn,
      "SE" : removeSpacesAndDashesFn,
      "GB" : function(value){
        return removeSpacesAndDashesFn(value).toUpperCase();
      }
    };
  }()),

  init : function (fieldOptions) {
    this._super(fieldOptions);

    if (fieldOptions.emeaPostCodeCountryFieldName) {
      this.countryFieldName = fieldOptions.emeaPostCodeCountryFieldName;
    }
  },

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @param {Boolean} [incompleteAllowed=false] If TRUE, then an incomplete field is allowed during this validation
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   */
  validate : function (element, incompleteAllowed) {
    var state = this._super(element, incompleteAllowed);
    var country = this.formEl.find('[name='+this.countryFieldName+']').val() || nike.COUNTRY;
    var regexp = this.REG_EXP_MAP[country];
    var value = element.val();

    // Run any pre processors
    if(this.PRE_PROCESSORS[country] && value) {
      value = this.PRE_PROCESSORS[country](value);
    }

    // Test the currently selected countries regexp against the value
    if(state === nike.exp.global.validation.STATE.VALID  &&
       regexp && regexp.test(value) === false) {
      state = nike.exp.global.validation.STATE.ERROR_PATTERN;
    }

    return state;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.PostalCodeEmeaField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.PostalCodeUsField
 */
nike.namespace('nike.exp.global.validation.field.PostalCodeUsField');

nike.requireDependency('nike.exp.global.validation.field.Field');

/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.PostalCodeUsField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.PostalCodeUsField.prototype */
{

  REG_EXP_MAP : {
    US : /(^\d{5}$)|(^\d{5}-\d{4}$)/,
    CA : /^([ABCEGHJKLMNPRSTVXYabceghjklmnprstvwy]{1}\d{1}[A-Za-z]{1} *\d{1}[A-Za-z]{1}\d{1}$)/
  },

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @param {Boolean} [incompleteAllowed=false] If TRUE, then an incomplete field is allowed during this validation
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   */
  validate : function (element, incompleteAllowed) {
    var state = this._super(element, incompleteAllowed);
    var country = this.formEl.find('[name=country]').val() || nike.COUNTRY;
    var regexp = this.REG_EXP_MAP[country];
    var value = element.val();

    // Test the currently selected countries regexp against the value
    if(state === nike.exp.global.validation.STATE.VALID  &&
      regexp && regexp.test(value) === false) {
      state = nike.exp.global.validation.STATE.ERROR_PATTERN;
    }

    return state;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.PostalCodeUsField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @namespace nike.exp.global.validation.field.PhoneNumberField
**/
nike.namespace('nike.exp.global.validation.field.PhoneNumberField');

nike.requireDependency('nike.exp.global.validation.field.Field');

/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.PhoneNumberField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.PhoneNumberField.prototype */
{
  phoneNumberFieldName : "phoneNumber",
  countryFieldName : "country",


  REG_EXP_MAP : {
    US : /^((\+\(?\d{1,3}\)?(-| |\s|\.)?\(?\d\)?(-| |\.)?\d{1,5})|(\d?\(?\d{1,6}\)?)|(\d{1}?(\.| |-)?\d{1,6})|(\d{1,6})|(\+\(\d{3}\))|(\d{1,3})?)(-| |\.)?(\d{3,4})(-| |\.)?(\d{4})(( )?(ext|extn|x)(:| |_|-)?(\d{1,4}))?$/i,
    CN : /^\d{7,11}$/
  },


  init : function (fieldOptions) {
    this._super(fieldOptions);

    if (fieldOptions.phoneNumberFieldName) {
      this.phoneNumberFieldName = fieldOptions.phoneNumberFieldName;
    }
  },
  

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   * @param {Boolean} [incompleteAllowed=false] If TRUE, then an incomplete field is allowed during this validation
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   */
  validate : function (element, incompleteAllowed) {
    var state = this._super(element, incompleteAllowed);
    var country = this.formEl.find('[name='+this.countryFieldName+']').val() || nike.COUNTRY;
    //Defaults to the US regex if not specified
    var regexp = this.REG_EXP_MAP[country] || this.REG_EXP_MAP["US"];
    var value = element.val();

    // Test the currently selected countries regexp against the value
    if(state === nike.exp.global.validation.STATE.VALID  &&
       regexp && regexp.test(value) === false) {
      state = nike.exp.global.validation.STATE.ERROR_PATTERN;
    }

    return state;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.PhoneNumberField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.DateField
 */
nike.namespace('nike.exp.global.validation.field.DateField');

nike.requireDependency('nike.exp.global.validation.field.Field');

/**
 * @extends nike.exp.global.validation.field.Field
 */
nike.exp.global.validation.field.DateField = nike.exp.global.validation.field.Field.extend(
/** @lends nike.exp.global.validation.field.DateField.prototype */
{
  /**
   * Validates a date stored in three select boxes.  Must have a name attributes in the form:
   *    nameYear, nameMonth, nameDay
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   * @override
   */
  validate : function (element) {
    var state = nike.exp.global.validation.STATE.VALID;
    var required = element.attr('required') || this.forceRequired;
    var date = this.getDate(element);

    if (date.isComplete && !this.validateDate(date.year, date.month, date.day)) {
      state = nike.exp.global.validation.STATE.ERROR_INVALID_FORMAT;
    } else if (!date.isComplete && required) {
      state = nike.exp.global.validation.STATE.ERROR_NOT_COMPLETE;
    } else if (!date.isComplete) {
      state = nike.exp.global.validation.STATE.NOT_VALIDATED;
    }

    return state;
  },

  /**
   * Gets date information from a select box
   *
   * @param {jQuery} element
   * @returns {{year: String, month: String, day: String, isComplete: Boolean, ageMin: String}}
   * @protected
   */
  getDate : function (element) {
    var name = element.attr('name');
    var subName = name.substr(0, name.search(/(Month|Day|Year)/));
    var day = this.formEl.find('select[name=' + subName + 'Day]').val();
    var month = this.formEl.find('select[name=' + subName + 'Month]').val();
    var yearEl = this.formEl.find('select[name=' + subName + 'Year]');
    var year = yearEl.val();
    var isComplete = day && month && year;

    return {
      year : year,
      month : month,
      day : day,
      isComplete : isComplete,
      ageMin : yearEl.data('agemin')
    }
  },

  /**
   *
   * @param {String} yearString
   * @param {String} monthString
   * @param {String} dayString
   * @returns {boolean} TRUE if date is valid, FALSE otherwise
   * @private
   */
  validateDate : function (yearString, monthString, dayString) {
    var year = yearString && yearString !== "" ? parseInt(yearString) : NaN;
    var month = monthString && monthString !== "" ? parseInt(monthString) : NaN;
    var day = dayString && dayString !== "" ? parseInt(dayString) : NaN;

    if( isNaN( year ) || (isNaN( month ) || month == 0) || isNaN( day )){
      return false;
    }

    var valid = true;
    //April, June, September and November does not have 31 days
    if((month === 4 || month === 6 || month === 9 || month === 11) && day === 31){
      valid = false;
    }
    else if(month === 2){
      // check for february 29th
      var isLeap = (year % 4 === 0 && (year %100 !== 0 || year % 400 === 0));
      if(day >29 || (day === 29 && !isLeap)){
        //February of leap years does not have 29 days
        valid = false;
      }
    }

    return valid;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.DateField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.global.validation.field.DobField
 */
nike.namespace('nike.exp.global.validation.field.DobField');

nike.requireDependency('nike.exp.global.validation.field.DateField');

//noinspection MagicNumberJS
/**
 * @extends nike.exp.global.validation.field.DateField
 */
nike.exp.global.validation.field.DobField = nike.exp.global.validation.field.DateField.extend(
/** @lends nike.exp.global.validation.field.DobField.prototype */
{

  /**
   * If no age limit is specified, then this will be the default age to use
   *
   * @type Number
   * @private
   * @constant
   */
  DEFAULT_MINIMUM_AGE : 18,

  /**
   * Validates the supplied element and returns the state of the field as
   * a {@link nike.exp.global.validation.STATE}
   *
   * @param {jQuery} element The element that will be validated.  This should not be a collection
   *
   * @return {nike.exp.global.validation.STATE} The current state of the field
   * @public
   * @override
   */
  validate : function (element) {
    var state = this._super(element);
    var date = this.getDate(element);

    if(state === nike.exp.global.validation.STATE.VALID &&
        !this.validateAge(date.year, date.month, date.day, date.ageMin)) {

      if (element.data("ageWarning")) {
        state = nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE_WARNING;
      } else {
        state = nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE;
      }
    }

    return state;
  },

  /**
   * Validates the given date of birth against the given age.
   *
   * @param {String} yearString
   * @param {String} monthString
   * @param {String} dayString
   * @param {String} ageMinString
   * @returns {boolean} TRUE if passed age verification, FALSE otherwise
   */
  validateAge : function (yearString, monthString, dayString, ageMinString) {
    var valid = true;
    var year = yearString && yearString !== "" ? parseInt(yearString) : NaN;
    var month = monthString && monthString !== "" ? parseInt(monthString) : NaN;
    var day = dayString && dayString !== "" ? parseInt(dayString) : NaN;
    var ageMin = ageMinString && ageMinString !== "" ? parseInt(ageMinString) : NaN;
    var threshold, now, dob, requiredDob, difference;

    // Make sure we have actual numbers in our date
    if(isNaN(year) || isNaN(month) || isNaN(day)) {
      valid = false;
    }

    // An agemin of 0 means that there is no age limit
    if(valid && ageMin !== 0) {
      // Now we can calculate the date that they would have to be, to meet the age requirement
      threshold = ageMin || this.DEFAULT_MINIMUM_AGE;
      now = new Date();
      dob = new Date(year, month - 1, day);
      requiredDob = new Date(now.getFullYear() - threshold, now.getMonth(), now.getDate());
      difference = requiredDob.getTime() - dob.getTime();

      // A negative number means that they are younger than the age requirement
      if(difference < 0) {
        valid = false;
      }
    }

    return valid;
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.field.DobField. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * User: BPYL
 * @namespace nike.exp.global.validation.Validator
 */
nike.namespace("nike.exp.global.validation.Validator");

nike.requireDependency('nike.exp.global.validation');
nike.requireDependency('nike.exp.global.validation.ValidationEvent');
nike.requireDependency('nike.exp.global.validation.field.Field');
nike.requireDependency('nike.exp.global.validation.field.FieldFactory');
nike.requireDependency('nike.exp.global.validation.field.PasswordField');
nike.requireDependency('nike.exp.global.validation.field.ToggleField');
nike.requireDependency('nike.exp.global.validation.field.PostalCodeEmeaField');
nike.requireDependency('nike.exp.global.validation.field.PostalCodeUsField');
nike.requireDependency('nike.exp.global.validation.field.PhoneNumberField');
nike.requireDependency('nike.exp.global.validation.field.DateField');
nike.requireDependency('nike.exp.global.validation.field.DobField');

nike.requireDependency('nike.exp.global.LocalValueUtil');

/**
 * @extends Class
 */
nike.exp.global.validation.Validator = Class.extend(
/** @lends nike.exp.global.validation.Validator.prototype */
{

  /**
   * Every field that has a data-validation attribute will be matched against this map and the
   * validator will be applied.  All other fields will have the "other" field mapped, which
   * is just a generic field validation using the attributes on the <input> element.
   *
   * @type Object<String,nike.exp.global.validation.field.Field>
   * @constant
   * @private
   */
  FIELD_MAP : {
    /**
     * Handles validating a DOB.  Will not validate the age requirement until explicitly told to in the
     * validation parameters
     */
    dob : nike.exp.global.validation.field.DobField,

    /**
     * Handles validating a Date in the form of 3 select boxes.  This will NOT validate a date string
     */
    date : nike.exp.global.validation.field.DateField,

    /**
     * Validates a postal code from the US or CA only
     */
    postalCode : nike.exp.global.validation.field.PostalCodeUsField,

    /**
     * Validates any postal code from several countries
     */
    postalCodeShipping : nike.exp.global.validation.field.PostalCodeEmeaField,

    /**
     * Handles radio boxes and check boxes
     */
    toggle : nike.exp.global.validation.field.ToggleField,

    /**
     * Check a password against password requirements.  This will return a complex state describing
     * the complexity requirements that still need to be met.
     */
    password : nike.exp.global.validation.field.PasswordField,

    /**
     * Ensures that this field exactly matches the password field
     */
    passwordConfirm : nike.exp.global.validation.field.FieldFactory.createConfirmFieldClass("password"),

    /**
     * Validates an email address
     */
    email : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(/^(([^<!>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/),

    /**
     * Ensures that the value entered in this field is exactly what is entered in the 'email' field.
     */
    emailConfirm : nike.exp.global.validation.field.FieldFactory.createConfirmFieldClass("email"),

    /**
     * Ensures that a phone number is formed correctly
     */
    phoneNumber : nike.exp.global.validation.field.PhoneNumberField,

    /**
     * 11 numeric characters and start with 1,
     */
    chinaMobileNumber : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(/^(1)+\d{10}$/),

    /**
     * No numbers are allowed in a city name
     */
    city : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(/^[^\d]+$/),

    /**
     * Ensures there are no invalid characters in a name field.
     * Uses negative look back to validate all characters in the string.
     */
    name : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(new RegExp('^((?!["<>$@*!#%^&+=_,?\\t/\\\\|<>(){}[\\]]{1,}).)*$')),

    /**
     * Ensures there are no invalid characters in a name field.
     * Uses negative look back to validate all characters in the string. Same as regex above EXCEPT allow the ()
     */
    hrName : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(new RegExp('^((?!["<>$@*!#%^&+=_,?\\t/\\\\|<>{}[\\]]{1,}).)*$')),

    /**
     * Ensures there are no invalid characters in a screen name field.
     * Uses negative look back to validate all characters in the string.
     */
    screenName : nike.exp.global.validation.field.FieldFactory.createRegExpFieldClass(new RegExp('^((?!["\'<>$@*!#%^&+=,?\\s/\\\\|<>(){}[\\]]{1,}).)*$')),

    /**
     * The basic Field class handles the required and pattern attributes correctly.
     */
    "default" : nike.exp.global.validation.field.Field
  },
  /**
   * Not all fields need to be converted to single byte, this is a string with comma
   * separated selectors for what doesn't need to be converted
   * @type String
   */
  multiByteFieldsToIgnore: "[name=recipientEmailAddress], [name=emailConfirm], [name=email], [name=password], [name=passwordConfirm], [name=country], [type=radio], [type=checkbox], [type=select]",

  /**
   * When a validator has not been specified on an input field, then this map will be used to try and guess
   * the validator that should be used.  However, this will be deprecated and removed in the future.
   *
   * @type Object<String,String>
   * @constant
   * @private
   * @deprecated
   */
  SELECTOR_MAP : {
    phoneNumber : 'input[name=phoneNumber],input[name=additionalPhoneNumber],input[name=mobileNumber]',
    name : 'input[name=firstName],input[name=lastName],input[name=jpFirstNameKana],input[name=jpLastNameKana]',
    city : 'input[name=city]',
    screenName : 'input[name=screenName]',
    email : 'input[name=email]',
    emailConfirm : 'input[name=emailConfirm]',
    postalCodeShipping : 'input[name=shippingPostalCode],input[name=emeaPostCode]',
    toggle : 'input[type=radio],input[type=checkbox]',
    dob : 'select.dob-dropdown',
    password : 'form[name=register-form] input[name=password],form[name=passwordUpdater-form] input[name=password],form[name=swoosh-profile-form] input[name=password]',
    passwordConfirm : 'input[name=passwordConfirm],input[name=confirmPassword],input[name=confirmpassword]'
  },

  /**
   * This is the assembled field class map that is created from constructor arguments
   *
   * @type Object<String,nike.exp.global.validation.field.Field>
   * @private
   */
  fieldMap : undefined,

  /**
   * The form that this validator will be validating.
   *
   * @type {jQuery}
   * @private
   */
  formEl : undefined,

  /**
   * @see nike.exp.global.validation.Validator.init(options)
   *
   * @type {Object}
   * @private
   */
  options : undefined,

  /**
   * This class handles the validation of a form.  When triggered on a specific element
   * or for the entire form, then validation errors will fire a
   * {@link nike.exp.global.validation.VALIDATION_EVENT} from the elements validated
   * and the event data will be an instance of the
   * {@link nike.exp.global.validation.ValidationEvent} class.
   *
   * @constructs
   *
   * @param {Object} options
   * @param {jQuery} options.formEl
   * @param {Object<String, nike.exp.global.validation.field.Field>} [options.additionalFieldClasses]
   * @param {Object<String, nike.exp.global.validation.field.Field>} [options.useFieldClasses]
   * @param {Object} [options.fieldOptions]
   */
  init : function (options) {
    this.options = options || {};
    this.fieldMap = this.FIELD_MAP;
    this.formEl = this.options.formEl;
    this.options.fieldOptions = this.options.fieldOptions || {};
    this.options.fieldOptions.formEl = this.options.formEl;

    // Assemble our field classes
    if(options.additionalFieldClasses) {
      $.extend(this.fieldMap, options.additionalFieldClasses);
    }

    if(options.useFieldClasses) {
      this.fieldMap = options.useFieldClasses;
    }

    // Initialize each of the forms fields to handle validation
    this.initFormFields(options);
  },

  /**
   * Handles initialization of each field and applies a field class to each
   *
   * @param {Object} [options.fieldOptions]
   * @private
   */
  initFormFields : function (options) {
    // Reference for callback function
    var self = this;

    // Find all the fields that need validation
    this.formEl.find('input:not([type="button"]):not([type="hidden"]):not([type="submit"]),textarea,select').each(
        function () {
          var element = $(this);
          var field = self.fieldMap["default"] || self.FIELD_MAP["default"];
          var requestedField = element.data('validator');
          var fieldGuess;
          var convertToMultiByte = element.not(self.multiByteFieldsToIgnore);

          // Find the validator for this field
          if(requestedField) {
            field = self.fieldMap[requestedField] || field;
          } else {
            // Attempt to find the field using a selector lookup
            fieldGuess = self.findFieldFromSelector(element);
            field = self.fieldMap[fieldGuess];
            // Add an explicit validator to make confirm fields simpler
            element.attr('data-validator', fieldGuess);
            nike.warn("DEPRECATED: data-validator has not been defined on an element, guessing '" +
                      fieldGuess + "' based on selector.  This guess is a deprecated feature " +
                      "that will be removed. All field validators should be explicitly defined.", element);
          }

          // Apply the fields to the elements
          element.data('field', new field(options.fieldOptions));
          element.attr('data-has-validation', true);

          //adding multibyte to singlebyte conversion attributes
          if(convertToMultiByte.length > 0 ){
            element.attr('data-multibytetosinglebyteonfocusout', true);
          }

          if(requestedField == "postalCode"){
            element.attr('data-multibytetosinglebyteonkeyup', true);
          }
        });
  },

  /**
   * Provides a guess of which validator should be used to validator this element.  If
   * no guess is found, then "other" will be used.
   *
   * @private
   * @param {jQuery} element The element in question
   * @return {String} The field map key that this element should be mapped to
   * @deprecated
   */
  findFieldFromSelector : function (element) {
    var fieldKey, fieldSelector, field;

    // Loop through all the selectors and find one that matches.
    for(fieldKey in this.SELECTOR_MAP) {
      if(this.SELECTOR_MAP.hasOwnProperty(fieldKey)) {
        fieldSelector = this.SELECTOR_MAP[fieldKey];
        if(element.is(fieldSelector)) {
          field = fieldKey;
          break;
        }
      }
    }

    return field || "default";
  },

  /**
   * Validates the form, a specific element or a group of elements.  Each field
   * that is validated will fire a {@link nike.exp.global.validation.VALIDATION_EVENT}
   * containing an instance of the class {@link nike.exp.global.validation.ValidationEvent}
   *
   * @public
   * @param {jQuery} [element=this.formEl] The element that you want to validate
   * @param {Object.<string,boolean>} [filter=&#123;errorMinimumAge:false,errorMinimumAgeWarning:false&#125;]
   *                                  This is a map of states that you want to exclude from triggering errors.
   *                                  This map can also be used to validate only a specific set of states.
   *                                  Setting a state to false will fire NOT_VALIDATED whenever that state
   *                                  is returned from the field validation. Setting a state to true will
   *                                  fire only the states that are set to true and NOT_VALIDATED if it's
   *                                  any other state.  VALID included unless that is also set to true.
   * @returns {Boolean} TRUE if all states were VALID or NOT_VALIDATED, FALSE if their were errors
   *
   * @example
   * validate(element, {errorMinimumAge:false,errorMinimumAgeWarning:false})
   * validate(element, {errorNotComplete:false,errorMinimumAge:false,errorMinimumAgeWarning:false})
   * validate(element, {errorRestrictedCharacters:true})
   */
  validate : function (element, filter) {
    var self = this;
    var fields = element.find('[data-has-validation]');
    var valid = true;
    var currentFilter = filter || {};

    // setup the default filter
    if(!filter) {
      currentFilter[nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE] = false;
      currentFilter[nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE_WARNING] = false;
    }

    if(element.is('[data-has-validation]')) {
      fields = fields.add(element);
    }

    // Run validation on each field
    fields.each(function () {
      // If we have returned an error, then return FALSE
      if(!self.doFieldValidation($(this), currentFilter)) {
        valid = false;
      }
    });

    return valid;
  },

  /**
   *
   * @param {Object.<string,boolean>} filter
   * @returns {boolean}
   */
  checkForWhiteListFilter : function (filter) {
    var isWhiteList = false;

    if(typeof filter === 'object') {
      for(var key in filter) {
        if(filter.hasOwnProperty(key)) {
          if(filter[key] === true) {
            isWhiteList = true;
            break;
          }
        }
      }
    }

    return isWhiteList;
  },

  /**
   * Validates a single field and triggers the validation event on that element
   *
   * @private
   * @param {jQuery} element
   * @param {Object.<string,boolean>} filter
   * @returns {boolean}
   */
  doFieldValidation : function (element, filter) {
    var field = element.data('field');
    var state = (field instanceof nike.exp.global.validation.field.Field) ?
                  field.validate(element) :
                  nike.exp.global.validation.STATE.NOT_VALIDATED;
    var isWhiteList = this.checkForWhiteListFilter(filter);
    var message;

    // Compare to the filter
    if(filter) {
      if(isWhiteList) {
        if(!filter[state] || filter[state] !== true) {
          state = nike.exp.global.validation.STATE.NOT_VALIDATED;
        }
      } else {
        if(filter[state] === false) {
          state = nike.exp.global.validation.STATE.NOT_VALIDATED;
        }
      }
    }

    // If we have been validated in some way, then fire the validation event
    if(state !== nike.exp.global.validation.STATE.NOT_VALIDATED) {
      message = this.resolveErrorMessage(element, state);
    }

    // Notify the element that validation has occurred
    element.trigger(nike.exp.global.validation.VALIDATION_EVENT,
      new nike.exp.global.validation.ValidationEvent(element, state, message));

    return state === nike.exp.global.validation.STATE.NOT_VALIDATED || state === nike.exp.global.validation.STATE.VALID;
  },

  /**
   * Tries to resolve the error message that should be displayed to the user.
   * This is using several different places to find the error to stay backwards
   * compatible to nike.Validation
   *
   * @protected
   * @param {jQuery} element
   * @param {nike.exp.global.validation.STATE} state
   *
   * @return {String}
   */
  resolveErrorMessage : function (element, state) {
    var STATE = nike.exp.global.validation.STATE;
    var error = element.data('error');
    var errorMsg = "";

    //noinspection FallthroughInSwitchStatementJS
    switch(state) {
      case STATE.NOT_VALIDATED:
      case STATE.VALID:
        error = "";
        break;
      case STATE.ERROR_NOT_COMPLETE:
        errorMsg = element.data('errorNotComplete') || element.data('errorEmpty') || error;
        break;
      case STATE.ERROR_NO_MATCH:
        errorMsg = element.data('errorNoMatch') || element.data('errorMatch') || error;
        break;
      case STATE.ERROR_PATTERN:
        errorMsg = element.data('errorPattern') || element.data('errorSpecialcharacters') || element.data('errorHasnumbers') || element.data('errorSpace') || error;
        break;
      case STATE.ERROR_RESTRICTED_CHARACTERS:
        errorMsg = element.data('errorRestrictedCharacters') || this.formEl.data('errorRestrictedCharacters') || nike.exp.global.LocalValueUtil.getLocal("profile.validation.restrictedchar.message");
        break;
      case STATE.ERROR_INVALID_FORMAT:
        errorMsg = element.data('errorInvalidFormat') || error;
        break;
      case STATE.ERROR_MINIMUM_AGE:
        errorMsg = element.data('errorMinimumAge') || element.data('errorUnderage') || error;
        break;
      case STATE.ERROR_MINIMUM_AMOUNT:
        errorMsg = element.data('errorMinimumAmount') || error;
        break;
      case STATE.ERROR_MAXIMUM_AMOUNT:
        errorMsg = element.data('errorMaximumAmount') || error;
        break;
      default:
        errorMsg = error;
    }

    return errorMsg;
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.validation.Validator. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * User: BPYL
 * @namespace nike.exp.global.AbstractForm
 */
nike.namespace("nike.exp.global.AbstractForm");

nike.requireDependency("nike.exp.global.validation");
nike.requireDependency("nike.exp.global.validation.Validator");

nike.requireDependency('nike.util.StringUtil');

/**
 * Reusable abstract class to handle forms.  Takes care of styling, validation and error display
 *
 * @extends Class
 */
nike.exp.global.AbstractForm = Class.extend(
/** @lends nike.exp.global.AbstractForm.prototype */
{

  /**
   * This is the jQuery element of the form itself
   *
   * @type jQuery
   * @public
   */
  formEl : undefined,

  /**
   * Setting this to a function will allow this to run on submit of the form AFTER validation is successful
   *
   * @type Function
   * @public
   */
  onSubmit : nike.emptyFn,

  /**
   * Setting this to a function will allow this to run on failure of form validation
   *
   * @type Function
   * @public
   */
  onFailedFormValidation : nike.emptyFn,

  /**
   *
   * This will be the validator used to for form validation
   *
   * @type nike.exp.global.validation.Validator
   * @protected
   */
  validator : undefined,

  /**
   * @constructs
   *
   * @param {jQuery} form The form you want this class to handle validation of
   * @param {nike.exp.global.validation.Validator} [validator] The class that will handle validation
   * @public
   */
  init : function (form, validator) {
    //noinspection JSValidateTypes
    if(this.constructor === nike.exp.global.AbstractForm.prototype.constructor) {
      var msg = "Attempt to instantiate an abstract class! The nike.exp.global.AbstractForm class MUST be extended to use.";
      nike.error(msg);
      throw new TypeError(msg);
    }
    this.formEl = form;
    // Turn off the validation that the browser might try to do
    this.formEl.attr('novalidate', true);

    this.initializeFormValues();
    this.saveDefaultValues();

    this.validator = validator || new nike.exp.global.validation.Validator({formEl : this.formEl});
  },

  /**
   * Validates the entire form, displays the errors and scrolls to the first one
   *
   * @param {jQuery} [element] If an element is specified, then it will only validate the single element
   * @return {Boolean} TRUE if valid, FALSE otherwise
   * @public
   */
  validate : function (element) {
    var testEl = element || this.formEl;

    if (testEl === this.formEl) {
      this.clearErrors();
    } else {
      this.clearError(testEl);
    }

    return this.validator.validate(testEl, {});
  },

  /**
   * Displays a specific error in the form.  Passing in nothing will use the forms general error (data-error).
   * Passing only a string will add the error into the form-failure.
   * Passing a string and an element will add the error to the specific element
   *
   * @param {String} [error=this.formEl.data('error')] The optional error you want to display to the user
   * @param {jQuery} [element=this.formEl.find('.form-failure')] The element you want to associate this error with
   * @public
   */
  displayError : function (error, element) {
    var errorContainer;

    if(element) {
      if( element.is("select") ) {
        element.parent().addClass("is-invalid");
      }

      element.removeClass("is-valid").addClass("is-invalid");
      element.parent().find('a').removeClass("is-valid").addClass("is-invalid");
      this.renderNotifier(element, error);

      //for EDF-21508, need to display error on top of the form instead of on each field.
      //Here might not be a good place to fix it, but don't know any other place.
      if(!error && this.formEl.attr('id') == 'addressForm'){
        this.formEl.find('.error.form-error.missing-fields').show();
      }

    } else {
      errorContainer = this.formEl.find('.form-failure');
      if(errorContainer.find('.failure-text') == undefined || errorContainer.find('.failure-text').length == 0) {
        errorContainer.append('<div class="failure-text"></div>');
      }
      errorContainer.find('.failure-text').html(error || this.formEl.data('error'));
      errorContainer.addClass('errorContainerDisplay');
      errorContainer.show();
    }

  },

  /**
   * Displays age violation errors to the use and disables the DOB boxes.  Will default to the
   * dbloctext data in the year select element as the default error to display.
   *
   * @param {String} [dobMsg=dobYearEl.data(dbloctext)] A message to display under the date of birth boxes.
   * @param {boolean} [warningOnly = false] Disable all registration fields and set 24 lockout cookie
   * @public
   */
  handleDOBFailure : function (dobMsg, warningOnly) {
    var dobEl = this.formEl.find(".dob");
    var dobYearEl = dobEl.find('select[name="dobYear"]');

    dobEl.addClass("is-invalid");

    if (!warningOnly) {
      this.disableFields(dobEl.find('select'));
      nike.exp.global.validation.setInvalidAge();

      if(this.formEl.attr('name') == 'exp-register-form'){
        var $registerFormIsValid = $('.is-valid');
        var $registerFormFields = $('form.exp-register-form input');
        var $registerForm = $('form.exp-register-form');
        var $registerFormDropDown = $('form.exp-register-form .nsg-form--drop-down');

        // Take all the is-valid classes out of the registration form.
        $registerFormIsValid.removeClass('is-valid');

        // Disable the properties and attributes of our form.
        $registerFormFields.prop('disabled', true).attr('disabled', true);

        // Disable the form and add the is-invalid class; the is-invalid class will put an opacity of
        //  .5 onto the form.
        $registerForm.attr('disabled', true).addClass('is-invalid');

        // Adding this class to the drop-down will remove the valid styling.
        $registerFormDropDown.addClass('is-invalid');

        //here is to fix IE9 styling issue on disabled form
        $('.exp-register-form .form-failure').addClass('disabled-for-dob').insertBefore($('.exp-register-form'));
      }
    }else {
      this.displayError(dobMsg || dobYearEl.data("dbloctext"), dobYearEl);
    }
  },

  /**
   * Handles the form submit.  If onSubmit returns TRUE when called, then the
   * browser will handle the form submission, otherwise, prevents the default behavior
   *
   * @param {Event} event
   * @public
   */
  submitForm : function (event) {
    var preventDefault = true;
    event.stopImmediatePropagation(); // prevents multiple events from firing this function

    if(this.validate()) {
      if(this.onSubmit() === true) {
        preventDefault = false;
      }
    } else {
      this.onFailedFormValidation();
    }

    if(preventDefault) {
      event.preventDefault();
    }
  },

  /**
   * Attaches the listeners to the form to handle user interaction, validation and displaying errors
   *
   * @public
   */
  attachListeners : function () {
    var self = this;

    var validateElement = function () {
      self.validator.validate($(this));
    };

    if(this.disabled && this.onAgeMinFailed) {
      this.onAgeMinFailed();
    }

    this.formEl.on(nike.exp.global.validation.VALIDATION_EVENT, $.proxy(this.validationEventHandler, this));

    // Required fields need validation when leaving the field
    this.formEl.on('focusout', 'textarea[required], input[required]:not([data-blur-validate="false"]), input[pattern]:not([required]):not([data-blur-validate="false"]), input[data-blur-validate="true"]:not([pattern]):not([required])', validateElement);

    // Handle validating characters as they are entered and re-validating after corrections
    this.formEl.on('keyup change cut paste', 'textarea, input:not([type="radio"]):not([type="checkbox"])',
        function validateWhileEditing (event) {
          var element = $(this);
          var filter;

          // Only validate the restricted characters unless we have a fully invalid field
          if(!element.hasClass("invalid-field") && !element.is('input[data-validator="password"]')) {
            filter = {};
            filter[nike.exp.global.validation.STATE.ERROR_RESTRICTED_CHARACTERS] = true;
          }

          // Cut and Paste won't have an updated field value until AFTER
          // the browser can process the event.   So we need to wait the minimum
          // number of milliseconds (4ms per specification) to check the value again.
          if(event.type === 'paste' || event.type === 'cut') {
            //noinspection JSCheckFunctionSignatures,DynamicallyGeneratedCodeJS
            setTimeout(function () { self.validator.validate(element, filter); }, 4);
          } else {
            self.validator.validate(element, filter);
          }
        });

    // Handle removing the check mark when a user is typing in the field
    this.formEl.on('keyup change paste cut', 'textarea.valid, input.is-valid',
        function removeValidCheckmarkOnChange () {
          $(this).removeClass('is-valid');
          $(this).removeClass('valid');
        });

    // Handle radio buttons
    this.formEl.on('change', 'input[type="radio"]',
        function validateRadioButtons () {
          // TODO: Validator should probably deal with validating all radio boxes
          self.validator.validate($(this).parents(".radio-container,.exp-field-container"));
        });

    // Handle check boxes
    this.formEl.on('change', 'input[type="checkbox"]', validateElement);

    // Handle re-validating the password when the screen name is changed
    this.formEl.on('keyup change', 'input[data-validator=screenName]',
        function reValidatePasswordOnScreenNameChange () {
          var passwordEl = self.formEl.find('input[data-validator=password]');
          if(passwordEl.hasClass('is-invalid') || passwordEl.hasClass('is-valid')) {
            self.validator.validate(passwordEl);
          }
        });

    // Handle select button changes
    this.formEl.on('change', 'select',
        function validateSelectButtons () {
          var select = $(this);
          if(select.parents('.dob,.exp-field-container:first').exists()) {
            self.validator.validate(self.formEl.find('.dob,.exp-field-container:first'), {errorNotComplete:false,'errorMinimumAge':false,'errorMinimumAgeWarning':false});
          } else {
            self.validator.validate(select, {errorNotComplete:false});
          }
        });

    // Handle the password container
    this.formEl.find('input[data-validator=password]:not(.invalid-characters)').on({
      "keyup" : $.proxy(this.passwordKeyupHandler, this),
      "focusin" : $.proxy(this.passwordFocusInHandler, this),
      "focusout" : $.proxy(this.passwordFocusOutHandler, this)
    });

    //Handle text fields (not post code) changes MultiByte to SingleByte
    this.formEl.on("focusout blur","input[data-multibytetosinglebyteonfocusout]", $.proxy(this.multiByteToSingleByteHandler, this));

    // TODO: This won't work on cut and paste because the field hasn't been processed yet.
    // You will need to wait for the browser to add the text into the field.
    // See the restricted character validation for an example
    this.formEl.on("keyup change cut paste", 'input[data-multibytetosinglebyteonkeyup]', $.proxy(this.multiByteToSingleByteHandler, this));

    // Handle updating the characters left in a text area
    this.formEl.find('textarea[maxlength]').on('keyup change focusout', this.textAreaCharactersLeftHandler);

    // Handle the form submission
    this.formEl.on('submit', $.proxy(this.submitForm, this));
    this.formEl.on(Modernizr.touch ? 'touchstart' : 'click', '[type="submit"]', $.proxy(this.submitForm, this));
  },

  /**
   * Removes all listeners from the form
   *
   * @public
   */
  removeListeners : function () {
    this.formEl.off('click focusin focusout keyup change submit touchstart cut paste', '**');
  },

  /**
   * Clears all the values in a form and resets selects to their default
   *
   * @public
   */
  clearForm : function () {
    var inputEls = this.formEl.find(':input');
    var checkedEls = inputEls.filter(':radio, :checkbox');

    this.clearErrors();

    inputEls.removeAttr('checked').removeAttr('selected');

    // Restore default values
    inputEls = inputEls.not(':button, :submit, [type="reset"], [type="hidden"], :radio, :checkbox');
    inputEls.val('');

    inputEls.each(
        function () {
          var input = $(this);
          var data = input.data('default');
          if(data) {
            input.val(data);
          }
        });

    checkedEls.each(
        function () {
          var input = $(this);
          var data = input.data('default');
          if(data === true) {
            input.attr('checked', true);
          }
        });

    // Reinitialize form values
    this.initializeFormValues();
  },

  /**
   * Retrieves all the data from a form and returns a key/value map of the results
   *
   * @return {Object}
   * @public
   * @nosideeffects
   */
  getFormData : function () {
    // Get all form values
    var value, input, sel, data = {};
    this.formEl.find(':input[name]').each(function(){
      input = $(this);
      if (input.is(':checkbox')){
        data[input.attr('name')] = input.is(':checked');
      } else if (input.is(':radio')){
        if (input.is(':checked')) {
          data[input.attr('name')] = input.val();
        }
      } else {
        value = input.val();
        //allow blank postal code for China
        if (input.attr('name') == 'postalCode') {
          if (!input.hasClass('inactivePostalCode')) {
            data[input.attr('name')] = value;
          }
        } else if (input.is('select') && input.attr('name') == 'state') {
          if (input.is(':visible') && value && value.length > 0) {
            data[input.attr('name')] = value;
          }
        } else {
          if (value && value.length > 0) {
            data[input.attr('name')] = value;
          }
        }
      }

    });

    return data;
  },

  /**
   * Consumes validation events from the Validator.  These will be used
   * to display errors to the user or set the valid class.
   *
   * @param {Event} event
   * @param {nike.exp.global.validation.ValidationEvent} data
   * @private
   */
  validationEventHandler : function (event, data) {
    var VALID = nike.exp.global.validation.STATE.VALID;
    var NOT_VALIDATED = nike.exp.global.validation.STATE.NOT_VALIDATED;
    var ERROR_MINIMUM_AGE = nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE;
    var ERROR_MINIMUM_AGE_WARNING = nike.exp.global.validation.STATE.ERROR_MINIMUM_AGE_WARNING;
    var ERROR_RESTRICTED_CHARACTERS = nike.exp.global.validation.STATE.ERROR_RESTRICTED_CHARACTERS;

    var isValid = data.state === VALID;
    var isInvalid = !(data.state === NOT_VALIDATED || data.state === VALID);
    var isErrorRestrictedCharacters = data.state === ERROR_RESTRICTED_CHARACTERS;
    // The password meter will handle display the errors to the user
    var focusedInPassword = data.element.is('[data-validator=password]:focus');

    event.stopPropagation();

    if (isInvalid && (!focusedInPassword || isErrorRestrictedCharacters)) {

      if(data.state === ERROR_MINIMUM_AGE){
        this.displayError(data.message);
      } else {
        this.displayError(data.message, data.element);
      }

      if(data.state === ERROR_RESTRICTED_CHARACTERS) {
        data.element.addClass("invalid-characters");
      } else {
        data.element.removeClass("invalid-characters").addClass("invalid-field");
      }
    } else if (!isInvalid || focusedInPassword) {
      this.clearError(data.element);
    }

    if(data.state === ERROR_MINIMUM_AGE) {
      this.handleDOBFailure();
    } else if (data.state === ERROR_MINIMUM_AGE_WARNING) {
      this.handleDOBFailure("", true);
    }

    data.element.toggleClass('is-valid', isValid);

  },


  /**
   * Takes the error and displays it in the element.  Handles adding additional 'invalid' classes
   * to the elements that require it.
   *
   * @param {jQuery} element
   * @param {String} error
   * @private
   */
  renderNotifier : function (element, error) {
    var type = element.attr('type');
    var container, errorContainer;

    if(element.is('select')) {
      type = 'select';
    }

    // UPGRADE NOTES:
    // TODO: this whole switch statement is lame.  Needs better logic
    // The validation events bubble up from the element, we ought to be able to attach
    // listeners at the DOM level we want the error to be rendered.  We can use data attributes to assist
    // data-catch-errors="ERROR_PATTERN,ERROR_RESTRICTED_CHARACTERS" - white list
    // data-ignore-errors="ERROR_MINIMUM_AGE" - black list
    // The form error will handle anything that slips through

    //noinspection FallthroughInSwitchStatementJS
    switch(type) {
      case 'radio':
      case 'checkbox':
      case 'select':
        container = element.parents('.radio-container,.checkbox-container,.select-container,.nsg-form--drop-down');
        if(container.parents('.horizontal-container:not(.dont-invalidate-whole-container)').exists()) {
          container = container.parents('.horizontal-container');
        }
        if(container.is('.select-container,.nsg-form--drop-down')) {
          container.addClass('is-invalid');
        } else {
          container.find('.select-container,.nsg-form--drop-down').addClass('is-invalid');
        }
        container.find('input.invalid,textarea.invalid').parent().addClass('is-invalid');
        errorContainer = container.find('.error-container');

        break;
      default:
        errorContainer = element.siblings('.error-container');
        break;
    }

    errorContainer.trigger('validationFailure');
    errorContainer.find('.failure-text').html(error);
    errorContainer.addClass('errorContainerDisplay');
  },

  /**
   * Initializes the form values and sets up any placeholder fallback logic.  Also checks for the age violation cookie.
   *
   * @private
   */
  initializeFormValues : function () {
    var self = this;
    // Disable the form if age verification failed previously
    if(this.formEl.find('.dob').exists() && nike.exp.global.validation.ageMinFailed()) {
      this.disableForm();
      this.displayError(this.formEl.find('.dob select[name="dobYear"]').data("errorCookieMessage"));
      this.disabled = true;

      //for register form IE9 issue, if form disabled, no color for text
      if(this.formEl.attr('name') == 'exp-register-form'){
        $('.exp-register-form .form-failure').addClass('disabled-for-dob').insertBefore($('.exp-register-form'));
      }
    }

    // Set the country select if does not exists
    this.formEl.find('select[name="country"]').each(function (_,select) {
      var selectEl = $(select);
      if (!selectEl.find('option[value=""]').exists() || selectEl.find('option:selected').val() === '') {
        selectEl.val(nike.COUNTRY);
      }
    });

    // Setup the characters left in any text area containers
    this.formEl.find('textarea[maxlength]').each(this.textAreaCharactersLeftHandler);
  },

  /**
   * Stores the initial state of select boxes to be restored when the form is cleared
   *
   * @private
   */
  saveDefaultValues : function () {
    var inputEls = this.formEl.find('input,select').not(':button, :submit, :reset, :hidden, :radio, :checkbox');
    var checkedEls = this.formEl.find('input:checked');

    inputEls.each(
        function () {
          var input = $(this);
          input.data('default', input.val())
        });

    checkedEls.each(
        function () {
          $(this).data('default', true);
        });
  },

  /**
   * Removes all the errors from the form
   * @private
   */
  clearErrors : function () {
    this.formEl.find('.notifier').remove();
    this.formEl.find('.error-container, .password-meter').hide();
    this.formEl.find('.error-container,.error-message').removeClass('errorContainerDisplay');
    this.formEl.find(".is-invalid").removeClass("is-invalid").removeClass("invalid-field").removeClass("invalid-characters");
    this.formEl.find(".is-valid").removeClass("is-valid");
    this.formEl.find('.error.form-error.service-error').hide();
    this.formEl.find('.error.form-error.service-message').hide();
    this.formEl.find('.error.form-error.missing-fields').hide();
    this.formEl.find('.error-message.form-failure').hide();
  },

  /**
   * Remove the errors of a single element
   * @param {jQuery} element
   * @protected
   */
  clearError : function (element) {
    element.siblings('.notifier').remove();
    element.siblings('.error-container').hide();
    element.siblings('.error-container').removeClass('errorContainerDisplay');
    element.removeClass("is-invalid");
    element.removeClass("invalid-field");
    element.removeClass("invalid-characters");
    element.removeClass("is-valid");
    if(element.is('[type=radio],[type=checkbox],select') || element.parents('[data-error-container]').exists()) {
      var container = element.parents('.radio-container,.checkbox-container,.select-container,.nsg-form--drop-down,.horizontal-container,[data-error-container]');
      container.removeClass('is-invalid');
      container.find('.is-invalid').removeClass('is-invalid');
      container.find('.error-container').hide();
      container.find('.error-container').removeClass('errorContainerDisplay');
      element.parent().find('a').removeClass('is-invalid');
    }
  },

  /**
   * Disables the form completely to prevent user input
   * @private
   */
  disableForm : function() {
    this.formEl.addClass('errorState disabled').attr('disabled', 'disabled');
    this.disableFields(this.formEl.find('select,input,textarea,[type="submit"]'));
  },

  /**
   * @private
   * @param {jQuery} fields
   * @param {boolean} [enable=false]
   */
  disableFields : function (fields, enable) {
    fields.each(function() {
      var $el = $(this),
      target = ($el.is("select.selectBox") && ($el.css('display') === 'none')) ? $el.next() : $el;

      if (enable) {
        target.removeAttr("disabled");
        if ($el.hasClass('selectBox')) {
          $el.selectBox('enable');
        }
      } else {
        target.attr("disabled", "disabled");
        if ($el.hasClass('selectBox')) {
          $el.selectBox('disable');
        }
      }
    });
  },

  /*
  TODO: The whole password thing should be moved somewhere else.  There is coupling between the PasswordField
  TODO: and the password meter that shouldn't be in AbstractForm, but also shouldn't be in PasswordField.
  TODO: Perhaps a PasswordMeter class that uses the PasswordField class would make more sense.
   */

  /**
   * Handles the keyup for a password element.  Updates the password strength window and
   * validates the confirmPassword if it's present.
   *
   * @private
   */
  passwordKeyupHandler : function () {
    var inputPasswordEl = this.formEl.find('[data-validator=password]');
    var passwordConfirmEl = this.formEl.find('[data-validator=passwordConfirm]');
    var field = inputPasswordEl.data('field');
    var state = (field instanceof nike.exp.global.validation.field.Field) ?
                  field.validate(inputPasswordEl) :
                  nike.exp.global.validation.STATE.NOT_VALIDATED;

    this.passwordStateHandler(state);

    // If the password confirm field has a value, check that immediately.
    if(passwordConfirmEl.val()) {
      this.validator.validate(passwordConfirmEl);
    }
  },

  /**
   * Handles the focusin for the password element. Displays the password strength window
   * and updates it.
   *
   * @private
   */
  passwordFocusInHandler : function () {
    var inputPasswordEl = this.formEl.find('[data-validator=password]');
    var field = inputPasswordEl.data('field');
    var state = (field instanceof nike.exp.global.validation.field.Field) ?
                  field.validate(inputPasswordEl) :
                  nike.exp.global.validation.STATE.NOT_VALIDATED;

    this.passwordStateHandler(state);
    this.formEl.find('.password-meter').css('display','block');
  },

  /**
   * Handles the focusout for the password element.  Hides the password strength window.
   * @private
   */
  passwordFocusOutHandler : function () {
    this.formEl.find('.password-meter').css('display','none');
  },

  /**
   * For a definition of this state see {@link nike.exp.global.validation.field.PasswordField.PASSWORD_STATE}
   *
   * @param {nike.exp.global.validation.STATE} state This complex state defines the password properties
   * @private
   */
  passwordStateHandler : function (state) {
    var passwordMeter = this.formEl.find('.password-meter');

    if(state === nike.exp.global.validation.STATE.VALID) {
      //noinspection AssignmentToFunctionParameterJS,JSValidateTypes
      state = {
        hasNum : true,
        isNotScreenName : true,
        hasReqCharLength : true,
        hasMixedChars : true
      };
    }

    if(typeof state === 'object') {
      passwordMeter.css('display', 'block');
      passwordMeter.siblings('.error').removeClass("visible");
      $.each(state,
          function(index, value){
            var glyphSpan = passwordMeter.find("." + index + " .nsg-glyph--check");
            if (value) {
              passwordMeter.find("." + index).addClass("is--good");
              if($(glyphSpan).length > 0) {
                $(glyphSpan).removeClass("is-hidden");
              }
            } else {
              passwordMeter.find("." + index).removeClass("is--good");
              if($(glyphSpan).length > 0) {
                $(glyphSpan).addClass("is-hidden");
              }
            }
          });
    } else if (state === nike.exp.global.validation.STATE.ERROR_RESTRICTED_CHARACTERS) {
      passwordMeter.css('display', 'none');
      passwordMeter.siblings('.error').addClass("visible");
    }

  },

  /**
   * Handles updating the characters remaining in a text area field
   *
   * @this Event callback
   * @private
   */
  textAreaCharactersLeftHandler : function () {
    var containerEl = $(this).parent();
    var textArea = containerEl.children('textarea');
    var messageCount = containerEl.children('.length-count');
    var maxLength = textArea.attr('maxlength');
    var lineCount = 0;
    if ( navigator.userAgent.indexOf('Firefox') == -1 ){ //Not Firefox
      var lineCounter = textArea.val().match(/(\r\n|\n|\r)/g);
      if (lineCounter !== null){
        lineCount = lineCounter.length;
      }
    }
    var count = maxLength - (textArea.val().length + lineCount);

    //hack for ie : https://nikensl.jira.com/browse/EDF-21591
    if (count <= 0) {
      textArea.prop('value', textArea.prop('value').substring(0,maxLength));
      count = 0;
    }

    messageCount.html('' + count + ' ' + messageCount.data('charsLeft'));
    messageCount.toggleClass('caution', count > 0 && count < 20);
    messageCount.toggleClass('invalid', count <= 0);
  },
  /**
   * Handles converting multibyte chars to singlebyte chars
   *
   * Note: This done on keyup/keypress/keydown will have adverse effects,
   * it replaces the whole string.
   * @param event
   */
  multiByteToSingleByteHandler : function(event){
    var $el = $(event.currentTarget);
    if($el.val()){
      $el.val(nike.util.StringUtil.multiByteToSingleByteConverter($el.val()));
    }
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.AbstractForm. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/**
 * User: bpyl
 * Date: 3/7/13
 * @namespace nike.exp.global.Form
 */
nike.namespace("nike.exp.global.Form");

nike.requireDependency('nike.exp.global.AbstractForm');
nike.requireDependency('nike.util.BrowserUtil');
nike.requireDependency('nike.exp.global.SelectBox');

//noinspection MagicNumberJS
/**
 * @extends nike.exp.global.AbstractForm
 */
nike.exp.global.Form = nike.exp.global.AbstractForm.extend(
/** @lends nike.exp.global.Form.prototype */
{

  /**
   * The key code for the ENTER button
   *
   * @type Number
   * @constant
   * @private
   */
  ENTER_BUTTON_KEY_CODE : 13,

  /**
   * The number of milliseconds to delay before beginning the fade out of error indicators
   *
   * @type Number
   * @constant
   * @private
   */
  ERROR_INDICATOR_DELAY : 3000,

  /**
   * The number of milliseconds the fade out animation should take for error indicators
   *
   * @type Number
   * @constant
   * @private
   */
  ERROR_INDICATOR_FADE : 500,

  /**
   * Used to help indicate when a form is being submitted.
   *
   * Errors need to be displayed differently in the registration modal.
   *
   * @todo This needs to be removed and moved into something more specific to the registration form
   *
   * @type Boolean
   * @private
   */
  suppressErrors : false,

	/**
	 * Allows the user to add extra CSS classes to a notifier element
	 */
	extraNotifierClass : undefined,

  /**
   * @constructs
   *
   * @param {jQuery} form The form you want this class to handle validation of
   * @param {nike.exp.global.validation.Validator} [validator] The class that will handle validation
   * @public
   */
  init : function (form, validator) {
    this._super(form, validator);
  },

  /**
   * Handles place holder requirements for browsers that don't support it.
   */
  initializeFormValues : function () {
    this._super();
    // If placeholder is not supported
    if(!Modernizr.input.placeholder) {
      // Add the default-value span above each text-input
      this.formEl.find('.nsg-form--input[placeholder]').each(function() {
        var input = $(this);
        var existingSpan = input.siblings(".default-value");
        var defaultValueSpan = $("<span>", { "class" : "default-value nsg-font-family--base", text : input.attr("placeholder") });

        if(existingSpan.exists()) {
          existingSpan.toggle(!input.val());
        } else {
          defaultValueSpan.toggle(!input.val());
          input.before(defaultValueSpan);
        }
      });
    }
  },

  /**
   * Validates the entire form
   *
   * @param {jQuery} [element]
   * @return {Boolean} TRUE if valid, FALSE otherwise
   * @public
   * @override
   */
  validate : function (element) {
    // This will keep all the errors from showing up on all the elements and gives us better control of
    // what is visible
    this.suppressErrors = true;
    var valid = this._super(element);

    // If any of the input boxes has focus, then display that error
    this.formEl.find('input:focus').not('[data-validator=password]').siblings('.notifier').addClass('visible');

    this.suppressErrors = false;
    return valid;
  },

  /**
   * Centers the notifier to the width of its container
   * @param {jQuery} notifier the notifier element
   * @param {jQuery} container the notifier's container
   */
  centerNotifier : function(notifier, container) {
    notifier.css('left', (container.innerWidth()/2) - (notifier.outerWidth()/2));
  },

  /**
   * Attaches the listeners to the form to handle user interaction, validation and displaying errors
   *
   * @public
   * @override
   */
  attachListeners : function () {
    var self = this;
    var selectEls = this.formEl.find('select');
    var body = $('body');
    var isTouch = (body.hasClass('Tablet') || body.hasClass('Phone')) && Modernizr.touch;
    this._super();

    // Handle the default value text if placeholder is not supported
    if(!Modernizr.input.placeholder) {
      // Hiding and Showing the default value
      this.formEl.on('focusin focusout', '.nsg-form--input[placeholder]',
          function () {
            var input = $(this);
            if(input.val().length === 0){
              input.siblings('.default-value').toggle(!input.is(':focus'));
            } else {
              input.siblings('.default-value').hide();
            }
          });

      // Handle clicking default value
      this.formEl.on(isTouch ? 'touchstart' : 'click', '.default-value',
          function () {
            $(this).siblings('.nsg-form--input').focus();
          });
    }

      // Add any helper text when entering a field that has it
    this.formEl.on('focusin', 'input[data-helper]',
        function () {
          var input = $(this);
          self.renderNotifier(input, input.data('helper'), 'helper', true);
        });

    // Remove the helper when leaving the field
    this.formEl.on('focusout', 'input[data-helper]',
        function () {
          $(this).parent().find('.helper.notifier').remove();
        });

    // :hover CSS attributes work great in desktop, but not so much in tablets,
    // specifically iPad's.  This is a work around that gains us what we want.

    // Deal with showing the error when the mouse is hovering over the label
    this.formEl.on(isTouch ? 'focusin' : 'focusin mouseenter', '.exp-input-wrapper,.exp-input-container:not(.exp-field-child),[data-error-container]',
        function (event) {
          var label = $(this);
          var notifier = label.find('.notifier');
          if(label.find('input.is-invalid,textarea.invalid,.selectBox.is-invalid,textarea.is-invalid').exists() &&
             !(label.find('[data-validator=password]:not(.invalid-characters)').exists() && (event.type === 'focusin' || label.find('input:focus'))) ) {
            self.centerNotifier(notifier, label);
            notifier.addClass('visible');
          }
        });

    // Recenter the visible notifiers if the orientation changes
    // Namespaced event to allow us to unlisten easier
    nike.listen(nike.Event.PAGE_LAYOUT + ".form-" + this.formEl.attr('name'),
      function() {
        var notifiers = $('div.notifier.visible');
        if (notifiers.length) {
          notifiers.each(
            function () {self.centerNotifier($(this), $(this).parent());}
          );
        }
      }
    );

    // Make sure clicking on a notifier focuses them into the input field
    this.formEl.on(isTouch ? 'touchstart' : 'click', '.error.notifier, .password-meter',
        function () {
          $(this).parent().find('input').focus();
        });

    // Handle removing the password notifier when clicked
    // TODO: This will need to be specific to a password field that has a password meter popup
    this.formEl.on('focusin', 'input[name="password"]:not(.invalid-characters)',
        function () {
          $(this).siblings('.error.notifier').removeClass('visible');
        });

    if(!isTouch) {
      // Show the password meter when hovering over an invalid password field (not because of restricted characters)
      this.formEl.on('mouseenter', 'input[data-validator="password"].is-invalid:not(.invalid-characters)',
          function () {
            $(this).siblings('.password-meter').show();
          });

      // Hide the password meter when leaving the field if we aren't focused in
      this.formEl.on('mouseleave', 'input[data-validator="password"].is-invalid:not(.invalid-characters)',
          function () {
            var element = $(this);
            if(!element.is(':focus')) {
              element.siblings('.password-meter').hide();
            }
          });

      // Hide the notifier only if we are not displaying an error because of a newly invalid field
      this.formEl.on('mouseleave', '.exp-input-wrapper,.exp-input-container:not(.exp-field-child),[data-error-container]',
          function () {
            var label = $(this);
            if(label.find('.is-invalid').exists() && !label.find('input:focus').exists()) {
              label.find('.notifier:not(.errorFadeOut)').removeClass('visible');
            }
          });
    }

    // Handle styling of select boxes with a jQuery plugin called selectBox
    selectEls.selectBox();
  },

  /**
   * Removes all listeners from the form
   *
   * @public
   * @override
   */
  removeListeners : function () {
    // Destroy the selectBox jQuery plugin
    this.formEl.find('select.selectBox').selectBox('destroy');
    nike.unlisten(".form-" + this.formEl.attr('name'));
    this._super();
  },

  /**
   * Clears all the values in a form and resets selects to their default
   *
   * @public
   * @override
   */
  clearForm : function () {
    var selectBoxEls = this.formEl.find('select.selectBox');
    this._super();

    // Restore default values
    selectBoxEls.each(function () {
      var select = $(this);
      select.selectBox('value', select.data('default') || '');
    });
  },

  /**
   * Displays age violation errors to the use and disables the DOB boxes.  Will default to the
   * dbloctext data in the year select element as the default error to display.
   *
   * @param {String} [dobMsg=dobYearEl.data(dbloctext)] A message to display under the date of birth boxes.
   * @param {boolean} [warningOnly=false]
   * @public
   * @override
   */
  handleDOBFailure : function (dobMsg,warningOnly) {
    this._super(dobMsg,warningOnly);

    if (!warningOnly) {
      var dobEls = this.formEl.find('.dob select.selectBox');
      dobEls.selectBox('disable');
    }
  },

  /**
   * Takes the error and displays it in the element.
   *
   * @param {jQuery} element
   * @param {String} error
   * @param {String} [className=error]
   * @param {Boolean} [preventFadeOut=false]
   * @private
   * @override
   */
  renderNotifier : function (element, error, className, preventFadeOut) {
    if(!error){ return; }

    var notifier = $('<div><\/div>', { "class" : "error notifier nsg-form--tool-tip" });
    var msg = $('<p><\/p>', { "class": "msg" });
    var notifierClass = className || "error";
    var timeoutId;

		if(this.extraNotifierClass){ notifier.addClass(this.extraNotifierClass); }


    msg.html(error);
    notifier.append(msg);

    var notifierContainer = element.parent();

    if (element.hasClass('nsg-form--checkbox') || element.hasClass('nsg-form--radio') || (element.is('select') && element.parent().hasClass('nsg-form--drop-down'))) {
      notifierContainer = notifierContainer.parent();
    }

    // Handle a declared target
    if(element.parents('[data-error-container]').exists()) {
      notifierContainer = element.parents('[data-error-container]:first');
      notifierContainer.addClass("is-invalid");
    }

    var existingNotifier = notifierContainer.children('.notifier');

    // Remove any existing error notifiers and stop processing for standard notifiers(helpers).
    if(notifierClass === "error" && existingNotifier.exists()) {
      // Remove any existing notifiers if we are trying to display an error
      existingNotifier.remove();
    } else if (notifierClass !== "error" && existingNotifier.exists() && existingNotifier.hasClass("error")) {
      // Do not add a notifier if it isn't an error and we already have an error displaying
      return;
    }

    // Add our new notifier and center it
    notifierContainer.append(notifier);
    this.centerNotifier(notifier, notifierContainer);

    // Ensure additional is-invalid classes are set
    if(element.hasClass('selectBox')) {
      element.next().addClass('is-invalid');
    }

    // add QA attribute to the notifier if the parent element has one.
    var qaAttr    = element.attr('data-qa');
    var parQAAttr = notifierContainer.attr('data-qa');
    var inputType = element.attr('type');
    var errorQAAttr;

    if(notifierContainer.is("[data-error-container]") && parQAAttr) {
      // For new data driven forms
      errorQAAttr = parQAAttr;
    } else if(qaAttr) {
      // for standard inputs
      errorQAAttr = qaAttr;
    } else if ((inputType == 'radio' || inputType == 'checkbox' || element.hasClass('selectBox')) && parQAAttr) {
      // for customized radio, checkbox, & select inputs
      errorQAAttr = parQAAttr;
    }

    // assign qa-attr
    if(errorQAAttr) {
      notifier.attr('data-qa', errorQAAttr + '.errorMsg');
    }

    // Handle the logic to fade out the notifier if we need to.
    if(!this.suppressErrors && preventFadeOut) {
      notifier.addClass('visible');
    } else if (!this.suppressErrors) {
      notifier.addClass('visible').addClass('errorFadeOut');
      timeoutId = setTimeout(
          function () {
            notifier.fadeOut(this.ERROR_INDICATOR_FADE,
              function () {
                notifier.css('display', '');
                notifier.removeClass('visible').removeClass('errorFadeOut');
              })
          }, this.ERROR_INDICATOR_DELAY);

      element.parent().on('mouseenter.errorFadeOut', function () {
        notifier.removeClass('visible').removeClass('errorFadeOut');
        clearTimeout(timeoutId);
        element.parent().off('mouseenter.errorFadeOut');
      });
    }

  },

  /**
   * Remove the errors of a single element
   * @param {jQuery} element
   * @protected
   * @override
   */
  clearError : function (element) {
    this._super(element);

    if(element.hasClass('selectBox')) {
      element.next().removeClass('is-invalid');
    }

    if (element.hasClass('nsg-form--checkbox') || element.hasClass('nsg-form--radio') || (element.is('select') && element.parent().hasClass('nsg-form--drop-down'))) {
      element.parent().parent().find('.nsg-form--tool-tip').remove();
    }

    if(element.parents('[data-error-container]').exists()) {
      element.parents('[data-error-container]:first').children('.nsg-form--tool-tip').remove();
    }
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.Form. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
// TODO: Figure out how much of this is used elsewhere.
// If Unite is all that matters, 50% of this can be ripped out.

/**
 * User: bpyl
 * Date: 3/7/13
 * @namespace nike.exp.profile.Register
 */
nike.namespace("nike.exp.profile.Register");

nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.exp.global.Form');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.exp.global.LocalValueUtil');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.util.BooleanUtil');
nike.requireDependency('nike.util.BrowserUtil');
nike.requireDependency('nike.interactionType');

nike.requireDependency('nike.exp.profile.CpcStateController');
nike.requireDependency('nike.exp.profile.ProfileStateController');

/**
 * Handles registration in the desktop/tablet version of the site.
 */
nike.exp.profile.Register = {

  /**
   * Holds the root jQuery element of registration
   *
   * @type jQuery
   * @private
   */
  containerEl: undefined,

  /**
   * Hold the {@link nike.exp.global.Form} class for the form
   *
   * @type nike.exp.global.Form
   * @private
   */
  form: undefined,

  /**
   * Hold the {@link nike.exp.global.Modal} class for the dialog
   *
   * @type nike.exp.global.Modal
   * @private
   */
  modal: undefined,

  /**
   * Indicates whether we are on the stand alone registration page or as a dialog in any page that
   * the OneNikeNav is located in
   *
   * @type Boolean
   * @private
   */
  isStandAlone: false,

  /**
   * Indicates that a registration is currently being processed
   *
   * @type Boolean
   * @private
   */
  processingRegistration: false,

  /**
   * Starts up the namespace and listeners to display and process user registration.
   *
   * @public
   */
  startup: function () {
    var standAloneEl = $('#accountStandalone.register');
    var self = this;

    this.isStandAlone = standAloneEl.exists();
    this.containerEl = this.isStandAlone ? standAloneEl : $('.register-modal.new-register.register');

    this.attachCommonListeners();

    if (this.isStandAlone) {
      $('.register-modal.new-register.register').remove();
      this.attachStandAloneListeners();
      this.initModal(true);
      this.form.attachListeners();
    } else {
      this.attachDialogListeners();
    }
    // Listen for Unite Events dispatched in Login.js
    nike.listen(nike.Event.UNITE_LOGIN_SUCCESS, self.handleUniteLogin.bind(self));
    nike.listen(nike.Event.UNITE_REGISTER_SUCCESS, self.handleUniteRegister.bind(self));
  },
  handleUniteRegister: function () {
    // empty
  },
  handleUniteLogin: function () {
    // How the hell did you get here?
  },

  /**
   * Displays the registration modal
   *
   * @public
   */
  show: function (event, params) {
    this.setDefaultCountry();

    if (nike.Validation.ageMinFailed()) {
      this.initWarningModal();
    } else {
      if (!this.modal) {
        this.initModal();
      }

      this.form.attachListeners();
    }

    if (params && params.afterModalCancelled) {
      this.afterModalCancelled = params.afterModalCancelled;
    }

    this.modal.open();
  },

  setDefaultCountry: function () {
    this.containerEl.find('select[name="country"]').selectBox('value', nike.COUNTRY);
  },

  /**
   * Will be called after modal is closed
   */
  afterModalCancelled: $.noop,

  /**
   * Hides the registration modal
   *
   * @public
   */
  hide: function () {
    if (this.modal) {
      this.form.removeListeners();
      this.modal.close();
    }
  },

  /**
   * Initializes the registration modal
   *
   * @param {Boolean} [isStandAlone=false]
   * @private
   */
  initModal: function (isStandAlone) {
    var self = this;
    if (!isStandAlone) {
      this.modal = new nike.exp.global.Modal({
        $content: this.containerEl,
        onClose: function (closeType) {
          self.form.clearForm();
          if (this.$content.hasClass('logged-in')) {
            nike.dispatchEvent(nike.Event.HIDE_REGISTER_AFTER_SUCCESS, {element: this.$content});
          } else {
            nike.dispatchEvent(nike.Event.CANCEL_REGISTER, {element: this.$content});
          }
        }
      });
    }

    this.form = new nike.exp.global.Form(this.containerEl.find('form.exp-register-form'));
    this.form.onSubmit = $.proxy(this.register, this);
  },

  /**
   * Show warning modal for Unable to Register
   * @private
   */
  initWarningModal: function () {
    var modalContentEl = $('.unable-to-register-modal');
    modalContentEl.removeClass('is-hidden');
    this.modal = new nike.exp.global.Modal({
      $content: modalContentEl,
      onClose: function () {
      }
    });
  },

  /**
   * Handles commmon listeners for both the stand alone and the dialog version of registration
   *
   * @private
   */
  attachCommonListeners: function () {
    // Attach registration service listeners
    nike.listen(nike.gadget.Event.REGISTER_SUCCESS, $.proxy(this.handleRegistrationSuccess, this));
    nike.listen(nike.gadget.Event.REGISTER_FAIL, $.proxy(this.handleRegistrationFail, this));
    nike.listen(nike.Event.MEMBER_LOGGED_OUT, $.proxy(this.handleUserLoggedOut, this));
  },

  /**
   * handle logout out user state, show register form instead of confirmation page
   */
  handleUserLoggedOut: function () {
    if (this.containerEl.hasClass("logged-in")) {
      this.containerEl.removeClass("logged-in");
      this.form.attachListeners();
    }
  },

  /**
   * Attaches listeners for the stand alone version of registration
   *
   * @private
   */
  attachStandAloneListeners: function () {
    /* When the continue button for *any other* Register Gadget is clicked, go to the home page, too. */
    nike.listen(nike.Event.HIDE_REGISTER, $.proxy(nike.navUtil.redirectToRegionalHomepage, nike.navUtil));
    // Deal with Start Shopping button
    this.containerEl.find('.register-start-shopping, .js-nextStepCta').on('click', function () {
      if (document.referrer) {
        window.location.href = document.referrer;
      } else {
        nike.navUtil.redirectToRegionalHomepage();
      }
    });

  },

  /**
   * Attaches listeners for the dialog version of registration
   *
   * @private
   */
  attachDialogListeners: function () {
    nike.listen(nike.Event.SHOW_REGISTER, $.proxy(this.show, this));
    nike.listen(nike.Event.HIDE_REGISTER, $.proxy(this.hide, this));
    nike.listen(nike.Event.CANCEL_REGISTER, $.proxy(this.cancelRegister, this));
    nike.listen(nike.Event.HIDE_REGISTER_AFTER_SUCCESS, function () {
      nike.exp.profile.Register.form.removeListeners();
    });

    // Deal with Start Shopping button
    this.containerEl.find('.js-nextStepCta').on('click', $.proxy(this.hide, this));

    // Handle the JOIN button in the OneNikeNav
    $('.gnav .join').click(function () {
      //Only send the showRegister event if cookies are enabled, otherwise send a featureRequiresCookies event
      if (nike.util.BrowserUtil.checkCookieEnabled()) {
        window.scrollTo(0, 0);
        nike.dispatchEvent(nike.Event.SHOW_REGISTER, {element: nike.exp.profile.Register.containerEl});
      } else {
        nike.dispatchEvent(nike.Event.FEATURE_REQUIRES_COOKIES, {feature: 'register'});
      }
    });
  },

  /**
   *  Remove the form listeners when the modal is closed, call cancel callback
   */
  cancelRegister: function () {
    nike.exp.profile.Register.form.removeListeners();
    this.afterModalCancelled();
  },

  /**
   * Handles the submit of the registration data to the Profile JS API to process
   *
   * @private
   */
  register: function () {
    var formData;

    if (this.processingRegistration) {
      return;
    }

    //we're clear to make the request, show the loading screen
    nike.dispatchEvent(nike.gadget.Event.SHOW_LOADING_SCREEN, {element: this.registrationFormEl});
    this.processingRegistration = true;

    // Get all form values
    formData = this.getRegisterFormData();

    // Make the call
    var register = nike.exp.profile.ProfileStateController.register(formData);

    // Process a successful call`
    register.done(
      function registrationSuccessful(model) {
        //noinspection JSUnresolvedVariable
        nike.dispatchEvent(nike.gadget.Event.REGISTER_SUCCESS, {
          element: nike.exp.profile.Register.containerEl,
          response: model,
          emailSignup: model.receiveEmail
        });
      });

    // Process a failed call
    register.fail(
      function registrationFailed(response) {
        nike.error("Unable to register user.  Reason: ", response);
        nike.dispatchEvent(nike.Event.REGISTER_FAIL, {
          element: nike.exp.profile.Register.containerEl,
          response: (response && response.statusText !== "error") ? response :
                    {responseText: '[{"errorCode":"APILoadError","fieldName":"unknown"}]'}
        });
      });

    // Always do these things so the user can try again
    register.always(
      function registrationAlways() {
        nike.exp.profile.Register.processingRegistration = false;
        nike.dispatchEvent(nike.gadget.Event.HIDE_LOADING_SCREEN, {});
      });
  },

  /**
   * All instances of this class should listen for this event from all sources. Only the active instance should
   * fire the HIDE_LOADING_SCREEN event.
   *
   * @private
   */
  handleRegistrationSuccess: function (event, data) {

    var state = nike.exp.profile.ProfileStateController.getUserState();
    var Account = nike.exp.profile.ProfileStateController.getAccountData();
    var $container = $('.js-standaloneRegContainer');

    window.scrollTo(0, 0);
    if ($container.length) {
      $container.find('.js-addTitleWithName').html(nike.Util.replaceSiteFurnitureValues(nike.exp.global.LocalValueUtil.getLocal('register.confirmation.titleName'), data.user.firstName));
    }

    if (event.type.toString() == "registerSuccessEvent") {
      nike.dispatchEvent(nike.gadget.Event.HIDE_LOADING_SCREEN, {});
    }

    if (!state || !state.loggedIn || !Account) {
      nike.error('The data object returned @handleRegistrationSuccess was missing required info');
    }

    this.containerEl.addClass("logged-in");
    if (this.form) {
      this.form.clearForm();
      this.form.removeListeners();
    }

    // Kick off a new cart summary request
    nike.Cart.loadCartSummary("nikestore", null, null, true);
  },

  /**
   * Handles registration service failures
   *
   * NOT BEING CALLED!
   * @private
   */
  handleRegistrationFail: function (event, data) {
    var jsonResp, resp, responseObject;
    var form = this.form;
    var el, errorMsg = "";

    try {
      jsonResp = data.response.responseText;
      resp = JSON.parse(jsonResp);
      responseObject = resp[0];
    } catch (exp) {
      nike.error("Unable to parse failure message from registration", exp, data);
      form.displayError();
      return;
    }

    // Make sure we are the correct event
    if (!data.element.is(this.containerEl)) {
      return;
    }

    // Walk through each error and display in the right place
    $.each(resp, $.proxy(function (i, msg) {
      if ((msg.errorCode == "NotUnique" || msg.errorCode == "InvalidArgument") && (msg.fieldName == "email")) {
        el = data.element.find("input[type=email]");
        if (responseObject.errorMessage) {
          el.data('dbloctext', responseObject.errorMessage);
        }
        errorMsg = el.data('dbloctext');
        errorMsg = errorMsg.replace("{emailAddress}", el.val());
        form.displayError(errorMsg, el);
      } else if ((msg.errorCode == "NotUnique" || msg.errorCode == "InvalidArgument") && (msg.fieldName
                                                                                          == "screenName")) {
        el = data.element.find("input[name=screenName]");
        if (responseObject.errorMessage) {
          el.data('dbloctext', responseObject.errorMessage);
        }
        errorMsg = el.data('dbloctext');
        errorMsg = errorMsg.replace("{screenName}", el.val());
        form.displayError(errorMsg, el);
      } else if ((msg.errorCode == "InvalidArgument") && (msg.fieldName == "dateOfBirth")) {
        form.displayError(msg.errorMessage);
        // The DOB failed even though we validated it with the age we knew of, so show a generic age failure
        form.handleDOBFailure();
      } else if ((msg.errorCode == "InvalidCOPPAweb") && (msg.fieldName == "dateOfBirth")) {
        form.displayError(msg.errorMessage);
        // The DOB failed even though we validated it with the age we knew of, so show a generic age failure
        form.handleDOBFailure();
      } else if (msg.errorCode == "Invalid" && msg.fieldName == "dateOfBirth") {
        form.displayError(msg.errorMessage);
      } else if (msg.errorCode == "Invalid" && msg.fieldName == "mobileNumber") {
        form.displayError(msg.errorMessage);
      } else if (msg.errorCode) {
        form.displayError(msg.errorMessage);
      }
    }, this));
  },

  /**
   * Retrieves the registration data from the form
   *
   * @return {Object} An object to give to the Profile JS API
   * @private
   * @nosideeffects
   */
  getRegisterFormData: function () {
    // Get all form values
    var formData = this.form.getFormData();
    var formObj = {},
      dobDay = formData["dobDay"],
      dobMonth = formData["dobMonth"],
      dobYear = formData["dobYear"],
      registrationSiteId = formData["registrationSiteId"];
    formObj["account"] = {};
    formObj["account"]["passwordSettings"] = {};

    // format obj
    $.each(formData, function (i, v) {
      if (i == "email" || i == "screenName" || i == "type") {  //format account objs
        formObj["account"][i] = v;
      } else if (i == "password" || i == "passwordConfirm") {    //format password objs
        formObj["account"]["passwordSettings"][i] = v;
      } else if (i == "receiveEmail" && (v == "true" || v === true)) { //add optIns
        var optIns = new Array();
        var optIn = {id: registrationSiteId, email: true};
        optIns.push(optIn);
        formObj["optIns"] = optIns;
        formObj[i] = v;
      } else if (i == "dobDay" || i == "dobMonth" || i == "dobYear" || (i == "optIns_0" && v != "true")) { //format DOB   1950-02-28
      } else {  // format everything else
        formObj[i] = v;
      }
    });

    formObj["dateOfBirth"] = dobYear + "-" + dobMonth + "-" + dobDay;   //format DOB   1950-02-28
    return formObj;
  }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.Register. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace('jQuery.throttle');
nike.requireDependency('jQuery');

/*
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function(b,c){var $=b.jQuery||b.Cowboy||(b.Cowboy={}),a;$.throttle=a=function(e,f,j,i){var h,d=0;if(typeof f!=="boolean"){i=j;j=f;f=c}function g(){var o=this,m=+new Date()-d,n=arguments;function l(){d=+new Date();j.apply(o,n)}function k(){h=c}if(i&&!h){l()}h&&clearTimeout(h);if(i===c&&m>e){l()}else{if(f!==true){h=setTimeout(i?k:l,i===c?e-m:e)}}}if($.guid){g.guid=j.guid=j.guid||$.guid++}return g};$.debounce=function(d,e,f){return f===c?a(d,e,false):a(d,f,e!==false)}})(this);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.throttle. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * @author bpyl<brenton.pyl@nike.com>
 * @namespace nike.exp.profile.UniteModal
 * new version of LoginModal; to be used for implementation of Unite
 */
nike.namespace('nike.exp.profile.UniteModal');

nike.requireDependency('Class');
nike.requireDependency('jQuery');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.exp.global.LocalValueUtil');
nike.requireDependency('nike.exp.profile.ProfileStateController');
nike.requireDependency('nike.interactionType');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.style.nsg.Classes');

/**
 * @extends Class
 */
nike.exp.profile.UniteModal = Class.extend(
/** @lends nike.exp.profile.UniteModal.prototype */
{

  /**
   * The contents of the login modal
   *
   * @type jQuery
   * @private
   */
  content : undefined,

  /**
   * The modal class that will deal with resizing and orientation changes
   *
   * @type nike.exp.global.Modal
   * @private
   */
  modal : undefined,

  /**
   * If we opened the modal with a 'link' attribute, then we will use this to apply to the
   * login success event
   *
   * @type string
   * @private
   */
  link : undefined,

  /**
   * jQuery element object
   *
   * @type {}
   * @private
   */
  els : {},

  /**
   * Array of domains for which we do not want to show the Unite modal
   */
  ALTERNATE_DOMAINS: ['hurley', 'converse'],

  /**
   * Handles displaying the login modal to the user
   *
   * @constructs
   */
  init: function () {
    var self = this;

    // Setup the content
    this.els.$content = $('.js-expUniteModal');
    this.els.$uniteContainer = this.els.$content.find('.js-uniteContainer');
    this.els.$confirmContainer = this.els.$content.find('.js-confirmContainer');

    this.els.$content.removeClass('hidden');
    this.els.$content.removeClass('original');

    // Create the modal class
    this.modal = new nike.exp.global.Modal({
      $content: this.els.$content,
      blockerClickCloses: false,
      autoDestroy: false,
      onClose : $.proxy(this.close, this),
      windowSelectorClass : "exp-unite-modal-window"
    });

    // Distach Register Analytics Event
    this.els.$content.find('.js-register-standalone').on(nike.interactionType.click, function () {
      nike.dispatchEvent(nike.Event.JOIN_CTA_CLICK, {});
    });

    // Open the login modal whenever a request is made for it
    nike.listen(nike.Event.SHOW_LOGIN, function showLoginHandler (event, data) {
      var isAltDomain = false;
      var altDomains = self.ALTERNATE_DOMAINS;

      // Check all the alternate domains to see if we are on a converse or hurley site
      for (var i=0; i<altDomains.length; i++) {
        if (location.host.indexOf(altDomains[i]) >=0 ) {
          isAltDomain = true;
          break;
        }
      }

      if (isAltDomain) {
        // If this is a converse or hurley or other domain from our alternate list, send the user to the standalone login page
        location.href = nike.exp.profile.Login.$memberFacet.find('[js-hook="loginLink"]').attr('href');
      } else {
        if(data && data.modal === true) {
          if(data.link){
            self.link = data.link;
          }
          self.open();
        } else {
          self.close(nike.exp.global.Modal.CLOSE_TYPE.PROGRAMMATIC);
        }
      }
    });
    // Listen for Unite Events dispatched in Login.js
    nike.listen(nike.Event.LOGIN_SUCCESS, self.handleLogin.bind(self));
    nike.listen(nike.Event.REGISTER_SUCCESS, self.handleRegister.bind(self));
  },

  /**
   * Toggles hide and show between the unite container and the confirmation container
   * @param boolean
   */
  toggleVisibleContainers : function (isReset) {
    if (this.els.$uniteContainer && this.els.$confirmContainer) {
      this.els.$uniteContainer.toggleClass('hidden', !isReset);
      this.els.$confirmContainer.toggleClass('hidden', isReset);
    }
  },

  /**
   * Opens the login modal
   *
   * @public
   */
  open : function () {
    this.toggleVisibleContainers(true);
    this.modal.open();
  },

  /**
   * Closes the login modal
   *
   * @param {nike.exp.global.Modal.CLOSE_TYPE} closeType
   */
  close : function (closeType) {
    // TODO: WHAAAAT IS THIS?
    if ((nike.objectDefined('nike.analytics.Tracking.config.pageId') && nike.analytics.Tracking.config.pageId === 'myorders')
         || /\/orders\//.test(window.location.href)) {
      if (document.referrer) {
        document.location = document.referrer;
      } else {
        nike.navUtil.redirectToRegionalHomepage();
      }
    }

    //On close of the modal, reset the Unite gadget to the Login view
    nike.unite.destroyAllViews();
    nike.unite.views.login.render();

    //dispatch CANCEL_LOGIN if the user closes modal and does not click JOIN/F
    //TODO: Do we still want this?
    // if(closeType !== nike.exp.global.Modal.CLOSE_TYPE.PROGRAMMATIC && !this.registerStarted) {
    //   nike.dispatchEvent(nike.Event.CANCEL_LOGIN, {});
    // }

    this.link = undefined;  //empty string results in event validation error
  },

  /**
   * Handles the making the login request and responding to the result.
   *
   * @private
   */
  handleLogin : function (event, data) {
    var modal = this.modal;
    var content = this.els.$content;
    var self = this;
    // Show loading screen
    nike.dispatchEvent(nike.gadget.Event.SHOW_LOADING_SCREEN, {});
    // dispatch Analytics Event
    // TODO: Do we need this?
    // nike.dispatchEvent(nike.Event.LOGIN_ATTEMPT, {});
    nike.dispatchEvent(nike.Event.HIDE_REGISTER);
    nike.dispatchEvent(nike.gadget.Event.HIDE_LOADING_SCREEN, {});
    if (modal.isOpen && !data.isRegister) {
      modal.close(); // This will trigger this.close() as well.
    }
  },

  handleRegister : function (event, data) {
    var $title = this.els.$confirmContainer.find('.js-addTitleWithName');

    $title.html(nike.Util.replaceSiteFurnitureValues(nike.exp.global.LocalValueUtil.getLocal('register.confirmation.titleName'), data.user.firstName));
    this.els.$confirmContainer.on(nike.interactionType.click, ".js-nextStepCta", this.closeByButton.bind(this));
    this.toggleVisibleContainers(false);
  },

  closeByButton : function () {
    var modal = this.modal;
    nike.dispatchEvent(nike.Event.HIDE_REGISTER); // Not sure if this is necessary
    modal.close()
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.UniteModal. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.profile.Login');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.Validation');
nike.requireDependency('nike.util.BrowserUtil');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.interactionType');
nike.requireDependency('jQuery');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('jQuery.growandshow');
nike.requireDependency('jQuery.hoverIntent');
nike.requireDependency('requestAnimationFrame');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('jQuery.throttle');
nike.requireDependency('nike.exp.global.Form');
nike.requireDependency('nike.exp.profile.ProfileStateController');
nike.requireDependency('nike.exp.profile.UniteModal');

//noinspection MagicNumberJS
nike.exp.profile.Login = {

  /**
   * The number of characters to show in the display name before cutting off the rest
   *
   * @type Number
   * @private
   * @constant
   */
  TRUNCATED_DISPLAY_NAME_LENGTH: 17,

  /**
   * The characters to show when a display name has been truncated
   *
   * @type String
   * @private
   * @constant
   */
  ELLIPSIS: "...",

  /**
   * The prefix for the url to the avatar of the user
   * @type String
   * @private
   * @constant
   */
  AVATAR_PREFIX: "vc/profile/",

  /**
   * Used to control how long the login dropdown wait before closing.
   *
   * @type number
   * @constant
   * @private
   */
  CLOSE_TIMER_WAIT_TIME: 600,

  startupLogin: function () {
    var self = nike.exp.profile.Login;
    var storedUniteInit = window.nikeUniteInit;

    self.$globalNav = $('.gnav');
    self.$loginMenu = self.$globalNav.find('[js-hook="exp-profile-dropdown"]');
    self.$memberFacet = self.$globalNav.find('[js-hook="gnav-member-bar--userMenu"]');
    self.$loginFacet = self.$globalNav.find('[js-hook="exp-join-login"]');
    self.$loginElement = $('.oneNike-login');
    self.$loginContainer = self.$loginElement.find('.oneNike-login-container');
    self.$homeButton = self.$globalNav.find('.home');
    self.$memberDropDown = $('.member_dropdown');
    self.memberCloseTimer = null;
    self.$loginMask = $('<div>', {'class': 'modal-mask-class'});

    self.setContext();
    self.setupEvents();
    self.setupListeners();
    self.setupLinkRedirector();

    if (self.isStandAlone && nike.objectDefined('nike.exp.profile.LoginStandalone')) {
      self.loginStandalone = new nike.exp.profile.LoginStandalone();
    } else if (!self.isStandAloneRegister) { // No login instantiation for standalone register
      self.loginModal = new nike.exp.profile.UniteModal();
    }
    window.nikeUniteInit = (function() {
      return function(str) {
        nike.unite.on.login.success.addHandler(function handleUniteLogin (result){
          nike.dispatchEvent(nike.Event.UNITE_LOGIN_SUCCESS, result);
        });
        nike.unite.on.join.success.addHandler(function handleUniteRegister (result){
          nike.dispatchEvent(nike.Event.UNITE_REGISTER_SUCCESS, result)
        });
        if (self.isStandAloneRegister) {
          nike.unite.destroyAllViews();
          nike.unite.views.join.render();
          $('div.js-standaloneRegContainer').removeClass('unite-hidden');
        }
        if (typeof storedUniteInit === "function") {
          // call whatever nikeUniteInit was previously if it was a function
          storedUniteInit.apply(this, arguments);
        }
      };
    }());
  },

  /**
   * Configures the link redirector to handle the events specified
   */
  setupLinkRedirector: function () {
    var setup;
    if (nike.gadget.LinkRedirector) {
      setup = new nike.gadget.LinkRedirector.PageSetup(true);

      // So far only this single event has been converted to use the LinkRedirector
      // This event merges with whatever page events have already been specified
      setup.setupEvent(nike.Event.PROFILE_MENU_ITEM_CLICKED);
      setup.setupEvent(nike.Event.LOGIN_SUCCESS);

      nike.gadget.LinkRedirector.setupPageEvents(setup);
    }
  },

  setupEvents: function () {

    var self = nike.exp.profile.Login;

    if (Modernizr.touch) {
      self.$memberFacet.on(nike.interactionType.click, function (e) {
        e.preventDefault();
        if (self.$memberFacet.hasClass('is-active')) {
          nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
        } else {
          nike.dispatchEvent(nike.Event.SHOW_MEMBER_DROPDOWN, {});
        }
      });
      self.$loginElement
        .on(nike.interactionType.down, '*', function (e) {
          $(this).addClass('touch-active');
        })
        .on(nike.interactionType.up, '*', function () {
          $(this).removeClass('touch-active');
        });
    } else {
      self.$memberFacet.hoverIntent({
        over: function () {
          nike.dispatchEvent(nike.Event.SHOW_MEMBER_DROPDOWN, {});
        },
        timeout: self.CLOSE_TIMER_WAIT_TIME,
        out: function () {
          nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
        }
      });

      self.$memberFacet.on(nike.interactionType.click, function (e) {
        e.preventDefault();
        if (self.$memberFacet.hasClass('is-active')) {
          nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
        } else {
          nike.dispatchEvent(nike.Event.SHOW_MEMBER_DROPDOWN, {});
        }
      });
    }

    /**
     * If this is the standalone login page, focus on the login form instead of dropping down the login form.
     * @todo enable multiple login forms per page instead of only allowing one.
     */
    if (self.isStandAlone) {

      // self.$loginFacet.on(nike.interactionType.click, function ( e ) {
      //   e.preventDefault();
      //   self.$loginEmailInput.trigger('focus');
      // });
    } else {

      self.$loginFacet.on(nike.interactionType.click, function () {
        nike.dispatchEvent(nike.gadget.Event.STORE_NAV_CHANGED, {
          clicked: true,
          navItemsFormatted: 'join or login'
        });

        if (!self.$loginElement.is(':animated') && self.$loginElement.hasClass('is-active')) {
          nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});
        } else if (!self.$loginElement.is(':animated') && !self.$loginElement.hasClass('is-active')) {
          self.sendShowLoginEvent({'modal': true});
        }
      });
    }

    self.$loginElement.on(nike.interactionType.click, '.exp-register', function (e) {
      e.preventDefault();
      e.stopPropagation();
      nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});

      //Only send the showRegister event if cookies are enabled, otherwise send a featureRequiresCookies event
      if (nike.util.BrowserUtil.checkCookieEnabled()) {
        nike.dispatchEvent(nike.Event.SHOW_REGISTER, {originalEvent: e, element: $(e.currentTarget), modal: true});
      } else {
        nike.dispatchEvent(nike.Event.FEATURE_REQUIRES_COOKIES, {feature: 'register'});
      }
    });

    /*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Clicks in member logged in drop down setup @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**/
    self.$loginMenu
      .on(nike.interactionType.click, '[js-hook="logout"]', function (e) {
        e.preventDefault();
        e.stopPropagation();
        // fire event for analytics
        nike.dispatchEvent(nike.Event.PROFILE_MENU_ITEM_CLICKED, {navItems: [$(this).attr('data-tracking')]});
        //nike.exp.profile.ProfileStateController.logout();
        //Use Unite to logout
        nike.unite.session.logout(function logoutSuccess() {
          nike.exp.profile.ProfileStateController.logout();
          nike.unite.destroyAllViews();
          nike.unite.views.login.render();
        }, function logoutFailure(result, code) {
          nike.error("Unite logout failure: " + code);
        });
      });

    self.$loginMenu.find('.js-navList .js-navItem').not('[js-hook=logout]')
      .on(nike.interactionType.click, function (event) {
        event.preventDefault();
        event.stopPropagation();

        var state = nike.exp.profile.ProfileStateController.getUserState();

        //if user doesn't have all required cookies then user isn't fully logged in
        var showLogin = !state.isSwoosh && !(state.loggedIn && !state.shallow);

        var eventData = {
          navItems: [$(this).attr('data-tracking')]
        };

        // Add additional information to handle the redirect
        if (!showLogin) {
          $.extend(eventData, nike.navUtil.getLinkEventProperties(event));
        }
        // fire event for analytics
        nike.dispatchEvent(nike.Event.PROFILE_MENU_ITEM_CLICKED, eventData);

        // Now show the login if needed
        if (showLogin) {

          self.sendShowLoginEvent({'modal': true, "link": $(this).attr('href')});

        }
      });
    /*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ENDS: Clicks in member logged in drop down setup @@@@@@@@@@@@@@@@@@@@@@@@@@@@
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**/

  },

  setContext: function () {
    var self = nike.exp.profile.Login;

    self.inDropdown = self.$loginElement.parent('.login_dropdown').length;
    self.inModal = self.$loginElement.parent('.login_modal').length;
    self.isStandAlone = $('#accountStandalone.new_login').exists();
    self.isStandAloneRegister = $('.js-standaloneRegister').exists();
  },

  /**
   * Send a show login event only if the user has cookies enabled.  If they don't, send a FeatureRequiresCookies event.
   */
  sendShowLoginEvent: function (loginEventData) {
    //Dispatch the login event if the browser has cookies enabled, dispactch a 'cookies required for feature event'
    if (nike.util.BrowserUtil.checkCookieEnabled()) {
      nike.dispatchEvent(nike.Event.SHOW_LOGIN, loginEventData);
    } else {
      nike.dispatchEvent(nike.Event.FEATURE_REQUIRES_COOKIES, {feature: 'login'});
    }
  },

  setupListeners: function () {

    var self = nike.exp.profile.Login;

    if (!Modernizr.touch) {
      $(window).on('scroll.loginDropdown', $.throttle(500, self.handleScrollEvent));
    }

    /**
     * Handle a successful login
     */
    nike.listen(nike.Event.LOGIN_SUCCESS, function (event, data) {
      nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});
    });

    /**
     * Handle a successful login with pass complex fail
     */
    nike.listen(nike.Event.LOGIN_SUCCESS_NEED_PASSWORD_RESET, function (element, data) {

      nike.dispatchEvent(nike.Event.SHOW_PASSWORD_RESET, data);

    });

    nike.listen(nike.Event.SHOW_LOGIN, function (event, data) {
      self.toggleLogin(true, data);
      nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN);

      $(window).on('click.loginDropDownClose', function (event) {
        if (!$(event.target).parents('.login_dropdown, [js-hook="exp-join-login"]').length || (event.target
                                                                                               === self.$loginMask.get(0))) {
          if (self.$loginElement.hasClass('is-active')) {
            nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});
          } else {
            $(window).unbind('click.loginDropDownClose');
          }
        }
      });
    });

    /**
     * Handle the hide event by removing the overlay and hiding the login
     * dropdown/popup
     */
    nike.listen(nike.Event.HIDE_LOGIN, function () {
      self.toggleLogin(false, {modal: self.inModal});
      $(window).unbind('click.loginDropDownClose');
    });

    nike.listen(nike.gadget.Event.MINI_CART_OPEN, function () {
      if (nike.exp.profile.ProfileStateController.getUserState().loggedIn) {
        nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
      } else {
        nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});
      }
    });

    /**
     * Handle SubNav being shown
     */
    nike.listen(nike.gadget.Event.SUB_NAV_VISIBLE, function () {
      if (nike.exp.profile.ProfileStateController.getUserState().loggedIn) {
        nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
      } else {
        nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});
      }
    });

    /**
     * Handle join/login hide
     */
    nike.listen(nike.Event.SHOW_MEMBER_SECTION, function (e, data) {
      var truncatedDisplayName,
        $avatarHolder = $('.nav-section.profile .avatar');
      // We need firstName and lastName but this is not avail. from cartSummary service,
      // Lets save a reference from the profile service for display purposes.
      truncatedDisplayName = data.displayName;

      // if user is in ja_JP locale and length is greater than 10 characters, truncate the displayName
      if (nike.LOCALE == "ja_JP") {
        if (truncatedDisplayName && truncatedDisplayName.length > 10) {
          truncatedDisplayName = truncatedDisplayName.substr(0, 8) + self.ELLIPSIS + self.ELLIPSIS;
        }
      } else {
        // BST 02/21/2014 (JIRA: EDF-25100)
        //  Because ja_JP will have attached on honorific, we need to remove that honorific when
        //  switching to any other language from the language tunnel.
        if (truncatedDisplayName.indexOf('さん') > 0) {
          truncatedDisplayName = truncatedDisplayName.substring(0, truncatedDisplayName.indexOf('さん'));
        }
      }

      //Truncate the name that appears in the header if it's longer than TRUNCATE_LENGTH and append ELLIPSIS
      if (truncatedDisplayName && truncatedDisplayName.length > self.TRUNCATED_DISPLAY_NAME_LENGTH) {
        truncatedDisplayName = truncatedDisplayName.substr(0, self.TRUNCATED_DISPLAY_NAME_LENGTH) + self.ELLIPSIS;
      }
      self.toggleJoinAndLogin(false);
      if (data) {
        if (data.avatarURL && data.avatarURL != "/profile/assets/img/default-profile-img.png") {
          // Update the Header Avatar Path
          $avatarHolder.find('span').hide();
          nike.exp.profile.Login.checkAvatarHeight(nike.exp.profile.Login.getFullAvatarProfileURL(data.avatarURL), $avatarHolder);
        } else {
          $avatarHolder.find('span').show();
          $avatarHolder.css({'background-size': '', 'background-image': ""}).removeClass('profile-image');
          ;
        }
        self.$memberFacet.find('[js-hook="username"]').html(truncatedDisplayName);
      }
      self.toggleMemberSection(true);
    });

    /**
     * Handle join/login show
     */
    nike.listen(nike.Event.HIDE_MEMBER_SECTION, function (event, data) {
      self.toggleJoinAndLogin(true);
      self.toggleMemberSection(false);

      if (Modernizr.touch) {
        $('#body').off('touchstart.closememberdropdown');
      }
    });

    nike.listen( nike.Event.SHOW_MEMBER_DROPDOWN, function () {
      self.$memberFacet.addClass( 'is-active' );
      self.$memberFacet.find('.js-rootItem').attr('aria-expanded', true);
      self.$loginMenu.attr('aria-expanded', true);
      self.$loginMenu.attr('aria-hidden', false);
      self.openMemberDropDown();
      nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
      if($('[js-hook="gnav-help-container"]').is('.is-active')){
        nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
      }

      if (Modernizr.touch) {
        $('#body').off('touchstart.closememberdropdown').on('touchstart.closememberdropdown', function () {
          nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
        });
      }
    });

    nike.listen(nike.Event.HIDE_MEMBER_DROPDOWN, self.closeMemberDropDown);

    nike.listen(nike.Event.UNITE_LOGIN_SUCCESS, self.handleUniteRegisterLoginSuccess.bind(self));
    nike.listen(nike.Event.UNITE_REGISTER_SUCCESS, self.handleUniteRegisterLoginSuccess.bind(self));

    //TODO: This is somehow doing the initial rendering of the Join/Login text; this needs to be moved to a pageLoad function
    // Might run immediately so needs to be at the bottom of the listeners
    nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.USER_LOADED,
      function () {
        var state = nike.exp.profile.ProfileStateController.getUserState();
        nike.dispatchEvent(nike.Event.SHOW_MEMBER_SECTION, state);
        nike.exp.profile.Login.updateSwooshState(state.loggedIn && state.isSwoosh);
      });

    // Might run immediately so needs to be at the bottom of the listeners
    nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN,
      function () {
        //Show Join And Login
        var state = nike.exp.profile.ProfileStateController.getUserState();
        self.toggleJoinAndLogin(true);
        nike.dispatchEvent(nike.Event.HIDE_MEMBER_SECTION, state);
        nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, state);
        nike.exp.profile.Login.updateSwooshState(state.loggedIn && state.isSwoosh);
      });
    //END TODO

  },

  handleUniteRegisterLoginSuccess: function (event, data) {
    var isRegister = !!data && !!data.joinModel;
    nike.unite.session.getUserProfile(
      function uniteLoginSuccessHandler(userProfile, userType) {
        if (!userProfile) {
          return null;
        }

        var user = userProfile.entity;

        nike.exp.profile.ProfileStateController.loginFromUnite(user, user.account);

        /*
         Step 1: Convert userProfile to a user state
         - basically what "var state = nike.exp.profile.ProfileStateController.getUserState()" is currently doing
         - repurposed from fromUserData() in UserState.js
         */
        var state = nike.exp.profile.ProfileStateController.convertUniteUserToState(user,userType);

        /*
         Step 2: Fire the event with the 'state' object
         - since we know that a login just happened, we can fire the SHOW_MEMBER_SECTION event here. In other places (i.e. page loads)
         we will need to determine the state first before firing the appropriate event (i.e. HIDE_MEMBER_SECTION)
         */
        nike.dispatchEvent(nike.Event.SHOW_MEMBER_SECTION, state);
        nike.dispatchEvent(nike.Event.LOGIN_SUCCESS, {
          response: userProfile.account,
          isRegister: isRegister
        });
        if (isRegister) {
          nike.dispatchEvent(nike.Event.REGISTER_SUCCESS, { response: state, user: user});
        }
      }.bind(this),
      function uniteLoginFailureHandler() {
        //TODO: yea, failures will happen. Lets handle it here
        return null;
      }.bind(this));
  },

  handleScrollEvent: function () {
    var state = nike.exp.profile.ProfileStateController.getUserState();
    if (!nike.gadget.OneNikeNav.isScrolling
        && state.loggedIn
        && nike.exp.profile.Login.$memberDropDown.is(":visible")) {
      nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
    }
  },

  /**
   * Shows or hides the loading icon for the login dropdown
   *
   * @param {boolean} [showSwitch]
   */
  toggleLoadingIcon: function (showSwitch) {
    var container = nike.exp.profile.Login.$loginElement.find('.oneNike-login-container');
    var overlay = container.find('.oneNike-login-overlay');
    var content = container.find('.oneNike-login-content');
    var showLoadingIcon = showSwitch;
    var isShowing = !overlay.hasClass('hidden');

    if (typeof showLoadingIcon !== 'boolean') {
      showLoadingIcon = !isShowing;
    }

    if (showLoadingIcon && !isShowing) {
      overlay.css('height', content.height());
    }

    overlay.toggleClass('hidden', !showLoadingIcon);
    content.toggleClass('hidden', showLoadingIcon);
  },

  /**
   * Display or hide the join, login, and register facets
   *
   * @param {Boolean} show TRUE if visible, FALSE otherwise
   */
  toggleJoinAndLogin: function (show) {
    var self = nike.exp.profile.Login;

    function joinAndLoginDisplayUnlessStandalone(bool) {
      if (self.isStandAloneRegister || self.isStandAlone) {
        return true; // Always hide if on a standalone register page.
      } else {
        return bool;
      }
    }

    self.$globalNav.find('[js-hook="exp-join-login"],.register').toggleClass('hidden', joinAndLoginDisplayUnlessStandalone(!show));
  },

  openMemberDropDown: function () {
    var self = nike.exp.profile.Login;
    self.$memberFacet.addClass('is-active');
    if (!self.$loginMenu.filter(':animated').length) {
      self.$loginMenu.growAndShow({
        action: 'open'
      });
    }
  },

  closeMemberDropDown: function () {
    var self = nike.exp.profile.Login;
    self.$memberFacet.removeClass( 'is-active' );
    self.$memberFacet.find('.js-rootItem').attr('aria-expanded', false);
    self.$loginMenu.attr('aria-expanded', false);
    self.$loginMenu.attr('aria-hidden', true);
    if ( !self.$loginMenu.filter(':animated').length ) {
      if ( self.$loginMenu.hasClass( 'is-active' ) ) {
        self.$loginMenu.growAndShow( {
          action : 'close'
        } );
      }
    }
  },

  /**
   * Show or hide the Login
   */
  toggleLogin: function (show, data) {
    var self = nike.exp.profile.Login;
    // One Standalone login page, only use inline login form.
    if (self.isStandAlone) {
      return;
    }

    if (!data || !data.modal) {
      if (!$('.login_dropdown').find(self.$loginElement).length) {
        self.$loginElement.appendTo('.login_dropdown').find('.oneNike-login-container').addClass('hidden');
      }

      // Toggle the login mask
      self.$loginMask.toggle(show);
      $('html').toggleClass('modal-show', show);

      // Toggle the dropdown
      self.$loginFacet.toggleClass('is-active', show);
      self.$loginElement.growAndShow({
        action: show ? 'open' : 'close'
      });
    }

    self.setContext();
  },

  /**
   * Show/hide the member section
   * @param show (boolean) True for show, false for hide
   */
  toggleMemberSection: function (show) {
    nike.exp.profile.Login.$memberFacet.toggleClass('hidden', !show);
  },

  /**
   * This will update the global nav to show that user is a swoosh user.
   *
   * @param isSwooshUser  A boolean that will decide if the user is a swoosh user.
   */
  updateSwooshState: function (isSwooshUser) {
    var self = nike.exp.profile.Login;
    var helpLink;
    var helpDropDown = self.$globalNav.find('div.is-normal-dd');
    var swooshDropDown = self.$globalNav.find('div.is-swoosh-dd');

    if (isSwooshUser) {
      //Added class to the home button to change position of the background image.
      self.$globalNav.addClass('is-swoosh');
      helpLink = self.$globalNav.find('a.exp-onenikenav-help');
      $('body').addClass('Swoosh');
      helpLink.attr('href', helpLink.attr('data-swoosh-path'));

      // swap the help dropdown to the swoosh version if the user is logged in as swoosh user
      if (helpDropDown.length && swooshDropDown.length) {
        helpDropDown.removeClass('exp-help-dropdown').addClass('exp-help-dropdown-normal');
        swooshDropDown.removeClass('exp-help-dropdown-swoosh').addClass('exp-help-dropdown');
      }

    } else {
      self.$globalNav.removeClass('is-swoosh');
      helpLink = self.$globalNav.find('[js-hook="gnav-help-link"]');
      $('body').removeClass('Swoosh');
      helpLink.attr('href', helpLink.attr('data-path'));

      // swap the help dropdown to the non-swoosh version if the user is NOT logged in as swoosh user
      if (helpDropDown.length && swooshDropDown.length) {
        helpDropDown.addClass('exp-help-dropdown').removeClass('exp-help-dropdown-normal');
        swooshDropDown.addClass('exp-help-dropdown-swoosh').removeClass('exp-help-dropdown');

        // if the helpDropDown has the data-qa attribute, swap that around as well so this doesn't break automation
        if (swooshDropDown.attr('data-qa')) {
          helpDropDown.attr('data-qa', 'darkbar.help.options');
          swooshDropDown.attr('data-qa', '');
        }
      }
    }
  },

  getFullAvatarProfileURL: function (avatarURL) {
    var fullUrl = nike.getServiceUrl('baseBrandURL') + nike.exp.profile.Login.AVATAR_PREFIX + avatarURL;

    if (fullUrl.search(/_50.jpg/i) == -1) {
      fullUrl += "_50.jpg";
    }
    return fullUrl;
  },

  checkAvatarHeight: function (avatarUrl, container) {
    var bgImg = $('<img />');
    bgImg.hide();
    bgImg.bind('load', function () {
      var h = $(this).height();
      var w = $(this).width();
      if (w != h) {
        if (w > h) {
          container.css({
            'background-image': 'url(' + avatarUrl + ')',
            'background-size': '20px auto',
            'background-repeat': 'no-repeat',
            'background-color': '#fff',
            'background-position': 'center center'
          }).addClass('profile-image');
        } else if (h > w) {
          container.css({
            'background-image': 'url(' + avatarUrl + ')',
            'background-size': 'auto 20px',
            'background-repeat': 'no-repeat',
            'background-color': '#fff',
            'background-position': 'center center'
          }).addClass('profile-image');
        }
      } else {
        container.css({
          'background-size': '20px',
          'background-position': 'center center',
          'background-repeat': 'no-repeat',
          'background-image': 'url(' + avatarUrl + ')'
        }).addClass('profile-image');
      }
    });
    $('body').append(bgImg);
    bgImg.attr('src', avatarUrl);
  }

};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.Login. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.profile.PasswordReset');
nike.requireDependency('nike.exp.profile.ProfileStateController');

nike.exp.profile.PasswordReset = {
    screenName:undefined,
    curPass:undefined,
    passResetModal:undefined,
    passwordChangedFlag:false,

    startupPasswordReset : function() {
        var element = $('#passwordStandalone');

        if(element.size() == 0){
            element = $('.new_password_reset');
        }
        nike.exp.profile.PasswordReset.setupEvents(element);
        nike.exp.profile.PasswordReset.setupListeners(element);
    },

    setupListeners:function(element) {
         /**
         * Handle Show Password Reset Event
         */
        nike.listen(nike.Event.SHOW_PASSWORD_RESET,function(event, data){
          if( $('.password-complexity-updater').hasClass('is-hidden') ) {
            $('.password-complexity-updater').removeClass('is-hidden');
          }
          if( ! $('.successful-pass-reset').hasClass('hidden') ) {
            $('.successful-pass-reset').addClass('hidden');
          }

          var form = $('.passwordUpdater-form');
          nike.exp.profile.PasswordReset.clearResetFields(form);

          nike.exp.profile.PasswordReset.show(true, data);
        });

        /**
         * Handle Hide Password Reset Event
         */
        nike.listen(nike.Event.HIDE_PASSWORD_RESET, function (event, data){
            nike.exp.profile.PasswordReset.show(false, data);
            if($('.passwordResetEmailInput').hasClass('hidden')){
                $('.passwordResetEmailInput').removeClass('hidden');
                $(".emailSentTo").text("");
                $('.emailSuccessfulMessage').addClass('hidden');
            }
	        if(nike.exp.profile.PasswordReset.passwordChangedFlag){
		        nike.exp.profile.Login.triggerStatusRefresh();
	        }
        });

        /**
         * Handle Cancel Password Reset Event
         */
        nike.listen(nike.Event.CANCEL_PASSWORD_RESET, function (){
          if(!nike.exp.profile.PasswordReset.passwordChangedFlag){
            // log out user
            nike.exp.profile.ProfileStateController.logout();
          }
          nike.dispatchEvent(nike.Event.HIDE_PASSWORD_RESET, {});
        });

        /**
         * Handle Password Reset Success
         */
        nike.listen(nike.Event.PASSWORD_RESET_SUCCEEDED, function () {
            if($('.password-complexity-updater').is(':visible')){
                $('.password-complexity-updater').addClass('hidden');
                $('.successful-pass-reset').removeClass('hidden');
            }
          nike.exp.profile.PasswordReset.passwordChangedFlag = true;
        });
        /**
         * Handle Password Reset Failure
         */
        nike.listen(nike.Event.PASSWORD_RESET_FAILED, function (event, data) {
            nike.exp.profile.PasswordReset.error(data);
        });
    },

    setupEvents:function(element){
        if (element.parents().is($("#content")) === false) {
            nike.exp.profile.PasswordReset.setupModal(element);
            $('close-button').show();
        }else{
            element.find('.closeWindow-button').on("click",function(event){
		            nike.navUtil.redirectToRegionalHomepage();
                });
            $('.close-button').hide();
        }

        //remove error field error message on click
        element.find(".passwordUpdater-form label").bind({
            focusin: function (event) {
                nike.exp.profile.PasswordReset.clearError(element.find(".passwordUpdater-form"));
            },
            click: function (event) {
                nike.exp.profile.PasswordReset.clearError(element.find(".passwordUpdater-form"));
            }
        });
        element.find(".continue-button").on("click",function(event){
            event.preventDefault();
            event.stopPropagation();
            nike.dispatchEvent(nike.Event.HIDE_PASSWORD_RESET, {});
        });

        var submitForm = function(event) {
            event.preventDefault();
            event.stopPropagation();
            var passwordResetForm = $(element).find('form');
            nike.exp.profile.PasswordReset.submit(passwordResetForm);
        };

        //bind keyboard events
        element.find("form").bind({
            submit: function(event) {
                    submitForm(event);
            },
            keyup: function(event) {
                if (event.keyCode == '13') {
                    submitForm(event);
                }
            }
        });


        element.find('.passwordReset-trigger').on("click", function (event) {
            event.preventDefault();
            event.stopPropagation();
            submitForm(event);
        });

        element.find('.passwordReset-cancel').on("click", function (event) {
            nike.exp.profile.PasswordReset.clearError(element.find(".passwordUpdater-form"));
            nike.dispatchEvent(nike.Event.CANCEL_PASSWORD_RESET, {});
        });

        nike.dispatchEvent(nike.Event.PASSWORD_RESET_SETUP_COMPLETE, {element: element});
    },
    setupModal:function(element){

        nike.exp.profile.PasswordReset.passResetModal = new nike.store.ui.widgets.ModalDialog({
            setContent: function($container) {
                $container.append(element);
            },
            onClose: function(el) {
                nike.dispatchEvent(nike.Event.CANCEL_PASSWORD_RESET, {});
            },
            positionAbsolute: false,
            noDestroy: true,
            autoShow: false,
            blockerClickCloses: false
        });
        nike.exp.profile.PasswordReset.passResetModal.init();

        element.find('.closeWindow-button').bind({
            click:function(event){
                event.preventDefault();
                event.stopPropagation();
              nike.dispatchEvent(nike.Event.CANCEL_PASSWORD_RESET, {});
            }
        });
        
        element.removeClass('is-hidden');
       
        this.passwordResetPasswordListener();
    },

    passwordResetPasswordListener : function() {
        var screenName,
            passwordEl = $(".passwordUpdater-form").find("input[name=password]"),
            passwordMeterDiv = $('.password-meter');

        passwordEl.keyup(function(){
            screenName = nike.exp.profile.PasswordReset.screenName;
            nike.Validation.passwordStrength(passwordEl.val(), screenName);
        });

        passwordEl.bind({
            focusin: function() {
                screenName = nike.exp.profile.PasswordReset.screenName;
                passwordMeterDiv.css('display','block');
                nike.Validation.passwordStrength(passwordEl.val(), screenName);
            },
            focusout: function() {
                passwordMeterDiv.css('display','none');
            }
        });
    },

    /**
     *Submit the form
     */
    submit : function(passResetForm) {
        //Innocent until proven guilty!
        var valid = true;
        var passEl = $(passResetForm).find('input[name="password"]');
        var curPass = $(passResetForm).find('input[name="currentPassword"]');
        var confirmPassEl = $(passResetForm).find('input[name="passwordConfirm"]');
        valid = nike.Validation.validateForm(passResetForm);

        if(valid){
            var formData = {
                password: curPass.val(),
                newPassword: passEl.val(),
                passwordConfirm: confirmPassEl.val()
            };
            nike.exp.profile.CpcStateController.requireState(nike.exp.profile.CPC_STATE.BASIC_READY).done(
                function () {
                  var update = nike.profile.api.password.update(formData);
                  update.done(nike.exp.profile.PasswordReset.options.success);
                  update.fail(nike.exp.profile.PasswordReset.options.error);
                }).fail(nike.exp.profile.PasswordReset.options.error);
        }
    },
    /*
     * Temporary success fail event handlers for the services response from Profile this needs further definition
     */
    options: {
        success: function () {
            nike.dispatchEvent(nike.Event.PASSWORD_RESET_SUCCEEDED, {});
        },
        error: function (collection, response) {
            nike.dispatchEvent(nike.Event.PASSWORD_RESET_FAILED, {data:response});
        }
    },

    /**
     *Clear the inputs
     */
    clearResetFields : function(element){
        element = $(element);
        element.find("input.text-input").val('');
        element.find("input, select").removeClass("invalid");
    },

    clearError : function(element) {
        element = $(element);
        element.find(".error-message").html("");
        element.find(".error").remove();
    },

    error : function(data) {
      var curPass = $('.passwordUpdater-form [name=currentPassword]');
      var errorMsg = $(curPass).data('error-match');
      curPass.addClass('invalid');
      nike.Validation.notifyState(curPass, errorMsg);
    },

    /**
     * Show or hide the window as a modal popup
     */
    show : function(show, data){
        var modalview = typeof data.modal == "undefined" ? true : data.modal;
        if (show){
            if (modalview) {
                nike.exp.profile.PasswordReset.curPass=data.currentpassword;
                nike.exp.profile.PasswordReset.screenName=data.currentscreenname;
                nike.exp.profile.PasswordReset.passResetModal.show();
            } else {
                this.clearError(data.element);
                this.clearLoginFields(data.element);
            }
        } else {
            if (modalview) {
                nike.exp.profile.PasswordReset.passResetModal.close();
            } else {
                if (typeof data.hide !== undefined && data.hide || typeof data.hide === undefined){
                    nike.navUtil.redirectToRegionalHomepage();
                }
            }
            this.clearError(data.element);
            this.clearResetFields(data.element);
        }
    }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.profile.PasswordReset. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
if(nike.namespace){nike.namespace('nike.exp.global.templates._TypeAhead');}
   (function() { 
     var template = Handlebars.template, 
         templates = Handlebars.templates = Handlebars.templates || {}; 
     templates['_TypeAhead'] = template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "  <ul role=\"listbox\">\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.results : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "  </ul>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "      <li id=\"search-suggestion-"
    + alias4(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
    + "\">\n        <a class=\"ta-link\" data-term=\""
    + alias4(((helper = (helper = helpers.typeAheadString || (depth0 != null ? depth0.typeAheadString : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"typeAheadString","hash":{},"data":data}) : helper)))
    + "\" data-searchtype=\""
    + alias4(((helper = (helper = helpers.searchType || (depth0 != null ? depth0.searchType : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"searchType","hash":{},"data":data}) : helper)))
    + "\" href=\""
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\">"
    + ((stack1 = ((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"label","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</a>\n      </li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.show : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true}); 
   })();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templates._TypeAhead. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
/*globals window, document, $, jQuery, nike */

/**
 * Global Top Navigation for OneNike
 * @namespace OneNikeNav
 */

nike.namespace('nike.gadget.OneNikeNav');

nike.requireDependency('Class');
nike.requireDependency('Modernizr');
nike.requireDependency('jQuery');
nike.requireDependency('jQuery.hoverIntent');
nike.requireDependency('jQuery.growandshow');
nike.requireDependency('requestAnimationFrame');
nike.requireDependency('nike');
nike.requireDependency('nike.gadget.AccessibleNav');
nike.requireDependency('nike.ScriptLoader');
nike.requireDependency('nike.EventBus');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.Validation');
nike.requireDependency('nike.NavigationUtil');
nike.requireDependency('nike.ServiceUtil');
nike.requireDependency('nike.interactionType');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.gadget.CartCount');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('nike.gadget.desktop.GlobalNavNotifier');
nike.requireDependency('nike.store.ui.widgets.ModalDialog');
nike.requireDependency('nike.page.OneNikePageLayout');
nike.requireDependency('iOS-quirks-fix');
nike.requireDependency('nike.exp.global.BrowserCheckNotifier');
nike.requireDependency('nike.geo.Configuration');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.exp.global.SelectBox');
nike.requireDependency('nike.exp.profile.Register');
nike.requireDependency('nike.exp.profile.Login');
nike.requireDependency('nike.exp.profile.PasswordReset');
nike.requireDependency('nike.exp.profile.ProfileStateController');
nike.requireDependency('jQuery.throttle');
nike.requireDependency('nike.exp.global.templates._TypeAhead');

nike.gadget.OneNikeNav.TRACKING_ATTRIBUTE = 'data-nav-tracking';
nike.gadget.OneNikeNav.TRACK_CLICK_ATTRIBUTE = 'data-track-click';
nike.gadget.OneNikeNav.TRACKING_CARTRIDGE = 'data-tracking-cartridge';
nike.gadget.OneNikeNav.SUB_NAV_ATTRIBUTE = 'data-subnav';
nike.gadget.OneNikeNav.SUB_NAV_HIDE_DELAY = 25;
nike.gadget.OneNikeNav.HELP_DROPDOWN_HIDE_DELAY = 600;

/**
 * Flag indicating if this script should handle redirecting on menu item click.  If should be set to false if you intend to handle the STORE_NAV_CHANGED events manually.
 */
nike.gadget.OneNikeNav.redirectsEnabled = true;

/**
 * Bind navigation events and perform any one-off functions that are required for the navigation to work properly.
 */

nike.gadget.OneNikeNav.init = function(element){

  var $element = $(element);
  var self = this;
  var profileData = nike.exp.profile.ProfileStateController.getUserState();
  self.containerElement = $('.gnav');
  self.containerElement.data('state', 'closed');
  self.transEndEventNames = {
    'WebkitTransition' : 'webkitTransitionEnd',
    'MozTransition' : 'transitionend',
    'OTransition' : 'oTransitionEnd',
    'msTransition' : 'MSTransitionEnd',
    'transition' : 'transitionend'
  };

  self.columnNav = new nike.gadget.AccessibleNav({
    navType: 'column',
    navClass: 'server-column-nav'
  });

  self.dropDownNav = new nike.gadget.AccessibleNav({
    navType: 'dropDown',
    navClass: 'dropdown-nav'
  });

  // Toggle the global nav cart link based on feature flag
  if (nike.FEATURE_LIST.GLOBAL_NAV_CART == true) {
    $('.exp-cart-container').fadeIn('fast');
  } else {
    $('.exp-cart-container').css('display','none');
  }

  self.transEndEventName = self.transEndEventNames[ Modernizr.prefixed('transition') ];

  self.isLoginEnabled = $element.find('[js-hook="exp-join-login"]').length !== 0 || $element.find('.gnav .register').length !== 0;
  self.isCartEnabled = $element.find('[js-hook="exp-cart-count"]').length !== 0;
  self.helpContainer = self.containerElement.find('[js-hook="gnav-help-container"]');
  self.isHelpDropdownEnabled = self.helpContainer.find('.exp-help-dropdown').length !== 0;

  if(Modernizr.touch) {
    self.containerElement.on(nike.interactionType.click, '[js-hook="gnav-bar--sections"] > li > a', function(e){
      var jsHook = $(this).parent().attr('js-hook');
      self.toggleSubNav(e, jsHook);
    });

    if(self.isHelpDropdownEnabled) {
      self.helpContainer.on('click', '[js-hook="gnav-help-link"]', function(e){
        if ($(this).parent().is('.is-active')) {
          nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
        } else {
          e.preventDefault();
          e.stopImmediatePropagation();
          nike.dispatchEvent(nike.Event.SHOW_HELP_DROPDOWN, {});
        }
      });
    }
  } else {
    self.containerElement.find('[js-hook="gnav-bar--sections"] li').hoverIntent({
      over: function(e) {
        var jsHook = $(this).attr('js-hook');
        nike.dispatchEvent(nike.gadget.Event.SUB_NAV_VISIBLE, {'hook':jsHook});
      },
      out: function(e) {
      }
    }).end().find('[js-hook="gnav-bar--sections"]').hoverIntent({
      over: function(e){
      },
      timeout: self.SUB_NAV_HIDE_DELAY,
      out:function(e){
        nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
      }
    });

    if(self.isHelpDropdownEnabled) {
      self.helpContainer.hoverIntent({
        over: function(e){
          nike.dispatchEvent(nike.Event.SHOW_HELP_DROPDOWN, {});
        },
        timeout: self.HELP_DROPDOWN_HIDE_DELAY,
        out:function(e){
          nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
        }
      });
    }
  }

  self.bindWindowListeners();

  $(window).load(function () {
    self.checkNavSize();
    self.alignHelpDropdown();
  });

  setTimeout(function(){
    self.checkNavSize();
    self.alignHelpDropdown();
  },250);

  nike.listen(nike.gadget.Event.SUB_NAV_HIDDEN, function(event, data) {
    nike.gadget.OneNikeNav.closeSubNav();

    if(Modernizr.touch){
      $('#body').off('touchstart.closenav');
    }
  });

  nike.listen(nike.gadget.Event.SUB_NAV_VISIBLE, function(event, data) {
    nike.gadget.OneNikeNav.openSubNav(data.hook);
    nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
    nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});

    if(Modernizr.touch){
      $('#body').off('touchstart.closenav').on('touchstart.closenav', function(){
        nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
      });
    }
  });

  nike.listen(nike.gadget.Event.MINI_CART_OPEN, function(event, data) {
    nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
    self.containerElement.find('.tier0 .cart').addClass('is-active');
  });

  nike.listen(nike.gadget.Event.MINI_CART_CLOSE, function(event, data) {
    self.containerElement.find('.tier0 .cart').removeClass('is-active');
  });

  nike.listen([
    nike.gadget.Event.STORE_NAV_CHANGED,
    nike.gadget.Event.FACET_NAV_CHANGED,
    nike.gadget.Event.TOUT_CLICK],

    function(event, data) {
      var url = data.query;

      // Check if the incoming URL starts with http before setting the cart link
      if (url && !/returnURL/.test(url) && url.indexOf('http') === 0) {
        self.setCartLink(url);
      }
    }
  );

  nike.listen(nike.Event.SHOW_HELP_DROPDOWN, function () {

    nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
    nike.dispatchEvent(nike.Event.HIDE_LOGIN, {});

    if(self.containerElement.find('[js-hook="gnav-member-bar--userMenu"]').is('.is-active')){
      nike.dispatchEvent(nike.Event.HIDE_MEMBER_DROPDOWN, {});
    }

    self.helpContainer.addClass('is-active');
    self.helpContainer.attr('aria-expanded', true);

    self.helpContainer.find('#exp-help-dropdown').attr('aria-expanded', true);
    self.helpContainer.find('#exp-help-dropdown').attr('aria-hidden', false);

    if(Modernizr.touch){
      $('#body').off('touchstart.closehelpdropdown').on('touchstart.closehelpdropdown', function(){
        nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
      });
    }
  });

  nike.listen(nike.Event.HIDE_HELP_DROPDOWN, function () {
    self.helpContainer.removeClass('is-active');
    self.helpContainer.attr('aria-expanded', false);

    self.helpContainer.find('#exp-help-dropdown').attr('aria-expanded', false);
    self.helpContainer.find('#exp-help-dropdown').attr('aria-hidden', true);

    if(Modernizr.touch){
      $('#body').off('touchstart.closehelpdropdown');
    }
  });
  /**
   * Listen for any state changes and hide/show the corresponding global nav sections
   */
  nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN, function () {
    $('[js-hook="gnav-bar--section-nikeplus"]').addClass('hidden');
    $('[js-hook="gnav-bar--section-nikeplus-loggedin"]').removeClass('hidden');
  });

  nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN, function () {
    $('[js-hook="gnav-bar--section-nikeplus"]').removeClass('hidden');
    $('[js-hook="gnav-bar--section-nikeplus-loggedin"]').addClass('hidden');
  });

  self.containerElement.find('[js-hook="gnav-cart-link"]').attr('href', function() {
    var returnURL = window.location.href;
    return $(this).attr('href') +
           '&site=nikestore' +
           '&returnURL=' + encodeURI(returnURL).replace('#', '%23');
  });

  self.setCartLink();

  self.TypeAhead.init();

  if (!Modernizr["display-table"]) {
    this.NoDisplayTableNavFix();
  }

  //Analytics : apply the click function to all links that have the track attribute.
  this.containerElement.on(nike.Event.GLOBAL_NAV_CLICK, 'a[' + self.TRACK_CLICK_ATTRIBUTE + '="true"]:not([href="#"])', $.proxy(this.navigate,this));

  //Fix any link that is only a hash and change it to "javascript:void(0)"
  this.containerElement.find('a[href="#"]').attr("href", "javascript:void(0);");

  if (self.isCartEnabled) {
    nike.gadget.CartCount.setup(self.containerElement);
  }

  if (self.isLoginEnabled) {
    nike.gadget.OneNikeNav.loadProfileAPI();
  }

  nike.listen(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, function autoRedirectListener(){
    nike.unlisten(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, autoRedirectListener);
    var searchTermAndAutoCorrect = nike.util.UrlUtil.getParameter(window.location, 'st');
    var acData = $('#autoCorrectData');
    if(searchTermAndAutoCorrect){
      nike.dispatchEvent(nike.gadget.Event.SEARCH_AUTO_REDIRECT, {
          onsiteSearchType: 'auto redirect',
          searchTerm: decodeURIComponent(searchTermAndAutoCorrect.replace(/(\+(?!\+))/g, ' '))
      });
    } else if( acData.length ){
      nike.dispatchEvent(nike.gadget.Event.SEARCH_AUTO_REDIRECT, {
          onsiteSearchType: 'auto redirect',
          searchTerm: acData.data('term') + ":" + acData.data('autocorrect')
      });
    }
  });

  var setup = new nike.gadget.LinkRedirector.PageSetup(true);
  setup.setupEvent(nike.gadget.Event.SEARCH, 300);
  setup.setupEvent(nike.gadget.Event.STORE_NAV_CHANGED, 300);
  nike.gadget.LinkRedirector.setupPageEvents(setup);

  //Open the chat in a new small window
  self.containerElement.on(nike.interactionType.click, 'a.exp-header-chat',function(e){
    e.preventDefault();
    var chatUrl = $(this).data('chat-url');
    window.open(chatUrl,'chatwindowcn','width=626,height=436');
  });

  // Site Feedback - Usabilla
  if (nike.FEATURE_LIST.GLOBAL_NAV_FEEDBACK) {

    var str = nike.LANGUAGE + "_" + nike.COUNTRY;
    var lang = str.toLocaleLowerCase();

    nike.listen(nike.Event.USABILLA_LOADED, function() {

      self.containerElement.on(nike.interactionType.click, "a.exp-onenikenav-feedback", function(e) {
        e.preventDefault();
        window.usabilla_live("setForm", lang);
        window.usabilla_live("click");
      });

    });

  } else {
    $(".exp-feedback-container").addClass("hidden");
  }

  this.globalNavNotifier = new nike.gadget.desktop.GlobalNavNotifier();

  // update the arial-label of profile and cart glyphs
  self.applyGlyphAria();

}; //nike.gadget.OneNikeNav.init


/**
 * update the arial-label of profile and cart glyphs
 */
nike.gadget.OneNikeNav.applyGlyphAria = function () {

  var currentCartQtdy = nike.Cart.getCartCount();
  var profileGlyphAria = nike.exp.global.LocalValueUtil.getLocal('GlobalNav.profileGlyph.aria');
  var cartGlyphAria = nike.exp.global.LocalValueUtil.getLocal('GlobalNav.cartGlyph.aria');
  var $cartIcon = $('.js-gnavMemberBarCartIcon');
  var $profileIconAnchor = $('.js-gnavDefaultProfileAnchor');

  var glyphAriaReplace = function(source, value) {
    return source.replace('{1}', value);
  }

  // update the cart icon aria label with current cart count
  $cartIcon.attr('aria-label', glyphAriaReplace(cartGlyphAria, currentCartQtdy));

  // listener for get a username of profile
  nike.listen(nike.Event.SHOW_MEMBER_SECTION, function ( e, data ) {
    $profileIconAnchor.attr('aria-label', glyphAriaReplace(profileGlyphAria, data.displayName));
  });

  // listener for update the aria-label of cart when some product was added on cart
  nike.listen(nike.Event.ADD_TO_CART_SUCCESS, function (e, data) {
    $cartIcon.attr('aria-label', glyphAriaReplace(cartGlyphAria, nike.Cart.getCartCount()));
  });

};

/**
 * We need this empty function to catch any random callbacks from the jQuery typeAhead ajax calls, since we are
 * defining our own callback name (to allow for caching).
 * All responses are processed with the .done() event, but we want to be sure we swallow any errors that might happen *if*
 * the callback is ever fired.
 * @param response
 */
window.typeaheadcallback = function (response){
};

nike.gadget.OneNikeNav.TypeAhead = {
  TYPEAHEAD_MIN_CHARS : 3,
  TYPEAHEAD_MAX_CHARS : 21,
  TYPEAHEAD_MAX_RESULTS : 4,
  typeAheadRequests : null,
  selectors : {
    searchForm : '.js-gnav-search-container',
    searchInput : '.js-gnav-search-box',
    clearSearchBtn : '.js-gnav-search-clear',
    searchSuggestions : '.js-type-ahead'
  },

  init : function() {
    this.typeAheadRequests = [];
    this.setupListeners();
  },

  setupListeners : function() {
    var self = this;

    //disable the default form submission
    $(this.selectors.searchForm).on('submit', function(e){return false;});

    $(self.selectors.searchInput).on('keyup.ta cut.ta paste.ta', _.debounce(function searchKeypressHandler(e){
      var term = $(this).val().trim();

      if(e.keyCode == 13) { //Enter
        nike.gadget.OneNikeNav.submitSearch(e);
      } else if(e.keyCode == 38) { //Up Arrow
        e.preventDefault();
        self.showPreviousTerm(term);
      } else if(e.keyCode == 40) { //Down Arrow
        e.preventDefault();
        self.showNextTerm(term);
      } else if($(self.selectors.searchSuggestions).length && term.length >= self.TYPEAHEAD_MIN_CHARS && term.length <= self.TYPEAHEAD_MAX_CHARS) {
        self.getTypeAheadResults(term).done(function(data){
          self.renderTypeAhead(data.response, term);
        });
      } else { //Clear TypeAhead results
        self.renderTypeAhead();
      }

      self.handleClearButtonDisplay(term);
    }, 150));

    //Fire the search event for analytics on the click of a type-ahead option
    $(self.selectors.searchSuggestions).on('touch.ta click.ta', 'a', function suggestedTermLinkClick(e){
      e.preventDefault();

      self.displayTerm(e.currentTarget.innerText);
      self.renderTypeAhead();

      nike.dispatchEvent(nike.gadget.Event.SEARCH, {
        onsiteSearchType: 'type ahead',
        element: $(self.selectors.searchInput),
        query: $(this).attr('href'),
        searchTerm: $(this).data('term')
      });
    });

    $(self.selectors.clearSearchBtn).on('touch.ta click.ta', function(e) {
      e.preventDefault();
      self.displayTerm();
      self.renderTypeAhead();
      self.handleClearButtonDisplay();
    });
  },

  showPreviousTerm : function(currentTerm) {
    var suggestedTerms = $(this.selectors.searchSuggestions)
      .find('a').map(function(){
        return $(this).data('term');
      }).get();
    var termToShow;

    if (suggestedTerms.length) {
      switch (suggestedTerms.indexOf(currentTerm)){
        case -1: //fall through
        case 0:
          termToShow = suggestedTerms[suggestedTerms.length -1];
          break;
        default:
          termToShow = suggestedTerms[suggestedTerms.indexOf(currentTerm) - 1];
          break;
      }

      this.displayTerm(termToShow);
      this.highlightTerm(termToShow);
    }
  },

  showNextTerm : function(currentTerm) {
    var suggestedTerms = $(this.selectors.searchSuggestions)
      .find('a').map(function(){
        return $(this).data('term');
      }).get();
    var termToShow;

    if (suggestedTerms.length) {
      switch (suggestedTerms.indexOf(currentTerm)){
        case -1: //fall through
        case suggestedTerms.length - 1:
          termToShow = suggestedTerms[0];
          break;
        default:
          termToShow = suggestedTerms[suggestedTerms.indexOf(currentTerm) + 1];
          break;
      }

      this.displayTerm(termToShow);
      this.highlightTerm(termToShow);
    }
  },

  displayTerm : function(term) {
    //replace value of search input with new term
    $(this.selectors.searchInput).val(term);
  },

  highlightTerm : function(term) {
    var self = this;

    $(self.selectors.searchSuggestions).find('[data-term]:not([data-term="'+ term +'"])').removeClass('selected');
    $(self.selectors.searchSuggestions).find('[data-term="'+ term +'"]').addClass('selected');

    // get the id of item selected on list
    var highlightedItem = $(self.selectors.searchSuggestions).find('[data-term="'+ term +'"]').parent();
    var highlightedItemId = highlightedItem.attr('id');

    // set the id of suggestion selected on input attr 'aria-activedescendant'
    $(self.selectors.searchInput).attr('aria-activedescendant', highlightedItemId);


    $('body').on('touchstart mousemove keypress', function(){
      $(self.selectors.searchSuggestions).find('[data-term]').removeClass('selected');
    });
  },

  getTypeAheadResults : function(term) {
    // abort any previous typeahead requests
    while(this.typeAheadRequests.length) {
      this.typeAheadRequests.pop().abort();
    }

    var tACall = $.ajax({
      dataType:'jsonp',
      jsonpCallback: 'typeaheadcallback',
      url: nike.getServiceUrl('typeAheadSearchService'),
      cache: true,
      jsonp: "callBack",
      data: {
        'searchTerms': term,
        'limit': this.TYPEAHEAD_MAX_RESULTS
      }
    });

    // store the request so we can abort() if the user keeps typing
    this.typeAheadRequests.push(tACall);

    return tACall;
  },

  renderTypeAhead : function(list, term) {
    var template = Handlebars.templates._TypeAhead;
    var data = {
      show : false,
      results : []
    };

    if (_.isArray(list)) {
      for(var i = 0; i < list.length; i++) {
        if (list[i].link && list[i].link.keyword) {
          data.results[i] = {
            typeAheadString : list[i].link.keyword,
            searchType : 'keyword',
            url : $(this.selectors.searchForm).attr('action') + '?sl=' + list[i].link.keyword
          };
        } else if (list[i].link && list[i].link.dimValName) {
          data.results[i] = {
            typeAheadString : list[i].link.dimValName,
            searchType : 'seoslug',
            url : nike.getLocalizedRootUrl() + 'pw' + list[i].link.seoSlug.replace('_/N-','')
          };
        }
        data.results[i].label = data.results[i].typeAheadString.replace( new RegExp( "(" + nike.Util.escapeRegExp( term ) + ")" , 'gi' ), "<span>$1</span>" );
      }

      data.show = !!data.results.length;
    }

    $(this.selectors.searchSuggestions).html(template(data));
  },

  handleClearButtonDisplay: function(term) {
    // Apply class to show search clear button if there is any input value
    if (term && term.length > 0) {
      $(this.selectors.clearSearchBtn).addClass('visible');
    } else {
      $(this.selectors.clearSearchBtn).removeClass('visible');
    }
  }
};

/**
 * Show the previous search term if a redirect has occurred
 */
nike.gadget.OneNikeNav.showAutoCorrectMessage = function(){
  // the message should only be shown once per result, so don't show it again when page is sorted.
  var currSL = nike.util.UrlUtil.getParameter(window.location.href, 'sl');
  var showMsg = (!nike.gadget.OneNikeNav.sl || nike.gadget.OneNikeNav.sl && nike.gadget.OneNikeNav.sl != currSL) ? true : false;
  // store the sl for later use
  nike.gadget.OneNikeNav.sl = currSL;

  // assign the message text if it's been provided from GridWall
  var acData = $('#autoCorrectData');
  if(acData.length > 0 && showMsg){
    var self = this;
    var msg = self.autoCorrectMessage;
    var openForThisManySeconds = 5;
    // store the original message for later use
    if(!this.autoCorrectMessageText){ this.autoCorrectMessageText = msg.text() };
    // set the new message
    msg.find('.js-inner').html( self.autoCorrectMessageText.replace('~1~', acData.data('term')).replace('~2~', acData.data('autocorrect')) );
    // get the height of the message
    msg.css({ height:'auto' });
    var openH = msg.outerHeight();
    // set the height back to zero for animation
    msg.css({ height:0 });
    // animate the message on and off the screen
    msg.animate({ height:openH }, function(){
      // after the message has opened, start the timer for how long it should stay open
      var timer = setTimeout(function(){
        msg.animate({ height:0 });
      }, 1000*openForThisManySeconds);

      // add functionality to the close button
      if(!msg.data('hasCloseEvent')){
        msg.find('.js-close-button').on('click touch', function(){
          msg.data('hasCloseEvent', true);
          clearTimeout(timer);
          msg.animate({ height:0 });
        });
      }
    });
  }
};

nike.gadget.OneNikeNav.setCartLink = function(returnURL) {
    returnURL = returnURL || window.location.href;

    this.containerElement.find('[js-hook="gnav-cart-link"]').attr('href', function() {
        return $(this).attr('data-cart-url') +
           '&site=nikestore' +
           '&returnURL=' + encodeURI(returnURL).replace('#', '%23');
    });
};

nike.gadget.OneNikeNav.loadProfileAPI = function () {
  var query = window.location.search;

  // Determine how much of the profile we need to load up
  if(query && query.indexOf("s/profile") !== -1) {
    // This is the profile page and we should get the whole profile setup
    nike.gadget.OneNikeNav.setupCompleteProfile();
  } else {
    // This is a store or www site and we will need basic profile abilities
    nike.gadget.OneNikeNav.setUpBasicProfile();
  }
};

/**
 * handles the submission of the search box. basically just fires an
 * event with a new path, that gets picked up by LinkRedirector.js.
 *
 * @notes refactored by gballi 2013-12-13
 */
nike.gadget.OneNikeNav.submitSearch = function(event) {
  var delimitFirst = null;
  var delimitSecond =null;
  var self = nike.gadget.OneNikeNav;
  var searchTerm = event.target.value
    .replace(/<|>|&|#/g, '');

    // this prevent " and ' characters from breaking things
    if (searchTerm.indexOf('"') > -1 ){
      delimitFirst = "[data-term='";
      delimitSecond = "']";
    } else {
      delimitFirst = '[data-term="';
      delimitSecond = '"]';
    }

  var suggestionLink = $( delimitFirst + searchTerm + delimitSecond);

  var suggestedUrl = suggestionLink.attr('href');
  var userTypedUrl = $(event.target).parents('form').attr('action') + '?sl=' + encodeURI(searchTerm);
  var eventData = {
    onsiteSearchType: suggestionLink.data('searchtype') || 'user typed',
    searchTerm: searchTerm,
    query: suggestedUrl || userTypedUrl,
    element: $(event.target)
  };

  if(!searchTerm) {
    event.stopImmediatePropagation();
    event.preventDefault();
  }

  self.TypeAhead.renderTypeAhead();
  nike.dispatchEvent(nike.gadget.Event.SEARCH, eventData);
};

/**
 * This is the function to be executed on any link that should be tracked.
 * This will construct the nav data needed for analytics and will dispatch the
 * tracking event.
 * Then after 200 mils the page will be changed to the desired location.
 *
 * c3/cartridgeTitle analytics tag for new globalNav touts are special unicorns, hence they get their
 * own special treatment and override the default behavior for that tag
 *
 * @param {Event} event The click event that is going to navigate
 * @param {Number} [delay=200] The number of milliseconds before the navigation happens
 */
nike.gadget.OneNikeNav.navigate = function (event, delay) {
  event.preventDefault();
  event.stopPropagation();

  var next = $(event.currentTarget);
  var trackingCartridge = next.attr(this.TRACKING_CARTRIDGE);
  var list = [];
  var trackAttribute;
  var linkProperties = nike.navUtil.getLinkEventProperties(event);
  var trackingPrefix = (next.parent() && !next.parent().find('[js-hook="gnav-home"]').length && !next.parents('.gnav-member-bar').length ) ? 'shop>' : '';
  //Android always seem to get in here on touchstart, although this method is bound with a click event.
  //Trying to prevent the event from bubbling up doesn't seem to work.
  //This works better than toggling 'nike.gadget.OneNikeNav.redirectsEnabled' which could create issues in all browsers.
  //Single tap of tier0 nav, opens tier1 subnav; double tap follows through on the url.
  if(nike.util.BrowserUtil.versionSearchString.toLowerCase() === 'android'){
    if(next.parent().data('subnav') && next.parent().hasClass('is-active')){
      return false;
    }
  }
  //Step up through the dom and acquire any element with a tracking attribute
  //and add that element to the start of the list.  Stop at the global nav container element.
  while ( !next.is(this.containerElement)) {
    trackAttribute = next.attr(this.TRACKING_ATTRIBUTE);
    if (trackAttribute) {
      //Since tracking will use ">" as a delimiter, remove any html tags that may
      //have made it into the tracking attribute.
      list.unshift(trackAttribute.replace(/<\/?.*?>/g,''));
    }
    next = next.parent();
  }

  nike.dispatchEvent(nike.gadget.Event.STORE_NAV_CHANGED, {
    navItems : list,
    clicked : true,
    query : linkProperties.query,
    newWindow: linkProperties.newWindow,
    noFollow : linkProperties.noFollow && !nike.gadget.OneNikeNav.redirectsEnabled,
    navItemsFormatted : trackingCartridge || trackingPrefix + list.join('>').replace(/(\r\n|\n|\r)/gm, '')
  });

  nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
};

/**
 * Rules for how the global nav should react to scroll events.
 */
nike.gadget.OneNikeNav.onScroll = function(){
  var openSubNav = this.containerElement.find('[js-hook="gnav-bar--sections"] li.is-active');
  var self = this;
  var $input = self.containerElement.find('.gsearch');

  if(Modernizr.touch && $input.is(':focus')) {
    // Put 40 in so keyboard doesnt auto close when touching the screen.
    // It will close when you scroll at least 40 pixels away from the top.
    if($(window).scrollTop() > 40) $input.trigger('blur');
  }

  if(openSubNav.length){
    nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
  }
  /*
  if(self.helpContainer.find('.exp-help-dropdown').is('.is-active')){
    nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
  }
  */
};

/**
 * Rules for how the global nav should react to resize events.
 */
nike.gadget.OneNikeNav.onResize = function() {
  var $this = this;
  nike.gadget.OneNikeNav.updateViewport();

  nike.gadget.OneNikeNav.updateLogIn();

  this.containerElement.find('.gsearch').trigger('blur');

  setTimeout(function(){
    $this.checkNavSize();
    $this.alignHelpDropdown();
  },250);
};

nike.gadget.OneNikeNav.checkNavSize = function() {
  if (this.containerElement.find('.tier0').width() > $(window).width()) {
    if (!this.navScrolling) {
      this.setNavBarScolling(true);
      this.navScrolling = true;
    }

  } else if (this.navScrolling) {
    this.setNavBarScolling(false);
    this.navScrolling = false;
  }
};

nike.gadget.OneNikeNav.setNavBarScolling = function(bind) {
    var $lightBar = this.containerElement.find('.tier0'),
        $win = $(window);

    if (bind) {
      $win.bind('scroll', $.throttle(50, nike.gadget.OneNikeNav.repositionBar));
    } else {
      $win.unbind('scroll', nike.gadget.OneNikeNav.repositionBar);
      $lightBar.css('left', 0);
    }
};

nike.gadget.OneNikeNav.repositionBar = function() {

    //Touch devices allow fixed position overflow, so don't readjust them:
    if(Modernizr.touch){
      return;
    }

    var $lightBar = nike.gadget.OneNikeNav.containerElement.find('.tier0'),
        $win = $(window);

    if ($lightBar.width() - $win.scrollLeft() > $win.width()) {
      $lightBar.css('left', $win.scrollLeft() * -1);
    } else {
      $lightBar.css('left', $win.width() - $lightBar.width());
    }
};

nike.gadget.OneNikeNav.updateLogIn = function() {
  if (nike.exp && nike.exp.profile && nike.exp.profile.Login) {
    var $loggedIn = this.containerElement.find('.logged-in');
    if ($loggedIn.outerWidth() >= 160) {
      //Update the logged in menu to match the logged in section since it is not meant to take up the whole window the the
      //rest of the menus.
      this.containerElement.find('.oneNike_memberLoggedIn').css({"min-width":$loggedIn.outerWidth()+"px"});
    } else {
      //If menu area is to small, then hide the menu.
      if ($loggedIn.hasClass('is-active')) {
        $loggedIn.trigger('click');
      }
    }
  }
};

nike.gadget.OneNikeNav.updateViewport = function() {

  var $tag = $('meta[name=viewport]');

  //mobile phones, display 100 percent of the viewable page
  if(screen.width && screen.width <= 480) {
    $tag.attr('content', 'width=device-width');
    //tablet and desktop set initial scale to 1.0
  } else {
    $tag.attr('content', 'width=device-width, initial-scale=1');
  }
}

/**
 * Open the subnav panel
 * @param {String} hook a string indicating which subnav item is to be opened.
 * @param {object} ariaInfo -- passes in selectors and aria targets from AccessibleNav instances
 */

nike.gadget.OneNikeNav.openSubNav = function (hook, ariaInfo) {
  var self = this;

  // get aria info from ariaInfo parameter or set default values
  var parentItemAria =  ariaInfo && ariaInfo.parentItemAria || 'aria-expanded';
  var parentItemSelector = ariaInfo && ariaInfo.parentItemSelector || '.js-rootItem';
  var subNavContainerSelector = ariaInfo && ariaInfo.subNavContainerSelector || '.js-subNavContainer';
  var subNavAriaHidden = ariaInfo && ariaInfo.subNavAriaHidden || 'aria-hidden';
  var subNavAriaExpanded = ariaInfo && ariaInfo.subNavAriaExpanded || 'aria-expanded';

  // get elements
  var rootListItem = self.containerElement.find('[js-hook="'+hook+'"]');
  var rootNavItem = rootListItem.find(parentItemSelector);
  var subNavContainer = rootListItem.find(subNavContainerSelector);

  rootListItem.addClass('is-active has--focus').siblings('li').removeClass('is-active has--focus');

  // change aria attributes to indicate menu is expanded
  rootNavItem.attr(parentItemAria, true);
  subNavContainer.attr(subNavAriaHidden, false);
  subNavContainer.attr(subNavAriaExpanded, true);

};

/**
 * Close the subnav panel
  * @param {object} ariaInfo -- passes in selectors and aria targets from AccessibleNav instances
 */
nike.gadget.OneNikeNav.closeSubNav = function (ariaInfo) {
  var self = this;

  // get aria info from ariaInfo parameter or set default values
  var parentItemSelector = ariaInfo && ariaInfo.parentItemSelector || '.js-rootItem';
  var rootListItem = ariaInfo && ariaInfo.rootListItemSelector || '.js-rootListItem';
  var parentItemAria =  ariaInfo && ariaInfo.parentItemAria || 'aria-expanded';
  var subNavContainerSelector = ariaInfo && ariaInfo.subNavContainerSelector || '.js-subNavContainer';
  var subNavAriaHidden = ariaInfo && ariaInfo.subNavAriaHidden || 'aria-hidden';
  var subNavAriaExpanded = ariaInfo && ariaInfo.subNavAriaExpanded || 'aria-expanded';

  // get elements
  // var columnNavList = self.containerElement.find('[js-hook="gnav-bar--sections"]');
  var rootListItems = self.containerElement.find('[js-hook="gnav-bar--sections"] li'+rootListItem);
  var rootNavItems = rootListItems.find(parentItemSelector);
  var subNavContainers = self.containerElement.find('.js-subNavContainer');

  // remove active class to close sub nav
  rootListItems.removeClass('is-active has--focus');
  // change aria on root list items to indicate sub nav is closed
  rootNavItems.attr(parentItemAria, false);
  // change aria on all  sub nav containers to indicate sub nav is closed
  subNavContainers.attr(subNavAriaHidden, true);
  subNavContainers.attr(subNavAriaExpanded, false);

};

/**
 * Hide or show a navigation element, depending on its current state
 * @param {String} hook a string indicating which subnav item is to be toggled.
 */
nike.gadget.OneNikeNav.toggleSubNav = function (e, hook) {
  var self = this;
  var $el = self.containerElement.find('[js-hook="' + hook + '"]');

  if ($el.is('.is-active')) {
    nike.dispatchEvent(nike.gadget.Event.SUB_NAV_HIDDEN, {});
  } else {
    e.preventDefault();
    nike.dispatchEvent(nike.gadget.Event.SUB_NAV_VISIBLE, {'hook':hook});

    if(self.helpContainer.is('.is-active')){
      nike.dispatchEvent(nike.Event.HIDE_HELP_DROPDOWN, {});
    }
  }
};

nike.gadget.OneNikeNav.NoDisplayTableNavFix = function() {
  var $gnav = this.containerElement,
  $tier0 = $gnav.find('.tier0'),
  $targetEl = $tier0.find('.search, .l-spacer-cell'),
  $allNavItems = $targetEl.siblings(), // all nav items except search
  $visibleNavItems = $allNavItems.filter(':visible'); // filter hidden items

  if ($targetEl.nextAll().filter(':visible').length > 0) {
    var setSearchWidth = function() {
      var width = 0,
      searchResize = 0,
      navWidth = $gnav.outerWidth();

      $visibleNavItems = $allNavItems.filter(':visible');
      $visibleNavItems.each(function(){
        width += $(this).outerWidth();
      });

      searchResize = navWidth - width - 2;
      $targetEl.css({
        'width' : searchResize,
        'float' : 'left'
      });
    };

    setSearchWidth();

    $allNavItems.on('propertychange', '.facet-label', function() {
      setSearchWidth();
    });

    // IE9 support for propertychange
    $allNavItems.each(function () {
      this.attachEvent('onpropertychange', function () {
        setSearchWidth();
      });
    });

    nike.Util.windowResizeListen(function(){
      setSearchWidth();
    });
  }
};

/**
 * This is the complete profile for use in the profile page
 */
nike.gadget.OneNikeNav.setupCompleteProfile = function () {
  // TODO: There is an error in modernizr that calls the callback before the code has executed
  // TODO: A solution should be found to solve that problem, however, this is a work around

  var attempts = 0;
  var complete = function () {
    if(nike.objectDefined("nike.exp.accountsettings.accountSettings")) {
      $(nike.exp.accountsettings.accountSettings.init);
    } else {
      if(attempts < 50) {
        setTimeout(complete, 50);
        attempts++;
      }
    }
  };

  nike.gadget.OneNikeNav.setUpBasicProfile();

  var resources = [
    nike.getRootUrl() + "common/scripts/NikeProfileGlobal.js",
    nike.getRootUrl() + "common/scripts/backbone-0.9.2.min.js",
    nike.getRootUrl() + "common/scripts/jquery.Jcrop.min.js"
  ];

 nike.loadExternalResources(resources, complete);
};

/**
 * This is the basic profile for use in www.nike.com or store.nike.com when not on the profile page
 */
nike.gadget.OneNikeNav.setUpBasicProfile = function () {
  $(function () {
    nike.exp.profile.Login.startupLogin();
    nike.exp.profile.Register.startup();
    nike.exp.profile.PasswordReset.startupPasswordReset();
    nike.dispatchEvent(nike.gadget.Event.LOGIN_SETUP_COMPLETE, {});
  });
};

/**
 * Adjusts the Help Dropdown so that it doesn't break the page dimensions
 */
nike.gadget.OneNikeNav.alignHelpDropdown = function () {
  var screenWidth = $(window).width();
  var $helpDropdown = $('.exp-help-dropdown ul');
  var $swooshHelpDropdown = $('.exp-help-dropdown-swoosh ul');

  if( !$helpDropdown.length ) return false;

  var rightPosition = $helpDropdown.offset().left + $helpDropdown.outerWidth();

  if (screenWidth < rightPosition) {
    var currentRight = parseInt($helpDropdown.css('right'), 10);
    var rightOffset = Math.ceil(rightPosition - screenWidth);
    var adjustedRight = Math.floor(currentRight + rightOffset);

    $helpDropdown.css('right', adjustedRight);
    $swooshHelpDropdown.css('right', adjustedRight);
  }
};

/**
 * Attach listeners for window scrolling and resizing
 */
nike.gadget.OneNikeNav.bindWindowListeners = function () {

  var self = this;

  $(window).on('scroll.gNav', $.throttle(250, $.proxy(nike.gadget.OneNikeNav.onScroll, self)));

  if(Modernizr.touch) { // Android fires resize on viewport zoom, so listen for orientationchange instead
    window.addEventListener('orientationchange', $.proxy( nike.gadget.OneNikeNav.onResize, self ) );
  } else {
    nike.Util.windowResizeListen( $.proxy( nike.gadget.OneNikeNav.onResize, self ) );
  }
};

/**
 * When OneNikeNav gadget is loaded, call init method
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data) {
  var self = nike.gadget.OneNikeNav;

  if(data && data.gadgetName == 'nike.gadget.OneNikeNav') {
    self.init(data.element);
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.OneNikeNav. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.Shipping');

nike.requireDependency('nike.Event');

/**
 * Load shipping options
 * 
 * @param element The gadget element
 * @param success Callback for a successful request
 * @param fail Callback for a failed request
 * @param refresh Force a request to load shipping options
 */
nike.Shipping.loadShippingOptions = function(element, success, fail, refresh){
  var gadgetAppName;
  var data;
  
  if (!element){
    nike.error('Gadget "element" must be defined when calling loadShippingOptions');
  }
  else{
    var responseData = {'success':false};
    
    // Success function
    function doSuccess(response){
      nike.dispatchEvent(nike.Event.GET_SHIPPING_OPTIONS_SUCCESS, 
          {'element':element, 'response':response});
      
      // Call callback
      if (success){
        success(response);
      }
    }
    
    // Fail function
    function doFail(response, element){
      var result = {'element':element, 'response':response};
      nike.dispatchEvent(nike.Event.GET_SHIPPING_OPTIONS_FAIL, 
          result);

      // Call fail callback
      if (fail){
        fail(result);
      }
    }
    
    if (!refresh && nike.Shipping.options){
      doSuccess(nike.Shipping.options, element);
    }
    else{
      // Get the app name according to the gadget calling this function
      gadgetAppName = nike.DEFAULT_APP_NAME;
      
      data = {'country':nike.COUNTRY,
              'lang_locale':nike.LOCALE,
              'rt':'JSON',
              'action':'getAllShippingMethods'};
  
      // Dispatch GET_SHIPPING_OPTIONS event
      nike.dispatchEvent(nike.Event.GET_SHIPPING_OPTIONS,
          {'element':element});
      
      // Make request
      $.ajax({
    	  dataType:'jsonp',
    	  url: nike.getServiceUrl('shippingMethods'),
          data: data,
          success: function(response){
        	  if (response.status === 'success'){
        		  doSuccess(response);
        	  } else {
        		  doFail(response, element);
        	  }
          },
          error: function(response){
              response.errorMessages = [response.toString()];
              doFail(response, element);
            }
      });
    }
  }
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Shipping. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.SiteIdUtil');

nike.requireDependency('nike.Event');
nike.requireDependency('nike.Cart');
nike.requireDependency('nike.exp.profile.ProfileStateController');

nike.SiteIdUtil.html = {siteIds :  {SITE_ID_US_STORE : 70, SITE_ID_US_SWOOSH : 72, SITE_ID_EMEA : 71, SITE_ID_JP_STORE : 91, SITE_ID_JP_SWOOSH : 92, SITE_ID_CN_STORE : 94, SITE_ID_CN_SWOOSH : 95} };
nike.SiteIdUtil.mobile = {siteIds : {SITE_ID_US_STORE : 73, SITE_ID_US_SWOOSH : 72, SITE_ID_EMEA : 74, SITE_ID_JP_STORE : 93, SITE_ID_CN_STORE : 96} };

/**
 * Get the default SiteId for the Nikestore.
 */
nike.SiteIdUtil.getDefaultSiteId = function(callback, sitePresentation) {

  //Default to using html presentation site ids if no presentation is specified
  var siteIds = nike.SiteIdUtil.html.siteIds;

  // Using the US Store in case of errors but I don't want anyone to use this so it's not a constant
  var defaultSiteId;

  if(sitePresentation == 'html'){
    siteIds = nike.SiteIdUtil.html.siteIds;
  } else if (sitePresentation == 'mobile'){
    siteIds = nike.SiteIdUtil.mobile.siteIds;
  }

  defaultSiteId = siteIds.SITE_ID_US_STORE;

  var callbackWithRegion = function(region){
    if(nike.exp.profile.ProfileStateController.userState.isSwoosh) {
      callback(siteIds["SITE_ID_"+region+"_SWOOSH"])
    }else{
      callback(siteIds["SITE_ID_"+region+"_STORE"])
    }
  };

  switch (nike.REGION){
    case "US":
    case "JP":
    case "CN":
      callbackWithRegion(nike.REGION);
      break;
    case "EMEA":
      callback(siteIds.SITE_ID_EMEA);
      break;
    default:
      nike.warn("Region " + nike.REGION + " is not configured with a default Site ID.");
      callback(defaultSiteId);
  }

};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.SiteIdUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.gadget.MiniCart');

nike.requireDependency('nike.Cart');
nike.requireDependency('nike.CurrencyUtil');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.gadget.Gadget');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('nike.gadget.OneNikeNav');
nike.requireDependency('nike.ImageUtil');
nike.requireDependency('nike.Shipping');
nike.requireDependency('nike.SiteIdUtil');

nike.gadget.MiniCart = nike.gadget.Gadget.extend({

  init: function(el) {
    this.MINI_CART_AUTO_CLOSE = 5000;
    this.cartQuantity = null;
    this.cartTotal = null;
    this.gadgetElement = el;
    this.cartContainerElement = el.find('.mini-cart');
    this.isTablet = Modernizr.touch;
    this.startYPos = parseInt(this.cartContainerElement.css('top'), 10);

    this.updateCartLinks();
    this.bindListeners();
    this.viewCartClick();
    this.checkOutClick();
    this.setupLinkRedirector();
  },

  setupLinkRedirector: function() {
    var setup = new nike.gadget.LinkRedirector.PageSetup(true);
    setup.setupEvent(nike.Event.CHECKOUT_CLICK);
    setup.setupEvent(nike.Event.VIEW_CART_CLICK);
    nike.gadget.LinkRedirector.setupPageEvents(setup);
  },

  updateCartLinks: function() {
    // Get the location of the top frame and catch an exception in case
    // this violates the same origin policy
    var returnURL = window.location.href;
    try {
      returnURL = top.location.href;
    } catch (e) {
      throw new Error(e);
    }

    // Add return URL to cart link
    this.gadgetElement.find('.view-cart-button, .checkout-button').attr('href', function() {
      return $(this).attr('data-query') + '&site=nikestore' + '&returnURL=' + encodeURI(returnURL).replace('#', '%23');
    });
  },

  truncatePrice: function(price) {
    if (price) {
      price = price.replace(/[.,]00(\D|$)/, '$1');
    } else {
      price = '';
    }
    return price;
  },

  /**
   * Populate the mini cart fields with information
   * from the current order
   *
   * @param element Gadget DOM element
   * @param order response loaded order
   */
  // TODO - refactor this!!!!!!
  populateOrderInfo: function(order, productId, isNikeId, qty) {

    function getOrderItemQuantity(order) {
      var quantity = 0;
      if (order.shippingGroups && order.shippingGroups.length > 0) {
        for (var i = 0; i < order.shippingGroups.length; i++) {
          commerceItems = order.shippingGroups[i].commerceItems;
          if (commerceItems && commerceItems.length > 0) {
            for (var j = 0; j < commerceItems.length; j++) {
              quantity += parseInt(commerceItems[j].quantity, 10);
            }
          }
        }
      }
      _self.cartQuantity = quantity;
      return quantity;
    }

    var _self = this;
    var cartContent = this.cartContainerElement.find('.cart-content');
    var item, size, commerceItems, price, onSale, imageUrl, shippingGroups;

    // replace this with toggle cart/locker states
    // this.toggleCart
    cartContent.addClass('cart').removeClass('locker');
    this.loadShippingMessage(true);

    if (typeof order === 'undefined') {
      throw new Error('missing order information');
    }

    var orderItemQuantity = getOrderItemQuantity(order); // order.itemQuantity counts number of commerce items, not total item count.
    var viewButton = this.cartContainerElement.find('.view-cart-button');
    var checkoutButton = this.cartContainerElement.find('.checkout-button');

    viewButton.html(viewButton.html().replace(/\(\d*\)/, '(' + orderItemQuantity + ')'));
    shippingGroups = order.shippingGroups;

    // Find latest added commerce item
    if (shippingGroups && shippingGroups.length > 0) {

      // if productId is defined, or it is a nikeid product, find the last element by looking into different shippingGroups.
      if (productId || isNikeId) {
        var itemFound;

        for (var group in shippingGroups) {
          commerceItems = shippingGroups[group].commerceItems;
          viewButton = this.cartContainerElement.find('.view-cart-button');
          viewButton.html(viewButton.html().replace(/\(\d*\)/, "(" + orderItemQuantity + ")"));
          shippingGroups = order.shippingGroups;

          // Find latest added commerce item
          if (shippingGroups && shippingGroups.length > 0) {
            for (ndex = shippingGroups.length - 1; ndex >= 0; ndex--) {
              var shipGroup = shippingGroups[ndex];
              var itemFound;
              commerceItems = shipGroup.commerceItems;
              if (commerceItems && commerceItems.length > 0) {
                itemFound = commerceItems[commerceItems.length - 1];
                if ((productId && itemFound.product.id == productId) ||
                    (isNikeId && itemFound.commerceItemClassType == 'nikeid')) {
                  item = itemFound;
                  break;
                } else {
                  // failback check, ideally we should find it above.
                  item = itemFound;
                }
              }
            }
          }
        }

      } else { // productId is not defined. Use the old logic to find just added element
        commerceItems = shippingGroups[shippingGroups.length - 1].commerceItems;
        if (commerceItems && commerceItems.length > 0) {
          item = commerceItems[commerceItems.length - 1];
        } else if (shippingGroups.length > 1 && shippingGroups[shippingGroups.length - 2] && shippingGroups[shippingGroups.length - 2].commerceItems) {
          /*
           * Sometimes (or perhaps consistently) there are multiple shipping groups returned and the last one tend to just have empty objects;
           * if that is the case, look at the second to last shipping group and grab the last commerceitem.
           * Based on my testing, we never seem to get into the `if`, 2 lines above, but I'm leaving it there just in case I missed a scenario.
           * OCP should just remove that blank shippinggroup from the cartservice response but that seems not to be a priority at this point.
           */
          commerceItems = shippingGroups[shippingGroups.length - 2].commerceItems;
          item = commerceItems[commerceItems.length - 1];
        }
      }
    }

    // Show cart layout and not locker
    this.gadgetElement.find('.cart-item-data').show();
    this.gadgetElement.find('.locker-item-data').hide();

    // Update cart values
    cartContent.find('.subtotal-value').html(this.truncatePrice(order.priceInfo.formattedAmount));
    // Also update the price total value for analytics purposes
    _self.cartTotal = order.priceInfo.rawSubtotal;

    // TODO refactor this!
    if (item && item.product) {
      var isConfigurable = item.commerceItemClassType === 'nikeConfigurableCommerceItem';

      onSale = item.priceInfo.onSale;

      if (onSale && onSale !== 'false') {
        price = item.priceInfo.formattedAmount;
      } else {
        price = item.priceInfo.formattedListPrice;
      }

      // TODO - imageUrl assignment should be in the constructor or in a proper method
      // Build correct image URL
      if (isNikeId || item.commerceItemClassType === 'nikeid') {

        if (item.metricId) {
          imageUrl = nike.getServiceUrl('nikeIDImageRedirect') + '/mtr-' + item.metricId + '/bgc-na/wid-100/fmt-png-alpha/';
        } else if (isConfigurable) {
          imageUrl = $('.alt-image[data-index="0"]').attr('src');
          imageUrl += '&fmt=png-alpha&wid=100';
        } else {
          imageUrl = item.imageUrl + '&fmt=png-alpha&wid=100';
        }

      } else {
        var removeQueryParam = true;
        imageUrl = nike.ImageUtil.getInlineImageUrl({
          style: item.product.styleNumber,
          color: item.product.colorNumber,
          format: 'png-alpha'
        }, removeQueryParam);
      }

      cartContent.find('.recent-item-image img').attr('src', imageUrl);
      cartContent.find('.product').html(item.product.displayName);

      if (qty && qty > 0 && qty >= item.quantity) {
        cartContent.find('.quantity-value').html(qty);
      } else {
        cartContent.find('.quantity-value').html(item.quantity);
      }

      // Use showPrice / hidePrice methods once you need to check against feature flags.
      this.showPrice(price, cartContent);

      cartContent.find('.item-total-value').html(item.priceInfo.formattedAmount);

      // if not null or 'cm' and not in China, then prepend it
      if(
        item.sizeType
        && item.sizeType !== 'null'
        && item.sizeType !== 'cm'
        && !['CN'].contains(nike.COUNTRY)
      ){
        size = item.sizeType + ' ';
      } else {
        size = '';
      }

      if (item.displaySize && item.displaySize.length > 0) {
        size += item.displaySize;
      } else if (item.sizeDescription) {
        size += item.sizeDescription;
      }

      if (item.sizeType === 'cm') {
        size += ' ' + item.sizeType;
      }

      cartContent.find('.size-value').html(size);

      // Show gift card information
      if (item.product.nikeType === 'GIFTCERTIFICATE' || item.product.nikeType === 'DIGITALGIFTCERTIFICATE') {

        if (item.message && item.message !== 'None') {
          var giftMessage;

          if (item.message.length > 125) {
            giftMessage = item.message.substring(0, 122) + '...';
          } else {
            giftMessage = item.message;
          }
          cartContent.find('.giftcard-message').html(giftMessage);
        } else {
          cartContent.find('.giftcard-message').html(cartContent.find('.giftcard-message').data('none'));
        }
        cartContent.find('.non-giftcard-data').hide();
        cartContent.find('.giftcard-data').show();
      } else {
        cartContent.find('.giftcard-data').hide();
        cartContent.find('.non-giftcard-data').show();
      }

      // Show color or message for NIKEiD
      if (isNikeId) {
        cartContent.find('.nike-id-color').show();
        cartContent.find('.color-value').hide();
      } else {
        cartContent.find('.nike-id-color').hide();
        cartContent.find('.color-value').show();
        cartContent.find('.color-value').html(item.colorDescription);
      }
      cartContent.find('.recent-item').show();
      cartContent.find('.empty-cart').hide();
    } else {
      cartContent.find('.recent-item').hide();
      cartContent.find('.empty-cart').show();
    }
  },

  populateLockerInfo: function(wishlistItems) {
    var cart = this.cartContainerElement.find('.cart-content');
    var item;
    var imageUrl;
    var _self = this;

    cart.addClass('locker').removeClass('cart');

    nike.Cart.loadCartSummary(nike.DEFAULT_APP_NAME, function(data) {
      // Show locker layout and not cart
      cart.find('.cart-item-data').hide();
      cart.find('.giftcard-data').hide();
      cart.find('.locker-item-data').show();

      // Populate values from last added item
      if (wishlistItems) {
        item = wishlistItems;

        if (item.product) {
          // TODO - imageUrl assignment should be in the constructor or in a proper method
          // Build correct image URL
          imageUrl = nike.ImageUtil.getInlineImageUrl({
            style: item.product.styleNumber,
            color: item.product.colorNumber,
            format: 'png-alpha'
          });

          cart.find('.recent-item-image img').attr('src', imageUrl);
          cart.find('.product').html(item.product.displayName);
          cart.find('.quantity-value').html(item.quantity);
          cart.find('.color-value').html(item.product.colorDescription);
          var onSale = item.product.onSale;
          var dpid = item.itemData && item.itemData.recipeId && item.itemData.recipeId !== null;
          var countryCode = nike.COUNTRY;
          var iso = nike.CurrencyUtil.getCurrencyCodeByCountry(countryCode);
          var price, size;
          var vasPrice = 0;

          if (item.childProduct) {
            if (data.response.userType === nike.Cart.UserType.EMPLOYEE && item.childProduct.product.employeeDiscount) {
              vasPrice = item.childProduct.product.employeePrice;
            } else if (item.childProduct.product.onSale) {
              vasPrice = item.childProduct.product.salePrice;
            } else {
              vasPrice = item.childProduct.product.listPrice;
            }
          }

          if (data.response.userType === nike.Cart.UserType.EMPLOYEE && item.product.employeeDiscount) {
            if (dpid) {
              price = _self.truncatePrice(nike.CurrencyUtil.formatCurrency(Number(vasPrice) + Number(item.product.employeePrice), iso));
            } else {
              price = item.product.formattedEmployeePrice;
            }
          } else {
            if (onSale) {
              if (dpid) {
                price = _self.truncatePrice(nike.CurrencyUtil.formatCurrency(Number(vasPrice) + Number(item.product.salePrice), iso));
              } else {
                price = item.product.formattedSalePrice;
              }
            } else {
              if (dpid) {
                price = _self.truncatePrice(nike.CurrencyUtil.formatCurrency(Number(vasPrice) + Number(item.product.listPrice), iso));
              } else {
                price = item.product.formattedListPrice;
              }
            }
          }

          if (nike.FEATURE_LIST['PRICING_WISHLIST']) {
            _self.showPrice(price, cart);
          } else {
            _self.hidePrice(cart);
          }

          if (data.response.userType === nike.Cart.UserType.EMPLOYEE) {
            cart.find('.locker-item-data a').attr('href', function() {
              return $(this).attr('href') + '&wfp=true';
            });
          }

          if (item.displaySizeTypeLabel) {
            size = item.displaySizeTypeLabel + ' ';
          } else {
            size = '';
          }
          if (item.sku) {
            var displaySize;
            if (item.sku.displaySize) {
              displaySize = item.sku.displaySize;
            } else {
              displaySize = item.sku.sizeDescription;
            }
            cart.find('.size-value').html(size + displaySize);
          }
        }
      }
    });
  },

  /**
   * Populate the mini cart fields with information
   * from the current NIKEiD order
   *
   * @param locker Wishlist service response object
   */
  populateNikeIdInfo: function(locker) {
    var cart, item, imageUrl;

    cart = this.cartContainerElement.find('.cart-content');
    cart.addClass('locker').removeClass('cart');
    item = locker.lockerItem[0];

    if (item.metricId) {
      imageUrl = nike.getServiceUrl('nikeIDImageRedirect') + '/mtr-' + item.metricId + '/bgc-na/wid-100/fmt-png-alpha/';
    }

    // hide cart items
    cart.find('.item-title .cart-item-data').hide();
    cart.find('.empty-cart').hide();
    cart.find('.cart-item-data.subtotal-row').hide();
    cart.find('.giftcard-data').hide();
    cart.find('.recent-item .size-container').hide();
    cart.find('.recent-item .qty-container').hide();
    cart.find('.shipping-message').hide();
    cart.find('.cart-item-data').hide();

    // show wishlist items
    cart.find('.locker-item-data').show();
    cart.find('.recent-item-image img').attr('src', imageUrl);
    cart.find('.recent-item img').removeClass('is-hidden');
    cart.find('.recent-item-image img').attr('alt', item.productName);
    cart.find('.product').html(item.productName);
    cart.find('.locker-buttons').show();
  },

  /**
   * Show the @ symbol if it is hidden, and add the price into the correct element
   * @param price
   * @param cart
   */
  showPrice: function(price, cart) {
    cart.find('.quanity-price-symbol').show();
    cart.find('.quantity-price-value').html(this.truncatePrice(price));
    cart.find('.quantity-price-suffix').show();
  },

  /**
   * Hide the @ symbol and empty the price element
   * @param cart
   */
  hidePrice: function(cart) {
    cart.find('.quanity-price-symbol').hide();
    cart.find('.quantity-price-value').html('');
    cart.find('.quantity-price-suffix').hide();
  },

  /**
   * Expand the mini cart.
   *
   * @param element StoreHeader gadget element
   * @param isLocker Boolean indicating if showing the mini-locker
   */
  displayCart: function() {
    var _self = this;
    var cart = this.cartContainerElement;
    nike.dispatchEvent(nike.gadget.Event.MINI_CART_OPEN, {
      'element': this.gadgetElement
    });
    if (this.isTablet) {
      $(document).scrollTop('50');
    }
    $(document).bind('click', $.proxy(this.checkCloseClick, this));
    // Open cart. Slide down duration for the message is set to half a second
    cart.slideDown(200, function() {
      cart.children().fadeTo(200, 1, function() {
        cart.data('lastInteraction', new Date().getTime());
        checkAutoClose();
      });
    });

    // Setup auto close
    function checkAutoClose() {
      var now = new Date().getTime();
      // If over cart update the timestamp
      if (cart.hasClass('hover')) {
        cart.data('lastInteraction', now);
        setTimeout(checkAutoClose, 500);
      } else {
        if (now - cart.data('lastInteraction') > _self.MINI_CART_AUTO_CLOSE) {
          _self.hideCart();
        } else {
          setTimeout(checkAutoClose, 500);
        }
      }
    }
  },

  hideCart: function() {
    var cart = this.cartContainerElement;

    nike.dispatchEvent(nike.gadget.Event.MINI_CART_CLOSE, {
      'element': this.gadgetElement
    });
    cart.children().fadeTo(200, 0, function() {
      cart.slideUp(200);
    });
  },

  checkCloseClick: function(ev) {
    var t = $(ev.target);
    var cart;

    if (t.hasClass('mini-cart')) {
      cart = t;
    } else {
      cart = t.parents('.mini-cart');
    }

    if (!t.length) {
      this.hideCart();
    }
  },

  /**
   * Request upsell shipping message to show
   * sk - included this for legacy support, but it doesn't seem to be called from anywhere now, it was called in the ADD_TO_CART_SUCCESS event before
   * probably will be removed
   *
   * this was call in the event listener:
   * nike.gadget.MiniCart.loadShippingMessage(gadget, true);
   */
  // TODO check to remove this method
  loadShippingMessage: function(refresh) {
    var shipping = this.gadgetElement.find('.shipping-message');

    // Get upsell message from shipping options
    shipping.empty();
    shipping.hide();
    nike.Shipping.loadShippingOptions(this.gadgetElement, function(data) {
      if (data.upsellMessage.message) {
        shipping.html(data.upsellMessage.message).show();
      }
    }, null, refresh);
  },

  bindListeners: function() {
    var _self = this;

    nike.listen(nike.gadget.Event.HISTORY_STATE_CHANGED, $.proxy(this.updateCartLinks, this));

    // re-position the cart if the notifier is present
    nike.gadget.OneNikeNav.globalNavNotifier.initialResizePromise.done(function(data) {
      _self.cartContainerElement.css('top', _self.startYPos + data.newHeight);
    });

    nike.listen(nike.gadget.Event.NOTIFIER_RESIZED, function(ev, data) {
      _self.cartContainerElement.css('top', _self.startYPos + data.newHeight);
    });

    /**
     * Listen for the add to cart event to update minicart
     */
    nike.listen(nike.Event.ADD_TO_CART_SUCCESS, function(event, data) {
      if (_.isEmpty(data)) return;
      var qty = 0;
      if (data.qty) {
        qty = data.qty;
      }
      if (!data.productId && nike.objectDefined('nike.exp.pdp.PdpPage.currentProduct')) {
        data.productId = nike.exp.pdp.PdpPage.currentProduct.productId;
      }
      _self.populateOrderInfo(data.response.order, data.productId, data.isNikeId, qty);
      nike.gadget.CartCount.setup($('[data-gadget="nike.gadget.OneNikeNav"]'));
      _self.displayCart();
    });

    nike.listen(nike.Event.ADD_WISHLIST_ITEM_SUCCESS, function(event, data) {
      var inline = data.response.wishlist; // Inline, Socks ICPDP, DigitalPiD, JerseyID
      var nikeId = data.response.locker; // NIKEiD PDP
      if (inline) {
        if(
          nike.objectDefined('exp.pdp.PdpPage.currentProduct', nike)
          && nike.exp.pdp.PdpPage.currentProduct.digitalPiD
        ){
          inline.wishlistItems.quantity = data.requestData.quantity;
        }
        _self.populateLockerInfo(inline.wishlistItems);
        _self.displayCart();
      }

      if (nikeId) {
        _self.populateNikeIdInfo(nikeId);
        _self.displayCart();
      }
    });

    this.gadgetElement.delegate('div.close', 'click', function() {
      _self.hideCart();
    });
    this.gadgetElement.bind({
      mouseover: function() {
        _self.cartContainerElement.addClass('hover');
      },
      mouseout: function() {
        _self.cartContainerElement.removeClass('hover');
      }
    });
  },

  checkOutClick: function() {
    var _self = this;
    this.gadgetElement.find('.checkout-button').bind('click', function(event) {
      event.preventDefault();
      var addToCartFormEl = $('.add-to-cart-form');
      var eventData = nike.navUtil.getLinkEventProperties(event);
      if (addToCartFormEl.length > 0) {
        // inline pdp
        if (nike.objectDefined('nike.exp.pdp.PdpPage')) {
          var siteIdCheck = addToCartFormEl.find('[name="siteId"]').val();
          if (!siteIdCheck) {
            nike.SiteIdUtil.getDefaultSiteId(function(siteId) {
              siteIdCheck = siteId;
            });
          }
          nike.exp.pdp.PdpPage.currentProduct.trackingData.product.qty = _self.cartQuantity;
          nike.exp.pdp.PdpPage.currentProduct.trackingData.product.totalCartValue = _self.cartTotal;
          nike.exp.pdp.PdpPage.currentProduct.trackingData.product.siteId = siteIdCheck;
        }
      } else if ($('#trackingObject').length > 0) {
        // Update the nikeID tracking object for analytics
        $('span#trackingObject').data('trackingData').product.qty = _self.cartQuantity;
        $('span#trackingObject').data('trackingData').product.totalCartValue = _self.cartTotal;
      }
      nike.dispatchEvent(nike.Event.CHECKOUT_CLICK, eventData);
    });
  },

  viewCartClick: function() {
    this.gadgetElement.find('.view-cart-button').bind('click', function(event) {
      event.preventDefault();
      var eventData = nike.navUtil.getLinkEventProperties(event);
      nike.dispatchEvent(nike.Event.VIEW_CART_CLICK, eventData);
    });
  }
});

/**
 * Setup gadget when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data) {
  if (data && data.gadgetName === 'nike.gadget.MiniCart') {
    $(data.element).data(nike.GADGET_INSTANCE, new nike.gadget.MiniCart(data.element));
  }
});
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.MiniCart. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
if(nike.namespace){nike.namespace('nike.exp.global.templates.GeodetectBanner');}
   (function() { 
     var template = Handlebars.template, 
         templates = Handlebars.templates = Handlebars.templates || {}; 
     templates['GeodetectBanner'] = template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return "    \r\n\r\n<div class=\"geolocator geodetect-banner geolocator nsg-font-family--platform nsg-bg--grey nsg-text--white\">\r\n  <div class=\"wrap\">\r\n    <div class=\"header\">\r\n      "
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"geolocator.brandmessage1",{"name":"getLocal","hash":{},"data":data}))
    + "\r\n    </div>\r\n    \r\n    <div id=\"exp-geo-compare-country\" class=\"option opt1\" country=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.compareCountry : depth0)) != null ? stack1.countryCode : stack1), depth0))
    + "\" language=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.compareCountry : depth0)) != null ? stack1.supportedLanguageList : stack1), depth0))
    + "\">\r\n      <a href=\"javascript:void(0);\" class=\"nsg-button nsg-grad--near-white\" >\r\n        <span>"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.compareCountry : depth0)) != null ? stack1.displayName : stack1), depth0))
    + "</span>\r\n      </a>\r\n    </div>\r\n    \r\n    <div id=\"exp-geo-original-country\" class=\"option opt2\" country=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.originalCountry : depth0)) != null ? stack1.countryCode : stack1), depth0))
    + "\" language=\""
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.originalCountry : depth0)) != null ? stack1.supportedLanguageList : stack1), depth0))
    + "\">\r\n      <a href=\"javascript:void(0);\" class=\"nsg-button nsg-grad--near-white\" >\r\n        <span>"
    + alias3(alias4(((stack1 = (depth0 != null ? depth0.originalCountry : depth0)) != null ? stack1.displayName : stack1), depth0))
    + "</span>\r\n      </a>\r\n    </div>\r\n    \r\n    <div id=\"exp-geo-see-all\" class=\"seeall\"><a class=\"nsg-text--white\" href=\"javascript:void(0);\">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"geolocator.brand.see.all.countries",{"name":"getLocal","hash":{},"data":data}))
    + "</a></div>\r\n  </div>\r\n  \r\n  <div class=\"bg_bottom\"></div>\r\n</div>";
},"useData":true}); 
   })();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templates.GeodetectBanner. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.GeodetectBanner');
nike.requireDependency('HandlebarsRuntime');
//Including jquery which means this component cannot be rendered serverside (which is fine for this one)
nike.requireDependency('jQuery');
nike.requireDependency('nike.geo.Util');
nike.requireDependency('nike.geo.Configuration');
nike.requireDependency('nike.exp.global.TemplateHelpers');

nike.requireDependency('nike.exp.global.templates.GeodetectBanner');

/**
 * Create a banner to display if the country that is currently in the url does not match the country geo thinks the user is in.
 *
 */
nike.exp.global.GeodetectBanner = _.extend(nike.exp.global.GeodetectBanner, {

  animationTime : 500,
  maxDisplayTime : 15000,
  _currentRemoveTimer : undefined,

  TEMPLATE_NAME : 'GeodetectBanner',

  displayBanner : function(bannerElement, originalCountry, compareCountry){
    var bannerMarkup = '';
    var localValues;
    var $bannerElement = $(bannerElement);
    var bannerTop;
    var originalCountryButton, compareCountryButton, seeAllButton;
    var originalCountryObj, compareCountryObj;

    //Only execute if the countries really are different
    if(originalCountry && compareCountry &&
       originalCountry.toLowerCase() != compareCountry.toLowerCase()){

      if(Handlebars && Handlebars.templates[nike.exp.global.GeodetectBanner.TEMPLATE_NAME]){

        //Render template
        originalCountryObj = nike.geo.Configuration.getCountryConfiguration(originalCountry);
        compareCountryObj = nike.geo.Configuration.getCountryConfiguration(compareCountry);
        bannerMarkup = Handlebars.templates[nike.exp.global.GeodetectBanner.TEMPLATE_NAME](
            {originalCountry : originalCountryObj, compareCountry : compareCountryObj});

        $bannerElement
          .hide()
          .html(bannerMarkup);

        //get buttons
        originalCountryButton = $bannerElement.find("#exp-geo-original-country");
        compareCountryButton = $bannerElement.find("#exp-geo-compare-country");
        seeAllButton = $bannerElement.find("#exp-geo-see-all");


        //Setup event listeners
        compareCountryButton.bind('click', function(event) {
          var countryId = $(this).attr('country');
          event.preventDefault();
          nike.debug('They chose the compare country -- countryId: '+ countryId);
          // Redirect to the new country without a locale, which will force the default
          nike.geo.Util.redirectToLocale(countryId, null, true, 0, nike.geo.Util.getPathWithoutLocale());
          nike.exp.global.GeodetectBanner.removeBanner($bannerElement);
        });

        originalCountryButton.bind('click', function(event) {
          var countryId = $(this).attr('country');
          event.preventDefault();
          nike.debug('They chose the original country -- countryId: '+ countryId);
          nike.geo.Util.updateUserLocaleSettings(nike.COUNTRY, nike.LOCALE, true);
          nike.exp.global.GeodetectBanner.removeBanner($bannerElement);
        });

        seeAllButton.bind('click', function(event) {
            nike.geo.Util.redirectToLanguageTunnel();
            nike.exp.global.GeodetectBanner.removeBanner($bannerElement);
        });



        //Slide the banner in from the top - we have to show it before jquery will measure the height

        bannerTop = 0 - parseInt($bannerElement.show().height());

        $bannerElement.children().first()
          .css('top', bannerTop + 'px')
          .animate({"top": "0px"}, nike.exp.global.GeodetectBanner.animationTime);

        //Setup a timeout to close the banner after it's been displayed for a while
        nike.exp.global.GeodetectBanner._currentRemoveTimer = setTimeout(function(){
          nike.exp.global.GeodetectBanner.removeBanner(bannerElement);
          }, nike.exp.global.GeodetectBanner.maxDisplayTime);
      }

    }

  },

  removeBanner : function(bannerElement){
    //hide the banner and kill dom elements
    var $bannerElement = $(bannerElement);
    var bannerTop;

    if($bannerElement.length > 0){

      if(nike.exp.global.GeodetectBanner._currentRemoveTimer !== undefined){
        clearTimeout(nike.exp.global.GeodetectBanner._currentRemoveTimer)
      }
      bannerTop = 0 - parseInt($bannerElement.height());
      $bannerElement.children().first()
        .animate({"top": bannerTop + 'px'},
            {duration : nike.exp.global.GeodetectBanner.animationTime,
             complete : function(){$bannerElement.empty();}}
        );
    }
  }

});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.GeodetectBanner. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
if(nike.namespace){nike.namespace('nike.exp.global.templates.GeodetectNotifier');}
   (function() { 
     var template = Handlebars.template, 
         templates = Handlebars.templates = Handlebars.templates || {}; 
     templates['GeodetectNotifier'] = template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "  <div class=\"exp--geodetect-notifier--language-variants-container nsg-font-family--base js-exp--geodetect-notifier--language-variants-container\">\r\n    <span class=\"exp--geodetect-notifier--language-select-title nsg-font-family--platform\">"
    + container.escapeExpression((helpers.getLocal || (depth0 && depth0.getLocal) || helpers.helperMissing).call(alias1,"languageSelector.select.language",{"name":"getLocal","hash":{},"data":data}))
    + "</span>\r\n    <div class=\"exp--geodetect-notifier--keyline nsg-keyline--horizontal\"></div>\r\n    <div class=\"exp--geodetect-notifier--language-variants js-exp--geodetect-notifier--language-variants\">\r\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.variants : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "    </div>\r\n  </div>\r\n";
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "      <div class=\"js-exp--geodetect-notifier--"
    + container.escapeExpression(((helper = (helper = helpers.key || (data && data.key)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"key","hash":{},"data":data}) : helper)))
    + "--language-variants exp--geodetect-notifier--is-transparent\">\r\n"
    + ((stack1 = helpers.each.call(alias1,depth0,{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "      </div>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "          <div class=\""
    + alias4(((helper = (helper = helpers.column || (depth0 != null ? depth0.column : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"column","hash":{},"data":data}) : helper)))
    + "exp--geodetect-notifier--language-variant\">\r\n            <a href=\""
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\" class=\"exp--geodetect-notifier--link js-exp--geodetect-notifier--link\" data-country=\""
    + alias4(((helper = (helper = helpers.country || (depth0 != null ? depth0.country : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"country","hash":{},"data":data}) : helper)))
    + "\" data-lang=\""
    + alias4(((helper = (helper = helpers.lang || (depth0 != null ? depth0.lang : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"lang","hash":{},"data":data}) : helper)))
    + "\">"
    + alias4(((helper = (helper = helpers.urlText || (depth0 != null ? depth0.urlText : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"urlText","hash":{},"data":data}) : helper)))
    + "</a>\r\n          </div>\r\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4=container.lambda;

  return alias3((helpers.requireDependency || (depth0 && depth0.requireDependency) || alias2).call(alias1,"nike.exp.global.TemplateHelpers",{"name":"requireDependency","hash":{},"data":data}))
    + "\r\n\r\n<div class=\"exp--geodetect-notifier--content nsg-text--dark-grey\">\r\n  <div class=\"exp--geodetect-notifier--title nsg-font-family--platform\">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"geolocator.brand.header",{"name":"getLocal","hash":{},"data":data}))
    + "</div>\r\n  <div class=\"exp--geodetect-notifier--keyline nsg-keyline--horizontal\"></div>\r\n  <div class=\"exp--geodetect-notifier--flags-title nsg-font-family--base nsg-text--medium-grey\">\r\n    <a href=\""
    + alias3(((helper = (helper = helpers.languageTunnelUrl || (depth0 != null ? depth0.languageTunnelUrl : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"languageTunnelUrl","hash":{},"data":data}) : helper)))
    + "\" class=\"exp--geodetect-notifier--link see-all-countries js-see-all-countries\">"
    + alias3((helpers.getLocal || (depth0 && depth0.getLocal) || alias2).call(alias1,"geolocator.brand.see.all.countries",{"name":"getLocal","hash":{},"data":data}))
    + "</a>\r\n  </div>\r\n  <div class=\"exp--geodetect-notifier--flags\">\r\n      <img class=\"exp--geodetect-notifier--flag js-exp--geodetect-notifier--flag\" src=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.alternate : stack1)) != null ? stack1.flag : stack1), depth0))
    + "\" data-flag=\"alternate\" alt=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.alternate : stack1)) != null ? stack1.altText : stack1), depth0))
    + "\" title=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.alternate : stack1)) != null ? stack1.altText : stack1), depth0))
    + "\" data-country=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.alternate : stack1)) != null ? stack1.code : stack1), depth0))
    + "\" data-lang=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.alternate : stack1)) != null ? stack1.iso : stack1), depth0))
    + "\" /><img class=\"exp--geodetect-notifier--flag js-exp--geodetect-notifier--flag\" src=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.origin : stack1)) != null ? stack1.flag : stack1), depth0))
    + "\" data-flag=\"origin\" alt=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.origin : stack1)) != null ? stack1.altText : stack1), depth0))
    + "\" title=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.origin : stack1)) != null ? stack1.altText : stack1), depth0))
    + "\" data-country=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.origin : stack1)) != null ? stack1.code : stack1), depth0))
    + "\" data-lang=\""
    + alias3(alias4(((stack1 = ((stack1 = (depth0 != null ? depth0.country : depth0)) != null ? stack1.origin : stack1)) != null ? stack1.iso : stack1), depth0))
    + "\" />\r\n  </div>\r\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.variants : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>";
},"useData":true}); 
   })();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templates.GeodetectNotifier. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.base.GeodetectNotifier');

nike.requireDependency('jQuery');
nike.requireDependency('HandlebarsRuntime');
nike.requireDependency('nike.geo.Util');
nike.requireDependency('nike.geo.Configuration');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.exp.global.TemplateHelpers');

nike.requireDependency('nike.exp.global.templates.GeodetectNotifier');

(function() {
  /**
   * @class
   * @augments Class
   * @namespace nike.exp.global.base.GeodetectNotifier
   */
  nike.exp.global.base.GeodetectNotifier = Class.extend(
    /**
     * @lends nike.exp.global.base.GeodetectNotifier
     */
    {

      /**
       * Initializes the notifier
       * @param {Object} conf - Configuration for notifier
       */
      init: function(conf){
        var _self = this;

        /**
         * The compiled markup used within the notifier
         * @type {String}
         */
        _self.modalContent = '';

        /**
         * List of notifier events
         * @type {Object}
         */
        _self.eventTypes = {
          CLICK : ( Modernizr.touch ) ? 'touchend.geoDetectNotifier' : 'click.geoDetectNotifier'
        };

        /**
         * The current country & lang (end of the url)
         * @type {String}
         */
        _self.currentLocale = (nike.COUNTRY+'/'+nike.LOCALE).toLowerCase();

        /**
         * Whether or not the user is staying on the current page
         * @type {Boolean}
         */
        _self.originSelected = true;

        /**
         * The default config for the notifier
         * @type {Object}
         * @alias conf
         * @memberof! nike.exp.global.base.GeodetectNotifier#
         * @instance
         * @default
         *
         * @property {Function} template - The Handlebars template used for the modal content.
         * @property {Object} country - An Object containing the current country & the possible alternative.
         * @property {Object} selectors - An Object of CSS selectors used to target markup.
         */
        _self.conf = {
          template : Handlebars.templates.GeodetectNotifier,
          imgPathFlags : '/nikestore/html/img/geo_flags_large',
          country : {
            origin    : null,
            alternate : null
          },
          cssClasses : {
            showLangVariants  : 'show-lang-variants',
            twoColumn         : 'two-column',
            threeColumn       : 'three-column',
            fourColumn        : 'four-column',
            isHidden          : 'exp--geodetect-notifier--is-transparent'
          },
          selectors : {
            flagImage       : '.js-exp--geodetect-notifier--flag',
            seeAllCountries : '.js-see-all-countries',
            variantsCont    : '.js-exp--geodetect-notifier--language-variants-container',
            variants        : '.js-exp--geodetect-notifier--language-variants',
            variantsType    : '.js-exp--geodetect-notifier--$1--language-variants',
            variantLink     : '.js-exp--geodetect-notifier--link'
          }
        };
        // override any defaults set by user
        $.extend(true, _self.conf, conf);

        // assign functionality to the notifier
        _self.buildNotifierContent();
        _self.addNotifierToWindow();
        _self.addListeners();
      },

      /**
       * Builds the image url for the flag image
       * @param {String} countryISO - The countries ISO code
       * @returns {String}
       */
      getFlagImagePath : function(countryISO){
        return this.conf.imgPathFlags+'/'+countryISO+'.png';
      },

      /**
       * Builds the country context used by the notifier template
       * @param {Object} obj - Object returned by nike.geo.Configuration.getCountryConfiguration
       * @returns {Object}
       */
      getCountryDataObject : function(obj){
        var _self = this;
        var variantsList = obj.supportedLanguageList;
        var variants = [];
        var columnClass = '';

        switch( variantsList.length ){
          case 2 : columnClass = _self.conf.cssClasses.twoColumn; break;
          case 3 : columnClass = _self.conf.cssClasses.threeColumn; break;
          case 4 : columnClass = _self.conf.cssClasses.fourColumn; break;
        }

        for( var i=0; i<variantsList.length; i++ ){
          var v = nike.exp.dynamic.AppConfig.LANGUAGES[ variantsList[i] ];
          var countryCode = obj.countryCode.toLocaleLowerCase();

          variants.push({
            url     : '/'+ countryCode +'/'+ v.abbrev +'/',
            urlText : v.displayName.toLowerCase(),
            country : countryCode,
            lang    : v.abbrev,
            column  : columnClass+' '
          });
        }

        return {
          code      : obj.countryCode,
          iso       : variantsList[0],
          flag      : this.getFlagImagePath(obj.countryCode),
          altText   : obj.displayName,
          variants  : variants
        };
      },

      /**
       * Builds out the content needed by the notifier
       */
      buildNotifierContent : function(){
        var _self = this;
        var originData = nike.geo.Configuration.getCountryConfiguration(_self.conf.country.origin);
        var alternateData = nike.geo.Configuration.getCountryConfiguration(_self.conf.country.alternate);
        _self.templateData = {
          country : {
            origin    : _self.getCountryDataObject(originData),
            alternate : _self.getCountryDataObject(alternateData)
          },
          languageTunnelUrl : nike.getServiceUrl('baseBrandURL') + 'language_tunnel'
        };

        // add the variants per country if there are any
        if( _self.templateData.country.origin.variants.length ){
          _self.templateData.variants = {};
          _self.templateData.variants.origin = _self.templateData.country.origin.variants;
        }
        if( _self.templateData.country.alternate.variants.length ){
          _self.templateData.variants = _self.templateData.variants || {};
          _self.templateData.variants.alternate = _self.templateData.country.alternate.variants;
        }

        _self.modalContent = _self.conf.template(_self.templateData);
      },

      /**
       * Appends the notifier content and displays it
       */
      addNotifierToWindow : function(){
        var _self = this;

        _self.modal = new nike.exp.global.Modal({
          $content : $(_self.modalContent),
          autoDestroy : true,
          onClose : function(){
            _self.closeBtnClicked = true;
            _self.closeNotifier();
          }
        });

        // keep track of it's open state so that the CookieSettingsManager doesn't open over the top of it
        nike.geo.geodetectNotifierIsOpen = true;

        _self.modal.open();
        if (!nike.analytics.Tracking.eventListenersRegistered) {
          nike.listen(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, function geodetectNotifierListener(){
            nike.unlisten(nike.Event.TRACKING_EVENT_LISTENERS_REGISTERED, geodetectNotifierListener);
            nike.dispatchEvent( nike.Event.GEODETECT_NOTIFIER_OPENED, {} );
          });
        } else {
          nike.dispatchEvent( nike.Event.GEODETECT_NOTIFIER_OPENED, {} );
        }
      },

      /**
       * Handles closing the notifier and dispatching any required events
       */
      closeNotifier : function(){
        var _self = this;
        var eventData = {};
        var closeModal = ( _self.closeBtnClicked ) ? false : true;

        // only show the CookieManager if the original country was selected
        eventData.originSelected = _self.originSelected;

        // if the close button of the modal was clicked the modal was already closed so no need for this
        if( closeModal ){
          _self.modal.close();
        }

        nike.dispatchEvent( nike.Event.GEODETECT_NOTIFIER_CLOSED, eventData );
      },

      /**
       * Adds functionality to the notifier contents
       */
      addListeners : function(){
        var _self = this;
        var $modalContent = _self.modal.$content;
        var $langTunnelLink = $modalContent.find( _self.conf.selectors.seeAllCountries );

        _self.$flagOrigin = $modalContent.find( '[data-flag="origin"]' );
        _self.$flagAlternate = $modalContent.find( '[data-flag="alternate"]' );

        // user wants to stay where they are
        _self.$flagOrigin.on(_self.eventTypes.CLICK, function(ev){
          ev.preventDefault();
          ev.stopImmediatePropagation();

          _self.setSelectedCountryAndLang(ev);

          _self.showVariantLanguages('origin');
        });

        // user wants to go to another country/language
        _self.$flagAlternate.on(_self.eventTypes.CLICK, function(ev){
          ev.preventDefault();
          ev.stopImmediatePropagation();

          _self.setSelectedCountryAndLang(ev);

          _self.showVariantLanguages('alternate');
        });

        // user wants to go to the language tunnel
        $langTunnelLink.on(_self.eventTypes.CLICK, function(ev){
          ev.preventDefault();
          ev.stopImmediatePropagation();

          _self.originSelected = false;

          nike.geo.Util.redirectToLanguageTunnel();
          _self.closeNotifier();
        });
      },

      /**
       * Sets the selected country & language
       * @param {Event} ev - Flag click or alternate language click
       */
      setSelectedCountryAndLang : function(ev){
        var _self = this;
        _self.selectedCountry = $(ev.currentTarget).data('country');
        _self.selectedLanguage = $(ev.currentTarget).data('lang');
      },

      /**
       * Checks if the user chose to stay on the current page
       * @returns {boolean}
       */
      originCheck : function(){
        var _self = this;
        var selectedLocale = (_self.selectedCountry+'/'+_self.selectedLanguage).toLowerCase();

        // if the user is staying where they are, do nothing
        if(selectedLocale == _self.currentLocale){
          nike.log( '[Geodetect Notifier] user chose the original country: '+ _self.selectedCountry );
          nike.geo.Util.updateUserLocaleSettings(nike.COUNTRY, nike.LOCALE, true);
          _self.closeNotifier();
          return false;
        }else{
          _self.originSelected = false;
        }
      },

      /**
       * Resets variant language elements to their default state, allowing the
       * user to click between country flags.
       */
      resetLangVariants : function(){
        var _self = this;
        var $variantsCont = _self.modal.$content.find( _self.conf.selectors.variantsCont );

        // hide any visible elements so they're setup correctly if another flag has variants
        $variantsCont.find( _self.conf.selectors.variants).children().addClass( _self.conf.cssClasses.isHidden );
      },

      /**
       * Parses the current URL the user is on, then replaces the country/lang_locale with
       * whatever the user chose from the notifier.
       * @param {String} selection - What the user chose from the notifier
       * @param {Object} loc - Reference of the window.location Object (passing the reference due to unit testing)
       * @returns {String}
       */
      getNewUrlForSelection : function(selection, loc){
        var regex = new RegExp(loc.host+'(/\\w{2}/\\w{2}_\\w{2}/)?', 'i');
        var replaceThis = loc.href.match(regex)[1]||'';

        if (replaceThis !== "") {
          return loc.href.replace( replaceThis, selection );
        } else {
          return false;
        }
      },

      /**
       * Shows the variant languages for a selected country if there are any.
       * If there aren't any variant languages it routes to the selected country (flag).
       * @param {String} selectionType - Either "origin" or "alternate"
       */
      showVariantLanguages : function(selectionType){
        var _self = this;
        var $modalContent = _self.modal.$content;

        _self.resetLangVariants();

        // if there are language variants, show them, otherwise just go to the selected country
        if( _self.templateData.variants && _self.templateData.variants[selectionType].length > 1 ){
          var $variants = $modalContent.find( _self.conf.selectors.variantsCont )
          var targetHref;

          // if there are multiple variants we have to display the current selection type
          $variants.find( _self.conf.selectors.variantsType.replace('$1', selectionType)).removeClass( _self.conf.cssClasses.isHidden );
          // animate the variants sections
          $variants.addClass( _self.conf.cssClasses.showLangVariants );

          if( !_self.variantListenersSetup ){
            // add listener to handle locale redirection
            $variants.find( _self.conf.selectors.variantLink ).on(_self.eventTypes.CLICK, function(ev){
              ev.preventDefault();
              ev.stopImmediatePropagation();

              _self.setSelectedCountryAndLang(ev);

              if( !_self.originCheck() ){
                _self.langVariantSelected = _self.selectedLanguage;
                targetHref = $(ev.currentTarget).attr('href');

                var newLocation = _self.getNewUrlForSelection( targetHref, location );

                if (newLocation === false) { // there was no initial locale, so let's add it

                  if (/^\/[a-zA-Z]{2}\/[a-zA-Z]{2}_[a-zA-Z]{2}\/$/.test(targetHref)){ // let's make sure we're supplementing
                                                                                      // with an actual locale
                    // Normalize link:               v If last character isn't a `/`, add it                      v if first character is `/`, remove it
                    newLocation = location.origin + (/[^\/]$/.test(targetHref) ? targetHref + '/' : targetHref) + location.pathname.replace(/^\//, '');
                  }
                }

                nike.Cart.clearCartSummary();
                $.CookieUtil( "NIKE_COMMERCE_CCR", Date.now(),
                { expires: 365,
                  path: '/',
                  domain: nike.Countries_Locales_Cookies.getCookieDomain()
                });

                _self.closeNotifier();
                nike.geo.Util.redirectToLocale( _self.selectedCountry, _self.selectedLanguage, true, 300, newLocation );
              }
            });
          }

          // it's possible the user could switch back and forth between countries so don't pile up listeners
          _self.variantListenersSetup = true;
        } else {
          if( !_self.originCheck() ){
            _self.closeNotifier();
            // Redirect to the new country without a locale, which will force the default
            nike.geo.Util.redirectToLocale( _self.selectedCountry , null, true, 0, nike.geo.Util.getPathWithoutLocale());
          }
        }
      }
    }
  );
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.base.GeodetectNotifier. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.gadget.UpgradePrompt');

nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.Notification');

nike.gadget.UpgradePrompt = $.extend({}, nike.gadget.UpgradePrompt, {
	setupEvent: function(element) {
		if (CFInstall && CFInstall.isAvailable()) return false;
		var self = this, buttons, app = 'nikestore';
		
		this.el = $(element);
		this.cancelBtn = this.el.find(".notification-button").eq(1);
				
		nike.Notification.show(this.el.html(), [], function(obj) {
			if (obj.index == 0) {
				CFInstall.check({mode: "overlay", destination: ( nike.getLocalizedRootUrl() )});
			} else {
				window.location = self.cancelBtn.attr("href");
			}
		}, "upgradePrompt");
	}
});

/**
 * Setup gadget when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data) {
	if (!$.browser.msie || ($.browser.msie && $.browser.version.indexOf("6") !== 0)) return false;
	if (data && data.gadgetName == 'nike.gadget.UpgradePrompt'){
		$.getScript("//ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js",
			function() {
				nike.gadget.UpgradePrompt.setupEvent(data.element);
		});
	}
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.UpgradePrompt. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/**
 * TrackingUtil.js
 *
 * Util functions for tracking
 *
 * @author twill
 */
nike.namespace('nike.analytics.TrackingUtil');

nike.analytics.TrackingUtil = {

  /**********************************************************************************
   * Util function for setting up tracking data on elements that contain a span with
   * track data formatted as a json string
   **********************************************************************************/
  setupTrackingData : function(element){
    //Setup tracking
    //Eval tracking data text if it exists and add it to the dom element
    var pageTrackingDataElement;
    var trackingData;
    
    if(element){
      if($(element).hasClass('trackingData')){
        pageTrackingDataElement = $(element);
      } else {
        pageTrackingDataElement = $(element).find('span.trackingData');
      }
      nike.debug('Element', element);
      nike.debug('pageTrackingData', pageTrackingDataElement);
      
      trackingData = nike.Util.getObjectFromElementJSON(pageTrackingDataElement);
      
      if(trackingData && trackingData.success){
        nike.debug('adding tracking data');
        element.data('trackingData', trackingData.response);
      } 
      else if (trackingData){
        element.data('trackingData', trackingData);
      }
      else {
        element.data('trackingData', {});
      }
      
    }
  },

  /**
   * @deprecated
   */
  delayLink : function(element, options){
    var options = options || {};
    var href = $(element).attr('href');
    
    if(href != '' && href != undefined){
      
      if($(element).preventDefault != undefined){
        element.preventDefault();
      }

      if(options.newWindow) {
        setTimeout(function(){ window.open(href); }, options.delay || 100);
      } else {
        setTimeout(function(){ window.location = href; }, options.delay || 100);
      }
    }
  },
  
  delaySubmit : function(submitInput, delay){
    
    if(submitInput != undefined){
      if(submitInput.submit != undefined ){
        
        if(submitInput.preventDefault != undefined){
          submitInput.preventDefault(); 
        }
        setTimeout(function(){submitInput.submit();}, delay || 100);
      }
    }
  }
  
};





}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.analytics.TrackingUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.requireDependency('nike.Util');
nike.requireDependency('nike.util.UrlUtil');
nike.requireDependency('jQuery.CookieUtil');
nike.namespace('nike.SitePresentationRoutingUtil');
/**
 * Common utility for routing clients to different presentations
 */

/**
 * SP cookie
 */
nike.SitePresentationRoutingUtil.SITE_PRESENTATION_COOKIE = 'sp';

/**
 * SP-ROUTE cookie - this indicates the sp cookie was set using the route param
 */
nike.SitePresentationRoutingUtil.SITE_PRESENTATION_ROUTE_COOKIE = 'sp-route';

/**
 * SP cookie values
 */
nike.SitePresentationRoutingUtil.SP_DESKTOP = 'desktop';
nike.SitePresentationRoutingUtil.SP_MOBILE = 'mobile';
nike.SitePresentationRoutingUtil.SP_ADA = 'ada';

nike.SitePresentationRoutingUtil.DEFAULT_COOKIE_LENGTH = 1;


/**
 * redirect with the route parameter added, as well as all query params and a referrer
 * @param {String} route value of the route param to set
 * @param {String} location window.location object to redirect with
 * @param {Number} [cookieLength=100] Indicates how long the redirection cookie stays active
 */
nike.SitePresentationRoutingUtil.redirectWithRoute = function(route, location, cookieLength) {
  var spUtil = nike.SitePresentationRoutingUtil;
  var retQuery = '';
  var params = {};
  
  cookieLength = (typeof cookieLength === 'undefined') ? spUtil.DEFAULT_COOKIE_LENGTH : cookieLength;
  
  
  if(location !== window.location || $.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE) !== route){
    //parse params
    nike.util.UrlUtil.parseUrlParams(location.search, params);
    nike.util.UrlUtil.parseUrlParams(location.hash, params);
    params.route = route;
    var referrer = nike.util.UrlUtil.getExternalReferrer();
    
    //add referrer
    if(referrer && referrer.length > 0){
      params.ref = encodeURIComponent(referrer);
    }
    
    //add params
    for(var tempProp in params){
      if(params.hasOwnProperty(tempProp)){
        if(retQuery.length > 0 ){
          retQuery += "&";
        } else {
          retQuery = "?";
        }
        retQuery += tempProp + "=" + params[tempProp];
      }
    }
    
    //set the cookie, just in case
    if(cookieLength > 0) {
      $.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE, route, {expires: cookieLength, path: '/', domain: nike.ROOT_DOMAIN});
    } else {
      $.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE, route, {path: '/', domain: nike.ROOT_DOMAIN});
    }
    
    //check if the cookie was actually set to avoid an infinite redirect
    if($.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE) === route) {
      // If we are on the same page, then force a reload
      if(location === window.location) {
        window.location.reload(true);
      } else {
        window.location = location.protocol + "//" + location.host + location.pathname + retQuery;
      }
    }
  }
};

nike.SitePresentationRoutingUtil.detectDevice = function() {
    var userAgent = navigator.userAgent;
    var ret = "NONE";
    var botRegEx = new RegExp("spider|crawl|slurp|bot", "i");
    var mobileRegEx = new RegExp("iphone|ipod|droid", "i");
    
    if(userAgent.match(botRegEx)){
      ret = "bot";
    } else if (userAgent.match(mobileRegEx)) {
      ret = "mobile";
    }

    return ret;
};


/**
 * Validate that the ada cookie was set recently.  This is to reset any ada cookies that were automatically set previosly.  
 * Now the ada site should only show if the user explictly uses the ada link.
 */
nike.SitePresentationRoutingUtil.validateADACookie = function(){
  var spUtil = nike.SitePresentationRoutingUtil;
  
  if($.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE) === spUtil.SP_ADA){
    //Check if sp-route cookie is present.  This indicates the cookie was set using the route param rather than set based on the user agent.
    if($.CookieUtil(spUtil.SITE_PRESENTATION_ROUTE_COOKIE) === null){
      //Clear the ada cookie - it needs to be reset using the route parameter
      $.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE, null, {expires: spUtil.DEFAULT_COOKIE_LENGTH, path: '/', domain: nike.ROOT_DOMAIN});
      
      //check if the cookie was actually removed to avoid an infinite redirect
      if($.CookieUtil(spUtil.SITE_PRESENTATION_COOKIE) === null) {
        // Force a reload
        window.location.reload(true);
      }
    }
  }
};
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.SitePresentationRoutingUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.global.Ad');

nike.requireDependency('nike.exp.global.CookieSettingsCheck');
nike.requireDependency('nike.analytics.Tracking');

nike.exp.global.Ad = {
	init : function(store, site) {
		if(nike.exp.global.CookieSettingsCheck.isCookieSettingsEnabled()) {
      nike.exp.global.CookieSettingsCheck.queueFPCall(function() {
        nike.analytics.Tracking.init(store, site);
      });
		} else {
			nike.analytics.Tracking.init(store, site);
		}
	}
}
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.Ad. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.global.CommerceOffNotification');

nike.requireDependency('jQuery');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.exp.global.Modal');
nike.requireDependency('nike.geo.Locate');

nike.exp.global.CommerceOffNotification = {
  modal : undefined,

  modalCheckInterval : undefined,

  COOKIE_NAME : 'browseonly',

  selectors : {
    commerceOffNotificationModal : '#exp-commerce-off-notification-modal',
    modalOKButton : '.js-confirm-button'
  },

  init : function() {
    var existingCookie = $.CookieUtil(this.COOKIE_NAME);

    if (!existingCookie) {
      this.initModal();
      this.bindListeners();
      this.startModalChecker();
    }
  },

  initModal : function() {
    this.modal = new nike.exp.global.Modal({
      $content: $(this.selectors.commerceOffNotificationModal).show(),
      blockerClickCloses: false,
      onClose: $.proxy(function(closeType) {
        if (closeType === nike.exp.global.Modal.CLOSE_TYPE.BUTTON){
          this.setCookie();
        }
      }, this)
    });
  },

  bindListeners : function() {
    var containerEl = $(this.selectors.commerceOffNotificationModal);

    //Handle "OK" button click
    containerEl.on('click touchend', '.js-ok-button', $.proxy(this.modalCloseHandler,this));
  },

  startModalChecker : function() {
    this.modalCheckInterval = setInterval($.proxy(this.checkForModals, this), 2000);
  },

  checkForModals : function() {
    if ($('.modal-mask-class:visible').length == 0) {
      clearInterval(this.modalCheckInterval);
      this.modal.open();
    }
  },

  modalCloseHandler : function(event) {
    event.preventDefault();
    event.stopImmediatePropagation();

    this.setCookie();
    this.modal.close();
  },

  setCookie : function(){
    var value = '0';
    var options = {
      path: '/',
      domain: nike.ROOT_DOMAIN
    };
    $.CookieUtil(this.COOKIE_NAME, value, options);
  }
};

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.CommerceOffNotification. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.page.html.OneNikeBaseScripts');

nike.requireDependency('nike');
nike.requireDependency('jQuery');
nike.requireDependency('nike.ScriptLoader');
nike.requireDependency('nike.EventBus');
nike.requireDependency('nike.analytics.Tracking');
nike.requireDependency('nike.analytics.TrackingUtil');
nike.requireDependency('jQuery.CookieUtil');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.SitePresentationRoutingUtil');
nike.requireDependency('nike.exp.global.Ad');
nike.requireDependency('nike.exp.global.CommerceOffNotification');

//Init tracking script
//nike.analytics.Tracking.init('nikestore', 'html');
nike.exp.global.Ad.init('nikestore','html');

//Check for IE6 - if it is, redirect to ada site
new function(){
  var spUtil = nike.SitePresentationRoutingUtil;
  var ieRegex = /.*MSIE\s[654]{1}.*/i;

  if(ieRegex.test(window.navigator.userAgent)){
    spUtil.redirectWithRoute(spUtil.SP_ADA, window.location);
  }
}();

$(document).ready(function(){
  //parseJSON tracking data text if it exists and add it to the dom element
  var pageTrackingDataElement = $('span#trackingData');
  var errorTrackingElement = $('span#errorData');
  var pdpErrorTrackingData = $('span#pdpErrorTrackingData');
  var giftCardTrackingData = $('span#giftcardTrackingData');
  var cdpTrackingData      = $('span#cdpTrackingData');
  var commerceOffNotificationModalContent = $('#exp-commerce-off-notification-modal');

  if(pageTrackingDataElement.length > 0){
    //Add page tracking data if it's defined
    nike.analytics.TrackingUtil.setupTrackingData(pageTrackingDataElement);
    //Get sessionId and set it on tracking data
    if(nike.REGION == 'US'){
      pageTrackingDataElement.data().trackingData.sessionId = $.CookieUtil('NTSESSIONID');
    } else if (nike.REGION == 'EMEA'){
      pageTrackingDataElement.data().trackingData.sessionId = $.CookieUtil('ESESSIONID');
    }
  }

  if(errorTrackingElement.length > 0){
    //Add error tracking data if it's defined
    nike.analytics.TrackingUtil.setupTrackingData(errorTrackingElement);
  }

  if(pdpErrorTrackingData.length > 0){
    //Add page tracking data if it's defined
    nike.analytics.TrackingUtil.setupTrackingData(pdpErrorTrackingData);
  }

  if(giftCardTrackingData.length > 0){
    //Add page tracking data if it's defined
    nike.analytics.TrackingUtil.setupTrackingData(giftCardTrackingData);
  }

  if(cdpTrackingData.length > 0){
    //Add page tracking data if it's defined
    nike.analytics.TrackingUtil.setupTrackingData(cdpTrackingData);
  }

  //Set the timeout of 300ms to allow tracking when CTA link in promo banner is clicked.
  $('.global-promo-banner .nike-cq-notification-banner-container .nike-cq-cta-component a[data-tracking]').click(function(event) {
    event.preventDefault();

    var target = $(this),
        list = [],
        eventData = nike.navUtil.getLinkEventProperties(event);

    list.push('promo:'+target.data('tracking'));

    eventData.navItems = list;

    nike.dispatchEvent(nike.gadget.Event.STORE_NAV_CHANGED, eventData);
  });

  if(commerceOffNotificationModalContent.length) {
    nike.exp.global.CommerceOffNotification.init();
  }

  //Add listener for featureRequiresCookies event
  nike.listen(nike.Event.FEATURE_REQUIRES_COOKIES, function(){
    var modalArgs, contentEl;

    if(nike.page.html.OneNikeBaseScripts.featureRequiresCookiesModal === undefined){

      contentEl = $('#exp-featureRequiresCookiesModal');
      //Make sure contentEl is visible
      contentEl.show();

      //Do the initial modal creation
      modalArgs = {contentEl : contentEl, blockContent : true, closeButton : true, noDestroy: true};

      nike.page.html.OneNikeBaseScripts.featureRequiresCookiesModal = new nike.store.ui.widgets.ModalDialog(modalArgs);

    } else {
      nike.page.html.OneNikeBaseScripts.featureRequiresCookiesModal.show();
    }
  });
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.page.html.OneNikeBaseScripts. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.page.util.TrackingUtil');

nike.requireDependency("nike.analytics.TrackingConfigUtil");

nike.page.util.TrackingUtil.pageRegexes =
  [ { 'pattern' : /(^|&|\?)l=shop,home/i, 'pageId' : 'home'},
    { 'pattern' : /(^|&|\?)l=shop,search((,|\/|&).*|$)/i, 'pageId' : 'gridwall'},
    { 'pattern' : /(^|&|\?)l=shop,reviews/i, 'pageId' : 'reviews_landing'},
    { 'pattern' : /(^|&|\?)l=shop,pwp((,|\/|&).*|$)/i, 'pageId' : 'gridwall'},
    { 'pattern' : /(^|&|\?)l=shop,pdp,ctr-giftCertificateDigital((\/|&).*|$)/i, 'pageId' : 'digital_giftcard_purchase'},
    { 'pattern' : /(^|&|\?)l=shop,pdp,ctr-giftCertificate((\/|&).*|$)/i, 'pageId' : 'giftcard_purchase'},
    { 'pattern' : /(^|&|\?)l=shop,pdp,ctr-submitReview((\/|&).*|$)/i, 'pageId' : 'submit review'},
    { 'pattern' : /(^|&|\?)l=shop,pdp((,|\/|&).*|$)/i, 'pageId' : 'pdpEvolution'},
    { 'pattern' : /(^|&|\?)l=shop,pdp,.*nikeid.*/i, 'pageId' : 'nike_id_pdp'},
    { 'pattern' : /(^|&|\?)l=s\/profile((,|\/|&).*|$)/i, 'pageId': 'profile'},
    { 'pattern' : /(^|&|\?)l=shop,cart((,|\/|&).*|$)/i, 'pageId' : 'cart'},
    { 'pattern' : /(^|&|\?)l=shop,gift_cards/i, 'pageId' : 'giftcard_landing'},
    { 'pattern' : /(^|&|\?)l=shop,gift_cards((,|\/|&).*|$)/i, 'pageId' : 'giftcard_balance'},
    { 'pattern' : /(^|&|\?)l=shop,corporate_gift_cards/i, 'pageId' : 'corporate_gift_cards'},
    { 'pattern' : /(^|&|\?)l=shop,refund_number.*/i, 'pageId' : 'giftcard_refund'},
    { 'pattern' : /(^|&|\?)l=shop,retrieve_gift_card.*/i, 'pageId' : 'giftcard_retrieve'},
    { 'pattern' : /(^|&|\?)l=shop,contact_us/i, 'pageId' : 'contact_us'},
    { 'pattern' : /(^|&|\?)l=shop,return_orders.*/i, 'pageId' : 'return_orders'},
    { 'pattern' : /(^|&|\?)l=shop,email_signup/i, 'pageId' : 'email_signup'},
    { 'pattern' : /(^|&|\?)l=shop,gearup.*/i, 'pageId' : 'gearup'},
    { 'pattern' : /(^|&|\?)l=shop,product((,|\/|&).*|$)/i, 'pageId' : 'sports_landing'},
    { 'pattern' : /(^|&|\?)l=shop,member_benefits$/i, 'pageId' : 'member_benefits'},
    { 'pattern' : /(^|&|\?)l=shop,mylocker.*/i, 'pageId' : 'mylocker'},
    { 'pattern' : /\/outfit\/(.*)/i, 'pageId' : 'pdpOutfit'},
    { 'pattern' : /\/pd\/(.*)/i, 'pageId' : 'pdpEvolution'},
    { 'pattern' : /\/pw\//i, 'pageId' : 'gridwall'},
    { 'pattern' : /\/sfg\/(.*)/i, 'pageId' : 'sizeFitGuide'},
    { 'pattern' : /\/product\/(.*)/i, 'pageId' : 'nike_id_pdp'},
    { 'pattern' : /\/launch(.*)/i, 'pageId' : 'launch_calendar'},
	  { 'pattern' : /\/orders(.*)/i, 'pageId' : 'myorders'},
    { 'pattern' : /\/p\/settings(.*)/i, 'pageId' : 'profile'},
    { 'pattern' : /\/s\/register(.*)/i, 'pageId' : 'register'},
    { 'pattern' : /(^|&|\?)l=shop,.*/i, 'pageId' : 'gridwall'}];

nike.page.util.TrackingUtil.defaultPageId = 'home';

/**
 * Get pageId for tracking purposes
 */

nike.page.util.TrackingUtil.getPageId = function () {
  var location = nike.analytics.TrackingConfigUtil.getCurrentAnalyticLocation();
  var hash = location.hash;
  //Remove ref parameter from search query
  var search = location.search.replace(/[?&]ref=.*/, '');
  var pathName = location.pathname;
  var pageId = undefined;


  //Check if page is product not found or an error first because they aren't based on the url
  if(isProductNotFound()){
    pageId = 'inactivePDP';

  } else if(isErrorPage()){
    pageId = 'error';

  }

  //First check hash for pageId
  if(pageId === undefined && hash.length > 1){
    //Remove first char from hash and test regexes
    hash = hash.substring(1);
    hash = decodeUrl(hash);
    pageId = testRegexes(hash);
  }

  //Next check search
  if(pageId === undefined && search.length > 1){
    search = search.substring(1);
    search = decodeUrl(search);
    pageId = testRegexes(search);
  }

  //Next check to see if we're in a particular path with
  // no search parameters
  if((!(search.length > 1)) && pageId == undefined && pathName.length > 1) {
    pageId = testRegexes(pathName);
  }

  if(pageId == undefined && pathName.length > 1) {
    pageId = testRegexes(pathName);
  }

  if(pageId === undefined || pageId.length == 0){
    pageId = nike.page.util.TrackingUtil.defaultPageId;
  }

  return pageId;

  /**
   * Test the list of regexes against the query
   */
  function testRegexes(queryToTest){
    var i, L;
    var reList = nike.page.util.TrackingUtil.pageRegexes;
    var ret = undefined;
    for(i = 0, L = reList.length; i < L; i++){
      if(reList[i].pattern.test(queryToTest)){
        ret = reList[i].pageId;
        break;
      }
    }

    return ret;
  }

  /**
   * Make sure url encoded vars are decoded
   */
  function decodeUrl(urlValue){
    return decodeURIComponent(urlValue.replace(/\+/g,  " "));
  }

  function isErrorPage(){
    var isError = false;
    var errorTrackingData = $("#errorData").data('trackingData');
    if(errorTrackingData && (errorTrackingData.isErrorPage === "true" || errorTrackingData.isErrorPage === true)) {
      isError = true;
    }
    return isError;
  }

  function isProductNotFound(){
    var isProductNotFound = false;
    var pdpErrorData = $("#pdpErrorTrackingData").data('trackingData');
    if(pdpErrorData && pdpErrorData.errorType == "ProductNotFound"){
      isProductNotFound = true;
    }
    return isProductNotFound;
  }
};


}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.page.util.TrackingUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}


try{
var nike = nike || {};
nike.namespace("nike.exp.global.CookieSettingsHandler");

nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.DomReady');
nike.requireDependency('jQuery');

nike.exp.global.CookieSettingsHandler = {
  initialized : false,

  init : function() {
    if (nike.IS_COOKIE_SETTINGS_ENABLED && !this.initialized) {
      this.bindListeners();

      if ($('[data-gadget="nike.gadget.OneNikeFooter"]').data('asyncLoaded') === "loaded") {
        this.bindClickEvents();
      } else {
        nike.listen(nike.EVENT_GADGET_LOADED, $.proxy(function(event, data){
          if (data && (data.gadgetName === "nike.gadget.OneNikeFooter" || data.gadgetName === "nike.gadget.CookieSettingsManager")) {
            this.bindClickEvents();
          }
        }, this));
      }
      this.checkForCookie();
      this.initialized = true;
    }
  },

  bindListeners : function() {
    //Setup listener to launch CookieSettingsManager
    nike.listen(nike.gadget.Event.SHOW_COOKIE_SETTINGS_DIALOG_EVENT, function(event, data) {
      var gadgetEl = $('[data-gadget="nike.gadget.CookieSettingsManager"]');

      if (data && typeof data.reload !== 'undefined') {
        gadgetEl.data('reload', data.reload);
      }
      //load the CookieSettingsManager gadget
      nike.requestScripts("nike.gadget.CookieSettingsManager", function() {
        nike.getGadget(gadgetEl);
      });
    });
  },

  bindClickEvents : function() {
    //Handle "Cookie Settings" footer link click
    $('footer a[href="#cookie_settings"], [href="/cookie_settings.html"]').on('click', function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();

      $('div[data-gadget="nike.gadget.CookieSettingsManager"]').data('showOptions', true);
      nike.dispatchEvent(nike.gadget.Event.SHOW_COOKIE_SETTINGS_DIALOG_EVENT, {});
    });
  },

  checkForCookie : function() {
    //check for 'sq' cookie
    if(!$.CookieUtil('sq')){
      nike.dispatchEvent(nike.gadget.Event.SHOW_COOKIE_SETTINGS_DIALOG_EVENT, {});
    }
  }
};

nike.DomReady(function() {
  nike.exp.global.CookieSettingsHandler.init();
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.CookieSettingsHandler. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.gadget.OneNikeFooter');

nike.requireDependency('nike.Util');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.NavigationUtil');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('nike.exp.global.CookieSettingsHandler');

nike.gadget.OneNikeFooter.setup = function(element) {
	var self = nike.gadget.OneNikeFooter;
  var gadget = $(element);
  var scripts = gadget.find('.scripts');
  var styles = gadget.find('.styles');
  var footerEl = gadget.find("footer");

	self.$regFooter = $("div.main-footer.regular-footer");
	self.$swooshFooter = $("div.main-footer.swoosh-footer");

   //setup tracking for footer link click
   if(footerEl && footerEl.length){
     footerEl.on("click", "a", function (event) {
       var curLink = $(this);
       var eventData = {
         element: gadget,
         navItems: [ "footer:" + curLink.text().trim() ]
       };

       // Redirect information should only be added if this is NOT a submenu.
       if((curLink.siblings().find("a").length === 0) || curLink.hasClass("nike-cq-list-link-level2")) {
         event.preventDefault();
         $.extend(eventData, nike.navUtil.getLinkEventProperties(event));
       }

       // dispatch footer link click event
       nike.dispatchEvent(nike.Event.FOOTER_LINK_CLICK, eventData);
     });
   }

   if(scripts.length || styles.length) {
       // Setup load of additional scripts and css
        nike.gadget.OneNikeFooter.setupDependencies(scripts, styles);
   }


  nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.REMEMBERED_LOG_IN, function () {
    var state = nike.exp.profile.ProfileStateController.getUserState();
    if (state.isSwoosh){
      if(self.$swooshFooter.hasClass('lazy-load') && !self.$swooshFooter.hasClass("loading")) {
        self.loadSwooshFooter();
        return;
      } else {
        self.$regFooter.hide();
        self.$swooshFooter.show();
      }
    } else {
      self.$regFooter.show();
      self.$swooshFooter.hide();
    }
  });

  nike.exp.profile.ProfileStateController.listenForCompatibleState(nike.exp.profile.PROFILE_STATE.NOT_LOGGED_IN, function () {
    self.$regFooter.show();
    self.$swooshFooter.hide();
  });

   var setup = new nike.gadget.LinkRedirector.PageSetup(true);
   setup.setupEvent(nike.Event.FOOTER_LINK_CLICK);
   nike.gadget.LinkRedirector.setupPageEvents(setup);

   //Add qa attribute to view card link
   var $viewCardsLink = $('footer').find('a[href*="gift_cards"]');
   nike.Util.addQaAttribute($viewCardsLink, 'homepage.viewcards_link');
};

nike.gadget.OneNikeFooter.setupDependencies = function (scripts, styles) {
    var styleArray = [];
    var scriptArray = [];

    styles.find('span').each(function () {
        var styleAsset = $(this).data('styleAsset');
        if(styleAsset) {
          styleArray.push(styleAsset);
        }
    });

    scripts.find('span').each(function () {
        var scriptAsset = $(this).data('scriptAsset');
        if(scriptAsset) {
          scriptArray.push(scriptAsset);
        }
    });

    if(styleArray.length && scriptArray.length) {
      // Daisy chain the resources because of EDF-13087 to ensure that the CSS is
      // applied before the scripts are executed.
      nike.loadExternalResources(styleArray, function () {
        nike.loadExternalResources(scriptArray);
      });
    } else if (styleArray.length) {
      nike.loadExternalResources(styleArray);
    } else if (scriptArray.length) {
      nike.loadExternalResources(styleArray);
    }
};

nike.gadget.OneNikeFooter.loadSwooshFooter = function () {
  var self = this;
  this.$swooshFooter.addClass("loading");
  var url = nike.getLocalizedRootUrl() + 'html-services/swooshFooterService';

  var params = {
    url: url,
    method: 'GET'
  };

  nike.request(params, function(response) {
    // noinspection JSUnresolvedVariable
    var data = $.parseJSON(response.data);
    self.$swooshFooter.html(data.swooshFooter);
    self.$swooshFooter.removeClass("loading");
    self.$swooshFooter.removeClass("lazy-load");
    self.$regFooter.hide();
    self.$swooshFooter.show();

    if(nike.objectDefined('nike.cq.PES.GlobalFooter.init')) {
      nike.cq.PES.GlobalFooter.init();
    }
  }, function() {
    // might want to do something here, if we can't get the footer
    nike.error('Unable to load Swoosh footer.');
  });
};

/**
 * Setup gadget when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data) {
	if (data && data.gadgetName == 'nike.gadget.OneNikeFooter') {
		nike.gadget.OneNikeFooter.setup(data.element);
    nike.exp.global.CookieSettingsHandler.init();
	}
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.OneNikeFooter. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

nike.namespace('jQuery.hammer');
nike.requireDependency('jQuery');

(function(window, undefined) {
    'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
    // add styles and attributes to the element to prevent the browser from doing
    // its native behavior. this doesnt prevent the scrolling, but cancels
    // the contextmenu, tap highlighting etc
    // set to false to disable this
    stop_browser_behavior: {
    // this also triggers onselectstart=false for IE
        userSelect: 'none',
    // this makes the element blocking in IE10 >, you could experiment with the value
    // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
        touchAction: 'none',
    touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    }

    // more settings are defined per gesture at gestures.js
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = document;

// plugins namespace
Hammer.plugins = {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
        if(Hammer.gestures.hasOwnProperty(name)) {
            Hammer.detection.register(Hammer.gestures[name]);
        }
    }

    // Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    this.element = element;

    // start/stop detection option
    this.enabled = true;

    // merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    // start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
        if(self.enabled) {
            Hammer.detection.startDetect(self, ev);
        }
    });

    // return instance
    return this;
};


Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    on: function onEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    off: function offEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     */
    trigger: function triggerEvent(gesture, eventData){
        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Hammer.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },


    /**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    }
};

/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
    /**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     */
    bindDom: function(element, type, handler) {
        var types = type.split(' ');
        for(var t=0; t<types.length; t++) {
            element.addEventListener(types[t], handler, false);
        }
    },


    /**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     */
    onTouch: function onTouch(element, eventType, handler) {
    var self = this;

        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();

            // onmouseup, but when touchend has been fired we do nothing.
            // this is for touchdevices which also fire a mouseup on touchend
            if(sourceEventType.match(/mouse/) && touch_triggered) {
                return;
            }

            // mousebutton must be down or a touch event
            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen
                sourceEventType.match(/pointerdown/) || // pointerevents touch
                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
            ){
                enable_detect = true;
            }

            // we are in a touch event, set the touch triggered bool to true,
            // this for the conflicts that may occur on ios and android
            if(sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
            }

            // count the total touches on the screen
            var count_touches = 0;

            // when touch has been triggered in this detection session
            // and we are now handling a mouse event, we stop that to prevent conflicts
            if(enable_detect) {
                // update pointerevent
                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
                // touch
                else if(sourceEventType.match(/touch/)) {
                    count_touches = ev.touches.length;
                }
                // mouse
                else if(!touch_triggered) {
                    count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }

                // if we are in a end event, but when we remove one touch and
                // we still have enough, set eventType to move
                if(count_touches > 0 && eventType == Hammer.EVENT_END) {
                    eventType = Hammer.EVENT_MOVE;
                }
                // no touches, force the end event
                else if(!count_touches) {
                    eventType = Hammer.EVENT_END;
                }

                // because touchend has no touches, and we often want to use these in our gestures,
                // we send the last move event as our eventData in touchend
                if(!count_touches && last_move_event !== null) {
                    ev = last_move_event;
                }
                // store the last move event
                else {
                    last_move_event = ev;
                }

                // trigger the handler
                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                // remove pointerevent from list
                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
            }

            //debug(sourceEventType +" "+ eventType);

            // on the end we reset everything
            if(!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                Hammer.PointerEvent.reset();
            }
        });
    },


    /**
     * we have different events for each device/browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     */
    determineEventTypes: function determineEventTypes() {
        // determine the eventtype we want to set
        var types;

        // pointerEvents magic
        if(Hammer.HAS_POINTEREVENTS) {
            types = Hammer.PointerEvent.getEvents();
        }
        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
        else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'];
        }
        // for non pointer events browsers and mixed browsers,
        // like chrome on windows8 touch laptop
        else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'];
        }

        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    /**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     */
    getTouchList: function getTouchList(ev/*, eventType*/) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return Hammer.PointerEvent.getTouchList();
        }
        // get the touchlist
        else if(ev.touches) {
            return ev.touches;
        }
        // make fake touchlist from mouse position
        else {
            return [{
                identifier: 1,
                pageX: ev.pageX,
                pageY: ev.pageY,
                target: ev.target
            }];
        }
    },


    /**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     */
    collectEventData: function collectEventData(element, eventType, ev) {
        var touches = this.getTouchList(ev, eventType);

        // find out pointerType
        var pointerType = Hammer.POINTER_TOUCH;
        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
            pointerType = Hammer.POINTER_MOUSE;
        }

        return {
            center      : Hammer.utils.getCenter(touches),
            timeStamp   : new Date().getTime(),
            target      : ev.target,
            touches     : touches,
            eventType   : eventType,
            pointerType : pointerType,
            srcEvent    : ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                if(this.srcEvent.preventManipulation) {
                    this.srcEvent.preventManipulation();
                }

                if(this.srcEvent.preventDefault) {
                    this.srcEvent.preventDefault();
                }
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Hammer.detection.stopDetect();
            }
        };
    }
};

Hammer.PointerEvent = {
    /**
     * holds all pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get a list of pointers
     * @returns {Array}     touchlist
     */
    getTouchList: function() {
        var self = this;
        var touchlist = [];

        // we can use forEach since pointerEvents only is in IE10
        Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     */
    updatePointer: function(type, pointerEvent) {
        if(type == Hammer.EVENT_END) {
            this.pointers = {};
        }
        else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }

        return Object.keys(this.pointers).length;
    },

    /**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     */
    matchType: function(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var types = {};
        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
        return types[pointerType];
    },


    /**
     * get events
     */
    getEvents: function() {
        return [
            'pointerdown MSPointerDown',
            'pointermove MSPointerMove',
            'pointerup pointercancel MSPointerUp MSPointerCancel'
        ];
    },

    /**
     * reset the list
     */
    reset: function() {
        this.pointers = {};
    }
};


Hammer.utils = {
    /**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
   * @parm  {Boolean} merge   do a merge
     * @returns {Object}    dest
     */
    extend: function extend(dest, src, merge) {
        for (var key in src) {
      if(dest[key] !== undefined && merge) {
        continue;
      }
            dest[key] = src[key];
        }
        return dest;
    },


    /**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     */
    hasParent: function(node, parent) {
        while(node){
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },


    /**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     */
    getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];

        for(var t= 0,len=touches.length; t<len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
        }

        return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
        };
    },


    /**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     */
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
            x: Math.abs(delta_x / delta_time) || 0,
            y: Math.abs(delta_y / delta_time) || 0
        };
    },


    /**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY,
            x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 / Math.PI;
    },


    /**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX),
            y = Math.abs(touch1.pageY - touch2.pageY);

        if(x >= y) {
            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
        }
        else {
            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
        }
    },


    /**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX,
            y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x*x) + (y*y));
    },


    /**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) /
                this.getDistance(start[0], start[1]);
        }
        return 1;
    },


    /**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) -
                this.getAngle(start[1], start[0]);
        }
        return 0;
    },


    /**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     */
    isVertical: function isVertical(direction) {
        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    /**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     */
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
        var prop,
            vendors = ['webkit','khtml','moz','ms','o',''];

        if(!css_props || !element.style) {
            return;
        }

        // with css properties for modern browsers
        for(var i = 0; i < vendors.length; i++) {
            for(var p in css_props) {
                if(css_props.hasOwnProperty(p)) {
                    prop = p;

                    // vender prefix at the property
                    if(vendors[i]) {
                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                    }

                    // set the style
                    element.style[prop] = css_props[p];
                }
            }
        }

        // also the disable onselectstart
        if(css_props.userSelect == 'none') {
            element.onselectstart = function() {
                return false;
            };
        }
    }
};

Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,


    /**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        this.current = {
            inst        : inst, // reference to HammerInstance we're working for
            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent   : false, // last eventData
            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },


    /**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // instance options
        var inst_options = this.current.inst.options;

        // call Hammer.gesture handlers
        for(var g=0,len=this.gestures.length; g<len; g++) {
            var gesture = this.gestures[g];

            // only when the instance options have enabled this gesture
            if(!this.stopped && inst_options[gesture.name] !== false) {
                // if a handler returns false, we stop with the detection
                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                    this.stopDetect();
                    break;
                }
            }
        }

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        // endevent, but not the last touch, so dont stop
        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {
            this.stopDetect();
        }

        return eventData;
    },


    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Hammer.utils.extend({}, this.current);

        // reset the current
        this.current = null;

        // stopped!
        this.stopped = true;
    },


    /**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     */
    extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;

        // if the touches change, set the new touches over the startEvent touches
        // this because touchevents don't have all the touches on touchstart, or the
        // user must place his fingers at the EXACT same time on the screen, which is not realistic
        // but, sometimes it happens that both fingers are touching at the EXACT same time
        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            // extend 1 level deep to get the touchlist with the touch objects
            startEv.touches = [];
            for(var i=0,len=ev.touches.length; i<len; i++) {
                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
            }
        }

        var delta_time = ev.timeStamp - startEv.timeStamp,
            delta_x = ev.center.pageX - startEv.center.pageX,
            delta_y = ev.center.pageY - startEv.center.pageY,
            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

        Hammer.utils.extend(ev, {
            deltaTime   : delta_time,

            deltaX      : delta_x,
            deltaY      : delta_y,

            velocityX   : velocity.x,
            velocityY   : velocity.y,

            distance    : Hammer.utils.getDistance(startEv.center, ev.center),
            angle       : Hammer.utils.getAngle(startEv.center, ev.center),
            direction   : Hammer.utils.getDirection(startEv.center, ev.center),

            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

            startEvent  : startEv
        });

        return ev;
    },


    /**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Hammer.utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if (a.index < b.index) {
                return -1;
            }
            if (a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


Hammer.gestures = Hammer.gestures || {};

/**
 * Custom gestures
 * ==============================
 *
 * Gesture object
 * --------------------
 * The object structure of a gesture:
 *
 * { name: 'mygesture',
 *   index: 1337,
 *   defaults: {
 *     mygesture_option: true
 *   }
 *   handler: function(type, ev, inst) {
 *     // trigger gesture event
 *     inst.trigger(this.name, ev);
 *   }
 * }

 * @param   {String}    name
 * this should be the name of the gesture, lowercase
 * it is also being used to disable/enable the gesture per instance config.
 *
 * @param   {Number}    [index=1000]
 * the index of the gesture, where it is going to be in the stack of gestures detection
 * like when you build an gesture that depends on the drag gesture, it is a good
 * idea to place it after the index of the drag gesture.
 *
 * @param   {Object}    [defaults={}]
 * the default settings of the gesture. these are added to the instance settings,
 * and can be overruled per instance. you can also add the name of the gesture,
 * but this is also added by default (and set to true).
 *
 * @param   {Function}  handler
 * this handles the gesture detection of your custom gesture and receives the
 * following arguments:
 *
 *      @param  {Object}    eventData
 *      event data containing the following properties:
 *          timeStamp   {Number}        time the event occurred
 *          target      {HTMLElement}   target element
 *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
 *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
 *          center      {Object}        center position of the touches. contains pageX and pageY
 *          deltaTime   {Number}        the total time of the touches in the screen
 *          deltaX      {Number}        the delta on x axis we haved moved
 *          deltaY      {Number}        the delta on y axis we haved moved
 *          velocityX   {Number}        the velocity on the x
 *          velocityY   {Number}        the velocity on y
 *          angle       {Number}        the angle we are moving
 *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
 *          distance    {Number}        the distance we haved moved
 *          scale       {Number}        scaling of the touches, needs 2 touches
 *          rotation    {Number}        rotation of the touches, needs 2 touches *
 *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
 *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
 *          startEvent  {Object}        contains the same properties as above,
 *                                      but from the first touch. this is used to calculate
 *                                      distances, deltaTime, scaling etc
 *
 *      @param  {Hammer.Instance}    inst
 *      the instance we are doing the detection for. you can get the options from
 *      the inst.options object and trigger the gesture event by calling inst.trigger
 *
 *
 * Handle gestures
 * --------------------
 * inside the handler you can get/set Hammer.detection.current. This is the current
 * detection session. It has the following properties
 *      @param  {String}    name
 *      contains the name of the gesture we have detected. it has not a real function,
 *      only to check in other gestures if something is detected.
 *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
 *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
 *
 *      @readonly
 *      @param  {Hammer.Instance}    inst
 *      the instance we do the detection for
 *
 *      @readonly
 *      @param  {Object}    startEvent
 *      contains the properties of the first gesture detection in this session.
 *      Used for calculations about timing, distance, etc.
 *
 *      @readonly
 *      @param  {Object}    lastEvent
 *      contains all the properties of the last gesture detect in this session.
 *
 * after the gesture detection session has been completed (user has released the screen)
 * the Hammer.detection.current object is copied into Hammer.detection.previous,
 * this is usefull for gestures like doubletap, where you need to know if the
 * previous gesture was a tap
 *
 * options that have been set by the instance can be received by calling inst.options
 *
 * You can trigger a gesture event by calling inst.trigger("mygesture", event).
 * The first param is the name of your gesture, the second the event argument
 *
 *
 * Register gestures
 * --------------------
 * When an gesture is added to the Hammer.gestures object, it is auto registered
 * at the setup of the first Hammer instance. You can also call Hammer.detection.register
 * manually and pass your gesture object as a param
 *
 */

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
    name: 'hold',
    index: 10,
    defaults: {
        hold_timeout  : 500,
        hold_threshold  : 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
        switch(ev.eventType) {
            case Hammer.EVENT_START:
                // clear any running timers
                clearTimeout(this.timer);

                // set the gesture so we can check in the timeout if it still is
                Hammer.detection.current.name = this.name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                this.timer = setTimeout(function() {
                    if(Hammer.detection.current.name == 'hold') {
                        inst.trigger('hold', ev);
                    }
                }, inst.options.hold_timeout);
                break;

            // when you move or end we clear the timer
            case Hammer.EVENT_MOVE:
                if(ev.distance > inst.options.hold_threshold) {
                    clearTimeout(this.timer);
                }
                break;

            case Hammer.EVENT_END:
                clearTimeout(this.timer);
                break;
        }
    }
};


/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
    name: 'tap',
    index: 100,
    defaults: {
        tap_max_touchtime : 250,
        tap_max_distance  : 10,
    tap_always      : true,
        doubletap_distance  : 20,
        doubletap_interval  : 300
    },
    handler: function tapGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // previous gesture, for the double tap since these are two different gesture detections
            var prev = Hammer.detection.previous,
        did_doubletap = false;

            // when the touchtime is higher then the max touch time
            // or when the moving distance is too much
            if(ev.deltaTime > inst.options.tap_max_touchtime ||
                ev.distance > inst.options.tap_max_distance) {
                return;
            }

            // check if double tap
            if(prev && prev.name == 'tap' &&
                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
                ev.distance < inst.options.doubletap_distance) {
        inst.trigger('doubletap', ev);
        did_doubletap = true;
            }

      // do a single tap
      if(!did_doubletap || inst.options.tap_always) {
        Hammer.detection.current.name = 'tap';
        inst.trigger(Hammer.detection.current.name, ev);
      }
        }
    }
};


/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        // set 0 for unlimited, but this can conflict with transform
        swipe_max_touches  : 1,
        swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // max touches
            if(inst.options.swipe_max_touches > 0 &&
                ev.touches.length > inst.options.swipe_max_touches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > inst.options.swipe_velocity ||
                ev.velocityY > inst.options.swipe_velocity) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
    name: 'drag',
    index: 50,
    defaults: {
        drag_min_distance : 10,
        // set 0 for unlimited, but this can conflict with transform
        drag_max_touches  : 1,
        // prevent default browser behavior when dragging occurs
        // be careful with it, it makes the element a blocking element
        // when you are using the drag gesture, it is a good practice to set this true
        drag_block_horizontal   : false,
        drag_block_vertical     : false,
        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
        // It disallows vertical directions if the initial direction was horizontal, and vice versa.
        drag_lock_to_axis       : false,
        // drag lock only kicks in when distance > drag_lock_min_distance
        // This way, locking occurs only when the distance has become large enough to reliably determine the direction
        drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // max touches
        if(inst.options.drag_max_touches > 0 &&
            ev.touches.length > inst.options.drag_max_touches) {
            return;
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.drag_min_distance &&
                    Hammer.detection.current.name != this.name) {
                    return;
                }

                // we are dragging!
                Hammer.detection.current.name = this.name;

                // lock drag to axis?
                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {
                    ev.drag_locked_to_axis = true;
                }
                var last_direction = Hammer.detection.current.lastEvent.direction;
                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
                    // keep direction on the axis that the drag gesture started on
                    if(Hammer.utils.isVertical(last_direction)) {
                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                    }
                    else {
                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                // trigger normal event
                inst.trigger(this.name, ev);

                // direction event, like dragdown
                inst.trigger(this.name + ev.direction, ev);

                // block the browser events
                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
                    ev.preventDefault();
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
    name: 'transform',
    index: 45,
    defaults: {
        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
        transform_min_scale     : 0.01,
        // rotation in degrees
        transform_min_rotation  : 1,
        // prevent default browser behavior when two touches are on the screen
        // but it makes the element a blocking element
        // when you are using the transform gesture, it is a good practice to set this true
        transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // atleast multitouch
        if(ev.touches.length < 2) {
            return;
        }

        // prevent default when two fingers are on the screen
        if(inst.options.transform_always_block) {
            ev.preventDefault();
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                var scale_threshold = Math.abs(1-ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scale_threshold < inst.options.transform_min_scale &&
                    rotation_threshold < inst.options.transform_min_rotation) {
                    return;
                }

                // we are transforming!
                Hammer.detection.current.name = this.name;

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                inst.trigger(this.name, ev); // basic transform event

                // trigger rotate event
                if(rotation_threshold > inst.options.transform_min_rotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scale_threshold > inst.options.transform_min_scale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        // call preventDefault at touchstart, and makes the element blocking by
        // disabling the scrolling of the page, but it improves gestures like
        // transforming and dragging.
        // be careful with using this, it can be very annoying for users to be stuck
        // on the page
        prevent_default: false,

        // disable mouse events, so only touch (or pen!) input triggers events
        prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.prevent_default) {
            ev.preventDefault();
        }

        if(ev.eventType ==  Hammer.EVENT_START) {
            inst.trigger(this.name, ev);
        }
    }
};


/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

// node export
if(typeof module === 'object' && typeof module.exports === 'object'){
    module.exports = Hammer;
}
// just window export
else {
    window.Hammer = Hammer;

    // requireJS module definition
    if(typeof window.define === 'function' && window.define.amd) {
        window.define('hammer', [], function() {
            return Hammer;
        });
    }
}
})(this);

(function($, undefined) {
    'use strict';

    // no jQuery or Zepto!
    if($ === undefined) {
        return;
    }

    /**
     * bind dom events
     * this overwrites addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        eventTypes
     * @param   {Function}      handler
     */
    Hammer.event.bindDom = function(element, eventTypes, handler) {
        $(element).on(eventTypes, function(ev) {
            var data = ev.originalEvent || ev;

            // IE pageX fix
            if(data.pageX === undefined) {
                data.pageX = ev.pageX;
                data.pageY = ev.pageY;
            }

            // IE target fix
            if(!data.target) {
                data.target = ev.target;
            }

            // IE button fix
            if(data.which === undefined) {
                data.which = data.button;
            }

            // IE preventDefault
            if(!data.preventDefault) {
                data.preventDefault = ev.preventDefault;
            }

            // IE stopPropagation
            if(!data.stopPropagation) {
                data.stopPropagation = ev.stopPropagation;
            }

            handler.call(this, data);
        });
    };

    /**
     * the methods are called by the instance, but with the jquery plugin
     * we use the jquery event methods instead.
     * @this    {Hammer.Instance}
     * @return  {jQuery}
     */
    Hammer.Instance.prototype.on = function(types, handler) {
        return $(this.element).on(types, handler);
    };
    Hammer.Instance.prototype.off = function(types, handler) {
        return $(this.element).off(types, handler);
    };


    /**
     * trigger events
     * this is called by the gestures to trigger an event like 'tap'
     * @this    {Hammer.Instance}
     * @param   {String}    gesture
     * @param   {Object}    eventData
     * @return  {jQuery}
     */
    Hammer.Instance.prototype.trigger = function(gesture, eventData){
        var el = $(this.element);
        if(el.has(eventData.target).length) {
            el = $(eventData.target);
        }

        return el.trigger({
            type: gesture,
            gesture: eventData
        });
    };


    /**
     * jQuery plugin
     * create instance of Hammer and watch for gestures,
     * and when called again you can change the options
     * @param   {Object}    [options={}]
     * @return  {jQuery}
     */
    $.fn.hammer = function(options) {
        return this.each(function() {
            var el = $(this);
            var inst = el.data('hammer');
            // start new hammer instance
            if(!inst) {
                el.data('hammer', new Hammer(this, options || {}));
            }
            // change the options
            else if(inst && options) {
                Hammer.utils.extend(inst.options, options);
            }
        });
    };

})(window.jQuery || window.Zepto);
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing jQuery.hammer. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}



try{
var nike = nike || {};
nike.namespace('nike.fonts.glyphPolyfill');

nike.requireDependency('Modernizr');
nike.requireDependency('jQuery');

/**
 This script allows OneNike glyphs to be used in browsers that don't support generated content (read: IE7).
 Instead of relying on generated content, SPAN elements are inserted inside the .glyph- elements.
 The classes used by this technique can be found in:
    /tesla-resources/onestore/src/main/resources/assets/styles/skin/onenike.css
 */
nike.fonts.glyphPolyfill.replaceGlyphs = function($el) {
    $el = $el || $(document);

    $el.find('[data-glyph]').not('.has-polyfill').each(function() {
        var $self = $(this).addClass('has-polyfill'),
            glyph = $self.data('glyph'),
            html = $self.html(),
            $span = $('<span/>'),
            $glyphSpan = $span.clone().addClass('glyph').attr('aria-hidden','true').text(glyph),
            $textSpan = ( html ) ? $span.clone().addClass('visuallyhidden').html(html) : [];

        if ($self.hasClass('glyph-replace')) {
            $self
                .html('')
                .append($glyphSpan, $textSpan);

        } else if ($self.hasClass('glyph-after')) {
            $self.append($glyphSpan);

        } else if ($self.hasClass('glyph-before')) {
            $self.prepend($glyphSpan);
        }
    });
};

if (!Modernizr.generatedcontent) {
    $(document).ready(function () {
        nike.fonts.glyphPolyfill.replaceGlyphs();
    });

    nike.listen(nike.EVENT_GADGET_LOADED, function(event, data){
        if (data && data.element && data.element.has('[data-glyph]').length) {
            nike.fonts.glyphPolyfill.replaceGlyphs(data.element);
        }
    });
}
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.fonts.glyphPolyfill. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.CrossSellRenderer');

nike.requireDependency('nike.ImageUtil');
nike.requireDependency('nike.fonts.glyphPolyfill');

nike.requireDependency('nike.interactionType');

nike.CrossSellRenderer = $.extend(nike.CrossSellRenderer, {

  templates: {
    wrap_template: {
      ampedTemplate: '<li class="featured crossSellItem">' +
                     '  <div class="rec-item-hover">' + // hover border
                     '    <a class="pdp-url" href="${pdpURL}">' +
                     '      <span class="item-image' + '${csImageType}' + '"><img src="${imageURL}" /></span>' +
                     '      ${productRating}' +
                     '      <span class="cs-nikeid">' +
                     '        ${nikeIdBadge}${totalColor}${nikeIdSign}' +
                     '      </span>' +
                     '      ${widthsAvailableEl}' +
                     '      ${renderedName}' +
                     '      <span class="price">${renderedPrice}</span>' +
                     '      ${nflLogo}' +
                     '      ${nflAllTeamEl}' +
                     '    </a>' +
                     '  </div>' + // hover border
                     '</li>',

      itemTemplate: '<li class="crossSellItem">' +
                    '  <div class="rec-item-hover">' + // hover border
                    '     <a class="pdp-url" href="${pdpURL}">' +
                    '       <span class="item-image' + '${csImageType}' + '"><img src="${imageURL}" /></span>' +
                    '       ${productRating}' +
                    '       <span class="cs-nikeid">' +
                    '         ${nikeIdBadge}${totalColor}' +
                    '       </span>' +
                    '       ${widthsAvailableEl}' +
                    '       ${renderedName}' +
                    '       <span class="price">${renderedPrice}</span>' +
                    '       ${nflLogo}' +
                    '       ${nflAllTeamEl}' +
                    '     </a>' +
                    '  </div>' + // end hover border
                    '</li>',
      styleName: '<span class="product-name">' +
                 '<span class="style-name nsg-font-family--base nsg-text--dark-grey edf-font-size--regular">${styleName}</span>' +
                 '</span>',

      productName: '<span class="product-name">' +
                   '<span class="style-name-line1 nsg-font-family--base nsg-text--dark-grey edf-font-size--regular">${productnameline1}</span>' +
                   '<span class="style-name-line2 nsg-font-family--base nsg-text--medium-grey edf-font-size--regular">${productnameline2}</span>' +
                   '</span>',

      itemSwooshPrice: '<span class="strikeout">${listPrice}</span>' +
                       '<span class="list-price nsg-font-family--base nsg-text--medium-grey edf-font-size--regular">${employeePrice}</span>',

      itemRegularPriceTemplate: '<span class="list-price nsg-font-family--base nsg-text--medium-grey edf-font-size--regular">${listPrice}</span>',

      itemSalePriceTemplate: '<span class="strikeout">${listPrice}</span>' +
                             '<span class="list-price nsg-font-family--base nsg-text--medium-grey edf-font-size--regular">${salePrice}</span>',

      nikeIdBadge: '<span class="nikeid-text nsg-font-family--platform nsg-glyph--colorwheel edf-font-size--regular">${nikeIdText}</span>',

      nikeIdSign: '<span class="sign"></span>',

      nflLogo: '<span class="cs-product-teamname">' +
               '<span title="${teamName}" class="icon ${iconName}"></span>' +
               '</span>',

      nflAllTeamEl: '<span class="cs-nfl-all-team">${nflAllTeam}</span>',

      totalColor: '<span class="cs-number-of-colors nsg-font-family--base nsg-text--dark-grey edf-font-size--small">${totalColorText}</span>',

      playerNamesAvailable: '<span class="player-names-available nsg-font-family--base nsg-text--dark-grey edf-font-size--small">${playerNamesAvailable}</span>',

      widthsAvailableEl: '<span class="cs-widths-wrapper">' +
                         '<p class="cs-widths-available-text">${widthsAvailable}</p>' +
                         '</span>',

      button: '<div class="cs-more-cta"><a href="${buttonLink}">${buttonText}</a></div>',

      containerTemplate: '<div class="certona-crossSell">' +
                         '  <div class="crossSell-header-container">' +
                         '    <div class="crossSell-header-text"><div class="crossSell-header nsg-font-family--platform nsg-text--dark-grey">${title}</div></div>' +
                         '    ${button}' +
                         '  </div>' +
                         '  <div class="crossSellContainer">' +
                         '    <ul>${ampedItems}${items}</ul>' +
                         '    <div class="spacer"></div>' +
                         '  </div>' +
                         '</div>'
    },
    mobile_pdp_template: {
        ampedTemplate: '<li class="featured crossSellItem crossSellItem--mobile">' +
                     '  <div class="rec-item-hover">' + // hover border
                     '    <a class="pdp-url" href="${pdpURL}">' +
                     '      <span class="item-image' + '${csImageType}' + '"><img src="${imageURL}" /></span>' +
                     '      ${productRating}' +
                     '      ${widthsAvailableEl}' +
                     '       ${renderedName}' +
                     '      <span class="price">${renderedPrice}</span>' +
                     '      <span class="cs-nikeid edf-font-size--xsmall nsg-text--medium-light-grey">' +
                     '        ${nikeIdBadge}${totalColor}${nikeIdSign}' +
                     '      </span>' +
                     '      ${nflLogo}' +
                     '      ${nflAllTeamEl}' +
                     '    </a>' +
                     '  </div>' + // hover border
                     '</li>',

      itemTemplate: '<li class="crossSellItem crossSellItem--mobile">' +
                    '  <div class="rec-item-hover">' + // hover border
                    '    <a class="pdp-url" href="${pdpURL}">' +
                    '      <span class="item-image' + '${csImageType}' + '"><img src="${imageURL}" /></span>' +
                    '        ${productRating}' +
                    '        ${widthsAvailableEl}' +
                    '        ${renderedName}' +
                    '        <span class="price">${renderedPrice}</span>' +
                    '        <span class="cs-nikeid edf-font-size--xsmall nsg-text--medium-light-grey">' +
                    '          ${nikeIdBadge}${totalColor}' +
                    '        </span>' +
                    '        ${nflLogo}' +
                    '        ${nflAllTeamEl}' +
                    '    </a>' +
                    '  </div>' + // end hover border
                    '</li>',
      styleName: '<span class="product-name">' +
                 '<span class="style-name nsg-font-family--base nsg-text--near-black edf-font-size--xsmall">${styleName}</span>' +
                 '</span>',

      productName: '<span class="product-name">' +
                   '<span class="style-name-line1 nsg-font-family--base nsg-text--near-black edf-font-size--xsmall">${productnameline1}</span>' +
                   '<span class="style-name-line2 nsg-font-family--base nsg-text--medium-light-grey edf-font-size--xsmall">${productnameline2}</span>' +
                   '</span>',

      itemSwooshPrice: '<span class="strikeout">${listPrice}</span>' +
                       '<span class="list-price nsg-font-family--base nsg-text--medium-light-grey edf-font-size--xsmall">${employeePrice}</span>',

      itemRegularPriceTemplate: '<span class="list-price nsg-font-family--base nsg-text--medium-light-grey edf-font-size--xsmall">${listPrice}</span>',

      itemSalePriceTemplate: '<span class="strikeout nsg-text--medium-light-grey">${listPrice}</span>' +
                             '<span class="list-price nsg-font-family--base nsg-text--near-black edf-font-size--xsmall">${salePrice}</span>',

      nikeIdBadge: '<span class="nikeid-text nsg-font-family--base nsg-glyph--colorwheel">${nikeIdText}</span>',

      nikeIdSign: '<span class="sign"></span>',

      nflLogo: '<span class="cs-product-teamname">' +
               '<span title="${teamName}" class="icon ${iconName}"></span>' +
               '</span>',

      nflAllTeamEl: '<span class="cs-nfl-all-team">${nflAllTeam}</span>',

      totalColor: '<span class="cs-number-of-colors nsg-font-family--base nsg-text--medium-light-grey edf-font-size--small">${totalColorText}</span>',

      playerNamesAvailable: '<span class="player-names-available nsg-font-family--base nsg-text--medium-light-grey edf-font-size--small">${playerNamesAvailable}</span>',

      widthsAvailableEl: '<span class="cs-widths-wrapper">' +
                         '<p class="cs-widths-available-text">${widthsAvailable}</p>' +
                         '</span>',

      button: '<div class="cs-more-cta"><a href="${buttonLink}">${buttonText}</a></div>',

      containerTemplate: '<div class="certona-crossSell">' +
                         '  <div class="crossSell-header-container">' +
                         '    <div class="crossSell-header-text"><div class="crossSell-header nsg-font-family--platform nsg-text--near-black">${title}</div></div>' +
                         '    ${button}' +
                         '  </div>' +
                         '  <div class="crossSellContainer">' +
                         '    <ul>${ampedItems}${items}</ul>' +
                         '    <div class="spacer"></div>' +
                         '  </div>' +
                         '</div>'
    },
    gearup_template: {
      itemTemplate: '<div class="exp-slide ${activeProduct}" data-option="">' +
                    '  <div class="exp-selected_product">' +
                    '    <div class="exp-product_image_container_cross">' +
                    '      <a href="${pdpURL}" data-name="${styleName}" data-productid="${productId}" class="pdp-url exp-pdp-selector">' +
                    '       <img src="${imageURL}" alt="" />' +
                    '      </a>' +
                    '    </div>' +
                    '    <div class="exp-product_detail_container">' +
                    '      <div class="exp-price">${renderedPrice}</div>' +
                    '       ${productRating}' +
                    '      <div class="clear"></div>' +
                    '      <div class="exp-product_title">${styleName}</div>' +
                    '      <div class="clear"></div>' +
                    '      <div class="exp-color_count">${totalColor}</div>' +
                    '      <div class="exp-mini-pdp-container"> ' +
                    '           <a href="${pdpURL}" data-name="${styleName}" data-productid="${productId}" class="pdp-url exp-gac_cart_btn exp-cart_btn exp-btn_st">${buyNowText}</a>' +
                    '      </div>' +
                    '    </div>' +
                    '   <div class="exp-options-nav">'  +
                    '     <div class="exp-options-title">${optionsText}</div>'  +
                    '       <a class="exp-arrow-left" data-productposition="3" href="javascript:void(0);"/>'  +
                    '        <ul>'  +
                    '          <li class="active">'  +
                    '            <a href="javascript:void(0);" data-productoption="1">1<span>${firstOption}</span></a>'  +
                    '          </li>'  +
                    '          <li>'  +
                    '            <a href="javascript:void(0);" data-productoption="2">2<span>${secondOption}</span></a>'  +
                    '          </li>'  +
                    '          <li class="last"> '  +
                    '            <a href="javascript:void(0);" data-productoption="3">3<span>${thirdOption}</span></a>'  +
                    '          </li>'  +
                    '        </ul>'  +
                    '        <a data-id="nextone" class="exp-arrow-right" data-productposition="3" href="javascript:void(0);"/>'  +
                    '        <div class="clear"></div>'  +
                    '    </div>' +
                    '  </div>' +
                    '</div>' ,

      gearTemplate: '${gearTitle}' +
                    '<li class="exp-selected_product">' +
                    '  <a href="${pdpURL}" data-name="${styleName}" class="pdp-url">' +
                    '     <img src="${imageURL}" alt=""/>' +
                    '  </a>' +
                    '</li>'+
                    '${gearEnding}',

      styleName: '<span class="exp-product-name">' +
                 '<span class="exp-style-name">${styleName}</span>' +
                 '</span>',

      productName: '<span class="exp-product-name">' +
                   '<span class="exp-style-name-line1">${productnameline1}</span>' +
                   '<span class="exp-style-name-line2">${productnameline2}</span>' +
                   '</span>',

      itemSwooshPrice: '<span class="exp-strikeout">${listPrice}</span>' +
                       '<span class="exp-list-price">${employeePrice}</span>',

      itemRegularPriceTemplate: '<span class="exp-list-price">${listPrice}</span>',

      itemSalePriceTemplate: '<span class="exp-strikeout">${listPrice}</span>' +
                             '<span class="exp-list-price">${salePrice}</span>',

      nikeIdBadge: '<span class="exp-nikeid-text">${nikeIdText}</span>',

      nflLogo: '<span class="exp-cs-product-teamname">' +
               '<span title="${teamName}" class="exp-icon ${iconName}"></span>' +
               '</span>',

      nflAllTeamEl: '<span class="exp-cs-nfl-all-team">${nflAllTeam}</span>',

      totalColor: '<span class="exp-cs-number-of-colors">${totalColorText}</span>',

      widthsAvailableEl: '<span class="exp-cs-widths-wrapper">' +
                         '<p class="exp-cs-widths-available-text">${widthsAvailable}</p>' +
                         '</span>',

      button: '<a class="exp-nike-button exp-nike-button-dark exp-cs-nikeid-button" href="${buttonLink}">${buttonText}</a>',

      containerTemplate: '<div class="exp-secondary-slideshow-container exp-slideshow-container">' +
                         '   <div class="exp-slideshow-${containerIndex} exp-slideshow">' +
                         '   ${ampedItems}${items} '  +
                         '  </div>'  +
                         '</div>'
    }
  },

  /**
   * Populate the specified template with the values in productData and add the markup to the element
   *
   */
  renderCrossSell: function (element, templateName, productLists) {
    var elementData = $(element).data();
    var localValues = elementData.localValues || {};
    var template = nike.CrossSellRenderer.templates[templateName];
    var populatedTemplate = '';
    var item = '';
    var items = '';
    var ampedItem = '';
    var ampedItems = '';
    var tempList;
    var listsIndex, listsLength;
    var productsIndex, productsLength;
    var allPopulatedTemplates = '';
    var currency = element.data('currency');
    var nikeIdUrl = localValues["nikeid-url"];
    var nikeIdButtonText = localValues["nikeid-button"];
    var nikeIdText = localValues["nikeid-text"];
    var customize = localValues["pdp.crosssell.nikeid"];
    var teamName = element.data('nfl-team-name');
    var iconName = '';
    var nflLogo = '';
    var scheme = element.data('scheme-names');
    var currentStoreURL = nike.getRootUrl();
    var urlProductMap = {};
    var colorText = localValues["color-singular"];
    var colorsText = localValues["color-plural"];
    var widthsAvailableText = localValues["widths-available"];
    var nflAllTeamText = localValues["all-nfl-teams-available"];
    var playerText = localValues["player-singular"];
    var playersText = localValues["player-plural"],
    buyNowText = localValues["buy-now"],
    optionsText = localValues["options" ],
    firstOption = localValues["first-option"],
    secondOption = localValues["second-option"],
    thirdOption = localValues["third-option"],
    gearTitleText = localValues["gear_rr"],
    playerNamesAvailableText = localValues["playerNamesAvailable"];

    if (template === undefined) {
      nike.error('Invalid template name: ' + templateName);
    } else if (productLists === undefined) {
      nike.error('No productData passed');
    } else {

      for (listsIndex = 0, listsLength = productLists.length; listsIndex < listsLength; listsIndex++) {
        tempList = '';
        populatedTemplate = '';
        items = '';
        item = '';
        ampedItems = '';
        nflLogo = '';
        tempList = productLists[listsIndex];
        for (productsIndex = 0, productsLength = tempList.products.length; productsIndex < productsLength; productsIndex++) {
          var renderedPrice = '';
          var product = tempList.products[productsIndex];
          var isAmped = (productsIndex == 0 && (productsLength == 5 || productsLength == 6)) || (productsIndex == 1 && productsLength == 6 ) ? true : false;
          var isGift = /GIFTCERTIFICATE/i.test(product.nikeType); // this will match anything with type giftcertificate even digitalgiftcertificate
          var productType = (product.productType != undefined) ? product.productType : product.nikeType;

          //html decode to restore the special character
          var prodName1decode = (product.productnameline1 && product.productnameline1 != "") ? $('<div/>').html(product.productnameline1).text() : "";
          var prodName2decode = (product.productnameline2 && product.productnameline2 != "") ? $('<div/>').html(product.productnameline2).text() : "";

          // if item has product name; else use styleName
          var renderedName = ((prodName1decode != undefined && prodName1decode != "") || (prodName2decode != undefined && prodName2decode != "")) ? nike.CrossSellRenderer.doReplacement(template.productName, product) : nike.CrossSellRenderer.doReplacement(template.styleName, product);
          var activeProduct = (productsIndex == 0) ? 'active' : "";
          var gearTitle = (productsIndex == 0) ? "<div class='exp-this-goes-with' >" +
                                                 "<div class='exp-carousel-title'>" +
                                                 gearTitleText+ "</div> " +
                                                 "<div class='exp-carousel_goes_with_wrapper'>" +
                                                 "<a class='exp-carousel_prev' href='javascript:void(0)'></a>" +
                                                 "<div class='exp-carousel_goes_with'>" +
                                                 "<ul data-id='exp-mycarousel'>" : "";
          var gearEnding = (productsIndex == productsLength - 1) ? "</ul> " +
                                                                   "</div> " +
                                                                   "<a class='exp-carousel_next' href='javascript:void(0)'></a> " +
                                                                   "</div>" +
                                                                   "</div>" : "";
          var overallRating = (product.ratings != 0) ? '<div class="exp-overall_rating">' +
                                   '<div class="exp-product_rating" data-rating="'+ product.ratings +'"  style="width: '+((Math.round(parseFloat(product.ratings))/5)*100)+'%;">' +
                                   '</div>' +
                                   '</div>': '';

          var overallReviews = (product.reviews != 0) ? ' <div class="exp-reviews-summary-review-count nsg-font-family--base nsg-text--medium-grey edf-font-size--xsmall">' +
                                   '('+ product.reviews +')' +
                                   '</div>' : '' ;

          var productRating = '<div class="exp-rating_wrap">';
          if(nike.FEATURE_LIST['RATINGS_REVIEWS'])
          {
            productRating += overallRating + overallReviews;
          }
          productRating += '</div>'

          if(elementData.isMobile) {
            productRating = '';
          }

          // if NIKEiD product
          var isNikeiD = product.nikeType == "NIKEID";
          var nikeIdBadge = isNikeiD ? nike.CrossSellRenderer.doReplacement(template.nikeIdBadge, {nikeIdText: nikeIdText, customize: customize}) : "";
          var nikeIdSign = isNikeiD ? nike.CrossSellRenderer.doReplacement(template.nikeIdSign,{}) : "";

          //for total number of colors OR Players Names Available msg
          var griditemMessaging = '';
          var messagingTemplate = template.totalColor;

          if(product.playerNamesAvailable ==  "true" && !isNikeiD){
            griditemMessaging = nike.CrossSellRenderer.doReplacement(template.playerNamesAvailable, {"playerNamesAvailable": playerNamesAvailableText});
            messagingTemplate = template.playerNamesAvailable;
          }
          else{
            if (!isNikeiD && product.colors != null && product.colors.length > 0) {
              if (product.colors == '1' || product.colors == "0") {
                  griditemMessaging = ' ';
              } else {
                if(product.playerNamesAvailable ==  "true"){
                  griditemMessaging = product.colors + ' ' + playersText;
                }else{
                  griditemMessaging = product.colors + ' ' + colorsText;
                }
              }
            }
            griditemMessaging = griditemMessaging.length > 0 ? nike.CrossSellRenderer.doReplacement(messagingTemplate, {"totalColorText": griditemMessaging}) : "";
          }

          var totalColor = griditemMessaging;

          //for null search pages (which needs 5 items but no amped products)
          if (tempList.schemeName == 'nosearch1_rr' || tempList.schemeName == 'nosearch2_rr') {
            isAmped = false;
          }

          //for showing 'widths available'
          var widthsAvailable = '';
          if (product.widths == 'Y') {
            widthsAvailable = widthsAvailableText;
          }
          var widthsAvailableEl = widthsAvailable.length > 0 ? nike.CrossSellRenderer.doReplacement(template.widthsAvailableEl, {widthsAvailable: widthsAvailable}) : "";

          //for showing 'widths available'
          var nflAllTeam = '';
          if (product.nfl == 'Y' && isNikeiD) {
            nflAllTeam = nflAllTeamText;
          }
          var nflAllTeamEl = nflAllTeam.length > 0 ? nike.CrossSellRenderer.doReplacement(template.nflAllTeamEl, {nflAllTeam: nflAllTeam}) : "";

          //for Team / NFL logos
          if (product.nfl == 'Y' && isNikeiD) { //if nfl && if nike iD  (to display only on Dunks)
            if (teamName !== undefined) { //if team
              // display team
              iconName = teamName.split(' ').join('-').toLowerCase();
              nflLogo = iconName.length > 0 ? nike.CrossSellRenderer.doReplacement(template.nflLogo, {iconName: iconName, teamName: teamName}) : "";
            }
            else { //else display NFL
              nflLogo = '';
            }
          } else { //else no badge
              nflLogo = '';
          }

          // add currency sign to listprice
          product.listPrice = nike.CrossSellRenderer.getFormattedPrice(currency, product.listPrice);
          // render price, not applicable to Gift card & if Global Store feature flag doesn't allow.
          if (nike.FEATURE_LIST['PRICING_RECS'] && !isGift) {
            // if product on sale or user is employee
            if (nike.gadget.CrossSell.isSwoosh == true && product.employeeDiscount == '1') {
              // add currency sign to employee price
              product.employeePrice = nike.CrossSellRenderer.getFormattedPrice(currency, product.employeePrice);
              renderedPrice = nike.CrossSellRenderer.doReplacement(template.itemSwooshPrice, product);
            } else if (product.onSale == '1') {
              // add currency sign to sale price
              product.salePrice = nike.CrossSellRenderer.getFormattedPrice(currency, product.salePrice);
              renderedPrice = nike.CrossSellRenderer.doReplacement(template.itemSalePriceTemplate, product);
            } else {
              renderedPrice = nike.CrossSellRenderer.doReplacement(template.itemRegularPriceTemplate, product);
            }
          }

          // If not amped, Construct IMG URL
          if (!isAmped) {
            var styleName = nike.CrossSellRenderer.formatProductName(product.styleName);
            var colorNumber = product.colorNumber;
            var templatePath = product.nikeType;
            var styleNumber = product.styleNumber;
            var preBuildId = product.prebuildId;
            var nikeType = product.nikeType;
            var productId = product.id;

            // Temporary placeholder image sizes in use until mobile Scene7 image templates are determined.
            // 2x-sized image
            var mobileImgSidePx = 256;
            // 1x-sized image
            // var mobileImgSidePx = 128;

            product.csImageType = ' fullsize';

            if (isNikeiD) {

              var props = {
                style: styleName,
                styleNumber: preBuildId,
                templatePath: productType,
                extension: 'tif',
                isAmped: isAmped,
                isSecure: nike.SSL_ONLY,
                nikeType: nikeType
              }

              if (elementData.isMobile) {
                props.height = mobileImgSidePx;
                props.width = mobileImgSidePx;
              }

              product.imageURL = nike.ImageUtil.getNikeIdImageUrl(props);
              if(product.productType == "Gear"){
                product.csImageType += " nike-id-gear";
              }
              product.csImageType += ' nike-id';

            } else {
              var props = {
                style: styleName,
                styleNumber: styleNumber,
                color: colorNumber,
                templatePath: productType,
                isAmped: isAmped,
                isSecure: nike.SSL_ONLY,
                nikeType: nikeType,
                nocrop: 'no-crop'
              }

              if(( listsIndex != 2) && (tempList.schemeName == 'tops_rr' || tempList.schemeName == 'bottoms_rr' || tempList.schemeName == 'shoes_rr' || tempList.schemeName === 'gear_rr')){
                props.height = 246;
                props.width = 200;
              }
              else if(( listsIndex === 2) && (tempList.schemeName == 'tops_rr' || tempList.schemeName == 'bottoms_rr' || tempList.schemeName == 'shoes_rr' || tempList.schemeName === 'gear_rr')){
                props.height = 120;
                props.width = 120;
                props.format = 'png-alpha';
              }else if(nikeType == "FOOTWEAR"){
                props.nocrop = "";
              }

              if (elementData.isMobile) {
                props.height = mobileImgSidePx;
                props.width = mobileImgSidePx;
               }
              product.imageURL = nike.ImageUtil.getGridwallImageUrl(props);
            }
          }


          //Amplify first if 5 products, amplify first two if 6 products
          if (isAmped) {
            product.csImageType = (scheme == "nfljerseypdp_rr" || scheme == "nfljerseykidspdp_rr") ? ' cs-jersey' : ' cs-builder';
            ampedItem = nike.CrossSellRenderer.doReplacement(template.ampedTemplate, product);
            ampedItems += nike.CrossSellRenderer.doReplacement(ampedItem, {nikeIdBadge: nikeIdBadge, nikeIdSign: nikeIdSign, nflLogo: nflLogo, renderedName: renderedName, renderedPrice: renderedPrice, totalColor: totalColor, widthsAvailableEl: widthsAvailableEl, nflAllTeamEl: nflAllTeamEl, productRating: productRating});
          } else {
            item = (listsIndex === 2 && (tempList.schemeName == 'gear_rr' || tempList.schemeName == 'tops_rr' || tempList.schemeName === 'bottoms_rr' || tempList.schemeName === 'shoes_rr')) ? nike.CrossSellRenderer.doReplacement(template.gearTemplate, product) : nike.CrossSellRenderer.doReplacement(template.itemTemplate, product);
            items += nike.CrossSellRenderer.doReplacement(item, {nikeIdBadge: nikeIdBadge, buyNowText : buyNowText,productId: productId, nflLogo: nflLogo, activeProduct: activeProduct, productRating: productRating, gearTitle: gearTitle,gearEnding: gearEnding, renderedName: renderedName, renderedPrice: renderedPrice, totalColor: totalColor, widthsAvailableEl: widthsAvailableEl, nflAllTeamEl: nflAllTeamEl});
          }
          urlProductMap[product.pdpURL] = product;
        }

        // if NikeId schema, add "see all" button
        var button = ((tempList.schemeName === "nosearch2_rr" || tempList.schemeName === "inactivepdp2_rr") && nikeIdUrl && nikeIdButtonText) ? nike.CrossSellRenderer.doReplacement(template.button, {buttonLink: nikeIdUrl, buttonText: nikeIdButtonText}) : "";
        var title = (tempList.explanation === "" || tempList.explanation === undefined || tempList.explanation === null) ? tempList.reccomendationTitle : tempList.explanation;
        var containerIndex = listsIndex +1;
        populatedTemplate = nike.CrossSellRenderer.doReplacement(template.containerTemplate, {ampedItems: ampedItems, items: items, title: title, button: button, containerIndex: containerIndex, optionsText : optionsText, firstOption : firstOption, secondOption : secondOption, thirdOption: thirdOption});
        allPopulatedTemplates += populatedTemplate;
      }


      //Set html of element to the populated template
      // if there are amplified products add class "amped-1" for 1 amplified
      // and "amped-2" for 2 amplified products as class name to container <ul>
      $(element).html(allPopulatedTemplates).find('.crossSellContainer ul').addClass(ampedItems ? 'amped-' + (productsLength - 4) : '').end().find('.crossSell-header').after(elementData.isMobile ? '<span class="scallop"></span>' : '');
      var $crossSellContainer = $(element).find('.crossSellContainer');
      $crossSellContainer.each(function() {
        var self = this;
        if ($(self).find('.nikeid-text').length > 0) {
          $(self).find('li').addClass('is-nikeid');
        }
      });

      //Setup click events for this template
      $(element).find('a.pdp-url').each(function () {
        nike.gadget.CrossSell.setupProductClick(element, this, urlProductMap[$(this).attr('href')]);
      });

      if(!elementData.isMobile) {
        // Get all crossSell items
        var $crossSellItems = $(element).find('.crossSellItem');
        // Setup mouse events
        $crossSellItems.each(function() {
          var $crossSellItem = $(this);
          // If device has touch, use 'touchstart', else 'mouseenter'
          $crossSellItem.find('.rec-item-hover').on(nike.interactionType.enter, '.item-image', function(e) {
            if ($crossSellItem.hasClass('on')) {
              return;
            } else {
              e.preventDefault();
            }
            $crossSellItems.removeClass('on');
            $crossSellItem.addClass('on');
          });
          // If device has touch, use 'touchend', else 'mouseleave'
          $crossSellItem.on('mouseleave', function() {
            $crossSellItem.removeClass('on');
          });
        });
      }

      //add QA automation
      if (nike.ENV_CONFIG && nike.ENV_CONFIG.renderDataQA == "true") {
        nike.Util.addQaAttribute($(element).find('.crossSell-header'), 'cross_sell.title');
        var itemIndex = 1;
        $(element).find('a.pdp-url').each(function () {
          nike.Util.addQaAttribute($(this), 'cross_sell.item-' + itemIndex);

          var itemImg = $(this).find('img');
          if (itemImg.length > 0) {
            nike.Util.addQaAttribute(itemImg, 'cross_sell.image-' + itemIndex);
          }
          var crossSellTitle = $(this).find('.style-name-line1');
          if (crossSellTitle.length > 0) {
            nike.Util.addQaAttribute(crossSellTitle, 'cross_sell.title-' + itemIndex);
          }
          var itemTitle = $(this).find('.style-name');
          if (itemTitle.length > 0) {
            nike.Util.addQaAttribute(itemTitle, 'cross_sell.title-' + itemIndex);
          }
          var itemSubTitle = $(this).find('.style-name-line2');
          if (itemSubTitle.length > 0) {
            nike.Util.addQaAttribute($(this).find('.style-name-line2'), 'cross_sell.subtitle-' + itemIndex);
          }
          var itemPrice = $(this).find('.list-price');
          if (itemPrice.length > 0) {
            nike.Util.addQaAttribute(itemPrice, 'cross_sell.price-' + itemIndex);
          }
          var numOfColors = $(this).find('.cs-number-of-colors');
          if (numOfColors.length > 0) {
            nike.Util.addQaAttribute(numOfColors, 'cross_sell.colorcount-' + itemIndex);
          }
          var playernamesavailable = $(this).find('.player-names-available');
          if (playernamesavailable.length > 0) {
            nike.Util.addQaAttribute(playernamesavailable, 'cross_sell.playernamesavailable-' + itemIndex);
          }
          var productRatings = $(this).find('.exp-product_rating');
          if (productRatings.length > 0) {
            nike.Util.addQaAttribute($(this).find('.exp-product_rating'), 'cross_sell.averagerating-' + itemIndex);
          }

          itemIndex++;
        });
      }

      //Do glyphPolyfill for IE7
      if (!Modernizr.generatedcontent) {
        nike.fonts.glyphPolyfill.replaceGlyphs($(element));
      }
    }

    if (!Modernizr.mq('only screen')) { // if browser doesn't support media query (IE8 below), use javascript to respond to different screen sizes
      $('html').addClass('no-mq');
      nike.dispatchEvent(nike.Event.PAGE_LAYOUT, {modernizerUpdate:true, ie8Sucks:true});
    }

    var thisGoesWithEl = $(element).find('div.exp-slideshow div.exp-this-goes-with');
    if($(element).find('div.exp-slideshow div.exp-this-goes-with').length == 1){
      nike.CrossSellRenderer.setupCrossSellCarousel(thisGoesWithEl);
    }

    nike.dispatchEvent(nike.Event.CROSSSELL_RENDER_COMPLETE, {});
  },

  /**
   * Simple value replacer that will replace instances or ${propname} in the itemtemplate with the values in the data object at propname.
   */
  doReplacement: function (itemTemplate, dataObject) {
    var prop;
    var populatedItem = itemTemplate;

    for (prop in dataObject) {
      if (dataObject.hasOwnProperty(prop)) {
        //populatedItem = populatedItem.replace('${' + prop + '}', dataObject[prop]);
        populatedItem = populatedItem.split('${' + prop + '}').join(dataObject[prop]);
      }
    }

    return populatedItem;
  },

  getFormattedPrice: function (currency, price) {
    if (price) {
      // If price is whole number, take out ".00"
      var priceArray = price.split(".");
      var cent = parseInt(priceArray[1]);
      price = (cent > 0) ? price : priceArray[0];
      //remove thousands separator (,)
      price = price.replace(',', '');

      if( !nike.gadget.CrossSell.priceFormatters[currency] ){
        nike.warn('[ CrossSellRenderer ] - No currency set for country');
        return 0;
      }else{
        return nike.gadget.CrossSell.priceFormatters[currency](price);
      }
    } else {
      return 0;
    }
  },

  formatProductName: function (productName) {
    var ret = '';

    if (productName) {
      ret = productName.replace(/ /g, "-").replace(/(['"()])/g, "").replace(/[^a-zA-Z0-9-]/gi, '');  // replace spaces with "-" and takes out characters '()
    }
    return ret;
  },

  setupCrossSellCarousel : function(element){
    var $slideShowContainer = $(element);
    var $nextArrow = $slideShowContainer.find('.exp-carousel_next');
    var $prevArrow = $slideShowContainer.find('.exp-carousel_prev');
    var $carousel = $slideShowContainer.find('.exp-carousel_goes_with');
    var $list = $carousel.find('ul');
    var $listItems = $list.find('li');
    var listWidth = 0;
    var widthOfFirstSix = 0;
    var containerWidth = 0;

    $listItems.each(function(index, item){
      listWidth += $(item).width();
      if(index < 6){
        widthOfFirstSix += $(item).width();
      }
    });

    //set list's width
    $list.width(listWidth);

    // get the width of the first 6 and use it to set view width
    $carousel.width(widthOfFirstSix);

    //get the width of the arrows + the 20px of padding around them + another 20px padding around the carousel
    //plus the width of the first 6(technically we can use the $carousel.width() as well.
    containerWidth = $nextArrow.width() + $prevArrow.width() + 90 + widthOfFirstSix;

    $slideShowContainer.width(containerWidth);

    //on first load we hide the prev arrow
    $prevArrow.hide();

    //if there are less than 6 items we need to hide the next arrow as well
    if($listItems.size() <= 6){
      $nextArrow.hide();
    }

    $prevArrow.on('click touch', function(event){
      var thisTarget = $(event.currentTarget);
      var parent = $(thisTarget).parent();
      var $nextArrow = $(parent).find('.exp-carousel_next');
      var $carousel = $(parent).find('.exp-carousel_goes_with');
      var carouselWidth = $carousel.width();
      var $carouselList = $carousel.find('ul');
      var listItems = $carouselList.find('li');
      var widthOfLastLiElements = 0;
      var widthOfFirstSix = 0;
      var carouselListWidth = $carouselList.width();

      var listItemWidth = 0;
      listItems.each(function(index, element){
        if( index < 6){
          widthOfFirstSix += $(element).width();
        } else {
          widthOfLastLiElements += $(element).width();
        }
        listItemWidth += $(this).width();
      });

      $carouselList.animate({
        right:'-=' + widthOfLastLiElements
      });

      $(thisTarget).hide();
      $nextArrow.show();
    });

    $nextArrow.on('click touch', function(event){
      var thisTarget = $(event.currentTarget);
      var parent = $(thisTarget).parent();
      var $prevArrow = $(parent).find('.exp-carousel_prev');
      var $carousel = $(parent).find('.exp-carousel_goes_with');
      var carouselWidth = $carousel.width();
      var $carouselList = $carousel.find('ul');
      var listItems = $carouselList.find('li');
      var widthOfLastLiElements = 0;
      var widthOfFirstSix = 0;

      var listItemWidth = 0;
      listItems.each(function(index, element){
        if( index < 6){
          widthOfFirstSix += $(element).width();
        } else {
          widthOfLastLiElements += $(element).width();
        }
        listItemWidth += $(this).width();
      });

      $carouselList.animate({
        right:'+=' + widthOfLastLiElements
      }, 500);

      //Here we assume that there is only 12 products this could be made to
      //handle more but right now it's out of scope
      $(thisTarget).hide();

      $prevArrow.show();
    });
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.CrossSellRenderer. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.gadget.CrossSell');

nike.requireDependency('nike.Util');
nike.requireDependency('nike.util.BooleanUtil');
nike.requireDependency('nike.CrossSellRenderer');
nike.requireDependency('nike.NavigationUtil');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('nike.Cart');
nike.requireDependency('nike.Event');
nike.requireDependency('nike.exp.global.LocalValueUtil');

nike.gadget.CrossSell.supportedVendors = {certona : 'certona'};

nike.gadget.CrossSell.setup = function(eventData){

    var csElement = eventData.element;
    var data = $(csElement).data();

    data.localValues = {
      "product_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.product_rr"),
      "nikeidpdp_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nikeidpdp_rr"),
      "cart_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.cart_rr"),
      "purchase_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.purchase_rr"),

      "nflbuilderpdp_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nflbuilderpdp_rr"),
      "nfljerseypdp_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nfljerseypdp_rr"),
      "nfljerseykidspdp_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nfljerseykidspdp_rr"),
      "nflpdp_rr_suffix": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nfl_pdp_suffix"),

      "error4041_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.error4041_rr"),
      "error4042_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.error4042_rr"),
      "error4043_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.error4043_rr"),

      "nosearch1_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nosearch1_rr"),
      "nosearch2_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.nosearch2_rr"),

      "inactivepdp1_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.inactivepdp1_rr"),
      "inactivepdp2_rr": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.title.inactivepdp2_rr"),

      "gear_rr": nike.exp.global.LocalValueUtil.getLocal("gearUp.thisGoesWith"),

      "nikeid-text": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.nikeidText"),
      "pdp.crosssell.nikeid": nike.exp.global.LocalValueUtil.getLocal("pdp.crosssell.nikeid"),
      "nikeid-url": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.nikeidUrl"),
      "nikeid-button": nike.exp.global.LocalValueUtil.getLocal("crossSell.certona.nikeidUrlText"),

      "color-plural": nike.exp.global.LocalValueUtil.getLocal("gridwall.colorplural"),
      "color-singular": nike.exp.global.LocalValueUtil.getLocal("gridwall.colorsingular"),
      "player-plural": nike.exp.global.LocalValueUtil.getLocal("gridwall.playersAvailable"),
      "player-singular": nike.exp.global.LocalValueUtil.getLocal("gridwall.singularPlayerAvailable"),
      "widths-available": nike.exp.global.LocalValueUtil.getLocal("buyingtools.widths.title"),
      "all-nfl-teams-available": nike.exp.global.LocalValueUtil.getLocal("gridwall.nfl.allteams"),
      "buy-now": nike.exp.global.LocalValueUtil.getLocal("gearUp.buyNow"),
      "options": nike.exp.global.LocalValueUtil.getLocal("gearUp.options"),
      "first-option": nike.exp.global.LocalValueUtil.getLocal("gearUp.firstOptionSuffix"),
      "second-option": nike.exp.global.LocalValueUtil.getLocal("gearUp.secondOptionSuffix"),
      "third-option": nike.exp.global.LocalValueUtil.getLocal("gearUp.thirdOptionSuffix"),
      "playerNamesAvailable": nike.exp.global.LocalValueUtil.getLocal("pw.nikeid.bannerbottom.customizejersey")
    };

    // determining if user is an employee by looking at the CART_SUMMARY cookie
    nike.gadget.CrossSell.isSwoosh = false;
    nike.gadget.CrossSell.isNikeId = false;

    if (nike.Cart.getUserType() == nike.Cart.UserType.EMPLOYEE || nike.Cart.getUserType() == nike.Cart.UserType.AFFILIATE) {
      nike.gadget.CrossSell.isSwoosh = true;
    }

    data.userType = nike.Cart.getUserType();
    data.profileId = nike.Cart.getProfileId();

    nike.gadget.CrossSell.refreshRecommendations(csElement);

    // Setup the LinkRedirector to respond to the CROSS_SELL_PRODUCT_CLICK
    var setup = new nike.gadget.LinkRedirector.PageSetup(true);
    setup.setupEvent(nike.gadget.Event.CROSS_SELL_PRODUCT_CLICK);
    nike.gadget.LinkRedirector.setupPageEvents(setup);
};

nike.gadget.CrossSell.refreshRecommendations = function(csElement){

  var data = $(csElement).data();
  var vendor = data.crosssellvendor;
  if(!nike.Util.isBlank(vendor)){

      if(vendor === nike.gadget.CrossSell.supportedVendors.certona){
          //Use certona as the vendor
          nike.gadget.CrossSell.setupCertonaCrossSell(csElement, data);

      } else {
          //Vendor not recognized.  Log a warning and use the default vendor
          nike.warn('Cross sell vendor param not recognized: ' + vendor + ' - Trying default vendor');
          nike.gadget.CrossSell.setupDefaultCrossSell(csElement, data);
      }

  } else {
      //Use default vendor if no vendor sent
      nike.gadget.CrossSell.setupDefaultCrossSell(csElement, data);
  }
};

/**
 * setup crosssell products using certona.
 * @author gballi
 * notes: refactored 2013-12-31
 */
nike.gadget.CrossSell.setupCertonaCrossSell = function(element, data) {
  var self = nike.gadget.CrossSell, schemeNames, productImpressions,
             gadgetData, requestData, products;

  // make sure CertonaTools are available
  if(!nike.objectDefined('nike.analytics.crosssell.CertonaTools')) {
    nike.error('nike.analytics.crosssell.CertonaTools must be ' +
               'defined to use the CrossSell gadget with certona as ' +
               'the vendor. Make sure CertonaTools has been added ' +
               'to the asset list and there are no other script errors.');


    return false;
  }

  // We have all the data we need in the gadget so we can can request recommendations for inline & PNF.
  // For iD, we have to wait for the product data from iD builder
  if(!data.isNikeId && !nike.analytics.crosssell.CertonaTools.isInitialized ){
    if(data.productImpressions && typeof data.productImpressions === 'string') {
        productImpressions = data.productImpressions.split(',');
    }
    if(data.products && typeof data.products === 'number') {
      products = [{productId: data.products}];
    }else if(data.products && typeof data.products === 'string'){
      //convert semi-colons to commas, split and filter empty items, and add to an array of objects
      products = data.products.replace(/;/g, ",").split(',').filter(function(item){return !!item}).map(function(id){return {productId: id.trim()}});
    }

    gadgetData = {
        productImpressions: productImpressions,
        appId: data.appId || nike.APP_ID,
        products: products,
        country: data.country || nike.COUNTRY,
        crossSellHost: nike.ENV_CONFIG.certonaHost,
        profileId: data.profileId,
        userType: data.userType
    }

    // make sure the tools are initialized. if they are not initialized,
    // set up a listener for the initialization event.
  } else if(!nike.analytics.crosssell.CertonaTools.isInitialized) {
    var eventHandler = function() {
      // remove the listener
      nike.unlisten(nike.Event.CERTONA_TOOLS_SETUP_COMPLETE);
      return nike.gadget.CrossSell.setupCertonaCrossSell(element, data);
    };

    // subscribe to the event
    nike.listen(nike.Event.CERTONA_TOOLS_SETUP_COMPLETE, eventHandler);

    return true;
  }


  if(data.schemeNames && typeof(data.schemeNames) === 'string') {
    schemeNames = data.schemeNames.split(',');
  } else {
    nike.error('data.schemeNames was not found or is not in the ' +
               'expected format. It should be a comma-separated ' +
               'list of schemes.');
    return false;
  }

  // make sure the template is defined
  if(nike.Util.isBlank(data.template)) {
    nike.error('data.template must be defined.');
    return false;
  }

  // get recommendations
  requestData = {
    currency: data.currency,
    country: data.country || nike.COUNTRY,
    language: data.language,
    numProducts: data.numProducts,
    schemeNames: schemeNames,
    eventName: data.eventName,
    nflTeamName: data.nflTeamName,
    studio : nike.util.BooleanUtil.getBoolean(data.studio, false) || null,
    timeout: data.timeout,
    successCallback: function(productLists) {
      // loop through the product lists and set the title
      var self = nike.gadget.CrossSell;
      for(var i in productLists) {
        var list = productLists[i];
        var localValues = $(element).data().localValues;
        var schemeName = list.schemeName;
        var nflTeamName = data.nflTeamName;
        var reccomendationTitle = self.getRecommendationTitle(schemeName, nflTeamName, localValues);
        list.reccomendationTitle = reccomendationTitle;
      }

      // display the cross sells
      self.displayCrossSells(element, data.template, productLists);
      //set back to false once we have cross sell data
      nike.analytics.Tracking.certonaRequestSetup = false;
    },
    failCallback: function() {
      nike.error('Failed when attempting to retrieve Certona ' +
                 'recommendations.');
    }
  };

  // if we have gadgetData, proceed to setup CertonaTools without waiting on tracking.
  if(gadgetData){
    requestData = $.extend(requestData, gadgetData);
    nike.analytics.crosssell.CertonaTools.setup(requestData);
    nike.analytics.Tracking.certonaRequestSetup = true;
  }

  // get recommendations
  nike.analytics.crosssell.CertonaTools.getRecommendations(requestData);
};


nike.gadget.CrossSell.getRecommendationTitle = function(schemeName, teamName, localValues){
  var title = 'NO TITLE FOUND! (' + schemeName + ')';
  if(localValues[schemeName] !== undefined){
    title = localValues[schemeName];
  }

  if (schemeName !== undefined ? schemeName.indexOf('nfl') != -1 : false) {
    if (teamName !== undefined && localValues["nflpdp_rr_suffix"] !== undefined) {
      title += ' ' + teamName.toUpperCase() + ' ' + localValues["nflpdp_rr_suffix"];
    }
  }

  return title;
};


nike.gadget.CrossSell.displayCrossSells = function(element, template, products){
    nike.CrossSellRenderer.renderCrossSell(element, template, products);
};


/**
 * Default crossSell setup if no vendor is specified
 */
nike.gadget.CrossSell.setupDefaultCrossSell = function (element, data){
    return nike.gadget.CrossSell.setupCertonaCrossSell(element, data);
};

/**
 * Setup gadget when it is loaded
 */
nike.listen(nike.EVENT_GADGET_LOADED, function(event, data){
  if (data && data.gadgetName == 'nike.gadget.CrossSell'){
    nike.gadget.CrossSell.setup(data);
  }
});

/**
 * Setup the click event and optional navigation for when a product link is clicked.
 * If the click event does not have a link target, it will just fire the event.
 */
nike.gadget.CrossSell.setupProductClick = function(crossSellElement, elementToClick, productInfo) {
  var followUrls = nike.util.BooleanUtil.getBoolean($(crossSellElement).data().followUrls, true);

  $(elementToClick).click(function(ev) {
      ev.preventDefault();
      var eventData = nike.navUtil.getLinkEventProperties(ev);
      eventData.element = crossSellElement;
      eventData.productInfo = productInfo;
      eventData.noFollow = eventData.noFollow || !followUrls;

      nike.dispatchEvent(nike.gadget.Event.CROSS_SELL_PRODUCT_CLICK, eventData);
  });
};

/**
 * Price formater. Iserts decimal and thousands separators. Expected input value is decimal number
 * with '.' as decimal separator.
 */
nike.gadget.CrossSell.priceFormatter = function (value, decimalSeparator, thousandsSeparator) {
    if (decimalSeparator != '.') {
        value = value.replace('.', decimalSeparator);
    }
    for (var rx = /(\d+)(\d{3})/; rx.test(value); value = value.replace(rx, '$1' + thousandsSeparator + '$2'));
    return value;
};

/**
 * Full price builders. Logic copied form ATG price builders.
 */
nike.gadget.CrossSell.priceFormatters = {};

nike.gadget.CrossSell.priceFormatters["USD"] = function (priceValue) {
  return "$" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["AED"] = function (priceValue) {
  return "AED " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["AUD"] = function (priceValue) {
  return "$" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["BGN"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " \u043B\u0432.";
};

nike.gadget.CrossSell.priceFormatters["CAD"] = function (priceValue) {
  return "CAD " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["CHF"] = function (priceValue) {
  return "CHF " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', '\'');
};

nike.gadget.CrossSell.priceFormatters["CLP"] = function (priceValue) {
  return "$" + nike.gadget.CrossSell.priceFormatter(priceValue, '', '.');
};

nike.gadget.CrossSell.priceFormatters["CNY"] = function (priceValue) {
  return "\u00A5" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["DKK"] = function (priceValue) {
  return "kr " + nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.');
};

nike.gadget.CrossSell.priceFormatters["EGP"] = function (priceValue) {
  return "EGP " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["EUR"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.') + " \u20ac";
};

nike.gadget.CrossSell.priceFormatters["GBP"] = function (priceValue) {
  return "\u00a3 " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["HRK"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.') + " kn";
};

nike.gadget.CrossSell.priceFormatters["IDR"] = function (priceValue) {
  return "Rp" + nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.');
};

nike.gadget.CrossSell.priceFormatters["ILS"] = function (priceValue) {
  return "\u20AA " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["INR"] = function (priceValue) {
  return "\u20B9" + nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.');
};

nike.gadget.CrossSell.priceFormatters["JPY"] = function (priceValue) {
  return "\u00A5" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["MAD"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " DH";
};

nike.gadget.CrossSell.priceFormatters["MXN"] = function (priceValue) {
  return "$" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["MYR"] = function (priceValue) {
  return "RM " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["NOK"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " kr";
};

nike.gadget.CrossSell.priceFormatters["NZD"] = function (priceValue) {
  return "$" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["PLN"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " z\u0142";
};

nike.gadget.CrossSell.priceFormatters["RON"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.') + " LEI";
};

nike.gadget.CrossSell.priceFormatters["RUB"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " py\u0431.";
};

nike.gadget.CrossSell.priceFormatters["SAR"] = function (priceValue) {
  return "SAR " + nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.');
};

nike.gadget.CrossSell.priceFormatters["SEK"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', ' ') + " kr";
};

nike.gadget.CrossSell.priceFormatters["SGN"] = function (priceValue) {
  return "S$" + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["THB"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, '', ',') + " THB";
};

nike.gadget.CrossSell.priceFormatters["TRY"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, ',', '.') + " \u20ba";
};

nike.gadget.CrossSell.priceFormatters["TWD"] = function (priceValue) {
  return "NT$ " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

nike.gadget.CrossSell.priceFormatters["VND"] = function (priceValue) {
  return nike.gadget.CrossSell.priceFormatter(priceValue, '', '.') + " \u20ab";
};

nike.gadget.CrossSell.priceFormatters["ZAR"] = function (priceValue) {
  return "R " + nike.gadget.CrossSell.priceFormatter(priceValue, '.', ',');
};

/**
 * Setup listener for liquid layout
 */
nike.listen(nike.Event.PAGE_LAYOUT, function() {
  if (!Modernizr.mq('only screen')) { // if browser doesn't support media query (IE8 below), use javascript to respond to different screen sizes
    var $crossSellContainer = $('.certona-crossSell');
    $crossSellContainer.toggleClass('wide', $crossSellContainer.outerWidth() >= 1019);
    $crossSellContainer.toggleClass('narrow', $crossSellContainer.outerWidth() < 1019);
    // add flag indicating no media query support (we need this in CSS)
  }
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.gadget.CrossSell. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('Flash.swfobject');
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing Flash.swfobject. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.requireDependency('Array');
nike.requireDependency('nike.ErrorHandler');
nike.requireDependency('nike.geo.Locate');
nike.requireDependency('nike.Notification');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.ImageUtil');
nike.requireDependency('nike.analytics.CertonaMapping');
nike.requireDependency('nike.analytics.Tracking');
nike.requireDependency('nike.gadget.CartCount');
nike.requireDependency('nike.gadget.Event');
nike.requireDependency('nike.gadget.Gadget');
nike.requireDependency('nike.gadget.MiniCart');
nike.requireDependency('nike.exp.global.GeodetectBanner');
nike.requireDependency('nike.exp.global.base.GeodetectNotifier');
nike.requireDependency('nike.gadget.LoadingScreen');
nike.requireDependency('nike.gadget.UpgradePrompt');
nike.requireDependency('nike.page.html.OneNikeBaseScripts');
nike.requireDependency('nike.page.util.TrackingUtil');
nike.requireDependency('nike.SitePresentationRoutingUtil');
nike.requireDependency('nike.gadget.OneNikeNav');
nike.requireDependency('nike.gadget.OneNikeFooter');
nike.requireDependency('nike.gadget.LinkRedirector');
nike.requireDependency('nike.Validation');
nike.requireDependency('nike.NavigationUtil');
nike.requireDependency('jQuery.xml2json');
nike.requireDependency('jQuery.md5');
nike.requireDependency('jQuery.hammer');
nike.requireDependency('nike.gadget.CrossSell');
nike.requireDependency('nike.fonts.glyphPolyfill');
nike.requireDependency('iOS-quirks-fix');
nike.requireDependency('polyfills');
nike.requireDependency('Flash.swfobject');
nike.requireDependency('nike.exp.global.BrowserCheckNotifier');
nike.requireDependency('nike.exp.global.Form');
nike.requireDependency('nike.exp.global.SelectBox');
nike.requireDependency('nike.exp.profile.Register');

/**
 * Setup listeners for the site shell
 */
nike.listen(nike.Event.LOAD_COUNTRY_COMPARE, function(event, data) {

  nike.debug("[Geodetect Notifier] countries don't match, show notifier.");
  $(document).ready(function(){
    data = data.data;

    new nike.exp.global.base.GeodetectNotifier({
      country : {
        origin : data.original_country,
        alternate : data.compare_country
      }
    });

  });
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.page.OneNikeShell. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}




try{
var nike = nike || {};
if(nike.namespace){nike.namespace('nike.exp.global.templates.Social');}
   (function() { 
     var template = Handlebars.template, 
         templates = Handlebars.templates = Handlebars.templates || {}; 
     templates['Social'] = template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "  <div class=\"fb-like\"\n    data-href=\"http://www.facebook.com/"
    + container.escapeExpression(((helper = (helper = helpers.handle || (depth0 != null ? depth0.handle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"handle","hash":{},"data":data}) : helper)))
    + "\"\n    "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dataAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  ></div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var helper, alias1=container.escapeExpression;

  return " data-"
    + alias1(((helper = (helper = helpers.key || (data && data.key)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"key","hash":{},"data":data}) : helper)))
    + "=\""
    + alias1(container.lambda(depth0, depth0))
    + "\"";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "  <div class=\"fb-like\"\n    data-href=\""
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\"\n    "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dataAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  ></div>\n";
},"6":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <a class=\"nsg-glyph--facebook glyph-facebook\" target=\"_blank\" href=\"https://www.facebook.com/sharer/sharer.php?u="
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"url","hash":{},"data":data}) : helper)))
    + "\" title=\"Facebook\"><img src=\"/nikestore/html/img/facebook_24.png\" width=\"24\" height=\"24\" alt=\"Facebook\"></a>\n";
},"8":function(container,depth0,helpers,partials,data) {
    return "<div class=\"pluginConnectButton\">\n  <div class=\"pluginButton pluginButtonSmall pluginButtonInline pluginConnectButtonDisconnected hidden_elem\" title=\"\">\n    <div>\n      <button type=\"submit\">\n        <i class=\"pluginButtonIcon img sp_like sx_like_fav\"></i>\n        Like\n      </button>\n    </div>\n  </div>\n</div>\n";
},"10":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "  <a href=\"https://twitter.com/"
    + container.escapeExpression(((helper = (helper = helpers.handle || (depth0 != null ? depth0.handle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"handle","hash":{},"data":data}) : helper)))
    + "\" class=\"twitter-follow-button\"\n    "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dataAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  >Follow</a>\n";
},"12":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "  <a href=\"https://twitter.com/share\" class=\"twitter-share-button\"\n    data-url=\""
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\"\n    "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dataAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  >Tweet</a>\n";
},"14":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <a class=\"nsg-glyph--twitter glyph-twitter\" target=\"_blank\" href=\"https://twitter.com/intent/tweet?text="
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&amp;url="
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\" title=\"Twitter\"><img src=\"/nikestore/html/img/twitter_24.png\" width=\"24\" height=\"24\" alt=\"Twitter\"></a>\n";
},"16":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {};

  return "  <a href=\""
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "\" class=\"pin-it-button\"\n    data-pin-do=\"buttonPin\"\n    data-pin-shallow=\"true\"\n    data-pin-config=\"none\"\n    "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.customAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n  >\n    <img src=\"http://assets.pinterest.com/images/pidgets/pin_it_button.png\"/>\n  </a>\n";
},"18":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <a class=\"nsg-glyph--pinterest glyph-pinterest\" target=\"_blank\" href=\""
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"url","hash":{},"data":data}) : helper)))
    + "\" title=\"Pinterest\"><img src=\"/nikestore/html/img/pinterest_24.png\" width=\"24\" height=\"24\" alt=\"Pinterest\"></a>\n";
},"20":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return "    <div class=\"g-plusone google-plusone-no-cookies\" href=\""
    + container.escapeExpression((helpers.socialMediaHelper || (depth0 && depth0.socialMediaHelper) || helpers.helperMissing).call(alias1,(depth0 != null ? depth0.url : depth0),{"name":"socialMediaHelper","hash":{},"data":data}))
    + "\"\n      data-size=\"medium\"\n      data-annotation=\"none\"\n      data-callback=\"plusClick\"\n      "
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.dataAttributes : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n    >\n    </div>\n";
},"22":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <a class=\"nsg-glyph--gplus glyph-gplus\" target=\"_blank\" href=\"https://plus.google.com/share?url="
    + container.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"url","hash":{},"data":data}) : helper)))
    + "\" title=\"Google+\"><img src=\"/nikestore/html/img/googleplus_24.png\" width=\"24\" height=\"24\" alt=\"Google+\"></a>\n";
},"24":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"social-sina-button\">\n    <a class=\"sina-weibo-button\" href=\"http://e.weibo.com/"
    + container.escapeExpression(((helper = (helper = helpers.handle || (depth0 != null ? depth0.handle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"handle","hash":{},"data":data}) : helper)))
    + "\" target=\"_blank\"></a>\n  </div>\n";
},"26":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <div class=\"social-sina-share-button\">\n    <a class=\"sina-weibo-button\" href=\"http://service.weibo.com/share/share.php?url="
    + ((stack1 = ((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + " - "
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&pic="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\" target=\"_blank\"></a>\n  </div>\n";
},"28":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <div class=\"static social-sina-share-button\">\n    <a class=\"sina-weibo-button\" href=\"http://service.weibo.com/share/share.php?url="
    + ((stack1 = ((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + " - "
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&pic="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\" target=\"_blank\"></a>\n  </div>\n";
},"30":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"tencentweibo-button\">\n    <a href=\"http://e.t.qq.com/"
    + container.escapeExpression(((helper = (helper = helpers.handle || (depth0 != null ? depth0.handle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"handle","hash":{},"data":data}) : helper)))
    + "\" target=\"_blank\"></a>\n  </div>\n";
},"32":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <div class=\"tencentweibo-button\">\n    <a class=\"js-tencentweibo-share-btn\"\n       href=\"http://share.v.t.qq.com/index.php?c=share&a=index&url="
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + " - "
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&appkey="
    + alias4(((helper = (helper = helpers.tencentAppKey || (depth0 != null ? depth0.tencentAppKey : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"tencentAppKey","hash":{},"data":data}) : helper)))
    + "&pic="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\"\n       target=\"_blank\"></a>\n  </div>\n";
},"34":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <div class=\"static tencentweibo-button\">\n    <a class=\"js-tencentweibo-share-btn tencentweibo-share-button\"\n       href=\"http://share.v.t.qq.com/index.php?c=share&a=index&url="
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + " - "
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&appkey="
    + alias4(((helper = (helper = helpers.tencentAppKey || (depth0 != null ? depth0.tencentAppKey : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"tencentAppKey","hash":{},"data":data}) : helper)))
    + "&pic="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\"\n       target=\"_blank\"></a>\n  </div>\n";
},"36":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <a class=\"social-qzone-button\" version=\"1.0\" target=\"_blank\" href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url="
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "&summary="
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&desc="
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&pics="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\"></a>\n";
},"38":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "  <a class=\"static social-qzone-button\" version=\"1.0\" target=\"_blank\" href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url="
    + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
    + "&title="
    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
    + "&summary="
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&desc="
    + alias4(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"description","hash":{},"data":data}) : helper)))
    + "&pics="
    + alias4(((helper = (helper = helpers.pic || (depth0 != null ? depth0.pic : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"pic","hash":{},"data":data}) : helper)))
    + "\"></a>\n";
},"40":function(container,depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"wechat-code\">\n    <img class=\"wechat-image\" width=\"230\" height=\"230\" src=\""
    + container.escapeExpression(((helper = (helper = helpers.qrCode || (depth0 != null ? depth0.qrCode : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"qrCode","hash":{},"data":data}) : helper)))
    + "\" />\n  </div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : {};

  return container.escapeExpression((helpers.requireDependency || (depth0 && depth0.requireDependency) || helpers.helperMissing).call(alias1,"nike.exp.global.TemplateHelpers",{"name":"requireDependency","hash":{},"data":data}))
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnFbFollow : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnFbShare : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticFbShare : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnFbPlaceholder : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnTwitFollow : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnTwitShare : depth0),{"name":"if","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticTwitShare : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnPintShare : depth0),{"name":"if","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticPintShare : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnGPlusShare : depth0),{"name":"if","hash":{},"fn":container.program(20, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticGPlusShare : depth0),{"name":"if","hash":{},"fn":container.program(22, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnSinaFollow : depth0),{"name":"if","hash":{},"fn":container.program(24, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnSinaShare : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticSinaShare : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnTencentFollow : depth0),{"name":"if","hash":{},"fn":container.program(30, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnTencentShare : depth0),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticTencentShare : depth0),{"name":"if","hash":{},"fn":container.program(34, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnQZoneShare : depth0),{"name":"if","hash":{},"fn":container.program(36, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnStaticQZoneShare : depth0),{"name":"if","hash":{},"fn":container.program(38, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.returnWeChat : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true}); 
   })();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.templates.Social. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.global.TemplateRenderer');

nike.requireDependency('HandlebarsRuntime');
nike.requireDependency('nike.exp.global.TemplateHelpers');
nike.requireDependency('nike.exp.global.templates.Social');


nike.exp.global.TemplateRenderer = $.extend(nike.exp.global.TemplateRenderer, {

  renderSocialMarkup : function(data){
    var template = Handlebars.helpers.buildSocialTool({socialData:data});
    var markup;

    if(template && template.string){
      markup = template.string;
    }

    return markup;
  }

});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.global.TemplateRenderer. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.CookieSettings');

nike.requireDependency('nike.exp.global.CookieSettingsCheck');
nike.requireDependency('nike.exp.global.TemplateRenderer');
nike.requireDependency('nike.exp.global.TemplateHelpers');


function get(name){
  if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
    return decodeURIComponent(name[1]);
}

(function(){
  /**
   * @class Creates a CookieSettings Object
   * @augments Class
   * @namespace nike.exp.util.shared.base.CookieSettings
   */
  nike.exp.util.shared.base.CookieSettings = Class.extend(
    /**
     * @lends nike.exp.util.shared.base.CookieSettings
     */
    {

      /**
       * What SocialTools Class to use
       * @type {String}
       * @default
       */
      socialToolsType : 'base',

      /**
       * Initialize the CookieSettings
       */
      init : function(){
        var _self = this;
        nike.debug("CookieSettings - INIT");

        /**
         * Whether or not CookieSettings has been i
         * @type {Boolean}
         * @instance
         * @default
         */
        _self.initialized = false;

        /**
         * Whether or not CookieSettings is enabled
         * @type {Boolean}
         * @instance
         * @default
         */
        _self.isCookieSettingsEnabled = false;

        /**
         * Whether or not Social Media & Advertising cookies are allowed
         * @type {Boolean}
         * @instance
         * @default
         */
        _self.isAdCookiesAllowed = false;

        /**
         * A reference to SocialTools
         * @type {Object}
         * @instance
         * @default
         */
        _self.socialTools = null;

        /**
         * Whether or not to display a dialog for the user to set their cookie preferences for the site.
         * @type {Boolean}
         * @instance
         * @default
         */
        _self.promptUserForCookieSettings = nike.exp.global.CookieSettingsCheck.isCookieSettingsEnabled();

        /**
         * True if in a country that doesn't require us to display the cookie settings dialog,
         * or True if the user has already set their preferences.
         * @type {Boolean}
         * @instance
         * @default
         */
        _self.adCookiesAllowed = nike.exp.global.CookieSettingsCheck.isAdCookiesAllowed();

        // If Social Media & Advertising cookies are disabled, listen for if/when the user re-enables them.
        if(_self.promptUserForCookieSettings){
          nike.listen(nike.gadget.Event.COOKIE_SETTINGS_CHANGED_EVENT, function(){
            _self.adCookiesAllowed = nike.exp.global.CookieSettingsCheck.isAdCookiesAllowed();
            _self.initAll(_self.adCookiesAllowed);
          });
        }

        _self.initAll(_self.adCookiesAllowed);

        _self.initialized = true;
      },

      /**
       * Init all functionality
       * @param {Boolean} userHasEnabledCookies - Whether or not the user has enabled their Social Media & Advertising cookies.
       */
      initAll : function(userHasEnabledCookies){
        var _self = this;

        var oldUserHasEnabledCookies = userHasEnabledCookies;
        /**
         * Instance of SocialTools
         * @type {Object}
         * @instance
         */
        _self.socialTools = new nike.exp.util.shared[_self.socialToolsType].Social.SocialTools({
          socialMediaAndAdvertisingEnabled : (
            // IF we're not required to prompt the user to set their cookies: enabled
            !_self.promptUserForCookieSettings ||
            // OR, IF we're required to prompt AND the user has already allowed Advertising cookies: enabled
            _self.promptUserForCookieSettings && _self.adCookiesAllowed
          ),
          userHasEnabledCookies : userHasEnabledCookies
        });

        if (get("danstestparam") == 'newrelic') {
          nike.log("danstestparam: cookies=" + oldUserHasEnabledCookies + "->" + userHasEnabledCookies + ", prompt="
            + _self.promptUserForCookieSettings + ", allowed=" + _self.adCookiesAllowed + ", socialTools=" + _self.socialTools
            + ", NewRelic=" + _self.NewRelic);
        }

        if (userHasEnabledCookies) {
          _self.NewRelic.init();
        }
      },

      NewRelic : {
        initialized : false,

        init : function(){
          var _self = this;
          nike.debug( 'CookieSettings - INIT: New Relic' );

          if(
            _self.NewRelic &&
            !_self.NewRelic.initialized &&
            nike.objectDefined("nike.exp.global.NewRelic.footer")
          ){
            $(nike.exp.global.NewRelic.footer).appendTo('body');
            _self.NewRelic.initialized = true;
          }
        }
      }
    }
  );

})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.CookieSettings. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}




try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.SocialToolsUtil');

nike.requireDependency('nike.exp.global.templates.Social');

(function(){
	/**
	 * Houses a collection of properties and methods
	 * needed by the social networks.
	 *
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.SocialToolsUtil
	 */
	nike.exp.util.shared.base.Social.SocialToolsUtil = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.SocialToolsUtil
		 */
		{

			/**
			 * Whether or not this is executing from a PDP.
			 * @type {Boolean}
			 * @default
			 */
			isPDP : (location.href.match(/\/pd\//i)) ? true : false,

      /**
       * On click of a static button, open a pop-up
       * @param {jQuery} $btns - The social button that's been clicked.
       * @param {String} windowName - The name of the pop-up window. Will limit instance to one.
       */
      handleStaticButtonClick : function($btns, windowName){
        var _self = this;
        //Remove event handler for Cookie Settings
        $btns.off('click touchend');

        setTimeout(function handleClick(){
          $btns.each(function(){
            var $btn = $(this);

            // if it has a handle, it's a full page, no pop-up
            if(!$btn.data('handle')){
              _self.assignPopUp({
                $btn: $btn,
                url: $btn.find('a').attr('href'),
                windowName: windowName
              });
            }

          });
        }, 3000);
      },

      /**
			 * Certain social buttons are supposed to have a popup open, use this instead of duplicating code. Add params as you see fit.
			 * @param {Object} params - Parameters used to customize your popup.
			 *  @property {String} params.$btn - The button that will have a popup open on click.
			 *  @property {String} params.url - The url the popup will open.
			 *  @property {String} params.windowName - The name of the window.
			 *  @property {String} params.width - The width of the window.
			 *  @property {String} params.height - The height of the window.
			 *  @property {Boolean} params.toolbar - Window has a toolbar.
			 *  @property {Boolean} params.scrollbars - Window has scrollbars.
			 *  @property {Boolean} params.delay - How many milliseconds before the popup opens.
			 */
			assignPopUp : function(params){
				var windowSettings = {
					url: '',
					windowName: 'socialPopUp',
					width: 504,
					height: 620,
					toolbar: false,
					scrollbars: true
				};
				$.extend(windowSettings, params);

				if (windowSettings.$btn.length) {
					windowSettings.$btn.on('click touchend', function (e) {
						e.preventDefault();
						var windowSpecs = 'height=' + windowSettings.height +
								',width=' + windowSettings.width +
								',toolbar=' + windowSettings.toolbar +
								',scrollbars=' + windowSettings.scrollbars;

						window.open(windowSettings.url, windowSettings.windowName, windowSpecs);

					});
				}
			},

			/**
			 * This function will loop over the enabled feature flags in nike.FEATURE_LIST and return an
			 * array of the enabled social networks.
			 * @property {String} flagName - The name of the Feature Flag that you're checking against.
			 * @returns {Boolean} enabled
			 */
			checkIfEnabled: function(flagName){
				var _self = this;

				// CDP's aren't controlled by FF's so pass those through, otherwise verify the FF and the page
				return ( !_self.isPDP || _self.isPDP && nike.FEATURE_LIST[flagName] ) ? true : false;
			},

			/**
			 * Retrieves all the placeholder elements on the page. If there are elements result.init will be true.
			 * @param {Array} selectorList - An Array of selectors used to grab all placeholder elements on the page.
			 * @returns {Object} - { els:<jQuery>, init:<Boolean> }
			 */
			getPlaceholders : function(selectorList){
				var result = {
					els : $(selectorList.join(', '))
				};

				result.init = ( result.els.length ) ? true : false;

				return result;
			},

			/**
			 * Determines whether or not to load the social network's API.
			 * @param {jQuery} $els - All the elements on the page with the current social network type.
			 * @param {Boolean} cookiesEnabled - Whether or not Functional & Performance cookies are enabled.
			 * @returns {Boolean}
			 */
			loadAPICheck : function($els, cookiesEnabled){
				var isAPI = false;

				// loop through all els, and if any of them have an API type
				$els.each(function(){
					var $el = $(this);
					/**
					 * Since we have to account for CDP pages that won't be adding any data attributes soon,
					 * default to API enabled if the 'type' attribute isn't set. In the future this should
					 * always default to a static button if not otherwise specified.
					 */
					if(
						!$el.data('type') && cookiesEnabled
						|| $el.data('type') == 'api' && cookiesEnabled
					){
						isAPI = true;
						return;
					}
				});
				return isAPI;
			},

			/**
			 * This function will take an object and encode its attirbutes using encodeURIComponent
			 * @param {Object} obj - The object whose attributes you want to include.
			 * @returns {Object}
			 */
			encodeObjectAttsBasedOnLocale : function(obj){
				if( nike.LANGUAGE.match(/zh|jp/) ){
					for (var i in obj){
						if (obj.hasOwnProperty(i)){
							var attr = obj[i];
              if(typeof attr === 'object' && attr !== null){
                //encode objects recursively
                obj[i] = this.encodeObjectAttsBasedOnLocale(attr);
              } else if(!i.match(/buttonText/)){ // exclude some props from being encoded
                obj[i] = encodeURIComponent(attr);
							}
						}
					}
				}
				return obj;
			}

		}
	);
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.SocialToolsUtil. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.Facebook');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.Facebook
	 */
	nike.exp.util.shared.base.Social.Facebook = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.Facebook
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.Facebook#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.Facebook#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.Facebook#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-facebook', '.social-mobile-facebook'],
					cookiesEnabled : true,
					defaultAtts : {
            'action' 			: 'like',
            'share' 			: 'true',
						'layout' 			: 'button_count',
						'show-faces' 	: 'false'
					},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_FACEBOOK',
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: 'FbFollow',
						share 				: 'FbShare',
						staticShare 	: 'StaticFbShare',
						staticFollow 	: 'StaticFbFollow'
					},
					socialName : 'facebook'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a Facebook button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: Facebook');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);

				if(placeholders.init){
					// render an API button
					if(initAPI){
						$('.pluginConnectButton').each(function (i, placeholderEl) {
							var placeholder = $(placeholderEl);
							var originalButton = placeholder.data('original-button');

							if(originalButton){
								placeholder.replaceWith(originalButton);
							}
						});

						if(!_self.initialized){
							/**
							 * Set the value of fbAsyncInit symbol of the window object to a function that is called when
							 * window.fbAsyncInit() is invoked from the Facebook all.js script.
							 */
							window.fbAsyncInit = function () {
								//noinspection JSUnresolvedVariable
								/**
								 * Call the init function of the FB object created when the all.js script is loaded below
								 * @see FB
								 */
								FB.init({
									appId: '',
									status: true,
									cookie: true,
									xfbml: true,
									channelUrl: 'http://www.nike.com/' + nike.LOCALE + '/social/facebook-channel.xfbml.html'
								});

								FB.Event.subscribe('edge.create', function (href, widget) {
									var nikeSite = $(widget).data('href').split('http://www.facebook.com/').pop(),
											data = {
												"shareType": networkKey,
												"interactionType": 'share',
												"site": 'nike.com'
											};
									// Landing Page like event
									if( !_self.socialToolsUtil.isPDP ){
										nike.dispatchEvent(nike.Event.FACEBOOK_LIKE_SUBSCRIBE, data);
									}
									// filter for www Follow Us Like Event
									else if (nikeSite.split('/').length == 1) {
										data = {
											"shareType": networkKey,
											"interactionType": 'like',
											"site": nikeSite,
											"prop3": "follow us:" + nikeSite + ":" + networkKey + ":like"
										};
										nike.dispatchEvent(nike.Event.SHARE_OPTION_CLICK, data);
									}
									// PDP Page Title Like Event
									else {
										nike.dispatchEvent(nike.Event.FACEBOOK_LIKE_SUBSCRIBE, data);
									}
								});
							};

							$('body').append('<div id="fb-root"></div>');

              (function(d, s, id){
                var url = '//connect.facebook.net/' + nike.LOCALE + '/sdk.js';
                var js, fjs = d.getElementsByTagName(s)[0];
                if (d.getElementById(id)) return;
                js = d.createElement(s); js.id = id;
                js.src = url + '#xfbml=1&version=v2.5';
                fjs.parentNode.insertBefore(js, fjs);
              }(document, 'script', 'facebook-jssdk'));

						}else{
							if(nike.objectDefined('FB.XFBML.parse')){
								FB.XFBML.parse();
							}
						}

						//hack for tablet comment flyout fb bug
						$('.fb-like iframe').css('position','inherit');
					}
				}
			}
		}
	);
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.Facebook. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.Twitter');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.Twitter
	 */
	nike.exp.util.shared.base.Social.Twitter = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.Twitter
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.Twitter#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.Twitter#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.Twitter#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-twitter', '.social-mobile-twitter'],
					cookiesEnabled : true,
					defaultAtts : {
						'lang' 						: nike.LANGUAGE,
						'show-count' 			: 'false',
						'show-screen-name': 'false',
						'count'						: 'none'
					},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_TWITTER',
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: 'TwitFollow',
						share 				: 'TwitShare',
						staticShare 	: 'StaticTwitShare',
						staticFollow 	: 'StaticTwitFollow'
					},
					socialName : 'twitter'
				};

        //Hacky fix for Taiwanese Twitter
        if(nike.LOCALE === 'zh_TW'){
          _self.conf.defaultAtts.lang = 'zh-tw';
        }

				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a Twitter button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: Twitter');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);

				if(placeholders.init){
					// render an API button
					if(initAPI){
						!function (d, s, id) {
							if(!_self.initialized){
								/*var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
								if (!d.getElementById(id)) {
									js = d.createElement(s);
									js.id = id;
									js.src = p + '://platform.twitter.com/widgets.js';
									fjs.parentNode.insertBefore(js, fjs);
								}*/



								var js,fjs=d.getElementsByTagName(s)[0];
								if(!d.getElementById(id)){
									js=d.createElement(s);
									js.id=id;
									js.src="https://platform.twitter.com/widgets.js";
									fjs.parentNode.insertBefore(js,fjs);
								}


								_self.initialized = true;
							}else{
								if(nike.objectDefined('twttr.widgets.load')){
									twttr.widgets.load();
								}
							}
						}(document, 'script', 'twitter-wjs');

						_self.waitForTwitter(networkKey);
					}
				}
			},

			/**
			 * Twitter's API has loaded, so add the tracking
			 * @param {String} networkKey - Twitter's network key
			 */
			setupTwitterTracking : function(networkKey){
				twttr.ready(function(twttr){

					// Follow Button
					twttr.events.bind('follow', function(event){
						var nikeSite = event.data.screen_name,
								data = {
									"shareType": networkKey,
									"interactionType": 'follow',
									"site": nikeSite,
									"prop3": "follow us:" + nikeSite + ":" + networkKey + ":follow"
								}
						nike.dispatchEvent(nike.Event.SHARE_OPTION_CLICK, data);
					});

					// Tweet Button initial click (opens tweet dialog window)
					twttr.events.bind('click', function (event) {
						if (event.region == 'tweet') {
							var data = {
								"shareType": networkKey,
								"interactionType": 'share',
								"site": 'nike.com'
							}
							nike.dispatchEvent(nike.Event.SHARE_OPTION_CLICK, data);
						}
					});

					// Tweet confirm (fires when user presses submit)
					twttr.events.bind('tweet', function(event){
						var data = {
							"confirm": true,
							"shareType": networkKey,
							"interactionType": 'share',
							"site": 'nike.com'
						}
						nike.dispatchEvent(nike.Event.SHARE_OPTION_CLICK, data);
					});
				});
			},

			/**
			 * Waits until Twitter's API is loaded before initializing the tracking
			 * @param {String} networkKey - Twitter's network key
			 */
			waitForTwitter : function(networkKey){
				var _self = this;
				if (typeof twttr === 'undefined' || typeof twttr.ready !== 'function') {
					setTimeout(function(){
						_self.waitForTwitter(networkKey);
					}, 100);
				} else {
					_self.setupTwitterTracking(networkKey);
				}
			}

		}
	);
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.Twitter. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.GooglePlus');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.GooglePlus
	 */
	nike.exp.util.shared.base.Social.GooglePlus = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.GooglePlus
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.GooglePlus#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.GooglePlus#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.GooglePlus#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-gplus'],
					cookiesEnabled : true,
					defaultAtts : {
						'size' 				: 'medium',
						'annotation' 	: 'none',
						'callback' 		: '(new nike.exp.util.shared.base.Social.GooglePlus()).plusClick'
					},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_GOOGLEPLUS',
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: 'GPlusFollow',
						share 				: 'GPlusShare',
						staticShare 	: 'StaticGPlusShare',
						staticFollow 	: 'StaticGPlusFollow'
					},
					socialName : 'google_plus'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a GooglePlus button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: Google Plus');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);

				if(placeholders.init){
					// render an API button
					if(initAPI){
						!function(){
							if(!_self.initialized){
								var po = document.createElement('script');
								po.type = 'text/javascript';
								po.async = true;
								po.src = 'https://apis.google.com/js/plusone.js';
								var s = document.getElementsByTagName('script')[0];
								s.parentNode.insertBefore(po, s);
								_self.initialized = true;
							} else {
								if (nike.objectDefined('gapi.plusone.go')) {
									gapi.plusone.go();
								}
							}
						}();
					}
				}
			},

			/**
			 * The default callback for the click of a GPlus button.
			 * @param {Object} data - Data returned from Google.
			 */
			plusClick : function(data) {
				if (data.state == "on") {
					nike.dispatchEvent(nike.Event.GOOGLE_PLUS_SUBSCRIBE, {});
				}
			}
		}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.GooglePlus. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.Pinterest');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.Pinterest
	 */
	nike.exp.util.shared.base.Social.Pinterest = Class.extend(
			/**
			 * @lends nike.exp.util.shared.base.Social.Pinterest
			 */
			{

				/**
				 * Initializes the network
				 * @param {Object} conf - User set configuration for network
				 */
				init: function(conf){
					var _self = this;

					/**
					 * Whether or no the network have been initialized
					 * @type {Boolean}
					 * @alias initialized
					 * @memberof! nike.exp.util.shared.base.Social.Pinterest#
					 * @instance
					 * @default
					 */
					_self.initialized = false;

					/**
					 * Store a reference to SocialToolsUtil for later use.
					 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
					 */
					_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

					/**
					 * The config of the network
					 * @type {Object}
					 * @alias conf
					 * @memberof! nike.exp.util.shared.base.Social.Pinterest#
					 * @instance
					 * @default
					 *
					 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
					 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
					 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
					 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
					 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
					 * @property {Function} [init=nike.exp.util.shared.base.Social.Pinterest#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
					 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
					 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
					 */
					_self.conf = {
						classList : ['.social-pinterest', '.social-mobile-pinterest'],
						cookiesEnabled : true,
						defaultAtts : {
							'pin-do' 				: 'buttonPin',
							'pin-shallow' 	: 'true',
							'pin-config' 		: 'none'
						},
						notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
						featureFlag : 'SOCIAL_PINTEREST',
						init : _self.initButton.bind(_self),
						keys : {
							follow 				: 'PintFollow',
							share 				: 'PintShare',
							staticShare 	: 'StaticPintShare',
							staticFollow 	: 'StaticPintFollow'
						},
						socialName : 'pinterest'
					};
					// override any defaults set by user
					$.extend(true, _self.conf, conf);

					/**
					 * Whether or not this network is enabled
					 * @type {Boolean}
					 */
					_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
				},

				/**
				 * Initializes a Pinterest button
				 */
				initButton : function(){
					nike.debug('SocialTools - INIT: Pinterest');

					var _self 				= this;
					var networkKey 		= _self.conf.socialName;
					var selectors 		= _self.conf.classList;
					var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
					var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);

					if(placeholders.init){
						// render an API button
						if(initAPI){
							if(!_self.initialized){
								var pinitUrl = "http://assets.pinterest.com/js/pinit.js";
								$('script[src*="assets.pinterest.com/js/pinit.js"]').remove();

								//Load pinit script
								$.ajax({
									type: "GET",
									url: pinitUrl,
									dataType: "script",
									cache: true
								});

								var s = document.createElement('script');
								s.type = "text/javascript";
								//Setting data-pin-shallow will stop Pinterest from trying to launch native app. on iOS devices
								s.setAttribute("data-pin-shallow", "true");
								s.src = pinitUrl;
								document.getElementsByTagName('head')[0].appendChild(s);

								_self.initialized = true;
							}else{
								var element = $('.pin-it-button');
								_self.reRenderPinterestButton(element);
							}
						}
					}
				},

				/**
				 * After Pinterest has already loaded on a page, if you try to reload it, say when a Colorway is selected on the PDP,
				 * the Pinterest button will no longer work. This function was created to remedy that. It just calls the functionality
				 * that's already present within the loaded Pinterest lib.
				 * @param {jQuery} $el - The button element, an anchor tag.
				 */
				reRenderPinterestButton : function($el){
					var pin = null;
					for(var prop in window){
						if(prop.indexOf('PIN_') === 0 && prop.length > 15){ pin = window[prop]; }
					}
					if(pin){
						pin.f.render.buttonPin($el[0]);
					}
				}

			}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.Pinterest. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.TencentWeibo');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.TencentWeibo
	 */
	nike.exp.util.shared.base.Social.TencentWeibo = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.TencentWeibo
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.TencentWeibo#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.TencentWeibo#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.TencentWeibo#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-tencentweiboqq', '.social-mobile-tencentweiboqq'],
					cookiesEnabled : true,
					defaultAtts : {},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_TENCENTWEIBO',
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: 'TencentFollow',
						share 				: 'TencentShare',
						staticShare 	: 'StaticTencentShare',
						staticFollow 	: 'StaticTencentFollow'
					},
					socialName : 'tencent_weibo'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a TencentWeibo button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: Tencent Weibo');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);
				var $containers 	= placeholders.els;

				if(placeholders.init){
					// render an API button
					if(initAPI){
						// Currently the API & Static implementation are the same so use the same functionality
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);
						_self.initialized = true;

					// init static functionality
					}else{
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);
					}
				}
			}
		}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.TencentWeibo. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.SinaWeibo');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.SinaWeibo
	 */
	nike.exp.util.shared.base.Social.SinaWeibo = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.SinaWeibo
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.SinaWeibo#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.SinaWeibo#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.SinaWeibo#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-sinaweibo', '.social-mobile-sinaweibo'],
					cookiesEnabled : true,
					defaultAtts : {},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_SINAWEIBO',
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: 'SinaFollow',
						share 				: 'SinaShare',
						staticShare 	: 'StaticSinaShare',
						staticFollow 	: 'StaticSinaFollow'
					},
					socialName : 'sina_weibo'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a SinaWeibo button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: Sina Weibo');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI		 		= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);
				var app_id 				= $('head meta[property="weibo:app_id"]').attr('content');
				var $containers 	= placeholders.els;

				if(placeholders.init){
					// render an API button
					if(initAPI){
						/*$('script[src*="tjs.sjs.sinajs.cn/open/api/js/wb.js"]').remove();

						//Load sina weibo script
						$.ajax({
							type		: "GET",
							url			: 'http://tjs.sjs.sinajs.cn/open/api/js/wb.js',
							dataType: "script",
							cache		: true
						});*/

            // Currently the API & Static implementation are the same so use the same functionality
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);

						_self.initialized = true;

					// init static functionality
					}else{
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);
					}
				}
			}
		}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.SinaWeibo. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.QZone');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.QZone
	 */
	nike.exp.util.shared.base.Social.QZone = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.QZone
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.QZone#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.QZone#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.QZone#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-qzone', '.social-mobile-qzone'],
					cookiesEnabled : true,
					defaultAtts : {},
					notDataAtts : [ 'url', 'handle', 'qa', 'type' ],
					featureFlag : 'SOCIAL_QZONE',
					init: _self.initButton.bind(_self),
					keys : {
						follow 				: 'QZoneFollow',
						share 				: 'QZoneShare',
						staticShare 	: 'StaticQZoneShare',
						staticFollow 	: 'StaticQZoneFollow'
					},
					socialName : 'qzone'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);
			},

			/**
			 * Initializes a SinaWeibo button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: QZone');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);
        var $containers 	= placeholders.els;

				if(placeholders.init){
					// render an API button
					if(initAPI){
						/*var $containerEl = $(selectors);
						var shareUrl = 'http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?' + $.param({
							url				: location.href,
							showcount	: '0', *//* Whether to display the total share, display: '1 ', does not display: '0' *//*
							desc			: '', *//* Default Sharing reason (optional) *//*
							summary		: $('[property="og:description"]').attr('content'), *//* Share Summary (optional) *//*
							title			: $('[property="og:title"]').attr('content'), *//* Sharing header (optional) *//*
							site			: $('[property="og:site_name"]').attr('content'), *//* Share sources such as: Tencent (optional) *//*
							pics			: $('[property="og:image"]').attr('content'), *//* Share pictures path (optional) *//*
							style			: '202',
							width			: 25,
							height		: 31
						}).replace(/undefined/g, '');

						$containerEl.data('url', shareUrl);

						//Load qzone script
						$.ajax({
							type: "GET",
							url: 'http://qzonestyle.gtimg.cn/qzone/app/qzlike/qzopensl.js#jsdate=20111201',
							dataType: "script",
							cache: true
						});*/

            // Currently the API & Static implementation are the same so use the same functionality
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);

						_self.initialized = true;
					}else{
            _self.socialToolsUtil.handleStaticButtonClick($containers, _self.conf.socialName);
          }
				}
			}
		}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.QZone. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.WeChat');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialToolsUtil');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.WeChat
	 */
	nike.exp.util.shared.base.Social.WeChat = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.WeChat
		 */
		{

			/**
			 * Initializes the network
			 * @param {Object} conf - User set configuration for network
			 */
			init: function(conf){
				var _self = this;

				/**
				 * Whether or no the network have been initialized
				 * @type {Boolean}
				 * @alias initialized
				 * @memberof! nike.exp.util.shared.base.Social.WeChat#
				 * @instance
				 * @default
				 */
				_self.initialized = false;

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * The config of the network
				 * @type {Object}
				 * @alias conf
				 * @memberof! nike.exp.util.shared.base.Social.WeChat#
				 * @instance
				 * @default
				 *
				 * @property {Array} [classList=[ 'network_name-btn', 'network_name-button' ]] - This is an array of classes that the code should loop through to replace with functional markup.
				 * @property {Boolean} [cookiesEnabled=true] - Whether or not Functional & Performance cookies are enabled.
				 * @property {Object} [defaultAtts={'data-att-name':val, 'data-att-name2':val2}] - These are default data attributes that will be set for each network.
				 * @property {Array} [notDataAtts=['data-att-name', 'data-att-name2']] - These will be ignored when attributes are added to the dataAttributes Object, and instead added to the root of the context for use within the template.
				 * @property {String} [featureFlag='SOCIAL_<NETWORK>'] - If the network has a feature flag, determine whether or not to init the network.
				 * @property {Function} [init=nike.exp.util.shared.base.Social.WeChat#initFacebook] - This method is used to run any initialization code and attach any events to the social button.
				 * @property {Object} [keys] - A map containing Strings that coincides with a Handlebars variable. Handlebars will render markup for Ex. 'TwitterFollow' or what key you pass.
				 * @property {String} [socialName='<network>'] - A String containing the name of the social network. Used to automatically add QA attributes to the social buttons.
				 */
				_self.conf = {
					classList : ['.social-wechat'],
					cookiesEnabled : true,
					defaultAtts : {},
					notDataAtts : [ 'url', 'handle', 'qa', 'type', 'qrCode' ],
					init : _self.initButton.bind(_self),
					keys : {
						follow 				: '',
						share 				: 'WeChat',
						staticShare 	: 'StaticWeChatShare',
						staticFollow 	: ''
					},
					socialName : 'wechat'
				};
				// override any defaults set by user
				$.extend(true, _self.conf, conf);

				/**
				 * Whether or not this network is enabled
				 * @type {Boolean}
				 */
				_self.enabled = _self.socialToolsUtil.checkIfEnabled(_self.conf.featureFlag);

        /**
         * Determines the event type to use
         * @type {String}
         */
        _self.eventType = (Modernizr.touch) ? 'touchend' : 'click';
			},

			/**
			 * Initializes a SinaWeibo button
			 */
			initButton : function(){
				nike.debug('SocialTools - INIT: WeChat');

				var _self 				= this;
				var networkKey 		= _self.conf.socialName;
				var selectors 		= _self.conf.classList;
				var placeholders 	= _self.socialToolsUtil.getPlaceholders(selectors);
				var initAPI 			= _self.socialToolsUtil.loadAPICheck(placeholders.els, _self.conf.cookiesEnabled);

				if(placeholders.init){
					// render an API button
					if(initAPI){
						nike.debug("INIT: Initializing WeChat");

						placeholders.els.on(_self.eventType, function(){
							var $wechatEl = $(this);
							var $body = $('body');

							if( !$wechatEl.hasClass('wechat-open') ){
								$body.off(_self.eventType+'.wechatclose').removeClass('wechat-click');

								// make the code open to the left if it's going to fall off screen
								( ($wechatEl.offset().left + 250) > $(window).width() ) ? $wechatEl.addClass('qr-right') : $wechatEl.removeClass('qr-right');

								// determine if this is in the follow-us section on the bottom of the page
								if($wechatEl.parents('.nike-cq-follow-us-mask').length) {
									//$wechatEl.parents('.nike-cq-follow-us-mask').first().css('overflow','visible').find('.nike-cq-follow-pages').first().css('overflow','visible');
								}

								// remove any other QR codes that are open
								$('.wechat-open').removeClass('wechat-open');

								if( !$body.hasClass('wechat-click') ){
									setTimeout(function(){
										$body.addClass('wechat-click').on(_self.eventType+'.wechatclose', _self.weChatCloseHandler.bind(_self));
									}, 250);
								}

								$wechatEl.addClass('wechat-open');

                //fix issue - sencond row QR code is cut off
                $wechatEl.parents('.nike-cq-follow-pages').css('height', '100%');
                if ($wechatEl.offset().top - $wechatEl.parents('.nike-cq-follow-us-mask').offset().top > 100) {
                  $wechatEl.find('.wechat-code').css('top', '-164px');
                }else{
                  $wechatEl.find('.wechat-code').css('top', '-1px');
                }
							}
						});

						_self.initialized = true;
					}
				}
			},

			/**
			 * Event handler to close the QR code on document click
			 * @param {Event} e - Click/Touch event on body
			 */
			weChatCloseHandler : function(e){
				var _self = this;
        $('.wechat-open').removeClass('wechat-open');
				$('body').off(_self.eventType+'.wechatclose').removeClass('wechat-click');
			}
		}
	);
})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.WeChat. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.Social.SocialTools');

nike.requireDependency('Class');
nike.requireDependency('nike.Util');
nike.requireDependency('nike.exp.global.templates.Social');
nike.requireDependency('nike.exp.util.shared.base.Social.Facebook');
nike.requireDependency('nike.exp.util.shared.base.Social.Twitter');
nike.requireDependency('nike.exp.util.shared.base.Social.GooglePlus');
nike.requireDependency('nike.exp.util.shared.base.Social.Pinterest');
nike.requireDependency('nike.exp.util.shared.base.Social.TencentWeibo');
nike.requireDependency('nike.exp.util.shared.base.Social.SinaWeibo');
nike.requireDependency('nike.exp.util.shared.base.Social.QZone');
nike.requireDependency('nike.exp.util.shared.base.Social.WeChat');


(function() {
	/**
	 * This initializes a collection of all set social networks.
	 *
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.base.Social.SocialTools
	 */
	nike.exp.util.shared.base.Social.SocialTools = Class.extend(
		/**
		 * @lends nike.exp.util.shared.base.Social.SocialTools
		 */
		{

      /**
			 * Whether or not the user is on a mobile device
			 * @type {Boolean}
			 * @default true if mobile device
			 */
			isMobile : nike.exp.script.device_detect.isMobile(),

			/**
			 * Used to differentiate between mobile and desktop
			 * @type {String}
			 * @default
			 */
			prefix : '',

			/**
			 * Used to target the Follow Us module on CQ pages
			 * @type {String}
			 * @default
			 */
			cqFollowUsModuleSelector : '.nike-cq-page-module.nike-cq-follow-us',

			/**
			 * Default is the Desktop template
			 * @type {Function}
			 * @default
			 */
			template : Handlebars.templates.Social,

			/**
			 * Initializes the SocialTools
			 * @param {Object} conf - User set configuration for SocialTools
			 */
			init: function(conf){
				var _self = this;
				var conf = conf || {};

				/**
				 * If false, then placeholders will be used until the user decides to enable cookies again
				 * @type Boolean
				 * @instance
				 * @default
				 */
				_self.socialMediaAndAdvertisingEnabled = (conf.socialMediaAndAdvertisingEnabled != null) ? conf.socialMediaAndAdvertisingEnabled : true;

				/**
				 * Social networks collection
				 * @type Object
				 * @default
				 */
				_self.socialNetworkMap = {
					facebook : new nike.exp.util.shared.base.Social.Facebook({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					twitter : new nike.exp.util.shared.base.Social.Twitter({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					googlePlus : new nike.exp.util.shared.base.Social.GooglePlus({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					pinterest : new nike.exp.util.shared.base.Social.Pinterest({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					tencentWeibo : new nike.exp.util.shared.base.Social.TencentWeibo({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					sinaWeibo : new nike.exp.util.shared.base.Social.SinaWeibo({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					qZone : new nike.exp.util.shared.base.Social.QZone({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					}),

					weChat : new nike.exp.util.shared.base.Social.WeChat({
						cookiesEnabled : _self.socialMediaAndAdvertisingEnabled
					})
				};

				/**
				 * Store a reference to SocialToolsUtil for later use.
				 * @type {nike.exp.util.shared.base.Social.SocialToolsUtil}
				 */
				_self.socialToolsUtil = new nike.exp.util.shared.base.Social.SocialToolsUtil();

				/**
				 * Whether or not the user has enabled Social Media and Advertising cookies. Passed in from CookieSettings
				 * @type Boolean
				 * @default
				 */
				_self.userHasEnabledCookies = false;

				nike.debug("SocialTools - INIT");

				// override any defaults set on SocialTools with user set properties
				$.extend(_self, conf);

				_self.renderTools();
			},

			/**
			 * Used whenever you need to render the tools on the page, such as a Colorway click
			 */
			renderTools : function(){
				var _self = this;

				// render markup
				_self.renderSocialMarkup();

				// init networks
				_self.initNetworks();
			},

			/**
			 * Loop through list of enabled networks and call their init methods.
			 */
			initNetworks : function(){
				var _self = this;

				for(var n in _self.socialNetworkMap){
					if(_self.socialNetworkMap.hasOwnProperty(n)){
						var socialNetwork = _self.socialNetworkMap[n];

						if(socialNetwork.enabled){
							socialNetwork.conf.init();

							// analytics
							_self.handleSocialAnalytics(socialNetwork.conf.classList, socialNetwork.conf.socialName);
						}
					}
				}
			},

      /**
			 * This function will take an array of social networks to be rendered (as defined above), find empty divs on the current page based on the classList attribute,
			 * loop over the data attributes on that empty div, and finally return a Handlebars template with populated data and append it onto the page.
			 *
			 * Note: This is intended to be a generic function that can be reused, so try not to put code specific to a social network in here. Put those in the init
			 * function for that specific network.
			 *
			 */
			renderSocialMarkup : function(){
				var _self = this;
				var staticSocialData = {
					tencentAppKey	: $('[property="tencent:app_id"]').attr('content'),
					sinaAppKey		: $('[property="weibo:app_id"]').attr('content'),
					description 	: $('[property="og:description"]').attr('content'),
					media 				: $('[property="og:image"]').attr('content'),
					pic 					: $('[property="og:image"]').attr('content'),
					title 				: $('[property="og:title"]').attr('content')
				};

				for(var n in _self.socialNetworkMap){
					if(_self.socialNetworkMap.hasOwnProperty(n)){
						var socialNetwork = _self.socialNetworkMap[n];
						var defaultDataAttributes = socialNetwork.conf.defaultAtts;
						var notDataAttributes = socialNetwork.conf.notDataAtts.join(' ');

						if(socialNetwork.enabled){
							var $emptyDivs = $(socialNetwork.conf.classList.join(", "));

							if ($emptyDivs.length > 0) {
								//Iterate through empty divs to be replaced with functional markup
								$emptyDivs.each(function () {
									// The rest of the context will defined in the below loop
									var socialData = { dataAttributes:defaultDataAttributes };
									var $el = $(this);
									var elData = $el.data();
									var returnType, action, qaAttr;

                  /**
                   * The below lines should live in the logic that defines 'returnType' in the
                   * static section, but since CQ won't update their stuff for a while it has to
                   * be here and bloat the context slightly.
                   */
                  socialData = $.extend(true, socialData, staticSocialData);
                  socialData = socialNetwork.socialToolsUtil.encodeObjectAttsBasedOnLocale(socialData);

                  //Loop through data attributes on empty div to build out socialData object
                  for (var d in elData) {
                    //Avoid looping over primitive object's prototype
                    if (elData.hasOwnProperty(d)) {
                      //Determine whether the action is a "share" or "follow" based on the data attribute present on the div
                      if ((d == 'url' || d == 'content' || d == 'qrCode' ) && elData[d]) {
                        action = 'share';
                        qaAttr = _self.prefix + 'share.' + socialNetwork.conf.socialName.replace(" ", "_");
                      } else if (d == 'handle' && elData[d]) {
                        action = 'follow';
                        qaAttr = _self.prefix + 'follow.' + socialNetwork.conf.socialName.replace(" ", "_") + '.'
                        + $el.data(d);
                      }

                      // Check if the current attribute should not be added as a data attribute
                      var attributeReg = new RegExp('\\b' + d + '\\b', 'g');
                      if (notDataAttributes.match(attributeReg)) {
                        socialData[d] = elData[d];

                      // ELSE, add the attributes to the context
                      } else {
                        // convert key to attribute style name
                        var key = d.replace(/([A-Z])/g, function (result) {
                          return '-' + result.toLowerCase();
                        });
                        socialData.dataAttributes[key] = String(elData[d]);
                      }
                    }
                  }

                  /**
                   * Since CQ pages won't have the 'type' attribute set, and they want
                   * everything running the same, default to API markup
                   */
                  if (!elData.type && !_self.isMobile || elData.type && elData.type == 'api') {
                    // this sets what template chunk to return. Ex: 'returnFbShare'
                    returnType = (action == 'share')
                    ? socialNetwork.conf.keys.share
                    : socialNetwork.conf.keys.follow;
                  } else { // static button
                    // dynamically assign the 'return' key
                    returnType = (action == 'share')
                    ? socialNetwork.conf.keys.staticShare
                    : socialNetwork.conf.keys.staticFollow;
                  }
                  socialData['return' + returnType] = true;

                  $el.html(new Handlebars.SafeString(_self.template(socialData)).string.trim());

                  /**
                   * Since some social API's replace all the markup we put on the page,
                   * we have to apply the QA atts to the parent.
                   */
                  nike.Util.addQaAttribute($el, qaAttr);
								});
							}
						}
					}
				}
			},

			/**
			 * The purpose of this function is to bind analytics event to social link on follow us section.
			 * @param {Array} classList - Array of network selectors we'll use to target a specific networks placeholders
			 * @param {String} socialSite - Social network name for tracking data
			 */
			handleSocialAnalytics: function (classList, socialSite) {
				var $socialDivs = $(classList.join(", "));

				if ($socialDivs.length) {
					$socialDivs.each(function () {
						// determine follow or share
						var $el = $(this);
						var type, nikeSite;
						if ($el.data('handle')) {
							type = 'follow';
							nikeSite = $el.data('handle');
						} else if ($el.data('url') || $el.data('content')) {
							type = 'share';
							nikeSite = 'nike.com';
						}
						var linkEl = $el.find('a');

            linkEl.on('click touch', function () {
              var data = {
                "shareType": socialSite.replace(/_/g, ' '),
                "interactionType": type,
                "site": nikeSite
              };
              if (type == 'follow') {
                data.prop3 = "follow us:" + nikeSite + ":" + socialSite + ":follow";
                if (socialSite != 'twitter') {
                  data.prop3 = "follow us:" + nikeSite + ":" + socialSite + ":like";
                }
              }

              nike.dispatchEvent(nike.Event.SHARE_OPTION_CLICK, data);
						});
					});
				}
			}
		}
	);
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.Social.SocialTools. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.desktop.Social.SocialTools');

nike.requireDependency('nike.exp.util.shared.base.Social.SocialTools');

(function() {
	/**
	 * @class
	 * @augments Class
	 * @namespace nike.exp.util.shared.desktop.Social.SocialTools
	 */
	nike.exp.util.shared.desktop.Social.SocialTools = nike.exp.util.shared.base.Social.SocialTools.extend(
			/**
			 * @lends nike.exp.util.shared.desktop.Social.SocialTools
			 */
			{

				// Desktop specific code here

			}
	);

})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.desktop.Social.SocialTools. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.desktop.CookieSettings');

nike.requireDependency('nike.exp.util.shared.base.CookieSettings');
nike.requireDependency('nike.exp.util.shared.desktop.Social.SocialTools');

(function(){
	/**
	 * @class Creates a CookieSettings Object
	 * @augments nike.exp.util.shared.base.CookieSettings
	 * @namespace nike.exp.util.shared.desktop.CookieSettings
	 */
	nike.exp.util.shared.desktop.CookieSettings = nike.exp.util.shared.base.CookieSettings.extend(
		/**
		 * @lends nike.exp.util.shared.desktop.CookieSettings
		 */
		{
			/**
			 * What SocialTools Class to use
			 * @type {String}
			 * @default
			 */
			socialToolsType : 'desktop'
		}
	);

})();
}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.desktop.CookieSettings. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}
try{
var nike = nike || {};
nike.namespace('nike.exp.util.shared.base.TextReplacement');

(function() {
  TextReplacement = {

    init: function() {
      var self = this;
      self.wrapNikeId();
      self.addPlatformFont();
    },

    wrapNikeId: function() {
      var self = this;

      $('.nsg-font-family--platform:contains("NIKEiD"), .nsg-font-family--marketing:contains("NIKEiD")').each(function() {
        var $elem = $(this);
        if($elem.children().length == 0) {
          var html = $elem.html().replace(/NIKEiD/g, '<span class="nikeid">NIKEiD</span>');
          $elem.html(html);
        } else {
          $elem.find(':contains("NIKEiD")').each(function() {
            var $child = $(this);
            if($child.children().length == 0) {
              var html = $child.html().replace(/NIKEiD/g, '<span class="nikeid">NIKEiD</span>');
              $child.html(html);
            }
          });
        }
      });
    },
    // function for adding nsg-font-family--platform to benefits headers (since we get the markup from PI) PDP & NikeiD
    addPlatformFont: function() {
      var elementList = ['.pi-pdpmainbody b', '.pi-main-title', '.pi-benefit-title', '.pi-more-benefit-title', '.details_container span', '.tech_specs_header', '.exp-productmessage-outofstock h2', '.custom-message h2', '.custom-out-of-stock-message h2'];

      $(elementList.join(', ')).each(function(){
        $(this).addClass('nsg-font-family--platform');
      });
    }
  };

  $(function() {
    nike.exp.util.shared.base.TextReplacement = TextReplacement;
    nike.exp.util.shared.base.TextReplacement.init();
  });
})();

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.exp.util.shared.base.TextReplacement. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

try{
var nike = nike || {};
nike.namespace('nike.Chat', function(){
  var $ = nike.requireDependency('jQuery');

  // In order to persist chats from page to page, we need to auto-initialize
  // the script. The timeout moves the init to the bottom of the stack so that
  // it doesn't block anything else from running.
  setTimeout(function(){
    $(function(){
      nike.chatInstance = new nike.Chat();
    });
  }, 1000);

  return Class.extend({
    init: function(){
      /**
       * Whether or not the chat service has been initialized.
       * @type {boolean}
       */
      this.initialized = false;
      /**
       * Whether or not the current user is a Swoosh user.
       * @type {boolean}
       */
      this.isSwoosh = false;
      /**
       * The configuration data set for the chat service if
       * on an inline PDP.
       * @type {object}
       */
      this.chatConfData = {};
      /**
       * The global configuration property name that the
       * primary chat service keys off of.
       * @type {string}
       */
      this.chatConfKey = 'needleParam';
      /**
       * Any logs this class uses will be prefixed by this so
       * things stay consistent.
       * @type {string}
       */
      this.LOG_PREFIX = '[ CHAT ] - ';
      /**
       * A map of selectors used to access DOM elements.
       * @type {object}
       */
      this.selectors = {
        CHAT_CONTAINER: '#chatModule',
        SECONDARY_CTA: '.js-chatCTA'
      };
      /**
       * A map of cached DOM elements.
       * @type {object}
       */
      this.els = {
        $chatContainer: $( this.selectors.CHAT_CONTAINER )
      };

      // check if any possible chat flags are enabled, if not, do nothing
      if(
        !nike.FEATURE_LIST.NEEDLE_CHAT
        && !nike.FEATURE_LIST.GOLF_CHAT
        && !nike.FEATURE_LIST.RUNNING_CHAT
        || nike.HIDE_CHAT
      ) return false;

      nike.log(this.LOG_PREFIX + 'Initializing');

      this.setUserType();
      if( this.disableForSwooshUsers() ) return;

      // Only sets up the conf if the data's been setup on the page.
      // Currently it's only setup on the inline PDP for Desktop & Mobile.
      if( nike.FEATURE_LIST.NEEDLE_CHAT && this.els.$chatContainer.length ) this.setupChatConfData();
      // If no conf data was found, we want to persist the chat, so just
      // load up the service scripts, and the service will handle loading
      // previous data.
      else if( nike.FEATURE_LIST.NEEDLE_CHAT ) this.setupPrimaryChatProvider();
      // Setup legacy chat provider (RNW) as a fallback
      else if( nike.FEATURE_LIST.GOLF_CHAT || nike.FEATURE_LIST.RUNNING_CHAT ) this.setupSecondaryChatProvider();
    },

    /**
     * User has clicked on the chat CTA
     *
     * @param {CustomEvent} ev - The event from chat service.
     */
    handleChatCtaClick: function(ev){
      nike.dispatchEvent(nike.Event.ANALYTICS_CHAT_CTA_CLICKED);
    },

    /**
     * The user and a chat rep have begun talking.
     *
     * @param {CustomEvent} ev - The event from the chat service.
     */
    handleChatInitiated: function(ev){
      nike.dispatchEvent(nike.Event.ANALYTICS_CHAT_INITIATED);
    },

    /**
     * Check if the user is a Swoosh user.
     */
    setUserType: function(){
      var cookie = nike.readCookie('CART_SUMMARY');
      if( cookie ){
        cookie = JSON.parse( decodeURIComponent(cookie).replace(/\+/g, ' ') );
        this.isSwoosh = cookie.userType == 'EMPLOYEE';
      }
    },

    /**
     * Disables the chat service for Swoosh users.
     */
    disableForSwooshUsers: function(){
      if( this.isSwoosh ) {
        nike.log(this.LOG_PREFIX + 'Exiting, not available for Swoosh users');

        this.els.$chatContainer.remove();

        return true;
      }

      return false;
    },

    /**
     * Sets up the global chat configuration data so the chat rep
     * knows what the user is looking at.
     */
    setupChatConfData: function(){
      // If chat's been initialized already, we want to verify we have the newest
      // element since it could've been recreated by a Colorway change.
      if( this.initialized ){
        this.els.$chatContainer = $( this.selectors.CHAT_CONTAINER );
      }

      this.setUserType();
      if( this.disableForSwooshUsers() ) return;

      if( nike.FEATURE_LIST.NEEDLE_CHAT ){
        nike.log(this.LOG_PREFIX + 'Setting up `window.'+ this.chatConfKey +'`');

        this.chatConfData = this.els.$chatContainer.data();

        // This property of the needleParam object is the only one dependent on the user state.
        // Set it here rather than receiving it from the model.
        this.chatConfData.swooshUser = this.isSwoosh;
        // Remove employee pricing data for standard users
        this.chatConfData.swooshPrice = '';
        // Remove clearance price if not on clearance.
        if( !this.chatConfData.onClearance ) this.chatConfData.clearancePrice = '';
        // set the global conf data for the Chat provider
        window[this.chatConfKey] = this.els.$chatContainer.data();

        this.setupPrimaryChatProvider();
      }
      else if( nike.FEATURE_LIST.GOLF_CHAT || nike.FEATURE_LIST.RUNNING_CHAT ){
        this.setupSecondaryChatProvider();
      }
    },

    /**
     * Gets any required exterior scripts for the chat provider to
     * function, and sets up any extra listeners needed for our
     * interactions.
     */
    setupPrimaryChatProvider: function(){
      // remove old instance and listeners if they exist
      if( !this.initialized ){
        var _self = this;
        nike.log( this.LOG_PREFIX + 'Loading service scripts' );

        $.getScript( nike.SERVICE_URLS.needleChatService ).done(function(){
          nike.log( _self.LOG_PREFIX + 'Service scripts loaded' );
          _self.initialized = true;

          // setting up analytics listeners, Needle dispatches from window :(
          window.addEventListener(nike.Event.CHAT_CTA_CLICKED, _self.handleChatCtaClick);
          window.addEventListener(nike.Event.CHAT_INITIATED, _self.handleChatInitiated);

        }).fail(function( xhr, settings, exception ){
          nike.error( _self.LOG_PREFIX + 'Service scripts failed to load' );
        });
      }else{
        // Re-render the current rule rather than loading their scripts again.
        if( window.Needle ){
          nike.log( this.LOG_PREFIX + 'Reloading rule' );
          window.Needle.stopUpdateTimer();
          window.Needle.PageUpdate('R');
        }
      }
    },

    /**
     * A fallback to setup our old chat provider if the current providers
     * feature flag is disabled. This will hopefully go away at some point
     * but we've never gotten the marching orders to remove it.
     */
    setupSecondaryChatProvider: function(){
      nike.log( this.LOG_PREFIX + 'Setting up secondary chat provider' );

      this.els.$chatContainer.on('click', this.selectors.SECONDARY_CTA, function(ev){
        var link = $(this).data("link");
        var height = 1024;
        var width = 460;
        var x = (screen.width / 2) - (width / 2);
        var y = (screen.height / 2) - (height / 2);
        if (link != "undefined") {
          window.open(link, "_blank", 'left=' + x + ',top=' + y + ',width=' + width + ',height=' + height + ',location=0,menubar=0,toolbar=0,scrollbars=yes');
        }
        nike.dispatchEvent(nike.Event.LIVE_CHAT_CLICK);
      });
    }
  });
});

}catch(ex){
if(nike.error){
nike.error('An unhandled exception was thrown while executing nike.Chat. Make sure to look for previous errors because this might have failed as a result of another script failing', ex, 'Stack:', ex.stack, 'Message:', ex.message);
}
}

if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templates.GeodetectNotifier', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.SelectBox', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.util.BooleanUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.Validator', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.AccessibleNav', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.AbstractState', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.TrackingUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.FieldFactory', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.hammer', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.UserState', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.Orientation', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.Ad', false);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.formatCurrency.all', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.util.UrlUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.CartCount', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.ExposeClosureForTest', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.Form', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templates.GeodetectBanner', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.TemplateRenderer', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.store.ui.widgets.ModalDialog', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.SiteIdUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.page.OneNikeShell', false);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.md5', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.UniteModal', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.fonts.glyphPolyfill', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.UserLoaded', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Util', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.ValidationEvent', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.geo.Edgescape', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.CpcStateController', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.BasicReady', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.Facebook', true);}
if(nike.addLoadedScript){nike.addLoadedScript('lib.lodash', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.MiniCart', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.RememberedLogIn', true);}
if(nike.addLoadedScript){nike.addLoadedScript('Modernizr', true);}
if(nike.addLoadedScript){nike.addLoadedScript('logging', false);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.formatCurrency', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.base.GeodetectNotifier', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.StateController', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templates.BrowserCheck', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.CookieUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templatehelpers.FormRenderHelpers', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.DomReady', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.CrossSellRenderer', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.LinkRedirector', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.LoadingScreen', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.interactionType', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.PartialUserLoaded', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.ErrorHandler', true);}
if(nike.addLoadedScript){nike.addLoadedScript('HandlebarsRuntime', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.NotKnown', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.geo.Locate', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.OneNikeFooter', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.AbstractForm', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.ImageUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.Field', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.geo.Configuration', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.ToggleField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Shipping', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.desktop.Social.SocialTools', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templates.Social', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Function', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.base.BrowserCheck', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.SitePresentationRoutingUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.page.html.OneNikeBaseScripts', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.Twitter', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.util.BrowserUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.ServiceUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.OutOfSync', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.EventBus', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.CookieSettingsCheck', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.Tracking', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.NavigationUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Countries_Locales_Cookies', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.TencentWeibo', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.geo.CookieData', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.NotLoggedIn', true);}
if(nike.addLoadedScript){nike.addLoadedScript('easyXDM', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.xml2json', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.page.OneNikePageLayout', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.Login', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.WeChat', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.PostalCodeUsField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.CurrencyUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.DateField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.style.exp.exp-desktop', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.ProfileStateController', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.UpgradePrompt', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.BrowserCheckNotifier', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Chat', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.geo.Util', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.NotLoaded', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.nsgInit', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.GooglePlus', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.util.StringUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.OneNikeNav', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.certonaResx', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.CommerceOffNotification', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.SocialToolsUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.PhoneNumberField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.TrackingConfigUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.CompleteReady', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.style.nsg.Classes', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.BasicLoaded', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.PostalCodeEmeaField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.exists', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.PasswordReset', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.cookie', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templatehelpers.generator.StateGenerator', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Event', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Validation', true);}
if(nike.addLoadedScript){nike.addLoadedScript('Class', true);}
if(nike.addLoadedScript){nike.addLoadedScript('iOS-quirks-fix', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.Register', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.base64', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.SocialTools', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.LocalValueUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.DobField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Cart', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.CookieSettingsHandler', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.CookieSettings', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.Event', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.Gadget', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.growandshow', true);}
if(nike.addLoadedScript){nike.addLoadedScript('JSON', true);}
if(nike.addLoadedScript){nike.addLoadedScript('requestAnimationFrame', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.desktop.CookieSettings', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.CrossSell', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.crosssell.CertonaTools', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.gadget.desktop.GlobalNavNotifier', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.QZone', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.TextReplacement', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.CompleteLoaded', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.LoggedIn', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.Notification', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.profile.state.Error', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.throttle', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.SinaWeibo', true);}
if(nike.addLoadedScript){nike.addLoadedScript('Flash.swfobject', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.TemplateHelpers', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.analytics.CertonaMapping', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.ScriptLoader', false);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.url', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.Modal', true);}
if(nike.addLoadedScript){nike.addLoadedScript('Date', true);}
if(nike.addLoadedScript){nike.addLoadedScript('Array', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.templates._TypeAhead', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery', false);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.base64url', true);}
if(nike.addLoadedScript){nike.addLoadedScript('jQuery.hoverIntent', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.page.util.TrackingUtil', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.validation.field.PasswordField', true);}
if(nike.addLoadedScript){nike.addLoadedScript('polyfills', false);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.util.shared.base.Social.Pinterest', true);}
if(nike.addLoadedScript){nike.addLoadedScript('nike.exp.global.GeodetectBanner', true);}


